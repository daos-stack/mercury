diff --git a/src/na/na_ucx.c b/src/na/na_ucx.c
index b14bd91..2376455 100644
--- a/src/na/na_ucx.c
+++ b/src/na/na_ucx.c
@@ -1490,6 +1490,8 @@ na_ucp_listener_destroy(ucp_listener_h listener)
 static void
 na_ucp_listener_conn_cb(ucp_conn_request_h conn_request, void *arg)
 {
+    char host_string[NI_MAXHOST];
+    char serv_string[NI_MAXSERV];
     struct na_ucx_class *na_ucx_class = (struct na_ucx_class *) arg;
     ucp_conn_request_attr_t conn_request_attrs = {
         .field_mask = UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR};
@@ -1507,13 +1509,26 @@ na_ucp_listener_conn_cb(ucp_conn_request_h conn_request, void *arg)
             UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR) == 0,
         error, "conn attributes contain no client addr");
 
+    int rc = getnameinfo((const struct sockaddr *) &conn_request_attrs.client_address,
+                         sizeof(struct sockaddr), host_string,
+                         sizeof(host_string), serv_string,
+                         sizeof(serv_string), NI_NUMERICHOST | NI_NUMERICSERV);
+
+    NA_LOG_SUBSYS_WARNING(addr, "Received connection req from %s:%s", host_string, serv_string);
+
     /* Lookup address from table */
     addr_key = (ucs_sock_addr_t){
         .addr = (const struct sockaddr *) &conn_request_attrs.client_address,
         .addrlen = sizeof(conn_request_attrs.client_address)};
     na_ucx_addr = na_ucx_addr_map_lookup(&na_ucx_class->addr_map, &addr_key);
-    NA_CHECK_SUBSYS_ERROR_NORET(addr, na_ucx_addr != NULL, error,
-        "An entry is already present for this address");
+ 
+
+    if (na_ucx_addr != NULL) {
+        NA_LOG_SUBSYS_WARNING(addr,
+	    "An entry is already present for this address: %s:%s, refcnt: %d",
+            host_string, serv_string, na_ucx_addr->refcount);
+        na_ucx_addr_map_remove(&na_ucx_class->addr_map, &addr_key);
+    }
 
     /* Insert new entry and create new address */
     na_ret = na_ucx_addr_map_insert(na_ucx_class, &na_ucx_class->addr_map,
@@ -1745,10 +1760,17 @@ static void
 na_ucp_ep_error_cb(
     void *arg, ucp_ep_h NA_UNUSED ep, ucs_status_t NA_DEBUG_LOG_USED status)
 {
+    char host_string[NI_MAXHOST];
+    char serv_string[NI_MAXSERV];
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) arg;
 
-    NA_LOG_SUBSYS_DEBUG(addr, "ep_err_handler() returned (%s) for address (%p)",
-        ucs_status_string(status), (void *) na_ucx_addr);
+    int rc = getnameinfo((const struct sockaddr *) &na_ucx_addr->ss_addr,
+                         sizeof(struct sockaddr), host_string,
+                         sizeof(host_string), serv_string,
+                         sizeof(serv_string), NI_NUMERICHOST | NI_NUMERICSERV);
+
+    NA_LOG_SUBSYS_WARNING(addr, "ep_err_handler() returned (%s) for address (%s:%s), with refcnt: %d",
+        ucs_status_string(status), host_string, serv_string, na_ucx_addr->refcount);
 
     /* Mark addr as no longer resolved to force reconnection */
     hg_atomic_and32(&na_ucx_addr->status, ~NA_UCX_ADDR_RESOLVED);
@@ -1823,7 +1845,6 @@ na_ucp_am_send_cb(void *request, ucs_status_t status, void NA_UNUSED *user_data)
     else
         NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucs_status_to_na(status),
             "ucp_am_send_nbx() failed (%s)", ucs_status_string(status));
-
 done:
     na_ucx_complete((struct na_ucx_op_id *) request, cb_ret);
 }
