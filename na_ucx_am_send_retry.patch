diff --git a/src/na/na_ucx.c b/src/na/na_ucx.c
index b14bd91..1c0850f 100644
--- a/src/na/na_ucx.c
+++ b/src/na/na_ucx.c
@@ -1490,6 +1490,8 @@ na_ucp_listener_destroy(ucp_listener_h listener)
 static void
 na_ucp_listener_conn_cb(ucp_conn_request_h conn_request, void *arg)
 {
+    char host_string[NI_MAXHOST];
+    char serv_string[NI_MAXSERV];
     struct na_ucx_class *na_ucx_class = (struct na_ucx_class *) arg;
     ucp_conn_request_attr_t conn_request_attrs = {
         .field_mask = UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR};
@@ -1507,248 +1509,267 @@ na_ucp_listener_conn_cb(ucp_conn_request_h conn_request, void *arg)
             UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR) == 0,
         error, "conn attributes contain no client addr");
 
+    int rc = getnameinfo((const struct sockaddr *) &conn_request_attrs.client_address,
+                         sizeof(struct sockaddr), host_string,
+                         sizeof(host_string), serv_string,
+                         sizeof(serv_string), NI_NUMERICHOST | NI_NUMERICSERV);
+
+    NA_LOG_SUBSYS_WARNING(addr, "Received connection req from %s:%s", host_string, serv_string);
+
     /* Lookup address from table */
     addr_key = (ucs_sock_addr_t){
         .addr = (const struct sockaddr *) &conn_request_attrs.client_address,
         .addrlen = sizeof(conn_request_attrs.client_address)};
     na_ucx_addr = na_ucx_addr_map_lookup(&na_ucx_class->addr_map, &addr_key);
-    NA_CHECK_SUBSYS_ERROR_NORET(addr, na_ucx_addr != NULL, error,
-        "An entry is already present for this address");
-
-    /* Insert new entry and create new address */
-    na_ret = na_ucx_addr_map_insert(na_ucx_class, &na_ucx_class->addr_map,
-        &addr_key, conn_request, &na_ucx_addr);
-    NA_CHECK_SUBSYS_NA_ERROR(
-        addr, error, na_ret, "Could not insert new address");
-
-    return;
-
-error:
-    return;
-}
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucp_accept(ucp_worker_h worker, ucp_conn_request_h conn_request,
-    ucp_err_handler_cb_t err_handler_cb, void *err_handler_arg, ucp_ep_h *ep_p)
-{
-    ucp_ep_params_t ep_params = {.field_mask = UCP_EP_PARAM_FIELD_CONN_REQUEST,
-        .conn_request = conn_request};
-
-    return na_ucp_ep_create(
-        worker, &ep_params, err_handler_cb, err_handler_arg, ep_p);
-}
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucp_connect(ucp_worker_h worker, const struct sockaddr *src_addr,
-    const struct sockaddr *dst_addr, socklen_t addrlen,
-    ucp_err_handler_cb_t err_handler_cb, void *err_handler_arg, ucp_ep_h *ep_p)
-{
-    ucp_ep_params_t ep_params = {
-        .field_mask = UCP_EP_PARAM_FIELD_FLAGS | UCP_EP_PARAM_FIELD_SOCK_ADDR,
-        .flags = UCP_EP_PARAMS_FLAGS_CLIENT_SERVER,
-        .sockaddr = (ucs_sock_addr_t){.addr = dst_addr, .addrlen = addrlen},
-        .conn_request = NULL};
-    struct sockaddr_storage src_ss_addr;
-    na_return_t ret;
-
-#ifdef NA_UCX_HAS_FIELD_LOCAL_SOCK_ADDR
-    if (src_addr != NULL) {
-        /* Reset port to 0 to ensure a separate port is used per connection. */
-        memcpy(&src_ss_addr, src_addr, addrlen);
-        if (src_ss_addr.ss_family == AF_INET)
-            ((struct sockaddr_in *) &src_ss_addr)->sin_port = 0;
-        else if (src_ss_addr.ss_family == AF_INET6)
-            ((struct sockaddr_in6 *) &src_ss_addr)->sin6_port = 0;
-        else
-            NA_GOTO_SUBSYS_ERROR(addr, error, ret, NA_PROTONOSUPPORT,
-                "unsupported address family");
-
-        ep_params.field_mask |= UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR;
-        ep_params.local_sockaddr.addr = (const struct sockaddr *) &src_ss_addr;
-        ep_params.local_sockaddr.addrlen = addrlen;
-    }
-#else
-    (void) src_addr;
-    (void) src_ss_addr;
-    (void) ret;
-#endif
-
-    return na_ucp_ep_create(
-        worker, &ep_params, err_handler_cb, err_handler_arg, ep_p);
-
-#ifdef NA_UCX_HAS_FIELD_LOCAL_SOCK_ADDR
-error:
-    return ret;
-#endif
-}
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucp_connect_worker(ucp_worker_h worker, ucp_address_t *address,
-    ucp_err_handler_cb_t err_handler_cb, void *err_handler_arg, ucp_ep_h *ep_p)
-{
-    ucp_ep_params_t ep_params = {
-        .field_mask = UCP_EP_PARAM_FIELD_REMOTE_ADDRESS,
-        .address = address,
-        .conn_request = NULL};
-
-    NA_LOG_SUBSYS_DEBUG(addr, "Connecting to worker ");
-
-    return na_ucp_ep_create(
-        worker, &ep_params, err_handler_cb, err_handler_arg, ep_p);
-}
-
-/*---------------------------------------------------------------------------*/
-#ifndef NA_UCX_HAS_MEM_POOL
-static void *
-na_ucp_mem_alloc(ucp_context_h context, size_t len, ucp_mem_h *mem_p)
-{
-    const ucp_mem_map_params_t mem_map_params = {
-        .field_mask =
-            UCP_MEM_MAP_PARAM_FIELD_LENGTH | UCP_MEM_MAP_PARAM_FIELD_FLAGS,
-        .length = len,
-        .flags = UCP_MEM_MAP_ALLOCATE // TODO use UCP_MEM_MAP_NONBLOCK ?
-    };
-    ucp_mem_attr_t mem_attrs = {.field_mask = UCP_MEM_ATTR_FIELD_ADDRESS};
-    ucp_mem_h mem = NULL;
-    ucs_status_t status;
-
-    /* Register memory */
-    status = ucp_mem_map(context, &mem_map_params, &mem);
-    NA_CHECK_SUBSYS_ERROR_NORET(mem, status != UCS_OK, error,
-        "ucp_mem_map() failed (%s)", ucs_status_string(status));
-
-    /* Query memory address */
-    status = ucp_mem_query(mem, &mem_attrs);
-    NA_CHECK_SUBSYS_ERROR_NORET(mem, status != UCS_OK, error,
-        "ucp_mem_map() failed (%s)", ucs_status_string(status));
-    NA_CHECK_SUBSYS_ERROR_NORET(mem,
-        (mem_attrs.field_mask & UCP_MEM_ATTR_FIELD_ADDRESS) == 0, error,
-        "mem attributes contain no address");
-
-    *mem_p = mem;
-
-    return mem_attrs.address;
-
-error:
-    if (mem)
-        (void) ucp_mem_unmap(context, mem);
-    return NULL;
-}
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucp_mem_free(ucp_context_h context, ucp_mem_h mem)
-{
-    ucs_status_t status;
-    na_return_t ret;
-
-    status = ucp_mem_unmap(context, mem);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_mem_unmap() failed (%s)",
-        ucs_status_string(status));
-
-    return NA_SUCCESS;
-
-error:
-    return ret;
-}
-
-#else
-/*---------------------------------------------------------------------------*/
-static int
-na_ucp_mem_buf_register(const void *buf, size_t len,
-    unsigned long NA_UNUSED flags, void **handle_p, void *arg)
-{
-    struct na_ucx_class *na_ucx_class = (struct na_ucx_class *) arg;
-    union {
-        void *ptr;
-        const void *const_ptr;
-    } safe_buf = {.const_ptr = buf};
-    const ucp_mem_map_params_t mem_map_params = {
-        .field_mask =
-            UCP_MEM_MAP_PARAM_FIELD_ADDRESS | UCP_MEM_MAP_PARAM_FIELD_LENGTH,
-        .address = safe_buf.ptr,
-        .length = len};
-    ucs_status_t status;
-    int ret;
-
-    /* Register memory */
-    status = ucp_mem_map(
-        na_ucx_class->ucp_context, &mem_map_params, (ucp_mem_h *) handle_p);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, HG_UTIL_FAIL,
-        "ucp_mem_map() failed (%s)", ucs_status_string(status));
-
-    return HG_UTIL_SUCCESS;
-
-error:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static int
-na_ucp_mem_buf_deregister(void *handle, void *arg)
-{
-    int ret;
-
-    if (handle) {
-        struct na_ucx_class *na_ucx_class = (struct na_ucx_class *) arg;
-        ucp_mem_h mem = (ucp_mem_h) handle;
-        ucs_status_t status;
-
-        status = ucp_mem_unmap(na_ucx_class->ucp_context, mem);
-        NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, HG_UTIL_FAIL,
-            "ucp_mem_unmap() failed (%s)", ucs_status_string(status));
-    }
-
-    return HG_UTIL_SUCCESS;
-
-error:
-    return ret;
-}
-
-#endif /* NA_UCX_HAS_MEM_POOL */
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucp_ep_create(ucp_worker_h worker, ucp_ep_params_t *ep_params,
-    ucp_err_handler_cb_t err_handler_cb, void *err_handler_arg, ucp_ep_h *ep_p)
-{
-    ucp_ep_h ep = NULL;
-    ucs_status_t status;
-    na_return_t ret;
-
-    ep_params->field_mask |=
-        UCP_EP_PARAM_FIELD_ERR_HANDLER | UCP_EP_PARAM_FIELD_ERR_HANDLING_MODE;
-    if (!(ep_params->field_mask & UCP_EP_PARAM_FIELD_REMOTE_ADDRESS))
-        ep_params->err_mode = UCP_ERR_HANDLING_MODE_PEER;
-    ep_params->err_handler.cb = err_handler_cb;
-    ep_params->err_handler.arg = err_handler_arg;
-
-    status = ucp_ep_create(worker, ep_params, &ep);
-    NA_CHECK_SUBSYS_ERROR(addr, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_ep_create() failed (%s)",
-        ucs_status_string(status));
-
-    *ep_p = ep;
-
-    return NA_SUCCESS;
-
-error:
-    return ret;
-}
+ 
+
+    if (na_ucx_addr != NULL) {
+        NA_LOG_SUBSYS_WARNING(addr,
+		    "An entry is already present for this address: %s:%s", host_string, serv_string);
+		na_ucx_addr_map_remove(&na_ucx_class->addr_map, &addr_key);
+	    }
+
+	    /* Insert new entry and create new address */
+	    na_ret = na_ucx_addr_map_insert(na_ucx_class, &na_ucx_class->addr_map,
+		&addr_key, conn_request, &na_ucx_addr);
+	    NA_CHECK_SUBSYS_NA_ERROR(
+		addr, error, na_ret, "Could not insert new address");
+
+	    return;
+
+	error:
+	    return;
+	}
+
+	/*---------------------------------------------------------------------------*/
+	static na_return_t
+	na_ucp_accept(ucp_worker_h worker, ucp_conn_request_h conn_request,
+	    ucp_err_handler_cb_t err_handler_cb, void *err_handler_arg, ucp_ep_h *ep_p)
+	{
+	    ucp_ep_params_t ep_params = {.field_mask = UCP_EP_PARAM_FIELD_CONN_REQUEST,
+		.conn_request = conn_request};
+
+	    return na_ucp_ep_create(
+		worker, &ep_params, err_handler_cb, err_handler_arg, ep_p);
+	}
+
+	/*---------------------------------------------------------------------------*/
+	static na_return_t
+	na_ucp_connect(ucp_worker_h worker, const struct sockaddr *src_addr,
+	    const struct sockaddr *dst_addr, socklen_t addrlen,
+	    ucp_err_handler_cb_t err_handler_cb, void *err_handler_arg, ucp_ep_h *ep_p)
+	{
+	    ucp_ep_params_t ep_params = {
+		.field_mask = UCP_EP_PARAM_FIELD_FLAGS | UCP_EP_PARAM_FIELD_SOCK_ADDR,
+		.flags = UCP_EP_PARAMS_FLAGS_CLIENT_SERVER,
+		.sockaddr = (ucs_sock_addr_t){.addr = dst_addr, .addrlen = addrlen},
+		.conn_request = NULL};
+	    struct sockaddr_storage src_ss_addr;
+	    na_return_t ret;
+
+	#ifdef NA_UCX_HAS_FIELD_LOCAL_SOCK_ADDR
+	    if (src_addr != NULL) {
+		/* Reset port to 0 to ensure a separate port is used per connection. */
+		memcpy(&src_ss_addr, src_addr, addrlen);
+		if (src_ss_addr.ss_family == AF_INET)
+		    ((struct sockaddr_in *) &src_ss_addr)->sin_port = 0;
+		else if (src_ss_addr.ss_family == AF_INET6)
+		    ((struct sockaddr_in6 *) &src_ss_addr)->sin6_port = 0;
+		else
+		    NA_GOTO_SUBSYS_ERROR(addr, error, ret, NA_PROTONOSUPPORT,
+			"unsupported address family");
+
+		ep_params.field_mask |= UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR;
+		ep_params.local_sockaddr.addr = (const struct sockaddr *) &src_ss_addr;
+		ep_params.local_sockaddr.addrlen = addrlen;
+	    }
+	#else
+	    (void) src_addr;
+	    (void) src_ss_addr;
+	    (void) ret;
+	#endif
+
+	    return na_ucp_ep_create(
+		worker, &ep_params, err_handler_cb, err_handler_arg, ep_p);
+
+	#ifdef NA_UCX_HAS_FIELD_LOCAL_SOCK_ADDR
+	error:
+	    return ret;
+	#endif
+	}
+
+	/*---------------------------------------------------------------------------*/
+	static na_return_t
+	na_ucp_connect_worker(ucp_worker_h worker, ucp_address_t *address,
+	    ucp_err_handler_cb_t err_handler_cb, void *err_handler_arg, ucp_ep_h *ep_p)
+	{
+	    ucp_ep_params_t ep_params = {
+		.field_mask = UCP_EP_PARAM_FIELD_REMOTE_ADDRESS,
+		.address = address,
+		.conn_request = NULL};
+
+	    NA_LOG_SUBSYS_DEBUG(addr, "Connecting to worker ");
+
+	    return na_ucp_ep_create(
+		worker, &ep_params, err_handler_cb, err_handler_arg, ep_p);
+	}
+
+	/*---------------------------------------------------------------------------*/
+	#ifndef NA_UCX_HAS_MEM_POOL
+	static void *
+	na_ucp_mem_alloc(ucp_context_h context, size_t len, ucp_mem_h *mem_p)
+	{
+	    const ucp_mem_map_params_t mem_map_params = {
+		.field_mask =
+		    UCP_MEM_MAP_PARAM_FIELD_LENGTH | UCP_MEM_MAP_PARAM_FIELD_FLAGS,
+		.length = len,
+		.flags = UCP_MEM_MAP_ALLOCATE // TODO use UCP_MEM_MAP_NONBLOCK ?
+	    };
+	    ucp_mem_attr_t mem_attrs = {.field_mask = UCP_MEM_ATTR_FIELD_ADDRESS};
+	    ucp_mem_h mem = NULL;
+	    ucs_status_t status;
+
+	    /* Register memory */
+	    status = ucp_mem_map(context, &mem_map_params, &mem);
+	    NA_CHECK_SUBSYS_ERROR_NORET(mem, status != UCS_OK, error,
+		"ucp_mem_map() failed (%s)", ucs_status_string(status));
+
+	    /* Query memory address */
+	    status = ucp_mem_query(mem, &mem_attrs);
+	    NA_CHECK_SUBSYS_ERROR_NORET(mem, status != UCS_OK, error,
+		"ucp_mem_map() failed (%s)", ucs_status_string(status));
+	    NA_CHECK_SUBSYS_ERROR_NORET(mem,
+		(mem_attrs.field_mask & UCP_MEM_ATTR_FIELD_ADDRESS) == 0, error,
+		"mem attributes contain no address");
+
+	    *mem_p = mem;
+
+	    return mem_attrs.address;
+
+	error:
+	    if (mem)
+		(void) ucp_mem_unmap(context, mem);
+	    return NULL;
+	}
+
+	/*---------------------------------------------------------------------------*/
+	static na_return_t
+	na_ucp_mem_free(ucp_context_h context, ucp_mem_h mem)
+	{
+	    ucs_status_t status;
+	    na_return_t ret;
+
+	    status = ucp_mem_unmap(context, mem);
+	    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret,
+		na_ucs_status_to_na(status), "ucp_mem_unmap() failed (%s)",
+		ucs_status_string(status));
+
+	    return NA_SUCCESS;
+
+	error:
+	    return ret;
+	}
+
+	#else
+	/*---------------------------------------------------------------------------*/
+	static int
+	na_ucp_mem_buf_register(const void *buf, size_t len,
+	    unsigned long NA_UNUSED flags, void **handle_p, void *arg)
+	{
+	    struct na_ucx_class *na_ucx_class = (struct na_ucx_class *) arg;
+	    union {
+		void *ptr;
+		const void *const_ptr;
+	    } safe_buf = {.const_ptr = buf};
+	    const ucp_mem_map_params_t mem_map_params = {
+		.field_mask =
+		    UCP_MEM_MAP_PARAM_FIELD_ADDRESS | UCP_MEM_MAP_PARAM_FIELD_LENGTH,
+		.address = safe_buf.ptr,
+		.length = len};
+	    ucs_status_t status;
+	    int ret;
+
+	    /* Register memory */
+	    status = ucp_mem_map(
+		na_ucx_class->ucp_context, &mem_map_params, (ucp_mem_h *) handle_p);
+	    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, HG_UTIL_FAIL,
+		"ucp_mem_map() failed (%s)", ucs_status_string(status));
+
+	    return HG_UTIL_SUCCESS;
+
+	error:
+	    return ret;
+	}
+
+	/*---------------------------------------------------------------------------*/
+	static int
+	na_ucp_mem_buf_deregister(void *handle, void *arg)
+	{
+	    int ret;
+
+	    if (handle) {
+		struct na_ucx_class *na_ucx_class = (struct na_ucx_class *) arg;
+		ucp_mem_h mem = (ucp_mem_h) handle;
+		ucs_status_t status;
+
+		status = ucp_mem_unmap(na_ucx_class->ucp_context, mem);
+		NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, HG_UTIL_FAIL,
+		    "ucp_mem_unmap() failed (%s)", ucs_status_string(status));
+	    }
+
+	    return HG_UTIL_SUCCESS;
+
+	error:
+	    return ret;
+	}
+
+	#endif /* NA_UCX_HAS_MEM_POOL */
+
+	/*---------------------------------------------------------------------------*/
+	static na_return_t
+	na_ucp_ep_create(ucp_worker_h worker, ucp_ep_params_t *ep_params,
+	    ucp_err_handler_cb_t err_handler_cb, void *err_handler_arg, ucp_ep_h *ep_p)
+	{
+	    ucp_ep_h ep = NULL;
+	    ucs_status_t status;
+	    na_return_t ret;
+
+	    ep_params->field_mask |=
+		UCP_EP_PARAM_FIELD_ERR_HANDLER | UCP_EP_PARAM_FIELD_ERR_HANDLING_MODE;
+	    if (!(ep_params->field_mask & UCP_EP_PARAM_FIELD_REMOTE_ADDRESS))
+		ep_params->err_mode = UCP_ERR_HANDLING_MODE_PEER;
+	    ep_params->err_handler.cb = err_handler_cb;
+	    ep_params->err_handler.arg = err_handler_arg;
+
+	    status = ucp_ep_create(worker, ep_params, &ep);
+	    NA_CHECK_SUBSYS_ERROR(addr, status != UCS_OK, error, ret,
+		na_ucs_status_to_na(status), "ucp_ep_create() failed (%s)",
+		ucs_status_string(status));
+
+	    *ep_p = ep;
+
+	    return NA_SUCCESS;
+
+	error:
+	    return ret;
+	}
 
 /*---------------------------------------------------------------------------*/
 static void
 na_ucp_ep_error_cb(
     void *arg, ucp_ep_h NA_UNUSED ep, ucs_status_t NA_DEBUG_LOG_USED status)
 {
+    char host_string[NI_MAXHOST];
+    char serv_string[NI_MAXSERV];
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) arg;
 
-    NA_LOG_SUBSYS_DEBUG(addr, "ep_err_handler() returned (%s) for address (%p)",
-        ucs_status_string(status), (void *) na_ucx_addr);
+    int rc = getnameinfo((const struct sockaddr *) &na_ucx_addr->ss_addr,
+                         sizeof(struct sockaddr), host_string,
+                         sizeof(host_string), serv_string,
+                         sizeof(serv_string), NI_NUMERICHOST | NI_NUMERICSERV);
+
+    NA_LOG_SUBSYS_WARNING(addr, "ep_err_handler() returned (%s) for address (%s:%s), with refcnt: %d",
+        ucs_status_string(status), host_string, serv_string, na_ucx_addr->refcount);
 
     /* Mark addr as no longer resolved to force reconnection */
     hg_atomic_and32(&na_ucx_addr->status, ~NA_UCX_ADDR_RESOLVED);
