diff --git a/src/na/na_ucx.c b/src/na/na_ucx.c
index b14bd91..2c224fa 100644
--- a/src/na/na_ucx.c
+++ b/src/na/na_ucx.c
@@ -105,7 +105,7 @@
         hg_atomic_set32(&_op->status, NA_UCX_OP_COMPLETED);                    \
     } while (0)
 
-#ifdef NA_HAS_DEBUG
+#ifdef NA_HAS_WARNING
 #    define NA_UCX_PRINT_ADDR_KEY_INFO(_msg, _key)                             \
         do {                                                                   \
             char _host_string[NI_MAXHOST];                                     \
@@ -115,7 +115,7 @@
                 sizeof(_host_string), _serv_string, sizeof(_serv_string),      \
                 NI_NUMERICHOST | NI_NUMERICSERV);                              \
                                                                                \
-            NA_LOG_SUBSYS_DEBUG(                                               \
+            NA_LOG_SUBSYS_WARNING(                                               \
                 addr, _msg " (%s:%s)", _host_string, _serv_string);            \
         } while (0)
 #else
@@ -453,7 +453,7 @@ na_ucp_am_send(ucp_ep_h ep, const void *buf, size_t buf_size,
  */
 static void
 na_ucp_am_send_cb(
-    void *request, ucs_status_t status, void NA_UNUSED *user_data);
+    void *request, ucs_status_t status, void *user_data);
 
 /**
  * Check if we received an AM or push the op to OP queue.
@@ -565,7 +565,8 @@ na_ucx_addr_map_lookup(
 static na_return_t
 na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
     struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key,
-    ucp_conn_request_h conn_request, struct na_ucx_addr **na_ucx_addr_p);
+    ucp_conn_request_h conn_request, struct na_ucx_addr **na_ucx_addr_p,
+    char* host_string, char* serv_string);
 
 /**
  * Update addr with new EP information.
@@ -1173,6 +1174,8 @@ error:
 }
 #endif
 
+static char* prot_name = "dc_mlx5";
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucp_config_init(
@@ -1189,10 +1192,11 @@ na_ucp_config_init(
         ucs_status_string(status));
 
     /* Set user-requested transport */
-    status = ucp_config_modify(config, "TLS", tls);
+    status = ucp_config_modify(config, "TLS", prot_name);
+
     NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_config_modify() failed (%s)",
-        ucs_status_string(status));
+        na_ucs_status_to_na(status), "ucp_config_modify() failed (%s), from %s to %s",
+        ucs_status_string(status), tls, prot_name);
 
     /* Disable backtrace by default */
     if (getenv("UCX_HANDLE_ERRORS") == NULL) {
@@ -1490,6 +1494,8 @@ na_ucp_listener_destroy(ucp_listener_h listener)
 static void
 na_ucp_listener_conn_cb(ucp_conn_request_h conn_request, void *arg)
 {
+    char host_string[NI_MAXHOST];
+    char serv_string[NI_MAXSERV];
     struct na_ucx_class *na_ucx_class = (struct na_ucx_class *) arg;
     ucp_conn_request_attr_t conn_request_attrs = {
         .field_mask = UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR};
@@ -1507,17 +1513,30 @@ na_ucp_listener_conn_cb(ucp_conn_request_h conn_request, void *arg)
             UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR) == 0,
         error, "conn attributes contain no client addr");
 
+    int rc = getnameinfo((const struct sockaddr *) &conn_request_attrs.client_address,
+                         sizeof(struct sockaddr), host_string,
+                         sizeof(host_string), serv_string,
+                         sizeof(serv_string), NI_NUMERICHOST | NI_NUMERICSERV);
+
+    NA_LOG_SUBSYS_WARNING(addr, "Received connection req from %s:%s", host_string, serv_string);
+
     /* Lookup address from table */
     addr_key = (ucs_sock_addr_t){
         .addr = (const struct sockaddr *) &conn_request_attrs.client_address,
         .addrlen = sizeof(conn_request_attrs.client_address)};
     na_ucx_addr = na_ucx_addr_map_lookup(&na_ucx_class->addr_map, &addr_key);
-    NA_CHECK_SUBSYS_ERROR_NORET(addr, na_ucx_addr != NULL, error,
-        "An entry is already present for this address");
+ 
+
+    if (na_ucx_addr != NULL) {
+        NA_LOG_SUBSYS_WARNING(addr,
+	    "An entry is already present for this address: %s:%s, refcnt: %d",
+            host_string, serv_string, na_ucx_addr->refcount);
+        na_ucx_addr_map_remove(&na_ucx_class->addr_map, &addr_key);
+    }
 
     /* Insert new entry and create new address */
     na_ret = na_ucx_addr_map_insert(na_ucx_class, &na_ucx_class->addr_map,
-        &addr_key, conn_request, &na_ucx_addr);
+        &addr_key, conn_request, &na_ucx_addr, host_string, serv_string);
     NA_CHECK_SUBSYS_NA_ERROR(
         addr, error, na_ret, "Could not insert new address");
 
@@ -1743,12 +1762,20 @@ error:
 /*---------------------------------------------------------------------------*/
 static void
 na_ucp_ep_error_cb(
-    void *arg, ucp_ep_h NA_UNUSED ep, ucs_status_t NA_DEBUG_LOG_USED status)
+    void *arg, ucp_ep_h ep, ucs_status_t NA_DEBUG_LOG_USED status)
 {
+    char host_string[NI_MAXHOST];
+    char serv_string[NI_MAXSERV];
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) arg;
 
-    NA_LOG_SUBSYS_DEBUG(addr, "ep_err_handler() returned (%s) for address (%p)",
-        ucs_status_string(status), (void *) na_ucx_addr);
+    int rc = getnameinfo((const struct sockaddr *) &na_ucx_addr->ss_addr,
+                         sizeof(struct sockaddr), host_string,
+                         sizeof(host_string), serv_string,
+                         sizeof(serv_string), NI_NUMERICHOST | NI_NUMERICSERV);
+
+    NA_LOG_SUBSYS_WARNING(addr,
+        "ep_err_handler() returned (%s) for address (%s:%s), ep (%p) with refcnt: %d",
+        ucs_status_string(status), host_string, serv_string, ep, na_ucx_addr->refcount);
 
     /* Mark addr as no longer resolved to force reconnection */
     hg_atomic_and32(&na_ucx_addr->status, ~NA_UCX_ADDR_RESOLVED);
@@ -1775,9 +1802,10 @@ na_ucp_am_send(ucp_ep_h ep, const void *buf, size_t buf_size,
 {
     const ucp_request_param_t send_params = {
         .op_attr_mask = UCP_OP_ATTR_FIELD_REQUEST | UCP_OP_ATTR_FIELD_CALLBACK |
-                        UCP_OP_ATTR_FIELD_FLAGS,
+                        UCP_OP_ATTR_FIELD_FLAGS | UCP_OP_ATTR_FIELD_USER_DATA,
         .cb = {.send = na_ucp_am_send_cb},
         .flags = UCP_AM_SEND_FLAG_REPLY,
+        .user_data = (void *) ep,
         .request = request};
     ucs_status_ptr_t status_ptr;
     na_return_t ret;
@@ -1809,12 +1837,13 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static void
-na_ucp_am_send_cb(void *request, ucs_status_t status, void NA_UNUSED *user_data)
+na_ucp_am_send_cb(void *request, ucs_status_t status, void *user_data)
 {
     na_return_t cb_ret;
-
+    ucp_ep_h ep = (ucp_ep_h) user_data;
     NA_LOG_SUBSYS_DEBUG(
-        msg, "ucp_am_send_nbx() completed (%s)", ucs_status_string(status));
+        msg, "ucp_am_send_nbx() completed (%s) ep (%p)",
+        ucs_status_string(status), (void *) ep);
 
     if (status == UCS_OK)
         NA_GOTO_DONE(done, cb_ret, NA_SUCCESS);
@@ -1822,8 +1851,8 @@ na_ucp_am_send_cb(void *request, ucs_status_t status, void NA_UNUSED *user_data)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
         NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucs_status_to_na(status),
-            "ucp_am_send_nbx() failed (%s)", ucs_status_string(status));
-
+            "ucp_am_send_nbx() failed (%s) for ep (%p)",
+             ucs_status_string(status), (void *) ep);
 done:
     na_ucx_complete((struct na_ucx_op_id *) request, cb_ret);
 }
@@ -1887,10 +1916,11 @@ na_ucp_am_recv_cb(void *arg, const void *header, size_t header_length,
     struct na_ucx_op_queue *unexpected_op_queue =
         &na_ucx_class->unexpected_op_queue;
     struct na_ucx_op_id *na_ucx_op_id = NULL;
-    struct na_ucx_addr *source_addr = NULL;
+    struct  na_ucx_addr *source_addr = NULL;
     ucp_tag_t tag;
     ucs_status_t ret;
 
+
     /* Retrieve tag */
     NA_CHECK_SUBSYS_ERROR(msg, header_length != sizeof(tag), error, ret,
         UCS_ERR_INVALID_PARAM, "Invalid tag size (%zu)", header_length);
@@ -1908,8 +1938,9 @@ na_ucp_am_recv_cb(void *arg, const void *header, size_t header_length,
         na_ucx_addr_ep_lookup(&na_ucx_class->addr_map, param->reply_ep);
     NA_CHECK_SUBSYS_ERROR(addr, source_addr == NULL, error, ret,
         UCS_ERR_INVALID_PARAM,
-        "No entry found for previously inserted src addr");
-
+        "No entry found for previously inserted src addr - ep (%p)",
+        (void *) param->reply_ep);
+        
     /* Pop op ID from queue */
     hg_thread_spin_lock(&unexpected_op_queue->lock);
     na_ucx_op_id = HG_QUEUE_FIRST(&unexpected_op_queue->queue);
@@ -2417,7 +2448,8 @@ na_ucx_addr_map_lookup(struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key)
 static na_return_t
 na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
     struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key,
-    ucp_conn_request_h conn_request, struct na_ucx_addr **na_ucx_addr_p)
+    ucp_conn_request_h conn_request, struct na_ucx_addr **na_ucx_addr_p,
+    char* host_string, char* serv_string)
 {
     struct na_ucx_addr *na_ucx_addr = NULL;
     na_return_t ret = NA_SUCCESS;
@@ -3001,9 +3033,10 @@ na_ucx_check_protocol(const char *protocol_name)
         "ucp_config_read() failed (%s)", ucs_status_string(status));
 
     /* Try to use requested protocol */
-    status = ucp_config_modify(config, "TLS", protocol_name);
+    status = ucp_config_modify(config, "TLS", prot_name);
     NA_CHECK_SUBSYS_ERROR_NORET(cls, status != UCS_OK, done,
-        "ucp_config_modify() failed (%s)", ucs_status_string(status));
+        "ucp_config_modify() failed (%s) %s-%s", ucs_status_string(status),
+         protocol_name, prot_name);
 
     status = ucp_init(&params, config, &context);
     if (status == UCS_OK) {
@@ -3340,7 +3373,7 @@ na_ucx_addr_lookup(na_class_t *na_class, const char *name, na_addr_t **addr_p)
 
         /* Insert new entry and create new address if needed */
         na_ret = na_ucx_addr_map_insert(na_ucx_class, &na_ucx_class->addr_map,
-            &addr_key, NULL, &na_ucx_addr);
+            &addr_key, NULL, &na_ucx_addr, host_string, serv_string);
         freeaddrinfo(hostname_res);
         NA_CHECK_SUBSYS_ERROR(addr, na_ret != NA_SUCCESS && na_ret != NA_EXIST,
             error, ret, na_ret, "Could not insert new address");
