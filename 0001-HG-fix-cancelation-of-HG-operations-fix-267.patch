--- b/Testing/CMakeLists.txt
+++ a/Testing/CMakeLists.txt
@@ -180,7 +180,7 @@
 
   # Coresident test (disable for BMI and MPI)
   if(MERCURY_TESTING_CORESIDENT AND
+    (NOT ((${comm} STREQUAL "bmi") OR (${comm} STREQUAL "mpi"))))
-    (NOT ((${comm} STREQUAL "bmi") OR (${comm} STREQUAL "mpi") OR (${test_name} STREQUAL "cancel"))))
     set(cores_test_name ${full_test_name}_self)
     set(cores_test_args ${test_args} --self_send)
     if (MERCURY_ENABLE_PARALLEL_TESTING)
@@ -267,7 +267,6 @@
   rpc
   bulk
   overflow
-  cancel
 )
 if(NOT WIN32)
   set(MERCURY_tests ${MERCURY_tests} posix)
@@ -287,3 +286,6 @@
   build_mercury_test(${MERCURY_test})
   add_mercury_test(${MERCURY_test})
 endforeach()
+
+#add_mercury_opt_test(bulk_seg "extra")
+#add_mercury_opt_test(bulk_seg "variable")
--- b/Testing/mercury_rpc_cb.c
+++ a/Testing/mercury_rpc_cb.c
@@ -1088,16 +1088,6 @@
 }
 
 /*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_cancel_rpc, handle)
-{
-    /* Destroy twice and do not send expected response back */
-    HG_Destroy(handle);
-    HG_Destroy(handle);
-
-    return HG_SUCCESS;
-}
-
-/*---------------------------------------------------------------------------*/
 //static hg_return_t
 //hg_test_nested1_forward_cb(const struct hg_cb_info *callback_info)
 //{
@@ -1187,7 +1177,6 @@
 HG_TEST_THREAD_CB(hg_test_perf_bulk)
 HG_TEST_THREAD_CB(hg_test_perf_bulk_read)
 HG_TEST_THREAD_CB(hg_test_overflow)
-HG_TEST_THREAD_CB(hg_test_cancel_rpc)
 //HG_TEST_THREAD_CB(hg_test_nested1)
 //HG_TEST_THREAD_CB(hg_test_nested2)
 
--- b/Testing/mercury_rpc_cb.h
+++ a/Testing/mercury_rpc_cb.h
@@ -68,12 +68,6 @@
 hg_test_overflow_cb(hg_handle_t handle);
 
 /**
- * test_cancel
- */
-hg_return_t
-hg_test_cancel_rpc_cb(hg_handle_t handle);
-
-/**
  * test_nested
  */
 hg_return_t
--- b/Testing/mercury_test.c
+++ a/Testing/mercury_test.c
@@ -93,9 +93,6 @@
 /* test_overflow */
 hg_id_t hg_test_overflow_id_g = 0;
 
-/* test_cancel */
-hg_id_t hg_test_cancel_rpc_id_g = 0;
-
 /* test_nested */
 hg_id_t hg_test_nested1_id_g = 0;
 hg_id_t hg_test_nested2_id_g = 0;
@@ -314,10 +311,6 @@
     hg_test_overflow_id_g = MERCURY_REGISTER(hg_class, "hg_test_overflow",
             void, overflow_out_t, hg_test_overflow_cb);
 
-    /* test_cancel */
-    hg_test_cancel_rpc_id_g = MERCURY_REGISTER(hg_class, "hg_test_cancel_rpc",
-            void, void, hg_test_cancel_rpc_cb);
-
     /* test_nested */
 //    hg_test_nested1_id_g = MERCURY_REGISTER(hg_class, "hg_test_nested",
 //            void, void, hg_test_nested1_cb);
--- b/Testing/test_cancel.c
+++ a/Testing/test_cancel.c
@@ -13,68 +13,128 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+extern hg_id_t hg_test_rpc_open_id_g;
+extern hg_id_t hg_test_bulk_write_id_g;
-extern hg_id_t hg_test_cancel_rpc_id_g;
-
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
 
-/*---------------------------------------------------------------------------*/
-/**
- * HG_Forward callback
- */
 static hg_return_t
 hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
 {
+    hg_handle_t handle = callback_info->info.forward.handle;
     hg_request_t *request = (hg_request_t *) callback_info->arg;
+    int rpc_open_ret;
+    int rpc_open_event_id;
+    rpc_open_out_t rpc_open_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
     if (callback_info->ret != HG_CANCELED) {
+        fprintf(stderr, "Error: HG_Forward() was not canceled: %d\n",
-        HG_TEST_LOG_DEBUG("Error: HG_Forward() was not canceled: %d",
             callback_info->ret);
+
+        /* Get output */
+        ret = HG_Get_output(handle, &rpc_open_out_struct);
+        if (ret != HG_SUCCESS) {
+            fprintf(stderr, "Could not get output\n");
+            goto done;
+        }
+
+        /* Get output parameters */
+        rpc_open_ret = rpc_open_out_struct.ret;
+        rpc_open_event_id = rpc_open_out_struct.event_id;
+        printf("rpc_open returned: %d with event_id: %d\n", rpc_open_ret,
+            rpc_open_event_id);
+
+        /* Free request */
+        ret = HG_Free_output(handle, &rpc_open_out_struct);
+        if (ret != HG_SUCCESS) {
+            fprintf(stderr, "Could not free output\n");
+            goto done;
+        }
     } else {
+        printf("HG_Forward() was successfully canceled\n");
-        HG_TEST_LOG_DEBUG("HG_Forward() was successfully canceled");
     }
 
     hg_request_complete(request);
 
+done:
     return ret;
 }
 
+#ifdef NA_HAS_CCI
-/*---------------------------------------------------------------------------*/
 static hg_return_t
+hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info)
+{
+    hg_handle_t handle = callback_info->info.forward.handle;
+    hg_request_t *request = (hg_request_t *) callback_info->arg;
+    size_t bulk_write_ret = 0;
+    bulk_write_out_t bulk_write_out_struct;
+    hg_return_t ret = HG_SUCCESS;
+
+    if (callback_info->ret != HG_CANCELED) {
+        /* Get output */
+        ret = HG_Get_output(handle, &bulk_write_out_struct);
+        if (ret != HG_SUCCESS) {
+            fprintf(stderr, "Could not get output\n");
+            goto done;
+        }
+
+        /* Get output parameters */
+        bulk_write_ret = bulk_write_out_struct.ret;
+        printf("bulk_write returned: %zu\n", bulk_write_ret);
+
+        /* Free request */
+        ret = HG_Free_output(handle, &bulk_write_out_struct);
+        if (ret != HG_SUCCESS) {
+            fprintf(stderr, "Could not free output\n");
+            goto done;
+        }
+    } else {
+        printf("HG_Forward() was successfully canceled\n");
+    }
+
+    hg_request_complete(request);
+
+done:
+    return ret;
+}
+#endif
+
+static hg_return_t
+cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr)
-hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
     hg_handle_t handle;
+
+    rpc_open_in_t rpc_open_in_struct;
+    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    rpc_handle_t rpc_open_handle;
+    hg_return_t ret;
-    hg_return_t ret = HG_SUCCESS;
 
     request = hg_request_create(request_class);
 
+    ret = HG_Create(context, addr, hg_test_rpc_open_id_g, &handle);
-    /* Create RPC request */
-    ret = HG_Create(context, addr, rpc_id, &handle);
     if (ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not start call\n");
-        HG_TEST_LOG_ERROR("Could not create handle");
         goto done;
     }
 
+    /* Fill input structure */
+    rpc_open_handle.cookie = 12345;
+    rpc_open_in_struct.path = rpc_open_path;
+    rpc_open_in_struct.handle = rpc_open_handle;
+
     /* Forward call to remote addr and get a new request */
+    printf("Forwarding rpc_open, op id: %u...\n", hg_test_rpc_open_id_g);
+    ret = HG_Forward(handle, hg_test_rpc_forward_cb, request,
+        &rpc_open_in_struct);
-    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
-    ret = HG_Forward(handle, callback, request, NULL);
     if (ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not forward call\n");
-        HG_TEST_LOG_ERROR("Could not forward call");
         goto done;
     }
 
-    /* Cancel request */
     ret = HG_Cancel(handle);
     if (ret != HG_SUCCESS) {
+        fprintf(stderr, "HG_Cancel failed: %d\n", ret);
-        HG_TEST_LOG_ERROR("Could not cancel call");
         goto done;
     }
 
@@ -83,40 +143,114 @@
     /* Complete */
     ret = HG_Destroy(handle);
     if (ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not complete\n");
-        HG_TEST_LOG_ERROR("Could not destroy handle");
         goto done;
     }
 
+    hg_request_destroy(request);
+
 done:
-    hg_request_destroy(request);
     return ret;
 }
 
+#ifdef NA_HAS_CCI
+static hg_return_t
+cancel_bulk_transfer(hg_class_t *hg_class, hg_context_t *context,
+    hg_request_class_t *request_class, hg_addr_t addr)
-/*---------------------------------------------------------------------------*/
-int
-main(int argc, char *argv[])
 {
+    hg_request_t *request = NULL;
+    hg_handle_t handle;
+    bulk_write_in_t bulk_write_in_struct;
+    int *bulk_buf = NULL;
+    void *buf_ptr[1];
+    size_t count =  (1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE) / sizeof(int);
+    size_t bulk_size = count * sizeof(int);
+    hg_bulk_t bulk_handle = HG_BULK_NULL;
+    hg_return_t ret;
+    size_t i;
+
+    /* Prepare bulk_buf */
+    bulk_buf = (int*) malloc(bulk_size);
+    for (i = 0; i < count; i++) {
+        bulk_buf[i] = (int) i;
+    }
+    *buf_ptr = bulk_buf;
+
+    request = hg_request_create(request_class);
+
+    ret = HG_Create(context, addr, hg_test_bulk_write_id_g, &handle);
+    if (ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not start call\n");
+        goto done;
+    }
+
+    /* Register memory */
+    ret = HG_Bulk_create(hg_class, 1, buf_ptr, (hg_size_t *) &bulk_size,
+            HG_BULK_READ_ONLY, &bulk_handle);
+    if (ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not create bulk data handle\n");
+        goto done;
+    }
+
+    /* Fill input structure */
+    bulk_write_in_struct.fildes = -1; /* To tell target to cancel bulk transfer */
+    bulk_write_in_struct.bulk_handle = bulk_handle;
+
+    /* Forward call to remote addr and get a new request */
+    printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_write_id_g);
+    ret = HG_Forward(handle, hg_test_bulk_forward_cb, request,
+            &bulk_write_in_struct);
+    if (ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not forward call\n");
+        goto done;
+    }
+
+    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+    /* Free memory handle */
+    ret = HG_Bulk_free(bulk_handle);
+    if (ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not free bulk data handle\n");
+        goto done;
+    }
+
+    /* Complete */
+    ret = HG_Destroy(handle);
+    if (ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not complete\n");
-    struct hg_test_info hg_test_info = { 0 };
-    hg_return_t hg_ret;
-    int ret = EXIT_SUCCESS;
-
-    /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
-
-    /* Cancel RPC test */
-    HG_TEST("cancel RPC");
-    hg_ret = hg_test_cancel_rpc(hg_test_info.context,
-        hg_test_info.request_class, hg_test_info.target_addr,
-        hg_test_cancel_rpc_id_g, hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
         goto done;
     }
+
+    hg_request_destroy(request);
-    HG_PASSED();
 
 done:
-    if (ret != EXIT_SUCCESS)
-        HG_FAILED();
-    HG_Test_finalize(&hg_test_info);
     return ret;
 }
+#endif
+
+/******************************************************************************/
+int
+main(int argc, char *argv[])
+{
+    hg_class_t *hg_class = NULL;
+    hg_context_t *context = NULL;
+    hg_request_class_t *request_class = NULL;
+    hg_addr_t addr;
+
+    /* Initialize the interface (for convenience, shipper_test_client_init
+     * initializes the network interface with the selected plugin)
+     */
+    hg_class = HG_Test_client_init(argc, argv, &addr, NULL, &context,
+        &request_class);
+
+    cancel_rpc(context, request_class, addr);
+
+#ifdef NA_HAS_CCI
+    if (strcmp(HG_Class_get_name(hg_class), "cci") == 0)
+        cancel_bulk_transfer(hg_class, context, request_class, addr);
+#endif
+
+    HG_Test_finalize(hg_class);
+
+    return EXIT_SUCCESS;
+}
--- b/src/mercury_core.c
+++ a/src/mercury_core.c
@@ -489,7 +489,7 @@
 /**
  * Reset handle.
  */
+static hg_return_t
-static void
 hg_core_reset(
         struct hg_core_handle *hg_core_handle,
         hg_bool_t reset_info
@@ -535,7 +535,7 @@
 /**
  * Send response locally.
  */
+static hg_return_t
-static HG_INLINE hg_return_t
 hg_core_respond_self(
         struct hg_core_handle *hg_core_handle
         );
@@ -543,7 +543,7 @@
 /**
  * Do not send response locally.
  */
+static hg_return_t
-static HG_INLINE hg_return_t
 hg_core_no_respond_self(
         struct hg_core_handle *hg_core_handle
         );
@@ -560,7 +560,7 @@
 /**
  * Do not send response through NA.
  */
+static hg_return_t
-static HG_INLINE hg_return_t
 hg_core_no_respond_na(
         struct hg_core_handle *hg_core_handle
         );
@@ -568,7 +568,7 @@
 /**
  * Send input callback.
  */
+static int
-static HG_INLINE int
 hg_core_send_input_cb(
         const struct na_cb_info *callback_info
         );
@@ -593,7 +593,7 @@
 /**
  * Send output callback.
  */
+static int
-static HG_INLINE int
 hg_core_send_output_cb(
         const struct na_cb_info *callback_info
         );
@@ -601,7 +601,7 @@
 /**
  * Recv output callback.
  */
+static int
-static HG_INLINE int
 hg_core_recv_output_cb(
         const struct na_cb_info *callback_info
         );
@@ -612,8 +612,7 @@
 static hg_return_t
 hg_core_process_output(
         struct hg_core_handle *hg_core_handle,
+        hg_bool_t *completed
-        hg_bool_t *completed,
-        hg_return_t (*done_callback)(hg_core_handle_t)
         );
 
 /**
@@ -627,7 +626,7 @@
 /**
  * Send ack callback. (HG_CORE_MORE_DATA flag on output)
  */
+static int
-static HG_INLINE int
 hg_core_send_ack_cb(
         const struct na_cb_info *callback_info
         );
@@ -635,7 +634,7 @@
 /**
  * Recv ack callback. (HG_CORE_MORE_DATA flag on output)
  */
+static int
-static HG_INLINE int
 hg_core_recv_ack_cb(
         const struct na_cb_info *callback_info
         );
@@ -667,16 +666,6 @@
         );
 
 /**
- * Complete handle and NA operation.
- */
-static HG_INLINE hg_return_t
-hg_core_complete_na(
-        struct hg_core_handle *hg_core_handle,
-        na_op_id_t *op_id,
-        hg_bool_t *completed
-        );
-
-/**
  * Complete handle and add to completion queue.
  */
 static HG_INLINE hg_return_t
@@ -1878,9 +1867,20 @@
 }
 
 /*---------------------------------------------------------------------------*/
+static hg_return_t
-static void
 hg_core_reset(struct hg_core_handle *hg_core_handle, hg_bool_t reset_info)
 {
+    hg_return_t ret = HG_SUCCESS;
+
+    if (hg_atomic_get32(&hg_core_handle->in_use)) {
+        /* Not safe to reset
+         * TODO could add the ability to defer the reset operation */
+        HG_LOG_ERROR("Cannot reset HG core handle, handle is still in use, "
+            "refcount: %d", hg_atomic_get32(&hg_core_handle->ref_count));
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
+
     /* Reset source address */
     if (reset_info) {
         if (hg_core_handle->hg_info.addr != HG_CORE_ADDR_NULL
@@ -1918,6 +1918,9 @@
 
     hg_core_header_request_reset(&hg_core_handle->in_header);
     hg_core_header_response_reset(&hg_core_handle->out_header);
+
+done:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2066,7 +2069,7 @@
 
 /*---------------------------------------------------------------------------*/
 #ifdef HG_HAS_SELF_FORWARD
+static hg_return_t
-static HG_INLINE hg_return_t
 hg_core_respond_self(struct hg_core_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
@@ -2086,7 +2089,7 @@
 }
 
 /*---------------------------------------------------------------------------*/
+static hg_return_t
-static HG_INLINE hg_return_t
 hg_core_no_respond_self(struct hg_core_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
@@ -2113,9 +2116,6 @@
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
-    /* Increment number of expected NA operations */
-    hg_core_handle->na_op_count++;
-
     /* Set operation type for trigger */
     hg_core_handle->op_type = HG_CORE_RESPOND;
 
@@ -2168,7 +2168,7 @@
 }
 
 /*---------------------------------------------------------------------------*/
+static hg_return_t
-static HG_INLINE hg_return_t
 hg_core_no_respond_na(struct hg_core_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
@@ -2187,13 +2187,16 @@
 }
 
 /*---------------------------------------------------------------------------*/
+static int
-static HG_INLINE int
 hg_core_send_input_cb(const struct na_cb_info *callback_info)
 {
+    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) callback_info->arg;
-    struct hg_core_handle *hg_core_handle =
-        (struct hg_core_handle *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
+    int ret = 0;
+
+    /* Reset op ID value */
+    if (!hg_core_handle->na_op_id_mine)
+        hg_core_handle->na_send_op_id = NA_OP_ID_NULL;
-    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
@@ -2204,24 +2207,28 @@
         goto done;
     }
 
+    /* Add handle to completion queue only when all operations have completed */
+    if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
+        == (hg_util_int32_t) hg_core_handle->na_op_count) {
+        /* Mark as completed */
+        if (hg_core_complete(hg_core_handle) != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not complete operation");
+            goto done;
+        }
+        /* Increment number of entries added to completion queue */
+        ret++;
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_send_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
     }
 
 done:
+    (void) na_ret;
+    return ret;
-    (void) na_ret; /* unused */
-    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
 static int
 hg_core_recv_input_cb(const struct na_cb_info *callback_info)
 {
+    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) callback_info->arg;
-    struct hg_core_handle *hg_core_handle =
-        (struct hg_core_handle *) callback_info->arg;
     struct hg_core_context *hg_core_context = hg_core_handle->hg_info.context;
     const struct na_cb_info_recv_unexpected *na_cb_info_recv_unexpected =
         &callback_info->info.recv_unexpected;
@@ -2232,12 +2239,17 @@
 # endif
 #endif
     na_return_t na_ret = NA_SUCCESS;
+    hg_bool_t completed = HG_FALSE;
+    int ret = 0;
+
+    /* Reset op ID value */
+    if (!hg_core_handle->na_op_id_mine)
+        hg_core_handle->na_recv_op_id = NA_OP_ID_NULL;
-    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
+        /* May only decrement refcount */
-        /* Only decrement refcount and exit */
         hg_core_destroy(hg_core_handle);
         goto done;
     } else if (callback_info->ret != NA_SUCCESS) {
@@ -2246,6 +2258,9 @@
         goto done;
     }
 
+    /* Increment NA completed count */
+    hg_atomic_incr32(&hg_core_handle->na_op_completed_count);
+
     /* Fill unexpected info */
     hg_core_handle->hg_info.addr->na_addr = na_cb_info_recv_unexpected->source;
     hg_core_handle->tag = na_cb_info_recv_unexpected->tag;
@@ -2302,17 +2317,12 @@
         goto done;
     }
 
+    /* Increment number of entries added to completion queue */
+    ret = (int) completed;
-    /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_recv_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
 
 done:
+    (void) na_ret;
+    return ret;
-    (void) na_ret; /* unused */
-    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2345,6 +2355,10 @@
     /* Parse flags */
     hg_core_handle->no_response = hg_core_handle->in_header.msg.request.flags
         & HG_CORE_NO_RESPONSE;
+    if (!hg_core_handle->no_response) {
+        /* Increment number of expected NA operations */
+        hg_core_handle->na_op_count++;
+    }
 #ifdef HG_HAS_SELF_FORWARD
     hg_core_handle->respond = hg_core_handle->in_header.msg.request.flags
         & HG_CORE_SELF_FORWARD ? hg_core_respond_self : hg_core_respond_na;
@@ -2373,21 +2387,30 @@
             goto done;
         }
         *completed = HG_FALSE;
+    } else {
+        ret = hg_core_complete(hg_core_handle);
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not complete operation");
+            goto done;
+        }
-    } else
         *completed = HG_TRUE;
+    }
 
 done:
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
+static int
-static HG_INLINE int
 hg_core_send_output_cb(const struct na_cb_info *callback_info)
 {
+    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) callback_info->arg;
-    struct hg_core_handle *hg_core_handle =
-        (struct hg_core_handle *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
+    int ret = 0;
+
+    /* Reset op ID value */
+    if (!hg_core_handle->na_op_id_mine)
+        hg_core_handle->na_send_op_id = NA_OP_ID_NULL;
-    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
@@ -2398,27 +2421,37 @@
         goto done;
     }
 
+    /* TODO common code with hg_core_no_respond_na */
+
+    /* Mark as completed (sanity check for NA op completed count) */
+    if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
+        == (hg_util_int32_t) hg_core_handle->na_op_count) {
+        if (hg_core_complete(hg_core_handle) != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not complete operation");
+            goto done;
+        }
+        /* Increment number of entries added to completion queue */
+        ret++;
-    /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_send_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
     }
 
 done:
+    (void) na_ret;
+    return ret;
-    (void) na_ret; /* unused */
-    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
+static int
-static HG_INLINE int
 hg_core_recv_output_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_handle *hg_core_handle =
         (struct hg_core_handle *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
+    hg_bool_t completed = HG_FALSE;
+    int ret = 0;
+
+    /* Reset op ID value */
+    if (!hg_core_handle->na_op_id_mine)
+        hg_core_handle->na_recv_op_id = NA_OP_ID_NULL;
-    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
@@ -2430,30 +2463,23 @@
     }
 
     /* Process output information */
+    if (hg_core_process_output(hg_core_handle, &completed) != HG_SUCCESS) {
-    if (hg_core_handle->ret != HG_CANCELED
-        && hg_core_process_output(hg_core_handle, &completed, hg_core_send_ack)
-            != HG_SUCCESS) {
         HG_LOG_ERROR("Could not process output");
         goto done;
     }
 
+    /* Increment number of entries added to completion queue */
+    ret = (int) completed;
-    /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_recv_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
 
 done:
+    (void) na_ret;
+    return ret;
-    (void) na_ret; /* unused */
-    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
 hg_core_process_output(struct hg_core_handle *hg_core_handle,
+    hg_bool_t *completed)
-    hg_bool_t *completed, hg_return_t (*done_callback)(hg_core_handle_t))
 {
     struct hg_core_context *hg_core_context = hg_core_handle->hg_info.context;
     hg_return_t ret = HG_SUCCESS;
@@ -2479,14 +2505,24 @@
             goto done;
         }
         ret = hg_core_context->hg_core_class->more_data_acquire(
+            (hg_core_handle_t) hg_core_handle, HG_OUTPUT, hg_core_send_ack);
-            (hg_core_handle_t) hg_core_handle, HG_OUTPUT, done_callback);
         if (ret != HG_SUCCESS) {
             HG_LOG_ERROR("Error in HG core handle more data acquire callback");
             goto done;
         }
         *completed = HG_FALSE;
+        goto done;
+    } else if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
+        == (hg_util_int32_t) hg_core_handle->na_op_count) {
+        /* Add handle to completion queue when all operations have completed */
+        ret = hg_core_complete(hg_core_handle);
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not complete operation");
+            goto done;
+        }
+        *completed = HG_TRUE;
     } else
+        *completed = HG_FALSE;
-        *completed = HG_TRUE;
 
 done:
     return ret;
@@ -2499,9 +2535,6 @@
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
-    /* Increment number of expected NA operations */
-    hg_core_handle->na_op_count++;
-
     /* Allocate buffer for ack */
     hg_core_handle->ack_buf = NA_Msg_buf_alloc(hg_core_handle->na_class,
         sizeof(hg_uint8_t), &hg_core_handle->ack_buf_plugin_data);
@@ -2532,13 +2565,17 @@
 }
 
 /*---------------------------------------------------------------------------*/
+static int
-static HG_INLINE int
 hg_core_send_ack_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_handle *hg_core_handle =
         (struct hg_core_handle *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
+    hg_bool_t completed = HG_FALSE;
+    int ret = 0;
+
+    /* Reset op ID value */
+    hg_core_handle->na_ack_op_id = NA_OP_ID_NULL;
-    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
@@ -2549,27 +2586,35 @@
         goto done;
     }
 
+    /* Add handle to completion queue when all operations have completed */
+    if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
+        == (hg_util_int32_t) hg_core_handle->na_op_count) {
+        if (hg_core_complete(hg_core_handle) != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not complete operation");
+            goto done;
+        }
+        completed = HG_TRUE;
-    /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_ack_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
     }
 
+    /* Increment number of entries added to completion queue */
+    ret = (int) completed;
+
 done:
+    (void) na_ret;
+    return ret;
-    (void) na_ret; /* unused */
-    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
+static int
-static HG_INLINE int
 hg_core_recv_ack_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_handle *hg_core_handle =
         (struct hg_core_handle *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
+    int ret = 0;
+
+    /* Reset op ID value */
+    hg_core_handle->na_ack_op_id = NA_OP_ID_NULL;
-    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
@@ -2580,17 +2625,22 @@
         goto done;
     }
 
+    /* TODO common code with hg_core_no_respond_na */
+
+    /* Mark as completed (sanity check for NA op completed count) */
+    if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
+        == (hg_util_int32_t) hg_core_handle->na_op_count) {
+        if (hg_core_complete(hg_core_handle) != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not complete operation");
+            goto done;
+        }
+        /* Increment number of entries added to completion queue */
+        ret++;
-    /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_ack_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
     }
 
 done:
+    (void) na_ret;
+    return ret;
-    (void) na_ret; /* unused */
-    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2601,7 +2651,6 @@
     struct hg_core_handle *hg_core_handle =
         (struct hg_core_handle *) callback_info->info.respond.handle;
     hg_return_t ret;
-    hg_bool_t completed = HG_TRUE;
 
     /* First execute response callback */
     if (hg_core_handle->response_callback) {
@@ -2615,22 +2664,18 @@
         hg_core_handle->response_callback(&hg_core_cb_info);
     }
 
+    /* TODO response check header */
+
     /* Assign forward callback back to handle */
     hg_core_handle->op_type = HG_CORE_FORWARD_SELF;
 
     /* Increment refcount and push handle back to completion queue */
     hg_atomic_incr32(&hg_core_handle->ref_count);
 
+    ret = hg_core_complete(hg_core_handle);
-    /* Process output */
-    ret = hg_core_process_output(hg_core_handle, &completed, hg_core_complete);
     if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete handle");
+        goto done;
-       HG_LOG_ERROR("Could not process output");
-       goto done;
-   }
-
-    /* Mark as completed */
-    if (completed && hg_core_complete(hg_core_handle) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
     }
 
 done:
@@ -2652,11 +2697,7 @@
    if (hg_core_process_input(hg_core_handle, &completed) != HG_SUCCESS) {
        HG_LOG_ERROR("Could not process input");
    }
+   (void) completed;
-
-   /* Mark as completed */
-   if (completed && hg_core_complete(hg_core_handle) != HG_SUCCESS) {
-       HG_LOG_ERROR("Could not complete operation");
-   }
 
    return thread_ret;
 }
@@ -2707,34 +2748,6 @@
 
 /*---------------------------------------------------------------------------*/
 static HG_INLINE hg_return_t
-hg_core_complete_na(struct hg_core_handle *hg_core_handle, na_op_id_t *op_id,
-    hg_bool_t *completed)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    /* Reset op ID value */
-    if (!hg_core_handle->na_op_id_mine)
-        *op_id = NA_OP_ID_NULL;
-
-    /* Add handle to completion queue when expected operations have completed */
-    if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
-        == (hg_util_int32_t) hg_core_handle->na_op_count && *completed) {
-        /* Mark as completed */
-        if (hg_core_complete(hg_core_handle) != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
-        /* Increment number of entries added to completion queue */
-        *completed = HG_TRUE;
-    } else
-        *completed = HG_FALSE;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static HG_INLINE hg_return_t
 hg_core_complete(struct hg_core_handle *hg_core_handle)
 {
     struct hg_core_context *context = hg_core_handle->hg_info.context;
@@ -2909,8 +2922,11 @@
         goto done;
 
     /* Reset the handle */
+    ret = hg_core_reset(hg_core_handle, HG_TRUE);
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Cannot reset handle");
+        goto done;
+    }
-    hg_core_reset(hg_core_handle, HG_TRUE);
-
     /* Also reset additional handle parameters */
     hg_atomic_set32(&hg_core_handle->ref_count, 1);
     hg_core_handle->hg_core_rpc_info = NULL;
@@ -3396,7 +3412,6 @@
         switch (hg_core_handle->op_type) {
 #ifdef HG_HAS_SELF_FORWARD
             case HG_CORE_FORWARD_SELF:
-                HG_FALLTHROUGH();
 #endif
             case HG_CORE_FORWARD:
                 hg_cb = hg_core_handle->request_callback;
@@ -3454,12 +3469,6 @@
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (hg_core_handle->is_self) {
-        HG_LOG_ERROR("Local cancelation is not supported");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
     /* Cancel all NA operations issued */
     if (hg_core_handle->na_recv_op_id != NA_OP_ID_NULL) {
         na_return_t na_ret;
@@ -3485,20 +3494,6 @@
         }
     }
 
-    /* TODO
-    if (hg_core_handle->na_ack_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret;
-
-        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-            hg_core_handle->na_ack_op_id);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel ack op id");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
-    }
-    */
-
 done:
     return ret;
 }
@@ -4741,15 +4736,11 @@
     }
 #endif
 
+    ret = hg_core_reset(hg_core_handle, HG_FALSE);
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not reset HG core handle");
-    /* Not safe to reset
-     * TODO could add the ability to defer the reset operation */
-    if (hg_atomic_get32(&hg_core_handle->in_use)) {
-        HG_LOG_ERROR("Cannot reset HG core handle, handle is still in use, "
-            "refcount: %d", hg_atomic_get32(&hg_core_handle->ref_count));
-        ret = HG_PROTOCOL_ERROR;
         goto done;
     }
-    hg_core_reset(hg_core_handle, HG_FALSE);
 
     /* Set addr / RPC ID */
     ret = hg_core_set_rpc(hg_core_handle, addr, id);
@@ -4949,7 +4940,8 @@
         goto done;
     }
 #ifndef HG_HAS_SELF_FORWARD
+    if (NA_Addr_is_self(hg_core_handle->hg_info.addr->na_class,
+        hg_core_handle->hg_info.addr->na_addr)) {
-    if (hg_core_handle->is_self) {
         HG_LOG_ERROR("Not enabled, please enable HG_USE_SELF_FORWARD");
         ret = HG_INVALID_PARAM;
         goto done;
