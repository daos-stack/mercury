diff --git a/CHANGELOG b/CHANGELOG
index 3a9a767..d247019 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -1,7 +1,28 @@
+================
+v1.0.1
+================
+Jerome Soumagne (12):
+  2019-02-11 HG: Fix HG_Reset() to reset NA resources upon NA class change (fix #272)
+  2019-01-18 HG Util: move inline functions for get/set and export create/destroy
+  2019-01-08 Travis: update build script to OFI 1.7.0
+  2019-01-07 Travis: update build script to OFI 1.7.0rc3
+  2018-12-19 NA SM: remove page size check that would prevent to run on system w pages        larger than 4KB (fix #268)
+  2018-12-07 Update CMake policy for CMake 3.12 and above
+  2018-12-07 HG Core: fix potential race when forcing a handle to be destroyed
+  2018-12-07 Update travis CI to use latest libfabric/CMake/MPICH
+  2018-12-06 NA OFI: fix cancelation of operations that cannot be canceled
+  2018-12-06 HG: fix cancelation of HG operations (fix #267)
+  2018-11-30 NA OFI: remove extra fi_addr_xxx prefix from URI
+  2018-11-30 Bump patch version
+
 ================
 v1.0.0rc2
 ================
-Jerome Soumagne (13):
+================
+v1.0.0
+================
+Jerome Soumagne (14):
+  2018-11-12 Update CHANGELOG
   2018-11-12 HG: fix uninitialized variable warning in hg_get_extra_payload() - part 2
   2018-11-12 HG: fix uninitialized variable warning in hg_get_extra_payload()
   2018-11-12 NA OFI: fix missing lock in mem pool alloc
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8231cc6..e7d46c8 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,7 +1,7 @@
 cmake_minimum_required(VERSION 2.8.12.2 FATAL_ERROR)
 
 # Setup cmake policies.
-foreach(p
+foreach(policy
     CMP0012
     CMP0013
     CMP0014
@@ -9,9 +9,11 @@ foreach(p
     CMP0025 # CMake 3.0
     CMP0053 # CMake 3.1
     CMP0054 # CMake 3.1
+    CMP0074 # CMake 3.12
+    CMP0075 # CMake 3.12
   )
-  if(POLICY ${p})
-    cmake_policy(SET ${p} NEW)
+  if(POLICY ${policy})
+    cmake_policy(SET ${policy} NEW)
   endif()
 endforeach()
 
diff --git a/COPYING b/COPYING
index d235cb6..e035e49 100644
--- a/COPYING
+++ b/COPYING
@@ -1,4 +1,4 @@
-Copyright (C) 2013-2018, Argonne National Laboratory, Department of Energy,
+Copyright (C) 2013-2019, Argonne National Laboratory, Department of Energy,
                    UChicago Argonne, LLC and The HDF Group.
 All rights reserved.
 
diff --git a/Examples/src/example_rpc.c b/Examples/src/example_rpc.c
index 152814e..54195b9 100644
--- a/Examples/src/example_rpc.c
+++ b/Examples/src/example_rpc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Examples/src/example_rpc.h b/Examples/src/example_rpc.h
index 4b3da9e..e4dda49 100644
--- a/Examples/src/example_rpc.h
+++ b/Examples/src/example_rpc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Examples/src/example_rpc_client.c b/Examples/src/example_rpc_client.c
index 120444d..d375d44 100644
--- a/Examples/src/example_rpc_client.c
+++ b/Examples/src/example_rpc_client.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Examples/src/example_rpc_engine.c b/Examples/src/example_rpc_engine.c
index b74532e..655192e 100644
--- a/Examples/src/example_rpc_engine.c
+++ b/Examples/src/example_rpc_engine.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Examples/src/example_rpc_engine.h b/Examples/src/example_rpc_engine.h
index 3d17067..f0ba6f8 100644
--- a/Examples/src/example_rpc_engine.h
+++ b/Examples/src/example_rpc_engine.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Examples/src/example_rpc_server.c b/Examples/src/example_rpc_server.c
index 77a9e0b..a4c2a10 100644
--- a/Examples/src/example_rpc_server.c
+++ b/Examples/src/example_rpc_server.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Examples/src/example_snappy.c b/Examples/src/example_snappy.c
index c76d5b6..47bf546 100644
--- a/Examples/src/example_snappy.c
+++ b/Examples/src/example_snappy.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Examples/src/example_snappy.h b/Examples/src/example_snappy.h
index bb4014d..0d8d6d5 100644
--- a/Examples/src/example_snappy.h
+++ b/Examples/src/example_snappy.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Examples/src/example_snappy_client.c b/Examples/src/example_snappy_client.c
index 9bcf044..7177d10 100644
--- a/Examples/src/example_snappy_client.c
+++ b/Examples/src/example_snappy_client.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Examples/src/example_snappy_server.c b/Examples/src/example_snappy_server.c
index 67a6328..ec84d72 100644
--- a/Examples/src/example_snappy_server.c
+++ b/Examples/src/example_snappy_server.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/README.md b/README.md
index 0a28689..f2a6ef4 100644
--- a/README.md
+++ b/README.md
@@ -83,7 +83,7 @@ The library itself is therefore not necessary since only the header is used.
 
 On Linux OpenPA v1.0.3 or higher is required (the version that is included
 with MPICH can also be used) for systems that do not have `stdatomic.h`
-(GCC version less than 4.8).
+(GCC version less than 4.9).
 
 Building
 ========
diff --git a/Testing/CMakeLists.txt b/Testing/CMakeLists.txt
index 08a871a..ce17a7f 100644
--- a/Testing/CMakeLists.txt
+++ b/Testing/CMakeLists.txt
@@ -180,7 +180,7 @@ macro(add_mercury_test_comm test_name comm protocol busy)
 
   # Coresident test (disable for BMI and MPI)
   if(MERCURY_TESTING_CORESIDENT AND
-    (NOT ((${comm} STREQUAL "bmi") OR (${comm} STREQUAL "mpi"))))
+    (NOT ((${comm} STREQUAL "bmi") OR (${comm} STREQUAL "mpi") OR (${test_name} STREQUAL "cancel"))))
     set(cores_test_name ${full_test_name}_self)
     set(cores_test_args ${test_args} --self_send)
     if (MERCURY_ENABLE_PARALLEL_TESTING)
@@ -267,6 +267,7 @@ set(MERCURY_tests
   rpc
   bulk
   overflow
+  cancel
 )
 if(NOT WIN32)
   set(MERCURY_tests ${MERCURY_tests} posix)
@@ -286,6 +287,3 @@ foreach(MERCURY_test ${MERCURY_tests})
   build_mercury_test(${MERCURY_test})
   add_mercury_test(${MERCURY_test})
 endforeach()
-
-#add_mercury_opt_test(bulk_seg "extra")
-#add_mercury_opt_test(bulk_seg "variable")
diff --git a/Testing/mercury_rpc_cb.c b/Testing/mercury_rpc_cb.c
index 3acafc0..5279c7f 100644
--- a/Testing/mercury_rpc_cb.c
+++ b/Testing/mercury_rpc_cb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -1087,6 +1087,16 @@ HG_TEST_RPC_CB(hg_test_overflow, handle)
     return ret;
 }
 
+/*---------------------------------------------------------------------------*/
+HG_TEST_RPC_CB(hg_test_cancel_rpc, handle)
+{
+    /* Destroy twice and do not send expected response back */
+    HG_Destroy(handle);
+    HG_Destroy(handle);
+
+    return HG_SUCCESS;
+}
+
 /*---------------------------------------------------------------------------*/
 //static hg_return_t
 //hg_test_nested1_forward_cb(const struct hg_cb_info *callback_info)
@@ -1177,6 +1187,7 @@ HG_TEST_THREAD_CB(hg_test_perf_rpc_lat)
 HG_TEST_THREAD_CB(hg_test_perf_bulk)
 HG_TEST_THREAD_CB(hg_test_perf_bulk_read)
 HG_TEST_THREAD_CB(hg_test_overflow)
+HG_TEST_THREAD_CB(hg_test_cancel_rpc)
 //HG_TEST_THREAD_CB(hg_test_nested1)
 //HG_TEST_THREAD_CB(hg_test_nested2)
 
diff --git a/Testing/mercury_rpc_cb.h b/Testing/mercury_rpc_cb.h
index 14b08e2..11c77bb 100644
--- a/Testing/mercury_rpc_cb.h
+++ b/Testing/mercury_rpc_cb.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -67,6 +67,12 @@ hg_test_perf_bulk_read_cb(hg_handle_t handle);
 hg_return_t
 hg_test_overflow_cb(hg_handle_t handle);
 
+/**
+ * test_cancel
+ */
+hg_return_t
+hg_test_cancel_rpc_cb(hg_handle_t handle);
+
 /**
  * test_nested
  */
diff --git a/Testing/mercury_test.c b/Testing/mercury_test.c
index 8213e56..0cd4be3 100644
--- a/Testing/mercury_test.c
+++ b/Testing/mercury_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -93,6 +93,9 @@ hg_id_t hg_test_perf_bulk_read_id_g = 0;
 /* test_overflow */
 hg_id_t hg_test_overflow_id_g = 0;
 
+/* test_cancel */
+hg_id_t hg_test_cancel_rpc_id_g = 0;
+
 /* test_nested */
 hg_id_t hg_test_nested1_id_g = 0;
 hg_id_t hg_test_nested2_id_g = 0;
@@ -311,6 +314,10 @@ hg_test_register(hg_class_t *hg_class)
     hg_test_overflow_id_g = MERCURY_REGISTER(hg_class, "hg_test_overflow",
             void, overflow_out_t, hg_test_overflow_cb);
 
+    /* test_cancel */
+    hg_test_cancel_rpc_id_g = MERCURY_REGISTER(hg_class, "hg_test_cancel_rpc",
+            void, void, hg_test_cancel_rpc_cb);
+
     /* test_nested */
 //    hg_test_nested1_id_g = MERCURY_REGISTER(hg_class, "hg_test_nested",
 //            void, void, hg_test_nested1_cb);
diff --git a/Testing/mercury_test.h b/Testing/mercury_test.h
index dd32455..e74fffe 100644
--- a/Testing/mercury_test.h
+++ b/Testing/mercury_test.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/mercury_test_config.h.in b/Testing/mercury_test_config.h.in
index 45d75ca..c1b44f1 100644
--- a/Testing/mercury_test_config.h.in
+++ b/Testing/mercury_test_config.h.in
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/mercury_test_drc.c b/Testing/mercury_test_drc.c
index b9b08c6..b383c1d 100644
--- a/Testing/mercury_test_drc.c
+++ b/Testing/mercury_test_drc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/mercury_test_drc.h b/Testing/mercury_test_drc.h
index a444fe9..fef6c6d 100644
--- a/Testing/mercury_test_drc.h
+++ b/Testing/mercury_test_drc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/na/na_test.c b/Testing/na/na_test.c
index 0969deb..b1b8190 100644
--- a/Testing/na/na_test.c
+++ b/Testing/na/na_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/na/na_test.h b/Testing/na/na_test.h
index 130fec2..62c1b61 100644
--- a/Testing/na/na_test.h
+++ b/Testing/na/na_test.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/na/na_test_getopt.c b/Testing/na/na_test_getopt.c
index 48c5914..3f2005d 100644
--- a/Testing/na/na_test_getopt.c
+++ b/Testing/na/na_test_getopt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/na/na_test_getopt.h b/Testing/na/na_test_getopt.h
index 634409f..c79ed14 100644
--- a/Testing/na/na_test_getopt.h
+++ b/Testing/na/na_test_getopt.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/na/test_cancel_client.c b/Testing/na/test_cancel_client.c
index 596c58c..5d6e36f 100644
--- a/Testing/na/test_cancel_client.c
+++ b/Testing/na/test_cancel_client.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/na/test_cancel_server.c b/Testing/na/test_cancel_server.c
index b70823d..b4dec3c 100644
--- a/Testing/na/test_cancel_server.c
+++ b/Testing/na/test_cancel_server.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/na/test_client.c b/Testing/na/test_client.c
index 9143bb0..9f2b24a 100644
--- a/Testing/na/test_client.c
+++ b/Testing/na/test_client.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/na/test_lat_client.c b/Testing/na/test_lat_client.c
index c107dd9..e0d2c16 100644
--- a/Testing/na/test_lat_client.c
+++ b/Testing/na/test_lat_client.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/na/test_lat_server.c b/Testing/na/test_lat_server.c
index c57f4c1..ea48512 100644
--- a/Testing/na/test_lat_server.c
+++ b/Testing/na/test_lat_server.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/na/test_server.c b/Testing/na/test_server.c
index 73559b6..67b068f 100644
--- a/Testing/na/test_server.c
+++ b/Testing/na/test_server.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/script/travis_build.sh b/Testing/script/travis_build.sh
index 0448391..f13e18f 100755
--- a/Testing/script/travis_build.sh
+++ b/Testing/script/travis_build.sh
@@ -1,10 +1,10 @@
 #!/bin/bash
 
-CMAKE_VERSION_MAJOR=3.11
-CMAKE_VERSION_MINOR=1
-MPI_VERSION=3.3b1
+CMAKE_VERSION_MAJOR=3.13
+CMAKE_VERSION_MINOR=2
+MPI_VERSION=3.3
 CCI_VERSION=2.1
-OFI_VERSION=1.6.2
+OFI_VERSION=1.7.0
 PREFIX=$HOME/install
 
 set -e
diff --git a/Testing/test_bulk.c b/Testing/test_bulk.c
index f575ea3..cfb31f2 100644
--- a/Testing/test_bulk.c
+++ b/Testing/test_bulk.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_bulk.h b/Testing/test_bulk.h
index 3009c16..02eecaf 100644
--- a/Testing/test_bulk.h
+++ b/Testing/test_bulk.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_bulk_seg.c b/Testing/test_bulk_seg.c
index fb62b02..c025d3f 100644
--- a/Testing/test_bulk_seg.c
+++ b/Testing/test_bulk_seg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_cancel.c b/Testing/test_cancel.c
index 0952c34..433336f 100644
--- a/Testing/test_cancel.c
+++ b/Testing/test_cancel.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -13,128 +13,68 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-extern hg_id_t hg_test_rpc_open_id_g;
-extern hg_id_t hg_test_bulk_write_id_g;
+extern hg_id_t hg_test_cancel_rpc_id_g;
 
+//#define HG_TEST_DEBUG
+#ifdef HG_TEST_DEBUG
+#define HG_TEST_LOG_DEBUG(...)                                \
+    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
+#else
+#define HG_TEST_LOG_DEBUG(...) (void)0
+#endif
+
+/*---------------------------------------------------------------------------*/
+/**
+ * HG_Forward callback
+ */
 static hg_return_t
 hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
 {
-    hg_handle_t handle = callback_info->info.forward.handle;
     hg_request_t *request = (hg_request_t *) callback_info->arg;
-    int rpc_open_ret;
-    int rpc_open_event_id;
-    rpc_open_out_t rpc_open_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
     if (callback_info->ret != HG_CANCELED) {
-        fprintf(stderr, "Error: HG_Forward() was not canceled: %d\n",
+        HG_TEST_LOG_DEBUG("Error: HG_Forward() was not canceled: %d",
             callback_info->ret);
-
-        /* Get output */
-        ret = HG_Get_output(handle, &rpc_open_out_struct);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not get output\n");
-            goto done;
-        }
-
-        /* Get output parameters */
-        rpc_open_ret = rpc_open_out_struct.ret;
-        rpc_open_event_id = rpc_open_out_struct.event_id;
-        printf("rpc_open returned: %d with event_id: %d\n", rpc_open_ret,
-            rpc_open_event_id);
-
-        /* Free request */
-        ret = HG_Free_output(handle, &rpc_open_out_struct);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not free output\n");
-            goto done;
-        }
     } else {
-        printf("HG_Forward() was successfully canceled\n");
+        HG_TEST_LOG_DEBUG("HG_Forward() was successfully canceled");
     }
 
     hg_request_complete(request);
 
-done:
     return ret;
 }
 
-#ifdef NA_HAS_CCI
+/*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info)
-{
-    hg_handle_t handle = callback_info->info.forward.handle;
-    hg_request_t *request = (hg_request_t *) callback_info->arg;
-    size_t bulk_write_ret = 0;
-    bulk_write_out_t bulk_write_out_struct;
-    hg_return_t ret = HG_SUCCESS;
-
-    if (callback_info->ret != HG_CANCELED) {
-        /* Get output */
-        ret = HG_Get_output(handle, &bulk_write_out_struct);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not get output\n");
-            goto done;
-        }
-
-        /* Get output parameters */
-        bulk_write_ret = bulk_write_out_struct.ret;
-        printf("bulk_write returned: %zu\n", bulk_write_ret);
-
-        /* Free request */
-        ret = HG_Free_output(handle, &bulk_write_out_struct);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not free output\n");
-            goto done;
-        }
-    } else {
-        printf("HG_Forward() was successfully canceled\n");
-    }
-
-    hg_request_complete(request);
-
-done:
-    return ret;
-}
-#endif
-
-static hg_return_t
-cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr)
+hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
     hg_handle_t handle;
-
-    rpc_open_in_t rpc_open_in_struct;
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
-    rpc_handle_t rpc_open_handle;
-    hg_return_t ret;
+    hg_return_t ret = HG_SUCCESS;
 
     request = hg_request_create(request_class);
 
-    ret = HG_Create(context, addr, hg_test_rpc_open_id_g, &handle);
+    /* Create RPC request */
+    ret = HG_Create(context, addr, rpc_id, &handle);
     if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not start call\n");
+        HG_TEST_LOG_ERROR("Could not create handle");
         goto done;
     }
 
-    /* Fill input structure */
-    rpc_open_handle.cookie = 12345;
-    rpc_open_in_struct.path = rpc_open_path;
-    rpc_open_in_struct.handle = rpc_open_handle;
-
     /* Forward call to remote addr and get a new request */
-    printf("Forwarding rpc_open, op id: %u...\n", hg_test_rpc_open_id_g);
-    ret = HG_Forward(handle, hg_test_rpc_forward_cb, request,
-        &rpc_open_in_struct);
+    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
+    ret = HG_Forward(handle, callback, request, NULL);
     if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not forward call\n");
+        HG_TEST_LOG_ERROR("Could not forward call");
         goto done;
     }
 
+    /* Cancel request */
     ret = HG_Cancel(handle);
     if (ret != HG_SUCCESS) {
-        fprintf(stderr, "HG_Cancel failed: %d\n", ret);
+        HG_TEST_LOG_ERROR("Could not cancel call");
         goto done;
     }
 
@@ -143,114 +83,40 @@ cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
     /* Complete */
     ret = HG_Destroy(handle);
     if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not complete\n");
+        HG_TEST_LOG_ERROR("Could not destroy handle");
         goto done;
     }
 
-    hg_request_destroy(request);
-
 done:
+    hg_request_destroy(request);
     return ret;
 }
 
-#ifdef NA_HAS_CCI
-static hg_return_t
-cancel_bulk_transfer(hg_class_t *hg_class, hg_context_t *context,
-    hg_request_class_t *request_class, hg_addr_t addr)
+/*---------------------------------------------------------------------------*/
+int
+main(int argc, char *argv[])
 {
-    hg_request_t *request = NULL;
-    hg_handle_t handle;
-    bulk_write_in_t bulk_write_in_struct;
-    int *bulk_buf = NULL;
-    void *buf_ptr[1];
-    size_t count =  (1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE) / sizeof(int);
-    size_t bulk_size = count * sizeof(int);
-    hg_bulk_t bulk_handle = HG_BULK_NULL;
-    hg_return_t ret;
-    size_t i;
-
-    /* Prepare bulk_buf */
-    bulk_buf = (int*) malloc(bulk_size);
-    for (i = 0; i < count; i++) {
-        bulk_buf[i] = (int) i;
-    }
-    *buf_ptr = bulk_buf;
-
-    request = hg_request_create(request_class);
-
-    ret = HG_Create(context, addr, hg_test_bulk_write_id_g, &handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not start call\n");
-        goto done;
-    }
-
-    /* Register memory */
-    ret = HG_Bulk_create(hg_class, 1, buf_ptr, (hg_size_t *) &bulk_size,
-            HG_BULK_READ_ONLY, &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        goto done;
-    }
-
-    /* Fill input structure */
-    bulk_write_in_struct.fildes = -1; /* To tell target to cancel bulk transfer */
-    bulk_write_in_struct.bulk_handle = bulk_handle;
-
-    /* Forward call to remote addr and get a new request */
-    printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_write_id_g);
-    ret = HG_Forward(handle, hg_test_bulk_forward_cb, request,
-            &bulk_write_in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not forward call\n");
-        goto done;
-    }
-
-    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
-
-    /* Free memory handle */
-    ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
+    struct hg_test_info hg_test_info = { 0 };
+    hg_return_t hg_ret;
+    int ret = EXIT_SUCCESS;
+
+    /* Initialize the interface */
+    HG_Test_init(argc, argv, &hg_test_info);
+
+    /* Cancel RPC test */
+    HG_TEST("cancel RPC");
+    hg_ret = hg_test_cancel_rpc(hg_test_info.context,
+        hg_test_info.request_class, hg_test_info.target_addr,
+        hg_test_cancel_rpc_id_g, hg_test_rpc_forward_cb);
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
         goto done;
     }
-
-    /* Complete */
-    ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not complete\n");
-        goto done;
-    }
-
-    hg_request_destroy(request);
+    HG_PASSED();
 
 done:
+    if (ret != EXIT_SUCCESS)
+        HG_FAILED();
+    HG_Test_finalize(&hg_test_info);
     return ret;
 }
-#endif
-
-/******************************************************************************/
-int
-main(int argc, char *argv[])
-{
-    hg_class_t *hg_class = NULL;
-    hg_context_t *context = NULL;
-    hg_request_class_t *request_class = NULL;
-    hg_addr_t addr;
-
-    /* Initialize the interface (for convenience, shipper_test_client_init
-     * initializes the network interface with the selected plugin)
-     */
-    hg_class = HG_Test_client_init(argc, argv, &addr, NULL, &context,
-        &request_class);
-
-    cancel_rpc(context, request_class, addr);
-
-#ifdef NA_HAS_CCI
-    if (strcmp(HG_Class_get_name(hg_class), "cci") == 0)
-        cancel_bulk_transfer(hg_class, context, request_class, addr);
-#endif
-
-    HG_Test_finalize(hg_class);
-
-    return EXIT_SUCCESS;
-}
diff --git a/Testing/test_drc_auth.c b/Testing/test_drc_auth.c
index c40d340..daae3e0 100644
--- a/Testing/test_drc_auth.c
+++ b/Testing/test_drc_auth.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_init.c b/Testing/test_init.c
index 3213ded..b45fcda 100644
--- a/Testing/test_init.c
+++ b/Testing/test_init.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_multiple.c b/Testing/test_multiple.c
index 940e25e..6c80d21 100644
--- a/Testing/test_multiple.c
+++ b/Testing/test_multiple.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_multiple.h b/Testing/test_multiple.h
index d5cd728..b497125 100644
--- a/Testing/test_multiple.h
+++ b/Testing/test_multiple.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_nested.c b/Testing/test_nested.c
index 20459a7..4b33a6e 100644
--- a/Testing/test_nested.c
+++ b/Testing/test_nested.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_overflow.c b/Testing/test_overflow.c
index 822b1d7..49499a6 100644
--- a/Testing/test_overflow.c
+++ b/Testing/test_overflow.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_overflow.h b/Testing/test_overflow.h
index c685c08..7fad03a 100644
--- a/Testing/test_overflow.h
+++ b/Testing/test_overflow.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_perf.c b/Testing/test_perf.c
index e6f1903..7da5abe 100644
--- a/Testing/test_perf.c
+++ b/Testing/test_perf.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_pipeline.c b/Testing/test_pipeline.c
index 6ba0e1f..9f540a0 100644
--- a/Testing/test_pipeline.c
+++ b/Testing/test_pipeline.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_posix.c b/Testing/test_posix.c
index 2dd4693..267cefb 100644
--- a/Testing/test_posix.c
+++ b/Testing/test_posix.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_posix.h b/Testing/test_posix.h
index 0f0dddf..770f946 100644
--- a/Testing/test_posix.h
+++ b/Testing/test_posix.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_read_bw.c b/Testing/test_read_bw.c
index 460226a..37a5648 100644
--- a/Testing/test_read_bw.c
+++ b/Testing/test_read_bw.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_rpc.c b/Testing/test_rpc.c
index b263543..67834dd 100644
--- a/Testing/test_rpc.c
+++ b/Testing/test_rpc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_rpc.h b/Testing/test_rpc.h
index 8d43480..fddc856 100644
--- a/Testing/test_rpc.h
+++ b/Testing/test_rpc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_rpc_lat.c b/Testing/test_rpc_lat.c
index 41f8cf9..a31c3c2 100644
--- a/Testing/test_rpc_lat.c
+++ b/Testing/test_rpc_lat.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_server.c b/Testing/test_server.c
index c392cca..bee0c8e 100644
--- a/Testing/test_server.c
+++ b/Testing/test_server.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/Testing/test_write_bw.c b/Testing/test_write_bw.c
index c4f3c7a..7c38896 100644
--- a/Testing/test_write_bw.c
+++ b/Testing/test_write_bw.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 7a84a03..17ee4be 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -179,11 +179,11 @@ configure_file(
 # Set sources
 #------------------------------------------------------------------------------
 set(MERCURY_SRCS
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury.c
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_bulk.c
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core.c
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core_header.c
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury.c
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_header.c
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_bulk.c
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_proc.c
   ${CMAKE_CURRENT_SOURCE_DIR}/proc_extra/mercury_string_object.c
 )
@@ -237,18 +237,20 @@ set(MERCURY_EXPORTED_LIBS mercury_hl ${MERCURY_EXPORTED_LIBS})
 # Specify project header files to be installed
 #-----------------------------------------------------------------------------
 set(MERCURY_HEADERS
+  ${CMAKE_CURRENT_BINARY_DIR}/mercury_config.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_bulk.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core_header.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core_types.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_proc.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_bulk.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_error.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_header.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_macros.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_proc_bulk.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_proc.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_types.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_macros.h
-  ${CMAKE_CURRENT_BINARY_DIR}/mercury_config.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_error.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/proc_extra/mercury_string_object.h
   ${CMAKE_CURRENT_SOURCE_DIR}/proc_extra/mercury_proc_string.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/proc_extra/mercury_string_object.h
 )
 set(MERCURY_HL_HEADERS
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_hl.h
diff --git a/src/mercury.c b/src/mercury.c
index af178c5..9bcbb6b 100644
--- a/src/mercury.c
+++ b/src/mercury.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -9,12 +9,9 @@
  */
 
 #include "mercury.h"
-#include "mercury_core.h"
-#include "mercury_header.h"
 #include "mercury_bulk.h"
 #include "mercury_proc.h"
 #include "mercury_proc_bulk.h"
-#include "mercury_error.h"
 
 #include "mercury_hash_string.h"
 #include "mercury_mem.h"
@@ -33,15 +30,16 @@
 #define HG_ERROR_STRING_MACRO(def, value, string) \
   if (value == def) string = #def
 
+#define HG_CONTEXT_CLASS(context) \
+    ((struct hg_private_class *)(context->hg_class))
+
 /************************************/
 /* Local Type and Struct Definition */
 /************************************/
 
 /* HG class */
-struct hg_class {
-    hg_core_class_t *core_class;    /* Core class */
-    hg_size_t in_offset;            /* Input offset */
-    hg_size_t out_offset;           /* Output offset */
+struct hg_private_class {
+    struct hg_class hg_class;       /* Must remain as first field */
     hg_thread_spin_t register_lock; /* Register lock */
 
     /* Callbacks */
@@ -49,12 +47,6 @@ struct hg_class {
     void *handle_create_arg;                            /* handle_create arg */
 };
 
-/* HG context */
-struct hg_context {
-    hg_core_context_t *core_context;/* Core context */
-    hg_class_t *hg_class;           /* HG class */
-};
-
 /* Info for function map */
 struct hg_proc_info {
     hg_rpc_cb_t rpc_cb;             /* RPC callback */
@@ -66,9 +58,8 @@ struct hg_proc_info {
 };
 
 /* HG handle */
-struct hg_handle {
-    hg_core_handle_t core_handle;   /* Core handle */
-    struct hg_info hg_info;         /* HG info */
+struct hg_private_handle {
+    struct hg_handle handle;        /* Must remain as first field */
     hg_cb_t forward_cb;             /* Forward callback */
     void *forward_arg;              /* Forward callback args */
     hg_cb_t respond_cb;             /* Respond callback */
@@ -83,8 +74,6 @@ struct hg_handle {
     hg_size_t out_extra_buf_size;   /* Extra output buffer size */
     hg_bulk_t out_extra_bulk;       /* Extra output bulk handle */
     hg_return_t (*extra_bulk_transfer_cb)(hg_core_handle_t); /* Bulk transfer callback */
-    void *data;                         /* User data */
-    void (*data_free_callback)(void *); /* User data free callback */
 };
 
 /* HG op id */
@@ -103,19 +92,6 @@ struct hg_op_id {
     } info;
 };
 
-/***********************/
-/* External Prototypes */
-/***********************/
-
-/**
- * Get RPC registered data.
- * TODO can be improved / same as calling HG_Registered_data()?
- */
-extern void *
-hg_core_get_rpc_data(
-        struct hg_core_handle *hg_core_handle
-        );
-
 /********************/
 /* Local Prototypes */
 /********************/
@@ -131,9 +107,9 @@ hg_proc_info_free(
 /**
  * Alloc function for private data.
  */
-static struct hg_handle *
+static struct hg_private_handle *
 hg_handle_create(
-        hg_class_t *hg_class
+        struct hg_private_class *hg_class
         );
 
 /**
@@ -192,8 +168,8 @@ hg_core_addr_lookup_cb(
  */
 static hg_return_t
 hg_get_struct(
-        struct hg_handle *hg_handle,
-        struct hg_proc_info *hg_proc_info,
+        struct hg_private_handle *hg_handle,
+        const struct hg_proc_info *hg_proc_info,
         hg_op_t op,
         void *struct_ptr
         );
@@ -203,8 +179,8 @@ hg_get_struct(
  */
 static hg_return_t
 hg_set_struct(
-        struct hg_handle *hg_handle,
-        struct hg_proc_info *hg_proc_info,
+        struct hg_private_handle *hg_handle,
+        const struct hg_proc_info *hg_proc_info,
         hg_op_t op,
         void *struct_ptr,
         hg_size_t *payload_size,
@@ -216,8 +192,8 @@ hg_set_struct(
  */
 static hg_return_t
 hg_free_struct(
-        struct hg_handle *hg_handle,
-        struct hg_proc_info *hg_proc_info,
+        struct hg_private_handle *hg_handle,
+        const struct hg_proc_info *hg_proc_info,
         hg_op_t op,
         void *struct_ptr
         );
@@ -227,7 +203,7 @@ hg_free_struct(
  */
 static hg_return_t
 hg_get_extra_payload(
-        struct hg_handle *hg_handle,
+        struct hg_private_handle *hg_handle,
         hg_op_t op,
         hg_return_t (*done_cb)(hg_core_handle_t)
         );
@@ -245,7 +221,7 @@ hg_get_extra_payload_cb(
  */
 static void
 hg_free_extra_payload(
-        struct hg_handle *hg_handle
+        struct hg_private_handle *hg_handle
         );
 
 /**
@@ -283,30 +259,30 @@ hg_proc_info_free(void *arg)
 }
 
 /*---------------------------------------------------------------------------*/
-static struct hg_handle *
-hg_handle_create(hg_class_t *hg_class)
+static struct hg_private_handle *
+hg_handle_create(struct hg_private_class *hg_class)
 {
-    struct hg_handle *hg_handle = NULL;
+    struct hg_private_handle *hg_handle = NULL;
     hg_return_t ret;
 
     /* Create private data to wrap callbacks etc */
-    hg_handle = (struct hg_handle *) malloc(
-        sizeof(struct hg_handle));
+    hg_handle = (struct hg_private_handle *) malloc(
+        sizeof(struct hg_private_handle));
     if (!hg_handle) {
         HG_LOG_ERROR("Could not allocate private data");
         goto done;
     }
-    memset(hg_handle, 0, sizeof(struct hg_handle));
-    hg_handle->hg_info.hg_class = hg_class;
+    memset(hg_handle, 0, sizeof(struct hg_private_handle));
+    hg_handle->handle.info.hg_class = (hg_class_t *) hg_class;
     hg_header_init(&hg_handle->hg_header, HG_UNDEF);
 
     /* CRC32 is enough for small size buffers */
-    ret = hg_proc_create(hg_class, HG_CRC32, &hg_handle->in_proc);
+    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32, &hg_handle->in_proc);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Cannot create HG proc");
         goto done;
     }
-    ret = hg_proc_create(hg_class, HG_CRC32, &hg_handle->out_proc);
+    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32, &hg_handle->out_proc);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Cannot create HG proc");
         goto done;
@@ -320,10 +296,10 @@ done:
 static void
 hg_handle_free(void *arg)
 {
-    struct hg_handle *hg_handle = (struct hg_handle *) arg;
+    struct hg_private_handle *hg_handle = (struct hg_private_handle *) arg;
 
-    if (hg_handle->data_free_callback)
-        hg_handle->data_free_callback(hg_handle->data);
+    if (hg_handle->handle.data_free_callback)
+        hg_handle->handle.data_free_callback(hg_handle->handle.data);
     if (hg_handle->in_proc != HG_PROC_NULL)
         hg_proc_free(hg_handle->in_proc);
     if (hg_handle->out_proc != HG_PROC_NULL)
@@ -337,24 +313,25 @@ static hg_return_t
 hg_handle_create_cb(hg_core_handle_t core_handle, void *arg)
 {
     struct hg_context *hg_context = (struct hg_context *) arg;
-    struct hg_handle *hg_handle;
+    struct hg_private_handle *hg_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    hg_handle = hg_handle_create(hg_context->hg_class);
+    hg_handle = hg_handle_create(HG_CONTEXT_CLASS(hg_context));
     if (!hg_handle) {
         HG_LOG_ERROR("Could not create HG handle");
         ret = HG_NOMEM_ERROR;
         goto done;
     }
-    hg_handle->core_handle = core_handle;
-    hg_handle->hg_info.context = hg_context;
+    hg_handle->handle.core_handle = core_handle;
+    hg_handle->handle.info.context = hg_context;
 
     HG_Core_set_data(core_handle, hg_handle, hg_handle_free);
 
     /* Call handle create if defined */
-    if (hg_context->hg_class->handle_create) {
-        ret = hg_context->hg_class->handle_create(hg_handle,
-            hg_context->hg_class->handle_create_arg);
+    if (HG_CONTEXT_CLASS(hg_context)->handle_create) {
+        ret = HG_CONTEXT_CLASS(hg_context)->handle_create(
+            (hg_handle_t) hg_handle,
+            HG_CONTEXT_CLASS(hg_context)->handle_create_arg);
         if (ret != HG_SUCCESS) {
             HG_LOG_ERROR("Error in handle create callback");
             goto done;
@@ -370,12 +347,12 @@ static hg_return_t
 hg_more_data_cb(hg_core_handle_t core_handle, hg_op_t op,
     hg_return_t (*done_cb)(hg_core_handle_t))
 {
-    struct hg_handle *hg_handle;
+    struct hg_private_handle *hg_handle;
     void *extra_buf;
     hg_return_t ret = HG_SUCCESS;
 
     /* Retrieve private data */
-    hg_handle = (struct hg_handle *) HG_Core_get_data(core_handle);
+    hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
     if (!hg_handle) {
         HG_LOG_ERROR("Could not get private data");
         ret = HG_PROTOCOL_ERROR;
@@ -419,10 +396,10 @@ done:
 static void
 hg_more_data_free_cb(hg_core_handle_t core_handle)
 {
-    struct hg_handle *hg_handle;
+    struct hg_private_handle *hg_handle;
 
     /* Retrieve private data */
-    hg_handle = (struct hg_handle *) HG_Core_get_data(core_handle);
+    hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
     if (!hg_handle) {
         goto done;
     }
@@ -438,15 +415,15 @@ static HG_INLINE hg_return_t
 hg_core_rpc_cb(hg_core_handle_t core_handle)
 {
     const struct hg_core_info *hg_core_info = HG_Core_get_info(core_handle);
-    struct hg_proc_info *hg_proc_info =
-        (struct hg_proc_info *) hg_core_get_rpc_data(core_handle);
-    struct hg_handle *hg_handle =
-        (struct hg_handle *) HG_Core_get_data(core_handle);
+    const struct hg_proc_info *hg_proc_info =
+        (const struct hg_proc_info *) HG_Core_get_rpc_data(core_handle);
+    struct hg_private_handle *hg_handle =
+        (struct hg_private_handle *) HG_Core_get_data(core_handle);
     hg_return_t ret = HG_SUCCESS;
 
-    hg_handle->hg_info.addr = (hg_addr_t) hg_core_info->addr;
-    hg_handle->hg_info.context_id = hg_core_info->context_id;
-    hg_handle->hg_info.id = hg_core_info->id;
+    hg_handle->handle.info.addr = (hg_addr_t) hg_core_info->addr;
+    hg_handle->handle.info.context_id = hg_core_info->context_id;
+    hg_handle->handle.info.id = hg_core_info->id;
 
     if (!hg_proc_info->rpc_cb) {
         HG_LOG_ERROR("No RPC callback registered");
@@ -455,7 +432,7 @@ hg_core_rpc_cb(hg_core_handle_t core_handle)
         ret = HG_INVALID_PARAM;
         goto done;
     }
-    ret = hg_proc_info->rpc_cb(hg_handle);
+    ret = hg_proc_info->rpc_cb((hg_handle_t) hg_handle);
 
 done:
     return ret;
@@ -482,8 +459,8 @@ hg_core_addr_lookup_cb(const struct hg_core_cb_info *callback_info)
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_get_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
-    hg_op_t op, void *struct_ptr)
+hg_get_struct(struct hg_private_handle *hg_handle,
+    const struct hg_proc_info *hg_proc_info, hg_op_t op, void *struct_ptr)
 {
     hg_proc_t proc = HG_PROC_NULL;
     hg_proc_cb_t proc_cb = NULL;
@@ -499,7 +476,7 @@ hg_get_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
     switch (op) {
         case HG_INPUT:
             /* Use custom header offset */
-            header_offset += hg_handle->hg_info.hg_class->in_offset;
+            header_offset += hg_handle->handle.info.hg_class->in_offset;
             /* Set input proc */
             proc = hg_handle->in_proc;
             proc_cb = hg_proc_info->in_proc_cb;
@@ -507,7 +484,7 @@ hg_get_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
             hg_header_hash = &hg_header->msg.input.hash;
 #endif
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->core_handle, &buf, &buf_size);
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
             if (ret != HG_SUCCESS) {
                 HG_LOG_ERROR("Could not get input buffer");
                 goto done;
@@ -523,7 +500,7 @@ hg_get_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
                 goto done;
             }
             /* Use custom header offset */
-            header_offset += hg_handle->hg_info.hg_class->out_offset;
+            header_offset += hg_handle->handle.info.hg_class->out_offset;
             /* Set output proc */
             proc = hg_handle->out_proc;
             proc_cb = hg_proc_info->out_proc_cb;
@@ -531,7 +508,7 @@ hg_get_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
             hg_header_hash = &hg_header->msg.output.hash;
 #endif
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->core_handle, &buf, &buf_size);
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
             if (ret != HG_SUCCESS) {
                 HG_LOG_ERROR("Could not get output buffer");
                 goto done;
@@ -604,7 +581,7 @@ hg_get_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
 
     /* Increment ref count on handle so that it remains valid until free_struct
      * is called */
-    HG_Core_ref_incr(hg_handle->core_handle);
+    HG_Core_ref_incr(hg_handle->handle.core_handle);
 
 done:
     return ret;
@@ -612,8 +589,9 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_set_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
-    hg_op_t op, void *struct_ptr, hg_size_t *payload_size, hg_bool_t *more_data)
+hg_set_struct(struct hg_private_handle *hg_handle,
+    const struct hg_proc_info *hg_proc_info, hg_op_t op, void *struct_ptr,
+    hg_size_t *payload_size, hg_bool_t *more_data)
 {
     hg_proc_t proc = HG_PROC_NULL;
     hg_proc_cb_t proc_cb = NULL;
@@ -630,7 +608,7 @@ hg_set_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
     switch (op) {
         case HG_INPUT:
             /* Use custom header offset */
-            header_offset += hg_handle->hg_info.hg_class->in_offset;
+            header_offset += hg_handle->handle.info.hg_class->in_offset;
             /* Set input proc */
             proc = hg_handle->in_proc;
             proc_cb = hg_proc_info->in_proc_cb;
@@ -638,7 +616,7 @@ hg_set_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
             hg_header_hash = &hg_header->msg.input.hash;
 #endif
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->core_handle, &buf, &buf_size);
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
             if (ret != HG_SUCCESS) {
                 HG_LOG_ERROR("Could not get input buffer");
                 goto done;
@@ -655,7 +633,7 @@ hg_set_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
                 goto done;
             }
             /* Use custom header offset */
-            header_offset += hg_handle->hg_info.hg_class->out_offset;
+            header_offset += hg_handle->handle.info.hg_class->out_offset;
             /* Set output proc */
             proc = hg_handle->out_proc;
             proc_cb = hg_proc_info->out_proc_cb;
@@ -663,7 +641,7 @@ hg_set_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
             hg_header_hash = &hg_header->msg.output.hash;
 #endif
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->core_handle, &buf, &buf_size);
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
             if (ret != HG_SUCCESS) {
                 HG_LOG_ERROR("Could not get output buffer");
                 goto done;
@@ -743,7 +721,7 @@ hg_set_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
         hg_proc_set_extra_buf_is_mine(proc, HG_TRUE);
 
         /* Create bulk descriptor */
-        ret = HG_Bulk_create(hg_handle->hg_info.hg_class, 1, extra_buf,
+        ret = HG_Bulk_create(hg_handle->handle.info.hg_class, 1, extra_buf,
             extra_buf_size, HG_BULK_READ_ONLY, extra_bulk);
         if (ret != HG_SUCCESS) {
             HG_LOG_ERROR("Could not create bulk data handle");
@@ -799,8 +777,8 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_free_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
-    hg_op_t op, void *struct_ptr)
+hg_free_struct(struct hg_private_handle *hg_handle,
+    const struct hg_proc_info *hg_proc_info, hg_op_t op, void *struct_ptr)
 {
     hg_proc_t proc = HG_PROC_NULL;
     hg_proc_cb_t proc_cb = NULL;
@@ -843,7 +821,7 @@ hg_free_struct(struct hg_handle *hg_handle, struct hg_proc_info *hg_proc_info,
     }
 
     /* Decrement ref count or free */
-    ret = HG_Core_destroy(hg_handle->core_handle);
+    ret = HG_Core_destroy(hg_handle->handle.core_handle);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not decrement handle ref count");
         goto done;
@@ -855,11 +833,11 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_get_extra_payload(struct hg_handle *hg_handle, hg_op_t op,
+hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
     hg_return_t (*done_cb)(hg_core_handle_t core_handle))
 {
     const struct hg_core_info *hg_core_info = HG_Core_get_info(
-        hg_handle->core_handle);
+        hg_handle->handle.core_handle);
     hg_proc_t proc = HG_PROC_NULL;
     void *buf, **extra_buf;
     hg_size_t buf_size, *extra_buf_size;
@@ -872,11 +850,11 @@ hg_get_extra_payload(struct hg_handle *hg_handle, hg_op_t op,
     switch (op) {
         case HG_INPUT:
             /* Use custom header offset */
-            header_offset += hg_handle->hg_info.hg_class->in_offset;
+            header_offset += hg_handle->handle.info.hg_class->in_offset;
             /* Set input proc */
             proc = hg_handle->in_proc;
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->core_handle, &buf, &buf_size);
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
             if (ret != HG_SUCCESS) {
                 HG_LOG_ERROR("Could not get input buffer");
                 goto done;
@@ -887,11 +865,11 @@ hg_get_extra_payload(struct hg_handle *hg_handle, hg_op_t op,
             break;
         case HG_OUTPUT:
             /* Use custom header offset */
-            header_offset += hg_handle->hg_info.hg_class->out_offset;
+            header_offset += hg_handle->handle.info.hg_class->out_offset;
             /* Set output proc */
             proc = hg_handle->out_proc;
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->core_handle, &buf, &buf_size);
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
             if (ret != HG_SUCCESS) {
                 HG_LOG_ERROR("Could not get output buffer");
                 goto done;
@@ -938,7 +916,7 @@ hg_get_extra_payload(struct hg_handle *hg_handle, hg_op_t op,
         goto done;
     }
 
-    ret = HG_Bulk_create(hg_handle->hg_info.hg_class, 1, extra_buf,
+    ret = HG_Bulk_create(hg_handle->handle.info.hg_class, 1, extra_buf,
         extra_buf_size, HG_BULK_READWRITE, &local_handle);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not create HG bulk handle");
@@ -947,7 +925,7 @@ hg_get_extra_payload(struct hg_handle *hg_handle, hg_op_t op,
 
     /* Read bulk data here and wait for the data to be here  */
     hg_handle->extra_bulk_transfer_cb = done_cb;
-    ret = HG_Bulk_transfer_id(hg_handle->hg_info.context,
+    ret = HG_Bulk_transfer_id(hg_handle->handle.info.context,
         hg_get_extra_payload_cb, hg_handle, HG_BULK_PULL,
         (hg_addr_t) hg_core_info->addr, hg_core_info->context_id,
         *extra_bulk, 0, local_handle, 0, *extra_buf_size,
@@ -970,10 +948,11 @@ done:
 static HG_INLINE hg_return_t
 hg_get_extra_payload_cb(const struct hg_cb_info *callback_info)
 {
-    struct hg_handle *hg_handle = (struct hg_handle *) callback_info->arg;
+    struct hg_private_handle *hg_handle =
+        (struct hg_private_handle *) callback_info->arg;
     hg_return_t ret = HG_SUCCESS;
 
-    ret = hg_handle->extra_bulk_transfer_cb(hg_handle->core_handle);
+    ret = hg_handle->extra_bulk_transfer_cb(hg_handle->handle.core_handle);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not execute bulk transfer callback");
         goto done;
@@ -985,7 +964,7 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static void
-hg_free_extra_payload(struct hg_handle *hg_handle)
+hg_free_extra_payload(struct hg_private_handle *hg_handle)
 {
     /* Free extra bulk buf if there was any */
     if (hg_handle->in_extra_buf) {
@@ -1009,8 +988,8 @@ hg_free_extra_payload(struct hg_handle *hg_handle)
 static HG_INLINE hg_return_t
 hg_core_forward_cb(const struct hg_core_cb_info *callback_info)
 {
-    struct hg_handle *hg_handle =
-            (struct hg_handle *) callback_info->arg;
+    struct hg_private_handle *hg_handle =
+            (struct hg_private_handle *) callback_info->arg;
     hg_return_t ret = HG_SUCCESS;
 
     /* Execute callback */
@@ -1020,7 +999,7 @@ hg_core_forward_cb(const struct hg_core_cb_info *callback_info)
         hg_cb_info.arg = hg_handle->forward_arg;
         hg_cb_info.ret = callback_info->ret;
         hg_cb_info.type = callback_info->type;
-        hg_cb_info.info.forward.handle = hg_handle;
+        hg_cb_info.info.forward.handle = (hg_handle_t) hg_handle;
 
         hg_handle->forward_cb(&hg_cb_info);
     }
@@ -1032,8 +1011,8 @@ hg_core_forward_cb(const struct hg_core_cb_info *callback_info)
 static HG_INLINE hg_return_t
 hg_core_respond_cb(const struct hg_core_cb_info *callback_info)
 {
-    struct hg_handle *hg_handle =
-            (struct hg_handle *) callback_info->arg;
+    struct hg_private_handle *hg_handle =
+            (struct hg_private_handle *) callback_info->arg;
     hg_return_t ret = HG_SUCCESS;
 
     /* Execute callback */
@@ -1043,7 +1022,7 @@ hg_core_respond_cb(const struct hg_core_cb_info *callback_info)
         hg_cb_info.arg = hg_handle->respond_arg;
         hg_cb_info.ret = callback_info->ret;
         hg_cb_info.type = callback_info->type;
-        hg_cb_info.info.respond.handle = hg_handle;
+        hg_cb_info.info.respond.handle = (hg_handle_t) hg_handle;
 
         hg_handle->respond_cb(&hg_cb_info);
     }
@@ -1097,44 +1076,46 @@ hg_class_t *
 HG_Init_opt(const char *na_info_string, hg_bool_t na_listen,
     const struct hg_init_info *hg_init_info)
 {
-    struct hg_class *hg_class = NULL;
+    struct hg_private_class *hg_class = NULL;
 
-    hg_class = malloc(sizeof(struct hg_class));
+    hg_class = malloc(sizeof(struct hg_private_class));
     if (!hg_class) {
         HG_LOG_ERROR("Could not allocate HG class");
         goto done;
     }
-    memset(hg_class, 0, sizeof(struct hg_class));
+    memset(hg_class, 0, sizeof(struct hg_private_class));
     hg_thread_spin_init(&hg_class->register_lock);
 
-    hg_class->core_class = HG_Core_init_opt(na_info_string, na_listen,
+    hg_class->hg_class.core_class = HG_Core_init_opt(na_info_string, na_listen,
         hg_init_info);
-    if (!hg_class->core_class) {
+    if (!hg_class->hg_class.core_class) {
         HG_LOG_ERROR("Could not create HG core class");
         goto done;
     }
 
     /* Set more data callback */
-    HG_Core_set_more_data_callback(hg_class->core_class, hg_more_data_cb,
-        hg_more_data_free_cb);
+    HG_Core_set_more_data_callback(hg_class->hg_class.core_class,
+        hg_more_data_cb, hg_more_data_free_cb);
 
 done:
-    return hg_class;
+    return (hg_class_t *) hg_class;
 }
 
 /*---------------------------------------------------------------------------*/
 hg_return_t
 HG_Finalize(hg_class_t *hg_class)
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
-    ret = HG_Core_finalize(hg_class->core_class);
+    ret = HG_Core_finalize(private_class->hg_class.core_class);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not finalize HG core class");
         goto done;
     }
-    hg_thread_spin_destroy(&hg_class->register_lock);
-    free(hg_class);
+    hg_thread_spin_destroy(&private_class->register_lock);
+    free(private_class);
 
 done:
     return ret;
@@ -1147,178 +1128,13 @@ HG_Cleanup(void)
     HG_Core_cleanup();
 }
 
-/*---------------------------------------------------------------------------*/
-const char *
-HG_Class_get_name(const hg_class_t *hg_class)
-{
-    const char *ret = NULL;
-
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
-
-    ret = HG_Core_class_get_name(hg_class->core_class);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-const char *
-HG_Class_get_protocol(const hg_class_t *hg_class)
-{
-    const char *ret = NULL;
-
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
-
-    ret = HG_Core_class_get_protocol(hg_class->core_class);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_bool_t
-HG_Class_is_listening(const hg_class_t *hg_class)
-{
-    hg_bool_t ret = HG_FALSE;
-
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
-
-    ret = HG_Core_class_is_listening(hg_class->core_class);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_size_t
-HG_Class_get_input_eager_size(const hg_class_t *hg_class)
-{
-    hg_size_t header = hg_header_get_size(HG_INPUT);
-    hg_size_t ret = 0;
-
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
-
-    ret = HG_Core_class_get_input_eager_size(hg_class->core_class);
-    if (ret > header)
-        ret -= header;
-    else
-        ret = 0;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_size_t
-HG_Class_get_output_eager_size(const hg_class_t *hg_class)
-{
-    hg_size_t ret = 0;
-    hg_size_t header = hg_header_get_size(HG_OUTPUT);
-
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
-
-    ret = HG_Core_class_get_output_eager_size(hg_class->core_class);
-    if (ret > header)
-        ret -= header;
-    else
-        ret = 0;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Class_set_input_offset(hg_class_t *hg_class, hg_size_t offset)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    hg_class->in_offset = offset;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Class_set_output_offset(hg_class_t *hg_class, hg_size_t offset)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    hg_class->out_offset = offset;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Class_set_data(hg_class_t *hg_class, void *data,
-    void (*free_callback)(void *))
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    ret = HG_Core_class_set_data(hg_class->core_class, data, free_callback);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-void *
-HG_Class_get_data(const hg_class_t *hg_class)
-{
-    void *ret = NULL;
-
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
-
-    ret = HG_Core_class_get_data(hg_class->core_class);
-
-done:
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 hg_return_t
 HG_Class_set_handle_create_callback(hg_class_t *hg_class,
     hg_return_t (*callback)(hg_handle_t, void *), void *arg)
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
     if (!hg_class) {
@@ -1327,8 +1143,8 @@ HG_Class_set_handle_create_callback(hg_class_t *hg_class,
         goto done;
     }
 
-    hg_class->handle_create = callback;
-    hg_class->handle_create_arg = arg;
+    private_class->handle_create = callback;
+    private_class->handle_create_arg = arg;
 
 done:
     return ret;
@@ -1414,76 +1230,6 @@ done:
     return ret;
 }
 
-/*---------------------------------------------------------------------------*/
-hg_class_t *
-HG_Context_get_class(const hg_context_t *context)
-{
-    hg_class_t *ret = NULL;
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        goto done;
-    }
-
-    ret = context->hg_class;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_uint8_t
-HG_Context_get_id(const hg_context_t *context)
-{
-    hg_uint8_t ret = 0;
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        goto done;
-    }
-
-    ret = HG_Core_context_get_id(context->core_context);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Context_set_data(hg_context_t *context, void *data,
-    void (*free_callback)(void *))
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    ret = HG_Core_context_set_data(context->core_context, data, free_callback);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-void *
-HG_Context_get_data(const hg_context_t *context)
-{
-    void *ret = NULL;
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        goto done;
-    }
-
-    ret = HG_Core_context_get_data(context->core_context);
-
-done:
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 hg_id_t
 HG_Register_name(hg_class_t *hg_class, const char *func_name,
@@ -1520,6 +1266,8 @@ hg_return_t
 HG_Registered_name(hg_class_t *hg_class, const char *func_name, hg_id_t *id,
     hg_bool_t *flag)
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     hg_id_t rpc_id = 0;
     hg_return_t ret = HG_SUCCESS;
 
@@ -1534,21 +1282,21 @@ HG_Registered_name(hg_class_t *hg_class, const char *func_name, hg_id_t *id,
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_class->register_lock);
+    hg_thread_spin_lock(&private_class->register_lock);
 
     /* Generate an ID from the function name */
     rpc_id = hg_hash_string(func_name);
 
-    ret = HG_Core_registered(hg_class->core_class, rpc_id, flag);
+    ret = HG_Core_registered(private_class->hg_class.core_class, rpc_id, flag);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not check for registered RPC id");
-        hg_thread_spin_unlock(&hg_class->register_lock);
+        hg_thread_spin_unlock(&private_class->register_lock);
         goto done;
     }
 
     if (id) *id = rpc_id;
 
-    hg_thread_spin_unlock(&hg_class->register_lock);
+    hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
     return ret;
@@ -1559,6 +1307,8 @@ hg_return_t
 HG_Register(hg_class_t *hg_class, hg_id_t id, hg_proc_cb_t in_proc_cb,
     hg_proc_cb_t out_proc_cb, hg_rpc_cb_t rpc_cb)
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     struct hg_proc_info *hg_proc_info = NULL;
     hg_bool_t registered;
     hg_return_t ret = HG_SUCCESS;
@@ -1569,7 +1319,7 @@ HG_Register(hg_class_t *hg_class, hg_id_t id, hg_proc_cb_t in_proc_cb,
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_class->register_lock);
+    hg_thread_spin_lock(&private_class->register_lock);
 
     /* Check if already registered */
     ret = HG_Core_registered(hg_class->core_class, id, &registered);
@@ -1620,7 +1370,7 @@ done:
         free(hg_proc_info);
     }
     if (hg_class)
-        hg_thread_spin_unlock(&hg_class->register_lock);
+        hg_thread_spin_unlock(&private_class->register_lock);
     return ret;
 }
 
@@ -1628,6 +1378,8 @@ done:
 hg_return_t
 HG_Deregister(hg_class_t *hg_class, hg_id_t id)
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
     if (!hg_class) {
@@ -1636,9 +1388,9 @@ HG_Deregister(hg_class_t *hg_class, hg_id_t id)
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_class->register_lock);
+    hg_thread_spin_lock(&private_class->register_lock);
     ret = HG_Core_deregister(hg_class->core_class, id);
-    hg_thread_spin_unlock(&hg_class->register_lock);
+    hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
     return ret;
@@ -1648,6 +1400,8 @@ done:
 hg_return_t
 HG_Registered(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag)
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
     if (!hg_class) {
@@ -1656,9 +1410,9 @@ HG_Registered(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag)
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_class->register_lock);
+    hg_thread_spin_lock(&private_class->register_lock);
     ret = HG_Core_registered(hg_class->core_class, id, flag);
-    hg_thread_spin_unlock(&hg_class->register_lock);
+    hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
     return ret;
@@ -1669,6 +1423,8 @@ hg_return_t
 HG_Registered_proc_cb(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag,
     hg_proc_cb_t *in_proc_cb, hg_proc_cb_t *out_proc_cb)
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
@@ -1678,7 +1434,7 @@ HG_Registered_proc_cb(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag,
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_class->register_lock);
+    hg_thread_spin_lock(&private_class->register_lock);
 
     ret = HG_Core_registered(hg_class->core_class, id, flag);
     if(ret == HG_SUCCESS && *flag) {
@@ -1688,7 +1444,7 @@ HG_Registered_proc_cb(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag,
         if (!hg_proc_info) {
             HG_LOG_ERROR("Could not get registered data");
             ret = HG_NO_MATCH;
-            hg_thread_spin_unlock(&hg_class->register_lock);
+            hg_thread_spin_unlock(&private_class->register_lock);
             goto done;
         }
         if (in_proc_cb)
@@ -1697,7 +1453,7 @@ HG_Registered_proc_cb(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag,
             *out_proc_cb = hg_proc_info->out_proc_cb;
     }
 
-    hg_thread_spin_unlock(&hg_class->register_lock);
+    hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
     return ret;
@@ -1708,6 +1464,8 @@ hg_return_t
 HG_Register_data(hg_class_t *hg_class, hg_id_t id, void *data,
     void (*free_callback)(void *))
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
@@ -1717,7 +1475,7 @@ HG_Register_data(hg_class_t *hg_class, hg_id_t id, void *data,
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_class->register_lock);
+    hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
@@ -1725,14 +1483,14 @@ HG_Register_data(hg_class_t *hg_class, hg_id_t id, void *data,
     if (!hg_proc_info) {
         HG_LOG_ERROR("Could not get registered data");
         ret = HG_NO_MATCH;
-        hg_thread_spin_unlock(&hg_class->register_lock);
+        hg_thread_spin_unlock(&private_class->register_lock);
         goto done;
     }
 
     hg_proc_info->data = data;
     hg_proc_info->free_callback = free_callback;
 
-    hg_thread_spin_unlock(&hg_class->register_lock);
+    hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
     return ret;
@@ -1742,6 +1500,8 @@ done:
 void *
 HG_Registered_data(hg_class_t *hg_class, hg_id_t id)
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     struct hg_proc_info *hg_proc_info = NULL;
     void *data = NULL;
 
@@ -1750,20 +1510,20 @@ HG_Registered_data(hg_class_t *hg_class, hg_id_t id)
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_class->register_lock);
+    hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
     if (!hg_proc_info) {
         HG_LOG_ERROR("Could not get registered data");
-        hg_thread_spin_unlock(&hg_class->register_lock);
+        hg_thread_spin_unlock(&private_class->register_lock);
         goto done;
     }
 
     data = hg_proc_info->data;
 
-    hg_thread_spin_unlock(&hg_class->register_lock);
+    hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
     return data;
@@ -1774,6 +1534,8 @@ hg_return_t
 HG_Registered_disable_response(hg_class_t *hg_class, hg_id_t id,
     hg_bool_t disable)
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
@@ -1783,7 +1545,7 @@ HG_Registered_disable_response(hg_class_t *hg_class, hg_id_t id,
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_class->register_lock);
+    hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
@@ -1791,13 +1553,13 @@ HG_Registered_disable_response(hg_class_t *hg_class, hg_id_t id,
     if (!hg_proc_info) {
         HG_LOG_ERROR("Could not get registered data");
         ret = HG_NO_MATCH;
-        hg_thread_spin_unlock(&hg_class->register_lock);
+        hg_thread_spin_unlock(&private_class->register_lock);
         goto done;
     }
 
     hg_proc_info->no_response = disable;
 
-    hg_thread_spin_unlock(&hg_class->register_lock);
+    hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
     return ret;
@@ -1808,6 +1570,8 @@ hg_return_t
 HG_Registered_disabled_response(hg_class_t *hg_class, hg_id_t id,
     hg_bool_t *disabled)
 {
+    struct hg_private_class *private_class =
+        (struct hg_private_class *) hg_class;
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
@@ -1822,7 +1586,7 @@ HG_Registered_disabled_response(hg_class_t *hg_class, hg_id_t id,
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_class->register_lock);
+    hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
@@ -1830,13 +1594,13 @@ HG_Registered_disabled_response(hg_class_t *hg_class, hg_id_t id,
     if (!hg_proc_info) {
         HG_LOG_ERROR("Could not get registered data");
         ret = HG_NO_MATCH;
-        hg_thread_spin_unlock(&hg_class->register_lock);
+        hg_thread_spin_unlock(&private_class->register_lock);
         goto done;
     }
 
     *disabled = hg_proc_info->no_response;
 
-    hg_thread_spin_unlock(&hg_class->register_lock);
+    hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
     return ret;
@@ -1960,7 +1724,7 @@ hg_return_t
 HG_Create(hg_context_t *context, hg_addr_t addr, hg_id_t id,
     hg_handle_t *handle)
 {
-    struct hg_handle *hg_handle = NULL;
+    struct hg_private_handle *hg_handle = NULL;
     hg_core_handle_t core_handle;
     hg_return_t ret = HG_SUCCESS;
 
@@ -1980,9 +1744,9 @@ HG_Create(hg_context_t *context, hg_addr_t addr, hg_id_t id,
     }
 
     /* Get data and HG info */
-    hg_handle = (struct hg_handle *) HG_Core_get_data(core_handle);
-    hg_handle->hg_info.addr = addr;
-    hg_handle->hg_info.id = id;
+    hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
+    hg_handle->handle.info.addr = addr;
+    hg_handle->handle.info.id = id;
 
     *handle = (hg_handle_t) hg_handle;
 
@@ -2012,6 +1776,8 @@ done:
 hg_return_t
 HG_Reset(hg_handle_t handle, hg_addr_t addr, hg_id_t id)
 {
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
     if (!handle) {
@@ -2028,97 +1794,9 @@ HG_Reset(hg_handle_t handle, hg_addr_t addr, hg_id_t id)
     }
 
     /* Set info */
-    handle->hg_info.addr = addr;
-    handle->hg_info.id = id;
-    handle->hg_info.context_id = 0;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Ref_incr(hg_handle_t handle)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    ret = HG_Core_ref_incr(handle->core_handle);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_int32_t
-HG_Ref_get(hg_handle_t handle)
-{
-    hg_int32_t ret = -1;
-
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        goto done;
-    }
-
-    ret = HG_Core_ref_get(handle->core_handle);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-const struct hg_info *
-HG_Get_info(hg_handle_t handle)
-{
-    const struct hg_info *ret = NULL;
-
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        goto done;
-    }
-
-    ret = &handle->hg_info;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Set_data(hg_handle_t handle, void *data, void (*free_callback)(void *))
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    handle->data = data;
-    handle->data_free_callback = free_callback;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-void *
-HG_Get_data(hg_handle_t handle)
-{
-    void *ret = NULL;
-
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        goto done;
-    }
-
-    ret = handle->data;
+    private_handle->handle.info.addr = addr;
+    private_handle->handle.info.id = id;
+    private_handle->handle.info.context_id = 0;
 
 done:
     return ret;
@@ -2128,7 +1806,7 @@ done:
 hg_return_t
 HG_Get_input(hg_handle_t handle, void *in_struct)
 {
-    struct hg_proc_info *hg_proc_info;
+    const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
     if (!handle) {
@@ -2143,7 +1821,7 @@ HG_Get_input(hg_handle_t handle, void *in_struct)
     }
 
     /* Retrieve RPC data */
-    hg_proc_info = (struct hg_proc_info *) hg_core_get_rpc_data(
+    hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
     if (!hg_proc_info) {
         HG_LOG_ERROR("Could not get proc info");
@@ -2152,7 +1830,8 @@ HG_Get_input(hg_handle_t handle, void *in_struct)
     }
 
     /* Get input struct */
-    ret = hg_get_struct(handle, hg_proc_info, HG_INPUT, in_struct);
+    ret = hg_get_struct((struct hg_private_handle *) handle, hg_proc_info,
+        HG_INPUT, in_struct);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not get input");
         goto done;
@@ -2166,7 +1845,7 @@ done:
 hg_return_t
 HG_Free_input(hg_handle_t handle, void *in_struct)
 {
-    struct hg_proc_info *hg_proc_info;
+    const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
     if (!handle) {
@@ -2181,7 +1860,7 @@ HG_Free_input(hg_handle_t handle, void *in_struct)
     }
 
     /* Retrieve RPC data */
-    hg_proc_info = (struct hg_proc_info *) hg_core_get_rpc_data(
+    hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
     if (!hg_proc_info) {
         HG_LOG_ERROR("Could not get proc info");
@@ -2190,7 +1869,8 @@ HG_Free_input(hg_handle_t handle, void *in_struct)
     }
 
     /* Free input struct */
-    ret = hg_free_struct(handle, hg_proc_info, HG_INPUT, in_struct);
+    ret = hg_free_struct((struct hg_private_handle *) handle, hg_proc_info,
+        HG_INPUT, in_struct);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not free input");
         goto done;
@@ -2204,7 +1884,7 @@ done:
 hg_return_t
 HG_Get_output(hg_handle_t handle, void *out_struct)
 {
-    struct hg_proc_info *hg_proc_info;
+    const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
     if (!handle) {
@@ -2219,7 +1899,7 @@ HG_Get_output(hg_handle_t handle, void *out_struct)
     }
 
     /* Retrieve RPC data */
-    hg_proc_info = (struct hg_proc_info *) hg_core_get_rpc_data(
+    hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
     if (!hg_proc_info) {
         HG_LOG_ERROR("Could not get proc info");
@@ -2228,7 +1908,8 @@ HG_Get_output(hg_handle_t handle, void *out_struct)
     }
 
     /* Get output struct */
-    ret = hg_get_struct(handle, hg_proc_info, HG_OUTPUT, out_struct);
+    ret = hg_get_struct((struct hg_private_handle *) handle, hg_proc_info,
+        HG_OUTPUT, out_struct);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not get output");
         goto done;
@@ -2242,7 +1923,7 @@ done:
 hg_return_t
 HG_Free_output(hg_handle_t handle, void *out_struct)
 {
-    struct hg_proc_info *hg_proc_info;
+    const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
     if (!handle) {
@@ -2257,7 +1938,7 @@ HG_Free_output(hg_handle_t handle, void *out_struct)
     }
 
     /* Retrieve RPC data */
-    hg_proc_info = (struct hg_proc_info *) hg_core_get_rpc_data(
+    hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
     if (!hg_proc_info) {
         HG_LOG_ERROR("Could not get proc info");
@@ -2266,7 +1947,8 @@ HG_Free_output(hg_handle_t handle, void *out_struct)
     }
 
     /* Free output struct */
-    ret = hg_free_struct(handle, hg_proc_info, HG_OUTPUT, out_struct);
+    ret = hg_free_struct((struct hg_private_handle *) handle, hg_proc_info,
+        HG_OUTPUT, out_struct);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not free output");
         goto done;
@@ -2280,6 +1962,8 @@ done:
 hg_return_t
 HG_Get_input_buf(hg_handle_t handle, void **in_buf, hg_size_t *in_buf_size)
 {
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
     if (!handle) {
@@ -2295,9 +1979,9 @@ HG_Get_input_buf(hg_handle_t handle, void **in_buf, hg_size_t *in_buf_size)
 
     /* Space must be left for input header, no offset if extra buffer since
      * only the user payload is copied */
-    if (handle->in_extra_buf) {
-        *in_buf = handle->in_extra_buf;
-        *in_buf_size = handle->in_extra_buf_size;
+    if (private_handle->in_extra_buf) {
+        *in_buf = private_handle->in_extra_buf;
+        *in_buf_size = private_handle->in_extra_buf_size;
     } else {
         void *buf;
         hg_size_t buf_size, header_offset = hg_header_get_size(HG_INPUT);
@@ -2321,6 +2005,8 @@ done:
 hg_return_t
 HG_Get_output_buf(hg_handle_t handle, void **out_buf, hg_size_t *out_buf_size)
 {
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
     if (!handle) {
@@ -2336,9 +2022,9 @@ HG_Get_output_buf(hg_handle_t handle, void **out_buf, hg_size_t *out_buf_size)
 
     /* Space must be left for output header, no offset if extra buffer since
      * only the user payload is copied */
-    if (handle->out_extra_buf) {
-        *out_buf = handle->out_extra_buf;
-        *out_buf_size = handle->out_extra_buf_size;
+    if (private_handle->out_extra_buf) {
+        *out_buf = private_handle->out_extra_buf;
+        *out_buf_size = private_handle->out_extra_buf_size;
     } else {
         void *buf;
         hg_size_t buf_size, header_offset = hg_header_get_size(HG_OUTPUT);
@@ -2358,34 +2044,13 @@ done:
     return ret;
 }
 
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Set_target_id(hg_handle_t handle, hg_uint8_t id)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    ret = HG_Core_set_target_id(handle->core_handle, id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set target id");
-        goto done;
-    }
-    handle->hg_info.context_id = id;
-
-done:
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 hg_return_t
 HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
 {
-    struct hg_proc_info *hg_proc_info;
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
+    const struct hg_proc_info *hg_proc_info;
     hg_size_t payload_size;
     hg_bool_t more_data = HG_FALSE;
     hg_uint8_t flags = 0;
@@ -2398,11 +2063,11 @@ HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
     }
 
     /* Set callback data */
-    handle->forward_cb = callback;
-    handle->forward_arg = arg;
+    private_handle->forward_cb = callback;
+    private_handle->forward_arg = arg;
 
     /* Retrieve RPC data */
-    hg_proc_info = (struct hg_proc_info *) hg_core_get_rpc_data(
+    hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
     if (!hg_proc_info) {
         HG_LOG_ERROR("Could not get proc info");
@@ -2411,7 +2076,7 @@ HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
     }
 
     /* Set input struct */
-    ret = hg_set_struct(handle, hg_proc_info, HG_INPUT, in_struct,
+    ret = hg_set_struct(private_handle, hg_proc_info, HG_INPUT, in_struct,
         &payload_size, &more_data);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not set input");
@@ -2442,7 +2107,9 @@ done:
 hg_return_t
 HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
 {
-    struct hg_proc_info *hg_proc_info;
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
+    const struct hg_proc_info *hg_proc_info;
     hg_size_t payload_size;
     hg_bool_t more_data = HG_FALSE;
     hg_uint8_t flags = 0;
@@ -2455,11 +2122,11 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     }
 
     /* Set callback data */
-    handle->respond_cb = callback;
-    handle->respond_arg = arg;
+    private_handle->respond_cb = callback;
+    private_handle->respond_arg = arg;
 
     /* Retrieve RPC data */
-    hg_proc_info = (struct hg_proc_info *) hg_core_get_rpc_data(
+    hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
     if (!hg_proc_info) {
         HG_LOG_ERROR("Could not get proc info");
@@ -2468,7 +2135,7 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     }
 
     /* Set output struct */
-    ret = hg_set_struct(handle, hg_proc_info, HG_OUTPUT, out_struct,
+    ret = hg_set_struct(private_handle, hg_proc_info, HG_OUTPUT, out_struct,
         &payload_size, &more_data);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not set output");
diff --git a/src/mercury.h b/src/mercury.h
index a76c9b4..7abfa02 100644
--- a/src/mercury.h
+++ b/src/mercury.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -12,6 +12,10 @@
 #define MERCURY_H
 
 #include "mercury_types.h"
+#include "mercury_header.h"
+#include "mercury_error.h"
+
+#include "mercury_core.h"
 
 /*************************************/
 /* Public Type and Struct Definition */
@@ -128,7 +132,7 @@ HG_Cleanup(
  *
  * \return the name of the class, or NULL if not a valid class
  */
-HG_EXPORT const char *
+static HG_INLINE const char *
 HG_Class_get_name(
         const hg_class_t *hg_class
         );
@@ -140,7 +144,7 @@ HG_Class_get_name(
  *
  * \return the name of the class's transport, or NULL if not a valid class
  */
-HG_EXPORT const char *
+static HG_INLINE const char *
 HG_Class_get_protocol(
         const hg_class_t *hg_class
         );
@@ -152,7 +156,7 @@ HG_Class_get_protocol(
  *
  * \return HG_TRUE if listening or HG_FALSE if not, or not a valid class
  */
-HG_EXPORT hg_bool_t
+static HG_INLINE hg_bool_t
 HG_Class_is_listening(
         const hg_class_t *hg_class
         );
@@ -166,7 +170,7 @@ HG_Class_is_listening(
  * \return the maximum size, or 0 if hg_class is not a valid class or XDR is
  * being used
  */
-HG_EXPORT hg_size_t
+static HG_INLINE hg_size_t
 HG_Class_get_input_eager_size(
         const hg_class_t *hg_class
         );
@@ -180,7 +184,7 @@ HG_Class_get_input_eager_size(
  * \return the maximum size, or 0 if hg_class is not a valid class or XDR is
  * being used
  */
-HG_EXPORT hg_size_t
+static HG_INLINE hg_size_t
 HG_Class_get_output_eager_size(
         const hg_class_t *hg_class
         );
@@ -196,7 +200,7 @@ HG_Class_get_output_eager_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Class_set_input_offset(
         hg_class_t *hg_class,
         hg_size_t offset
@@ -213,7 +217,7 @@ HG_Class_set_input_offset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Class_set_output_offset(
         hg_class_t *hg_class,
         hg_size_t offset
@@ -229,7 +233,7 @@ HG_Class_set_output_offset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Class_set_data(
         hg_class_t *hg_class,
         void *data,
@@ -243,7 +247,7 @@ HG_Class_set_data(
  *
  * \return Pointer to user data or NULL if not set or any error has occurred
  */
-HG_EXPORT void *
+static HG_INLINE void *
 HG_Class_get_data(
         const hg_class_t *hg_class
         );
@@ -325,7 +329,7 @@ HG_Context_destroy(
  *
  * \return Pointer to associated HG class or NULL if not a valid context
  */
-HG_EXPORT hg_class_t *
+static HG_INLINE hg_class_t *
 HG_Context_get_class(
         const hg_context_t *context
         );
@@ -337,7 +341,7 @@ HG_Context_get_class(
  *
  * \return Non-negative integer (max value of 255) or 0 if no ID has been set
  */
-HG_EXPORT hg_uint8_t
+static HG_INLINE hg_uint8_t
 HG_Context_get_id(
         const hg_context_t *context
         );
@@ -352,7 +356,7 @@ HG_Context_get_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Context_set_data(
         hg_context_t *context,
         void *data,
@@ -366,7 +370,7 @@ HG_Context_set_data(
  *
  * \return Pointer to user data or NULL if not set or any error has occurred
  */
-HG_EXPORT void *
+static HG_INLINE void *
 HG_Context_get_data(
         const hg_context_t *context
         );
@@ -652,7 +656,6 @@ HG_Addr_to_string(
         hg_addr_t   addr
         );
 
-
 /**
  * Initiate a new HG RPC using the specified function ID and the local/remote
  * target defined by addr. The HG handle created can be used to query input
@@ -713,7 +716,7 @@ HG_Reset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Ref_incr(
         hg_handle_t hg_handle
         );
@@ -725,7 +728,7 @@ HG_Ref_incr(
  *
  * \return Non-negative value or negative if the handle is not valid
  */
-HG_EXPORT hg_int32_t
+static HG_INLINE hg_int32_t
 HG_Ref_get(
         hg_handle_t handle
         );
@@ -739,7 +742,7 @@ HG_Ref_get(
  *
  * \return Pointer to info or NULL in case of failure
  */
-HG_EXPORT const struct hg_info *
+static HG_INLINE const struct hg_info *
 HG_Get_info(
         hg_handle_t handle
         );
@@ -754,7 +757,7 @@ HG_Get_info(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Set_data(
         hg_handle_t handle,
         void *data,
@@ -768,7 +771,7 @@ HG_Set_data(
  *
  * \return Pointer to user data or NULL if not set or any error has occurred
  */
-HG_EXPORT void *
+static HG_INLINE void *
 HG_Get_data(
         hg_handle_t handle
         );
@@ -901,7 +904,7 @@ HG_Get_output_buf(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Set_target_id(
         hg_handle_t handle,
         hg_uint8_t id
@@ -1010,6 +1013,297 @@ HG_Cancel(
         hg_handle_t handle
         );
 
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
+
+/* HG class */
+struct hg_class {
+    hg_core_class_t *core_class;        /* Core class */
+    hg_size_t in_offset;                /* Input offset */
+    hg_size_t out_offset;               /* Output offset */
+};
+
+/* HG context */
+struct hg_context {
+    hg_core_context_t *core_context;    /* Core context */
+    hg_class_t *hg_class;               /* HG class */
+};
+
+/* HG handle */
+struct hg_handle {
+    hg_core_handle_t core_handle;       /* Core handle */
+    struct hg_info info;                /* HG info */
+    void *data;                         /* User data */
+    void (*data_free_callback)(void *); /* User data free callback */
+};
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE const char *
+HG_Class_get_name(const hg_class_t *hg_class)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return NULL;
+    }
+#endif
+    return HG_Core_class_get_name(hg_class->core_class);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE const char *
+HG_Class_get_protocol(const hg_class_t *hg_class)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return NULL;
+    }
+#endif
+    return HG_Core_class_get_protocol(hg_class->core_class);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_bool_t
+HG_Class_is_listening(const hg_class_t *hg_class)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return HG_FALSE;
+    }
+#endif
+    return HG_Core_class_is_listening(hg_class->core_class);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_size_t
+HG_Class_get_input_eager_size(const hg_class_t *hg_class)
+{
+    hg_size_t core, header;
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return 0;
+    }
+#endif
+    core = HG_Core_class_get_input_eager_size(hg_class->core_class);
+    header = hg_header_get_size(HG_INPUT);
+
+    return (core > header) ? core - header : 0;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_size_t
+HG_Class_get_output_eager_size(const hg_class_t *hg_class)
+{
+    hg_size_t core, header;
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return 0;
+    }
+#endif
+    core = HG_Core_class_get_output_eager_size(hg_class->core_class);
+    header = hg_header_get_size(HG_OUTPUT);
+
+    return (core > header) ? core - header : 0;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Class_set_input_offset(hg_class_t *hg_class, hg_size_t offset)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    hg_class->in_offset = offset;
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Class_set_output_offset(hg_class_t *hg_class, hg_size_t offset)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    hg_class->out_offset = offset;
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Class_set_data(hg_class_t *hg_class, void *data,
+    void (*free_callback)(void *))
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    return HG_Core_class_set_data(hg_class->core_class, data, free_callback);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE void *
+HG_Class_get_data(const hg_class_t *hg_class)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return NULL;
+    }
+#endif
+    return HG_Core_class_get_data(hg_class->core_class);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_class_t *
+HG_Context_get_class(const hg_context_t *context)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        return NULL;
+    }
+#endif
+    return context->hg_class;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_uint8_t
+HG_Context_get_id(const hg_context_t *context)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        return 0;
+    }
+#endif
+    return HG_Core_context_get_id(context->core_context);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Context_set_data(hg_context_t *context, void *data,
+    void (*free_callback)(void *))
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    return HG_Core_context_set_data(context->core_context, data, free_callback);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE void *
+HG_Context_get_data(const hg_context_t *context)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        return NULL;
+    }
+#endif
+    return HG_Core_context_get_data(context->core_context);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Ref_incr(hg_handle_t handle)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    return HG_Core_ref_incr(handle->core_handle);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_int32_t
+HG_Ref_get(hg_handle_t handle)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return -1;
+    }
+#endif
+    return HG_Core_ref_get(handle->core_handle);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE const struct hg_info *
+HG_Get_info(hg_handle_t handle)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return NULL;
+    }
+#endif
+    return &handle->info;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Set_data(hg_handle_t handle, void *data, void (*free_callback)(void *))
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    handle->data = data;
+    handle->data_free_callback = free_callback;
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE void *
+HG_Get_data(hg_handle_t handle)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return NULL;
+    }
+#endif
+    return handle->data;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Set_target_id(hg_handle_t handle, hg_uint8_t id)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    handle->info.context_id = id;
+
+    return HG_Core_set_target_id(handle->core_handle, id);
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/mercury_bulk.c b/src/mercury_bulk.c
index 21d7a15..ba0040c 100644
--- a/src/mercury_bulk.c
+++ b/src/mercury_bulk.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -13,7 +13,7 @@
 #include "mercury_private.h"
 #include "mercury_error.h"
 
-#include "na_private.h"
+#include "na.h"
 
 #include "mercury_atomic.h"
 
@@ -379,7 +379,7 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
     na_class_t *na_sm_class = HG_Core_class_get_na_sm(hg_class->core_class);
 #endif
     hg_bool_t use_register_segments = (hg_bool_t)
-        (na_class->mem_handle_create_segments && count > 1);
+        (na_class->ops->mem_handle_create_segments && count > 1);
     unsigned int i;
 
     hg_bulk = (struct hg_bulk *) malloc(sizeof(struct hg_bulk));
@@ -867,7 +867,8 @@ hg_bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
         (hg_core_addr_t) origin_addr);
     hg_bool_t is_self = NA_Addr_is_self(na_origin_addr_class, na_origin_addr);
     hg_bool_t scatter_gather =
-        (na_class->mem_handle_create_segments && !is_self) ? HG_TRUE : HG_FALSE;
+        (na_class->ops->mem_handle_create_segments && !is_self) ? HG_TRUE :
+            HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
     unsigned int i;
 
@@ -1643,8 +1644,8 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
         buf_ptr += serialize_size;
         buf_size_left -= (ssize_t) serialize_size;
 
-        hg_bulk->addr = HG_Core_addr_create(hg_bulk->hg_class->core_class);
-        if (hg_bulk->addr == HG_CORE_ADDR_NULL) {
+        ret = HG_Core_addr_create(hg_bulk->hg_class->core_class, &hg_bulk->addr);
+        if (ret != HG_SUCCESS) {
             HG_LOG_ERROR("Could not create core addr");
             ret = HG_NOMEM_ERROR;
             goto done;
diff --git a/src/mercury_bulk.h b/src/mercury_bulk.h
index ce33211..9b60d8b 100644
--- a/src/mercury_bulk.h
+++ b/src/mercury_bulk.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_config.h.in b/src/mercury_config.h.in
index 5521b65..fe0e00f 100644
--- a/src/mercury_config.h.in
+++ b/src/mercury_config.h.in
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_core.c b/src/mercury_core.c
index 6ac3907..846a1da 100644
--- a/src/mercury_core.c
+++ b/src/mercury_core.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -9,26 +9,22 @@
  */
 
 #include "mercury_core.h"
-#include "mercury_core_header.h"
 #include "mercury_private.h"
-#include "mercury_error.h"
 
+#include "mercury_atomic_queue.h"
+#ifdef HG_HAS_SELF_FORWARD
+#include "mercury_event.h"
+#endif
 #include "mercury_hash_table.h"
-#include "mercury_atomic.h"
-#include "mercury_queue.h"
 #include "mercury_list.h"
+#include "mercury_mem.h"
+#include "mercury_poll.h"
+#include "mercury_queue.h"
+#include "mercury_thread_condition.h"
 #include "mercury_thread_mutex.h"
+#include "mercury_thread_pool.h"
 #include "mercury_thread_spin.h"
-#include "mercury_thread_condition.h"
 #include "mercury_time.h"
-#include "mercury_atomic.h"
-#include "mercury_poll.h"
-#include "mercury_thread_pool.h"
-#ifdef HG_HAS_SELF_FORWARD
-#include "mercury_event.h"
-#endif
-#include "mercury_atomic_queue.h"
-#include "mercury_mem.h"
 
 #ifdef HG_HAS_SM_ROUTING
 #include <uuid/uuid.h>
@@ -46,6 +42,7 @@
 #define HG_CORE_ATOMIC_QUEUE_SIZE   1024
 #define HG_CORE_PENDING_INCR        256
 #define HG_CORE_PROCESSING_TIMEOUT  1000
+#define HG_CORE_MAX_TRIGGER_COUNT   1
 #ifdef HG_HAS_SM_ROUTING
 # define HG_CORE_UUID_MAX_LEN       36
 # define HG_CORE_ADDR_MAX_SIZE      256
@@ -77,15 +74,22 @@ typedef hg_atomic_int32_t hg_core_stat_t;
 #define HG_CORE_STAT_INIT HG_ATOMIC_VAR_INIT
 #endif
 
+#define HG_CORE_CONTEXT_CLASS(context) \
+    ((struct hg_core_private_class *)(context->core_context.core_class))
+
+#define HG_CORE_HANDLE_CLASS(handle) \
+    ((struct hg_core_private_class *)(handle->core_handle.info.core_class))
+#define HG_CORE_HANDLE_CONTEXT(handle) \
+    ((struct hg_core_private_context *)(handle->core_handle.info.context))
+
 /************************************/
 /* Local Type and Struct Definition */
 /************************************/
 
 /* HG class */
-struct hg_core_class {
-    na_class_t *na_class;               /* NA class */
+struct hg_core_private_class {
+    struct hg_core_class core_class;    /* Must remain as first field */
 #ifdef HG_HAS_SM_ROUTING
-    na_class_t *na_sm_class;            /* NA SM class */
     uuid_t na_sm_uuid;                  /* UUID for local identification */
 #endif
     hg_hash_table_t *func_map;          /* Function map */
@@ -97,8 +101,6 @@ struct hg_core_class {
 #ifdef HG_HAS_COLLECT_STATS
     hg_bool_t stats;                    /* (Debug) Print stats at exit */
 #endif
-    void *data;                         /* User data */
-    void (*data_free_callback)(void *); /* User data free callback */
     hg_atomic_int32_t n_contexts;       /* Atomic used for number of contexts */
     hg_atomic_int32_t n_addrs;          /* Atomic used for number of addrs */
 
@@ -109,47 +111,34 @@ struct hg_core_class {
 };
 
 /* HG context */
-struct hg_core_context {
-    struct hg_core_class *hg_core_class;          /* HG core class */
-    na_context_t *na_context;                     /* NA context */
-#ifdef HG_HAS_SM_ROUTING
-    na_context_t *na_sm_context;                  /* NA SM context */
-#endif
-    hg_uint8_t id;                                /* Context ID */
-    struct hg_poll_set *poll_set;                 /* Context poll set */
+struct hg_core_private_context {
+    struct hg_core_context core_context;        /* Must remain as first field */
+    struct hg_poll_set *poll_set;               /* Context poll set */
     /* Pointer to function used for making progress */
-    hg_return_t (*progress)(struct hg_core_context *context, unsigned int timeout);
-    struct hg_atomic_queue *completion_queue;     /* Default completion queue */
+    hg_return_t (*progress)(struct hg_core_private_context *context,
+        unsigned int timeout);
+    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
     HG_QUEUE_HEAD(hg_completion_entry) backfill_queue; /* Backfill completion queue */
-    hg_atomic_int32_t backfill_queue_count;       /* Backfill queue count */
-    hg_thread_mutex_t completion_queue_mutex;     /* Completion queue mutex */
-    hg_thread_cond_t  completion_queue_cond;      /* Completion queue cond */
-    hg_atomic_int32_t trigger_waiting;            /* Waiting in trigger */
-    HG_LIST_HEAD(hg_core_handle) pending_list;    /* List of pending handles */
-    hg_thread_spin_t pending_list_lock;           /* Pending list lock */
+    hg_atomic_int32_t backfill_queue_count;     /* Backfill queue count */
+    hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
+    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
+    hg_atomic_int32_t trigger_waiting;          /* Waiting in trigger */
+    HG_LIST_HEAD(hg_core_private_handle) pending_list;  /* List of pending handles */
+    hg_thread_spin_t pending_list_lock;         /* Pending list lock */
 #ifdef HG_HAS_SM_ROUTING
-    HG_LIST_HEAD(hg_core_handle) sm_pending_list; /* List of SM pending handles */
-    hg_thread_spin_t sm_pending_list_lock;        /* SM pending list lock */
+    HG_LIST_HEAD(hg_core_private_handle) sm_pending_list; /* List of SM pending handles */
+    hg_thread_spin_t sm_pending_list_lock;      /* SM pending list lock */
 #endif
-    HG_LIST_HEAD(hg_core_handle) created_list;    /* List of handles for that context */
-    hg_thread_spin_t created_list_lock;           /* Handle list lock */
+    HG_LIST_HEAD(hg_core_private_handle) created_list;  /* List of handles for that context */
+    hg_thread_spin_t created_list_lock;         /* Handle list lock */
 #ifdef HG_HAS_SELF_FORWARD
-    int completion_queue_notify;                  /* Self notification */
-    hg_thread_pool_t *self_processing_pool;       /* Thread pool for self processing */
+    int completion_queue_notify;                /* Self notification */
+    hg_thread_pool_t *self_processing_pool;     /* Thread pool for self processing */
 #endif
     hg_return_t (*handle_create)(hg_core_handle_t, void *); /* handle_create */
-    void *handle_create_arg;                      /* handle_create arg */
-    void *data;                                   /* User data */
-    void (*data_free_callback)(void *);           /* User data free callback */
-    hg_bool_t finalizing;                         /* Prevent reposts */
-    hg_atomic_int32_t n_handles;                  /* Atomic used for number of handles */
-};
-
-/* Info for function map */
-struct hg_core_rpc_info {
-    hg_core_rpc_cb_t rpc_cb;        /* RPC callback */
-    void *data;                     /* User data */
-    void (*free_callback)(void *);  /* User data free callback */
+    void *handle_create_arg;                    /* handle_create arg */
+    hg_bool_t finalizing;                       /* Prevent reposts */
+    hg_atomic_int32_t n_handles;                /* Atomic used for number of handles */
 };
 
 #ifdef HG_HAS_SELF_FORWARD
@@ -163,11 +152,9 @@ struct hg_core_self_cb_info {
 #endif
 
 /* HG addr */
-struct hg_core_addr {
-    na_class_t *na_class;               /* NA class from NA address */
-    na_addr_t na_addr;                  /* NA address */
+struct hg_core_private_addr {
+    struct hg_core_addr core_addr;      /* Must remain as first field */
 #ifdef HG_HAS_SM_ROUTING
-    na_addr_t na_sm_addr;               /* NA SM address */
     uuid_t na_sm_uuid;                  /* NA SM UUID */
 #endif
     hg_bool_t is_mine;                  /* Created internally or not */
@@ -187,8 +174,8 @@ typedef enum {
 } hg_core_op_type_t;
 
 /* HG core handle */
-struct hg_core_handle {
-    struct hg_core_info hg_info;        /* HG info */
+struct hg_core_private_handle {
+    struct hg_core_handle core_handle;  /* Must remain as first field */
     na_class_t *na_class;               /* NA class */
     na_context_t *na_context;           /* NA context */
     hg_core_cb_t request_callback;      /* Request callback */
@@ -199,23 +186,17 @@ struct hg_core_handle {
     na_tag_t tag;                       /* Tag used for request and response */
     hg_uint8_t cookie;                  /* Cookie */
     hg_return_t ret;                    /* Return code associated to handle */
-    HG_LIST_ENTRY(hg_core_handle) created;  /* Created list entry */
-    HG_LIST_ENTRY(hg_core_handle) pending;  /* Pending list entry */
+    HG_LIST_ENTRY(hg_core_private_handle) created;  /* Created list entry */
+    HG_LIST_ENTRY(hg_core_private_handle) pending;  /* Pending list entry */
     struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
     hg_bool_t repost;                   /* Repost handle on completion (listen) */
     hg_bool_t is_self;                  /* Self processed */
     hg_atomic_int32_t in_use;           /* Is in use */
     hg_bool_t no_response;              /* Require response or not */
 
-    void *in_buf;                       /* Input buffer */
     void *in_buf_plugin_data;           /* Input buffer NA plugin data */
-    na_size_t in_buf_size;              /* Input buffer size */
-    na_size_t na_in_header_offset;      /* Input NA header offset */
     na_size_t in_buf_used;              /* Amount of input buffer used */
-    void *out_buf;                      /* Output buffer */
     void *out_buf_plugin_data;          /* Output buffer NA plugin data */
-    na_size_t out_buf_size;             /* Output buffer size */
-    na_size_t na_out_header_offset;     /* Output NA header offset */
     na_size_t out_buf_used;             /* Amount of output buffer used */
     void *ack_buf;                      /* Ack buf for more data */
     void *ack_buf_plugin_data;          /* Ack plugin data */
@@ -227,37 +208,32 @@ struct hg_core_handle {
     hg_atomic_int32_t na_op_completed_count;    /* Number of NA operations completed */
     hg_bool_t na_op_id_mine;            /* Operation ID created by HG */
 
-    hg_atomic_int32_t ref_count;        /* Reference count */
-
     struct hg_core_header in_header;    /* Input header */
     struct hg_core_header out_header;   /* Output header */
 
-    struct hg_core_rpc_info *hg_core_rpc_info;  /* Associated RPC info */
-    void *data;                         /* User data */
-    void (*data_free_callback)(void *); /* User data free callback */
-
+    hg_atomic_int32_t ref_count;        /* Reference count */
     struct hg_thread_work thread_work;  /* Used for self processing and testing */
 
     /* Callbacks */
     hg_return_t (*forward)(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         ); /* forward */
     hg_return_t (*respond)(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         ); /* respond */
     hg_return_t (*no_respond)(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         ); /* no_respond */
 };
 
 /* HG op id */
 struct hg_core_op_info_lookup {
-    struct hg_core_addr *hg_core_addr;  /* Address */
+    struct hg_core_private_addr *hg_core_addr; /* Address */
     na_op_id_t na_lookup_op_id;         /* Operation ID for lookup */
 };
 
 struct hg_core_op_id {
-    struct hg_core_context *context;    /* Context */
+    struct hg_core_private_context *context; /* Context */
     hg_cb_type_t type;                  /* Callback type */
     hg_core_cb_t callback;              /* Callback */
     void *arg;                          /* Callback arguments */
@@ -312,23 +288,9 @@ hg_core_func_map_value_free(
  */
 static HG_INLINE na_tag_t
 hg_core_gen_request_tag(
-        struct hg_core_class *hg_core_class
+        struct hg_core_private_class *hg_core_class
         );
 
-/**
- * Retrieve usable buffer to store input payload.
- */
-static HG_INLINE void
-hg_core_get_input(struct hg_core_handle *hg_core_handle, void **in_buf,
-    hg_size_t *in_buf_size);
-
-/**
- * Retrieve usable buffer to store output payload.
- */
-static HG_INLINE void
-hg_core_get_output(struct hg_core_handle *hg_core_handle, void **out_buf,
-    hg_size_t *out_buf_size);
-
 /**
  * Proc request header and verify it if decoded.
  */
@@ -354,7 +316,7 @@ hg_core_proc_header_response(
  */
 static hg_return_t
 hg_core_pending_list_cancel(
-        struct hg_core_context *context
+        struct hg_core_private_context *context
         );
 
 #ifdef HG_HAS_SM_ROUTING
@@ -363,7 +325,7 @@ hg_core_pending_list_cancel(
  */
 static hg_return_t
 hg_core_sm_pending_list_cancel(
-        struct hg_core_context *context
+        struct hg_core_private_context *context
         );
 #endif
 
@@ -372,13 +334,13 @@ hg_core_sm_pending_list_cancel(
  */
 static hg_return_t
 hg_core_created_list_wait(
-        struct hg_core_context *context
+        struct hg_core_private_context *context
         );
 
 /**
  * Initialize class.
  */
-static struct hg_core_class *
+static struct hg_core_private_class *
 hg_core_init(
         const char *na_info_string,
         hg_bool_t na_listen,
@@ -390,15 +352,15 @@ hg_core_init(
  */
 static hg_return_t
 hg_core_finalize(
-        struct hg_core_class *hg_core_class
+        struct hg_core_private_class *hg_core_class
         );
 
 /**
  * Create addr.
  */
-static struct hg_core_addr *
+static struct hg_core_private_addr *
 hg_core_addr_create(
-        struct hg_core_class *hg_core_class,
+        struct hg_core_private_class *hg_core_class,
         na_class_t *na_class
         );
 
@@ -407,7 +369,7 @@ hg_core_addr_create(
  */
 static hg_return_t
 hg_core_addr_lookup(
-        struct hg_core_context *context,
+        struct hg_core_private_context *context,
         hg_core_cb_t callback,
         void *arg,
         const char *name,
@@ -435,8 +397,8 @@ hg_core_addr_lookup_complete(
  */
 static hg_return_t
 hg_core_addr_free(
-        struct hg_core_class *hg_core_class,
-        struct hg_core_addr *hg_core_addr
+        struct hg_core_private_class *hg_core_class,
+        struct hg_core_private_addr *hg_core_addr
         );
 
 /**
@@ -444,8 +406,8 @@ hg_core_addr_free(
  */
 static hg_return_t
 hg_core_addr_self(
-        struct hg_core_class *hg_core_class,
-        struct hg_core_addr **self_addr
+        struct hg_core_private_class *hg_core_class,
+        struct hg_core_private_addr **self_addr
         );
 
 /**
@@ -453,9 +415,9 @@ hg_core_addr_self(
  */
 static hg_return_t
 hg_core_addr_dup(
-        struct hg_core_class *hg_core_class,
-        struct hg_core_addr *hg_core_addr,
-        struct hg_core_addr **hg_new_addr
+        struct hg_core_private_class *hg_core_class,
+        struct hg_core_private_addr *hg_core_addr,
+        struct hg_core_private_addr **hg_new_addr
         );
 
 /**
@@ -463,18 +425,18 @@ hg_core_addr_dup(
  */
 static hg_return_t
 hg_core_addr_to_string(
-        struct hg_core_class *hg_core_class,
+        struct hg_core_private_class *hg_core_class,
         char *buf,
         hg_size_t *buf_size,
-        struct hg_core_addr *hg_core_addr
+        struct hg_core_private_addr *hg_core_addr
         );
 
 /**
  * Create handle.
  */
-static struct hg_core_handle *
+static struct hg_core_private_handle *
 hg_core_create(
-        struct hg_core_context *context,
+        struct hg_core_private_context *context,
         hg_bool_t use_sm
         );
 
@@ -483,15 +445,32 @@ hg_core_create(
  */
 static void
 hg_core_destroy(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 
 /**
- * Reset handle.
+ * Allocate NA resources.
  */
 static hg_return_t
+hg_core_alloc_na(
+        struct hg_core_private_handle *hg_core_handle,
+        hg_bool_t use_sm
+        );
+
+/**
+ * Freee NA resources.
+ */
+static void
+hg_core_free_na(
+        struct hg_core_private_handle *hg_core_handle
+        );
+
+/**
+ * Reset handle.
+ */
+static void
 hg_core_reset(
-        struct hg_core_handle *hg_core_handle,
+        struct hg_core_private_handle *hg_core_handle,
         hg_bool_t reset_info
         );
 
@@ -500,26 +479,18 @@ hg_core_reset(
  */
 static hg_return_t
 hg_core_set_rpc(
-        struct hg_core_handle *hg_core_handle,
-        hg_core_addr_t addr,
+        struct hg_core_private_handle *hg_core_handle,
+        struct hg_core_private_addr *addr,
         hg_id_t id
         );
 
-/**
- * Get RPC registered data.
- */
-void *
-hg_core_get_rpc_data(
-        struct hg_core_handle *hg_core_handle
-        );
-
 #ifdef HG_HAS_SELF_FORWARD
 /**
  * Forward handle locally.
  */
 static hg_return_t
 hg_core_forward_self(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 #endif
 
@@ -528,24 +499,24 @@ hg_core_forward_self(
  */
 static hg_return_t
 hg_core_forward_na(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 
 #ifdef HG_HAS_SELF_FORWARD
 /**
  * Send response locally.
  */
-static hg_return_t
+static HG_INLINE hg_return_t
 hg_core_respond_self(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 
 /**
  * Do not send response locally.
  */
-static hg_return_t
+static HG_INLINE hg_return_t
 hg_core_no_respond_self(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 #endif
 
@@ -554,21 +525,21 @@ hg_core_no_respond_self(
  */
 static hg_return_t
 hg_core_respond_na(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 
 /**
  * Do not send response through NA.
  */
-static hg_return_t
+static HG_INLINE hg_return_t
 hg_core_no_respond_na(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 
 /**
  * Send input callback.
  */
-static int
+static HG_INLINE int
 hg_core_send_input_cb(
         const struct na_cb_info *callback_info
         );
@@ -586,14 +557,14 @@ hg_core_recv_input_cb(
  */
 static hg_return_t
 hg_core_process_input(
-        struct hg_core_handle *hg_core_handle,
+        struct hg_core_private_handle *hg_core_handle,
         hg_bool_t *completed
         );
 
 /**
  * Send output callback.
  */
-static int
+static HG_INLINE int
 hg_core_send_output_cb(
         const struct na_cb_info *callback_info
         );
@@ -601,7 +572,7 @@ hg_core_send_output_cb(
 /**
  * Recv output callback.
  */
-static int
+static HG_INLINE int
 hg_core_recv_output_cb(
         const struct na_cb_info *callback_info
         );
@@ -611,8 +582,9 @@ hg_core_recv_output_cb(
  */
 static hg_return_t
 hg_core_process_output(
-        struct hg_core_handle *hg_core_handle,
-        hg_bool_t *completed
+        struct hg_core_private_handle *hg_core_handle,
+        hg_bool_t *completed,
+        hg_return_t (*done_callback)(hg_core_handle_t)
         );
 
 /**
@@ -620,13 +592,13 @@ hg_core_process_output(
  */
 static hg_return_t
 hg_core_send_ack(
-        struct hg_core_handle *hg_core_handle
+        hg_core_handle_t handle
         );
 
 /**
  * Send ack callback. (HG_CORE_MORE_DATA flag on output)
  */
-static int
+static HG_INLINE int
 hg_core_send_ack_cb(
         const struct na_cb_info *callback_info
         );
@@ -634,7 +606,7 @@ hg_core_send_ack_cb(
 /**
  * Recv ack callback. (HG_CORE_MORE_DATA flag on output)
  */
-static int
+static HG_INLINE int
 hg_core_recv_ack_cb(
         const struct na_cb_info *callback_info
         );
@@ -662,7 +634,17 @@ hg_core_process_thread(
  */
 static hg_return_t
 hg_core_process(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
+        );
+
+/**
+ * Complete handle and NA operation.
+ */
+static HG_INLINE hg_return_t
+hg_core_complete_na(
+        struct hg_core_private_handle *hg_core_handle,
+        na_op_id_t *op_id,
+        hg_bool_t *completed
         );
 
 /**
@@ -670,7 +652,7 @@ hg_core_process(
  */
 static HG_INLINE hg_return_t
 hg_core_complete(
-        struct hg_core_handle *hg_core_handle
+        hg_core_handle_t handle
         );
 
 /**
@@ -688,7 +670,7 @@ hg_core_completion_add(
  */
 static hg_return_t
 hg_core_context_post(
-        struct hg_core_context *context,
+        struct hg_core_private_context *context,
         unsigned int request_count,
         hg_bool_t repost,
         hg_bool_t use_sm
@@ -699,7 +681,7 @@ hg_core_context_post(
  */
 static hg_return_t
 hg_core_post(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 
 /**
@@ -707,7 +689,7 @@ hg_core_post(
  */
 static hg_return_t
 hg_core_reset_post(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 
 /**
@@ -715,7 +697,7 @@ hg_core_reset_post(
  */
 static hg_return_t
 hg_core_progress_na(
-        struct hg_core_context *context,
+        struct hg_core_private_context *context,
         unsigned int timeout
         );
 
@@ -723,7 +705,7 @@ hg_core_progress_na(
 /**
  * Completion queue notification callback.
  */
-static int
+static HG_INLINE int
 hg_core_completion_queue_notify_cb(
         void *arg,
         unsigned int timeout,
@@ -769,7 +751,7 @@ hg_core_poll_try_wait_cb(
  */
 static hg_return_t
 hg_core_progress_poll(
-        struct hg_core_context *context,
+        struct hg_core_private_context *context,
         unsigned int timeout
         );
 
@@ -778,7 +760,7 @@ hg_core_progress_poll(
  */
 static hg_return_t
 hg_core_trigger(
-        struct hg_core_context *context,
+        struct hg_core_private_context *context,
         unsigned int timeout,
         unsigned int max_count,
         unsigned int *actual_count
@@ -797,7 +779,7 @@ hg_core_trigger_lookup_entry(
  */
 static hg_return_t
 hg_core_trigger_entry(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 
 /**
@@ -813,7 +795,7 @@ hg_bulk_trigger_entry(
  */
 static hg_return_t
 hg_core_cancel(
-        struct hg_core_handle *hg_core_handle
+        struct hg_core_private_handle *hg_core_handle
         );
 
 #ifdef HG_HAS_COLLECT_STATS
@@ -916,7 +898,7 @@ hg_core_func_map_value_free(hg_hash_table_value_t value)
 
 /*---------------------------------------------------------------------------*/
 static HG_INLINE na_tag_t
-hg_core_gen_request_tag(struct hg_core_class *hg_core_class)
+hg_core_gen_request_tag(struct hg_core_private_class *hg_core_class)
 {
     na_tag_t request_tag = 0;
 
@@ -930,32 +912,6 @@ hg_core_gen_request_tag(struct hg_core_class *hg_core_class)
     return request_tag;
 }
 
-/*---------------------------------------------------------------------------*/
-static HG_INLINE void
-hg_core_get_input(struct hg_core_handle *hg_core_handle, void **in_buf,
-    hg_size_t *in_buf_size)
-{
-    hg_size_t header_offset = hg_core_header_request_get_size() +
-        hg_core_handle->na_in_header_offset;
-
-    /* Space must be left for request header */
-    *in_buf = (char *) hg_core_handle->in_buf + header_offset;
-    *in_buf_size = hg_core_handle->in_buf_size - header_offset;
-}
-
-/*---------------------------------------------------------------------------*/
-static HG_INLINE void
-hg_core_get_output(struct hg_core_handle *hg_core_handle, void **out_buf,
-    hg_size_t *out_buf_size)
-{
-    hg_size_t header_offset = hg_core_header_response_get_size() +
-        hg_core_handle->na_out_header_offset;
-
-    /* Space must be left for response header */
-    *out_buf = (char *) hg_core_handle->out_buf + header_offset;
-    *out_buf_size = hg_core_handle->out_buf_size - header_offset;
-}
-
 /*---------------------------------------------------------------------------*/
 static HG_INLINE hg_return_t
 hg_core_proc_header_request(struct hg_core_handle *hg_core_handle,
@@ -1020,14 +976,15 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_pending_list_cancel(struct hg_core_context *context)
+hg_core_pending_list_cancel(struct hg_core_private_context *context)
 {
     hg_return_t ret = HG_SUCCESS;
 
     hg_thread_spin_lock(&context->pending_list_lock);
 
     while (!HG_LIST_IS_EMPTY(&context->pending_list)) {
-        struct hg_core_handle *hg_core_handle = HG_LIST_FIRST(&context->pending_list);
+        struct hg_core_private_handle *hg_core_handle =
+            HG_LIST_FIRST(&context->pending_list);
         HG_LIST_REMOVE(hg_core_handle, pending);
 
         /* Prevent reposts */
@@ -1049,14 +1006,15 @@ hg_core_pending_list_cancel(struct hg_core_context *context)
 /*---------------------------------------------------------------------------*/
 #ifdef HG_HAS_SM_ROUTING
 static hg_return_t
-hg_core_sm_pending_list_cancel(struct hg_core_context *context)
+hg_core_sm_pending_list_cancel(struct hg_core_private_context *context)
 {
     hg_return_t ret = HG_SUCCESS;
 
     hg_thread_spin_lock(&context->sm_pending_list_lock);
 
     while (!HG_LIST_IS_EMPTY(&context->sm_pending_list)) {
-        struct hg_core_handle *hg_core_handle = HG_LIST_FIRST(&context->sm_pending_list);
+        struct hg_core_private_handle *hg_core_handle =
+            HG_LIST_FIRST(&context->sm_pending_list);
         HG_LIST_REMOVE(hg_core_handle, pending);
 
         /* Prevent reposts */
@@ -1078,7 +1036,7 @@ hg_core_sm_pending_list_cancel(struct hg_core_context *context)
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_created_list_wait(struct hg_core_context *context)
+hg_core_created_list_wait(struct hg_core_private_context *context)
 {
     hg_util_bool_t created_list_empty = HG_UTIL_FALSE;
     /* Convert timeout in ms into seconds */
@@ -1118,11 +1076,11 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static struct hg_core_class *
+static struct hg_core_private_class *
 hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     const struct hg_init_info *hg_init_info)
 {
-    struct hg_core_class *hg_core_class = NULL;
+    struct hg_core_private_class *hg_core_class = NULL;
     na_tag_t na_max_tag;
 #ifdef HG_HAS_SM_ROUTING
     na_tag_t na_sm_max_tag;
@@ -1131,19 +1089,20 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     hg_return_t ret = HG_SUCCESS;
 
     /* Create new HG class */
-    hg_core_class = (struct hg_core_class *) malloc(sizeof(struct hg_core_class));
+    hg_core_class = (struct hg_core_private_class *) malloc(
+        sizeof(struct hg_core_private_class));
     if (!hg_core_class) {
         HG_LOG_ERROR("Could not allocate HG class");
         ret = HG_NOMEM_ERROR;
         goto done;
     }
-    memset(hg_core_class, 0, sizeof(struct hg_core_class));
+    memset(hg_core_class, 0, sizeof(struct hg_core_private_class));
 
     /* Parse options */
     if (hg_init_info) {
         /* External NA class */
         if (hg_init_info->na_class) {
-            hg_core_class->na_class = hg_init_info->na_class;
+            hg_core_class->core_class.na_class = hg_init_info->na_class;
             hg_core_class->na_ext_init = HG_TRUE;
         }
         hg_core_class->progress_mode = hg_init_info->na_init_info.progress_mode;
@@ -1170,9 +1129,9 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
 
     /* Initialize NA if not provided externally */
     if (!hg_core_class->na_ext_init) {
-        hg_core_class->na_class = NA_Initialize_opt(na_info_string, na_listen,
-            &hg_init_info->na_init_info);
-        if (!hg_core_class->na_class) {
+        hg_core_class->core_class.na_class = NA_Initialize_opt(
+            na_info_string, na_listen, &hg_init_info->na_init_info);
+        if (!hg_core_class->core_class.na_class) {
             HG_LOG_ERROR("Could not initialize NA class");
             ret = HG_NA_ERROR;
             goto done;
@@ -1182,7 +1141,8 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
 #ifdef HG_HAS_SM_ROUTING
     /* Initialize SM plugin */
     if (auto_sm) {
-        if (strcmp(NA_Get_class_name(hg_core_class->na_class), "na") == 0) {
+        if (strcmp(NA_Get_class_name(hg_core_class->core_class.na_class),
+            "na") == 0) {
             HG_LOG_ERROR("Cannot use auto SM mode if initialized NA class is "
                 "already using SM");
             ret = HG_PROTOCOL_ERROR;
@@ -1190,9 +1150,9 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
         }
 
         /* Initialize NA SM first so that tmp directories are created */
-        hg_core_class->na_sm_class = NA_Initialize_opt("na+sm", na_listen,
-            &hg_init_info->na_init_info);
-        if (!hg_core_class->na_sm_class) {
+        hg_core_class->core_class.na_sm_class = NA_Initialize_opt("na+sm",
+            na_listen, &hg_init_info->na_init_info);
+        if (!hg_core_class->core_class.na_sm_class) {
             HG_LOG_ERROR("Could not initialize NA SM class");
             ret = HG_NA_ERROR;
             goto done;
@@ -1208,7 +1168,7 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
 #endif
 
     /* Compute max request tag */
-    na_max_tag = NA_Msg_get_max_tag(hg_core_class->na_class);
+    na_max_tag = NA_Msg_get_max_tag(hg_core_class->core_class.na_class);
     if (!na_max_tag) {
         HG_LOG_ERROR("NA Max tag is not defined");
         ret = HG_NA_ERROR;
@@ -1218,7 +1178,8 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
 
 #ifdef HG_HAS_SM_ROUTING
     if (auto_sm) {
-        na_sm_max_tag = NA_Msg_get_max_tag(hg_core_class->na_sm_class);
+        na_sm_max_tag = NA_Msg_get_max_tag(
+            hg_core_class->core_class.na_sm_class);
         if (!na_max_tag) {
             HG_LOG_ERROR("NA Max tag is not defined");
             ret = HG_NA_ERROR;
@@ -1262,7 +1223,7 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_finalize(struct hg_core_class *hg_core_class)
+hg_core_finalize(struct hg_core_private_class *hg_core_class)
 {
     hg_util_int32_t n_addrs, n_contexts;
     hg_return_t ret = HG_SUCCESS;
@@ -1291,25 +1252,26 @@ hg_core_finalize(struct hg_core_class *hg_core_class)
     hg_core_class->func_map = NULL;
 
     /* Free user data */
-    if (hg_core_class->data_free_callback)
-        hg_core_class->data_free_callback(hg_core_class->data);
+    if (hg_core_class->core_class.data_free_callback)
+        hg_core_class->core_class.data_free_callback(
+            hg_core_class->core_class.data);
 
     /* Destroy mutex */
     hg_thread_spin_destroy(&hg_core_class->func_map_lock);
 
     if (!hg_core_class->na_ext_init) {
         /* Finalize interface */
-        if (NA_Finalize(hg_core_class->na_class) != NA_SUCCESS) {
+        if (NA_Finalize(hg_core_class->core_class.na_class) != NA_SUCCESS) {
             HG_LOG_ERROR("Could not finalize NA interface");
             ret = HG_NA_ERROR;
             goto done;
         }
-        hg_core_class->na_class = NULL;
+        hg_core_class->core_class.na_class = NULL;
     }
 
 #ifdef HG_HAS_SM_ROUTING
     /* Finalize SM interface */
-    if (NA_Finalize(hg_core_class->na_sm_class) != NA_SUCCESS) {
+    if (NA_Finalize(hg_core_class->core_class.na_sm_class) != NA_SUCCESS) {
         HG_LOG_ERROR("Could not finalize NA SM interface");
         ret = HG_NA_ERROR;
         goto done;
@@ -1324,21 +1286,23 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static struct hg_core_addr *
-hg_core_addr_create(struct hg_core_class *hg_core_class, na_class_t *na_class)
+static struct hg_core_private_addr *
+hg_core_addr_create(struct hg_core_private_class *hg_core_class,
+    na_class_t *na_class)
 {
-    struct hg_core_addr *hg_core_addr = NULL;
+    struct hg_core_private_addr *hg_core_addr = NULL;
 
-    hg_core_addr = (struct hg_core_addr *) malloc(sizeof(struct hg_core_addr));
+    hg_core_addr = (struct hg_core_private_addr *) malloc(
+        sizeof(struct hg_core_private_addr));
     if (!hg_core_addr) {
         HG_LOG_ERROR("Could not allocate HG addr");
         goto done;
     }
-    memset(hg_core_addr, 0, sizeof(struct hg_core_addr));
-    hg_core_addr->na_class = na_class;
-    hg_core_addr->na_addr = NA_ADDR_NULL;
+    memset(hg_core_addr, 0, sizeof(struct hg_core_private_addr));
+    hg_core_addr->core_addr.na_class = na_class;
+    hg_core_addr->core_addr.na_addr = NA_ADDR_NULL;
 #ifdef HG_HAS_SM_ROUTING
-    hg_core_addr->na_sm_addr = NA_ADDR_NULL;
+    hg_core_addr->core_addr.na_sm_addr = NA_ADDR_NULL;
 #endif
     hg_atomic_init32(&hg_core_addr->ref_count, 1);
 
@@ -1351,13 +1315,13 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_addr_lookup(struct hg_core_context *context, hg_core_cb_t callback, void *arg,
-    const char *name, hg_core_op_id_t *op_id)
+hg_core_addr_lookup(struct hg_core_private_context *context,
+    hg_core_cb_t callback, void *arg, const char *name, hg_core_op_id_t *op_id)
 {
-    na_class_t *na_class = context->hg_core_class->na_class;
-    na_context_t *na_context = context->na_context;
+    na_class_t *na_class = context->core_context.core_class->na_class;
+    na_context_t *na_context = context->core_context.na_context;
     struct hg_core_op_id *hg_core_op_id = NULL;
-    struct hg_core_addr *hg_core_addr = NULL;
+    struct hg_core_private_addr *hg_core_addr = NULL;
     na_return_t na_ret;
 #ifdef HG_HAS_SM_ROUTING
     char lookup_name[HG_CORE_ADDR_MAX_SIZE] = {'\0'};
@@ -1381,7 +1345,7 @@ hg_core_addr_lookup(struct hg_core_context *context, hg_core_cb_t callback, void
     hg_core_op_id->info.lookup.na_lookup_op_id = NA_OP_ID_NULL;
 
     /* Allocate addr */
-    hg_core_addr = hg_core_addr_create(context->hg_core_class, NULL);
+    hg_core_addr = hg_core_addr_create(HG_CORE_CONTEXT_CLASS(context), NULL);
     if (!hg_core_addr) {
         HG_LOG_ERROR("Could not create HG addr");
         ret = HG_NOMEM_ERROR;
@@ -1414,11 +1378,12 @@ hg_core_addr_lookup(struct hg_core_context *context, hg_core_cb_t callback, void
         local_name = lookup_names;
 
         /* Compare UUIDs, if they match it's local address */
-        if (context->na_sm_context && uuid_compare(hg_core_addr->na_sm_uuid,
-            context->hg_core_class->na_sm_uuid) == 0) {
+        if (context->core_context.na_sm_context
+            && uuid_compare(hg_core_addr->na_sm_uuid,
+            HG_CORE_CONTEXT_CLASS(context)->na_sm_uuid) == 0) {
             name_str = local_name;
-            na_class = context->hg_core_class->na_sm_class;
-            na_context = context->na_sm_context;
+            na_class = context->core_context.core_class->na_sm_class;
+            na_context = context->core_context.na_sm_context;
         } else {
             /* Remote lookup */
             name_str = remote_name;
@@ -1426,7 +1391,7 @@ hg_core_addr_lookup(struct hg_core_context *context, hg_core_cb_t callback, void
     }
 #endif
     /* Assign corresponding NA class */
-    hg_core_addr->na_class = na_class;
+    hg_core_addr->core_addr.na_class = na_class;
 
     /* Assign op_id */
     if (op_id && op_id != HG_CORE_OP_ID_IGNORE)
@@ -1453,7 +1418,7 @@ done:
     if (ret != HG_SUCCESS) {
         free(hg_core_op_id);
         if (hg_core_addr != NULL)
-            hg_core_addr_free(context->hg_core_class, hg_core_addr);
+            hg_core_addr_free(HG_CORE_CONTEXT_CLASS(context), hg_core_addr);
     }
 
     return ret;
@@ -1463,7 +1428,8 @@ done:
 static int
 hg_core_addr_lookup_cb(const struct na_cb_info *callback_info)
 {
-    struct hg_core_op_id *hg_core_op_id = (struct hg_core_op_id *) callback_info->arg;
+    struct hg_core_op_id *hg_core_op_id =
+        (struct hg_core_op_id *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
     int ret = 0;
 
@@ -1472,7 +1438,8 @@ hg_core_addr_lookup_cb(const struct na_cb_info *callback_info)
     }
 
     /* Assign addr */
-    hg_core_op_id->info.lookup.hg_core_addr->na_addr = callback_info->info.lookup.addr;
+    hg_core_op_id->info.lookup.hg_core_addr->core_addr.na_addr =
+        callback_info->info.lookup.addr;
 
     /* Mark as completed */
     if (hg_core_addr_lookup_complete(hg_core_op_id) != HG_SUCCESS) {
@@ -1490,7 +1457,7 @@ done:
 static hg_return_t
 hg_core_addr_lookup_complete(struct hg_core_op_id *hg_core_op_id)
 {
-    hg_core_context_t *context = hg_core_op_id->context;
+    hg_core_context_t *context = &hg_core_op_id->context->core_context;
     struct hg_completion_entry *hg_completion_entry =
         &hg_core_op_id->hg_completion_entry;
     hg_return_t ret = HG_SUCCESS;
@@ -1513,7 +1480,8 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_addr_free(struct hg_core_class *hg_core_class, struct hg_core_addr *hg_core_addr)
+hg_core_addr_free(struct hg_core_private_class *hg_core_class,
+    struct hg_core_private_addr *hg_core_addr)
 {
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
@@ -1529,8 +1497,10 @@ hg_core_addr_free(struct hg_core_class *hg_core_class, struct hg_core_addr *hg_c
     hg_atomic_decr32(&hg_core_class->n_addrs);
 
 #ifdef HG_HAS_SM_ROUTING
-    if (hg_core_addr->na_sm_addr != NA_ADDR_NULL) { /* Self address case with SM */
-        na_ret = NA_Addr_free(hg_core_class->na_sm_class, hg_core_addr->na_sm_addr);
+    /* Self address case with SM */
+    if (hg_core_addr->core_addr.na_sm_addr != NA_ADDR_NULL) {
+        na_ret = NA_Addr_free(hg_core_class->core_class.na_sm_class,
+            hg_core_addr->core_addr.na_sm_addr);
         if (na_ret != NA_SUCCESS) {
             HG_LOG_ERROR("Could not free NA SM address");
             ret = HG_NA_ERROR;
@@ -1540,7 +1510,8 @@ hg_core_addr_free(struct hg_core_class *hg_core_class, struct hg_core_addr *hg_c
 #endif
 
     /* Free NA address */
-    na_ret = NA_Addr_free(hg_core_addr->na_class, hg_core_addr->na_addr);
+    na_ret = NA_Addr_free(hg_core_addr->core_addr.na_class,
+        hg_core_addr->core_addr.na_addr);
     if (na_ret != NA_SUCCESS) {
         HG_LOG_ERROR("Could not free address");
         ret = HG_NA_ERROR;
@@ -1554,21 +1525,23 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_addr_self(struct hg_core_class *hg_core_class,
-    struct hg_core_addr **self_addr)
+hg_core_addr_self(struct hg_core_private_class *hg_core_class,
+    struct hg_core_private_addr **self_addr)
 {
-    struct hg_core_addr *hg_core_addr = NULL;
+    struct hg_core_private_addr *hg_core_addr = NULL;
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
-    hg_core_addr = hg_core_addr_create(hg_core_class, hg_core_class->na_class);
+    hg_core_addr = hg_core_addr_create(hg_core_class,
+        hg_core_class->core_class.na_class);
     if (!hg_core_addr) {
         HG_LOG_ERROR("Could not create HG addr");
         ret = HG_NOMEM_ERROR;
         goto done;
     }
 
-    na_ret = NA_Addr_self(hg_core_class->na_class, &hg_core_addr->na_addr);
+    na_ret = NA_Addr_self(hg_core_class->core_class.na_class,
+        &hg_core_addr->core_addr.na_addr);
     if (na_ret != NA_SUCCESS) {
         HG_LOG_ERROR("Could not get self address");
         ret = HG_NA_ERROR;
@@ -1576,9 +1549,10 @@ hg_core_addr_self(struct hg_core_class *hg_core_class,
     }
 
 #ifdef HG_HAS_SM_ROUTING
-    if (hg_core_class->na_sm_class) {
+    if (hg_core_class->core_class.na_sm_class) {
         /* Get SM address */
-        na_ret = NA_Addr_self(hg_core_class->na_sm_class, &hg_core_addr->na_sm_addr);
+        na_ret = NA_Addr_self(hg_core_class->core_class.na_sm_class,
+            &hg_core_addr->core_addr.na_sm_addr);
         if (na_ret != NA_SUCCESS) {
             HG_LOG_ERROR("Could not get self SM address");
             ret = HG_NA_ERROR;
@@ -1598,8 +1572,9 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_addr_dup(struct hg_core_class *hg_core_class,
-    struct hg_core_addr *hg_core_addr, struct hg_core_addr **hg_new_addr)
+hg_core_addr_dup(struct hg_core_private_class *hg_core_class,
+    struct hg_core_private_addr *hg_core_addr,
+    struct hg_core_private_addr **hg_new_addr)
 {
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
@@ -1610,16 +1585,17 @@ hg_core_addr_dup(struct hg_core_class *hg_core_class,
      * refcount of original address.
      */
     if (hg_core_addr->is_mine) {
-        struct hg_core_addr *dup = NULL;
+        struct hg_core_private_addr *dup = NULL;
 
-        dup = hg_core_addr_create(hg_core_class, hg_core_addr->na_class);
+        dup = hg_core_addr_create(hg_core_class,
+            hg_core_addr->core_addr.na_class);
         if (!dup) {
             HG_LOG_ERROR("Could not create HG addr");
             ret = HG_NOMEM_ERROR;
             goto done;
         }
-        na_ret = NA_Addr_dup(hg_core_addr->na_class, hg_core_addr->na_addr,
-            &dup->na_addr);
+        na_ret = NA_Addr_dup(hg_core_addr->core_addr.na_class,
+            hg_core_addr->core_addr.na_addr, &dup->core_addr.na_addr);
         if (na_ret != NA_SUCCESS) {
             HG_LOG_ERROR("Could not duplicate address");
             ret = HG_NA_ERROR;
@@ -1637,8 +1613,8 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_addr_to_string(struct hg_core_class *hg_core_class, char *buf, hg_size_t *buf_size,
-    struct hg_core_addr *hg_core_addr)
+hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
+    hg_size_t *buf_size, struct hg_core_private_addr *hg_core_addr)
 {
     char *buf_ptr = buf;
     hg_size_t new_buf_size = 0, buf_size_used = 0;
@@ -1653,7 +1629,7 @@ hg_core_addr_to_string(struct hg_core_class *hg_core_class, char *buf, hg_size_t
     new_buf_size = *buf_size;
 
 #ifdef HG_HAS_SM_ROUTING
-    if (hg_core_addr->na_sm_addr) {
+    if (hg_core_addr->core_addr.na_sm_addr) {
         char addr_str[HG_CORE_ADDR_MAX_SIZE];
         char uuid_str[HG_CORE_UUID_MAX_LEN + 1];
         int desc_len;
@@ -1676,8 +1652,8 @@ hg_core_addr_to_string(struct hg_core_class *hg_core_class, char *buf, hg_size_t
             new_buf_size = *buf_size - (hg_size_t) desc_len;
 
         /* Get NA SM address string */
-        na_ret = NA_Addr_to_string(hg_core_class->na_sm_class, buf_ptr,
-            &new_buf_size, hg_core_addr->na_sm_addr);
+        na_ret = NA_Addr_to_string(hg_core_class->core_class.na_sm_class,
+            buf_ptr, &new_buf_size, hg_core_addr->core_addr.na_sm_addr);
         if (na_ret != NA_SUCCESS) {
             HG_LOG_ERROR("Could not convert SM address to string");
             ret = HG_NA_ERROR;
@@ -1694,8 +1670,8 @@ hg_core_addr_to_string(struct hg_core_class *hg_core_class, char *buf, hg_size_t
 #endif
 
     /* Get NA address string */
-    na_ret = NA_Addr_to_string(hg_core_class->na_class, buf_ptr, &new_buf_size,
-        hg_core_addr->na_addr);
+    na_ret = NA_Addr_to_string(hg_core_class->core_class.na_class, buf_ptr,
+        &new_buf_size, hg_core_addr->core_addr.na_addr);
     if (na_ret != NA_SUCCESS) {
         HG_LOG_ERROR("Could not convert address to string");
         ret = HG_NA_ERROR;
@@ -1708,95 +1684,58 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static struct hg_core_handle *
-hg_core_create(struct hg_core_context *context, hg_bool_t HG_UNUSED use_sm)
+static struct hg_core_private_handle *
+hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
 {
-    na_class_t *na_class = context->hg_core_class->na_class;
-    na_context_t *na_context = context->na_context;
-    struct hg_core_handle *hg_core_handle = NULL;
+    struct hg_core_private_handle *hg_core_handle = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    hg_core_handle = (struct hg_core_handle *) malloc(sizeof(struct hg_core_handle));
+    hg_core_handle = (struct hg_core_private_handle *) malloc(
+        sizeof(struct hg_core_private_handle));
     if (!hg_core_handle) {
         HG_LOG_ERROR("Could not allocate handle");
         goto done;
     }
-    memset(hg_core_handle, 0, sizeof(struct hg_core_handle));
+    memset(hg_core_handle, 0, sizeof(struct hg_core_private_handle));
 
     hg_core_handle->op_type = HG_CORE_PROCESS; /* Default */
-    hg_core_handle->hg_info.hg_core_class = context->hg_core_class;
-    hg_core_handle->hg_info.context = context;
-    hg_core_handle->hg_info.addr = HG_CORE_ADDR_NULL;
-    hg_core_handle->hg_info.id = 0;
-    hg_core_handle->hg_info.context_id = 0;
-#ifdef HG_HAS_SM_ROUTING
-    if (use_sm) {
-        na_class = context->hg_core_class->na_sm_class;
-        na_context = context->na_sm_context;
-    }
-#endif
-    hg_core_handle->na_class = na_class;
-    hg_core_handle->na_context = na_context;
+    hg_core_handle->core_handle.info.core_class =
+        context->core_context.core_class;
+    hg_core_handle->core_handle.info.context = &context->core_context;
+    hg_core_handle->core_handle.info.addr = HG_CORE_ADDR_NULL;
+    hg_core_handle->core_handle.info.id = 0;
+    hg_core_handle->core_handle.info.context_id = 0;
+
+    /* Default return code */
     hg_core_handle->ret = HG_SUCCESS;
 
     /* Add handle to handle list so that we can track it */
-    hg_thread_spin_lock(&hg_core_handle->hg_info.context->created_list_lock);
-    HG_LIST_INSERT_HEAD(&hg_core_handle->hg_info.context->created_list,
+    hg_thread_spin_lock(&HG_CORE_HANDLE_CONTEXT(hg_core_handle)->created_list_lock);
+    HG_LIST_INSERT_HEAD(&HG_CORE_HANDLE_CONTEXT(hg_core_handle)->created_list,
         hg_core_handle, created);
-    hg_thread_spin_unlock(&hg_core_handle->hg_info.context->created_list_lock);
+    hg_thread_spin_unlock(&HG_CORE_HANDLE_CONTEXT(hg_core_handle)->created_list_lock);
 
     /* Handle is not in use */
     hg_atomic_init32(&hg_core_handle->in_use, HG_FALSE);
 
-    /* Initialize processing buffers and use unexpected message size */
-    hg_core_handle->in_buf_size = NA_Msg_get_max_unexpected_size(na_class);
-    hg_core_handle->out_buf_size = NA_Msg_get_max_expected_size(na_class);
-    hg_core_handle->na_in_header_offset = NA_Msg_get_unexpected_header_size(na_class);
-    hg_core_handle->na_out_header_offset = NA_Msg_get_expected_header_size(na_class);
-
-    hg_core_handle->in_buf = NA_Msg_buf_alloc(na_class, hg_core_handle->in_buf_size,
-        &hg_core_handle->in_buf_plugin_data);
-    if (!hg_core_handle->in_buf) {
-        HG_LOG_ERROR("Could not allocate buffer for input");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    NA_Msg_init_unexpected(na_class, hg_core_handle->in_buf, hg_core_handle->in_buf_size);
-
-    hg_core_handle->out_buf = NA_Msg_buf_alloc(na_class, hg_core_handle->out_buf_size,
-        &hg_core_handle->out_buf_plugin_data);
-    if (!hg_core_handle->out_buf) {
-        HG_LOG_ERROR("Could not allocate buffer for output");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    NA_Msg_init_expected(na_class, hg_core_handle->out_buf, hg_core_handle->out_buf_size);
-
     /* Init in/out header */
     hg_core_header_request_init(&hg_core_handle->in_header);
     hg_core_header_response_init(&hg_core_handle->out_header);
 
-    /* Create NA operation IDs */
-    hg_core_handle->na_send_op_id = NA_Op_create(na_class);
-    hg_core_handle->na_recv_op_id = NA_Op_create(na_class);
-    if (hg_core_handle->na_recv_op_id || hg_core_handle->na_send_op_id) {
-        if ((hg_core_handle->na_recv_op_id == NA_OP_ID_NULL)
-            || (hg_core_handle->na_send_op_id == NA_OP_ID_NULL)) {
-            HG_LOG_ERROR("NULL operation ID");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
-        hg_core_handle->na_op_id_mine = HG_TRUE;
-    }
-    hg_core_handle->na_op_count = 1; /* Default (no response) */
-    hg_atomic_init32(&hg_core_handle->na_op_completed_count, 0);
-
     /* Set refcount to 1 */
     hg_atomic_init32(&hg_core_handle->ref_count, 1);
 
     /* Increment N handles from HG context */
     hg_atomic_incr32(&context->n_handles);
 
+    /* Alloc/init NA resources */
+    ret = hg_core_alloc_na(hg_core_handle, use_sm);
+    if (ret != HG_SUCCESS) {
+        NA_LOG_ERROR("Could not allocate NA handle ops");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
+
 done:
     if (ret != HG_SUCCESS) {
         hg_core_destroy(hg_core_handle);
@@ -1807,58 +1746,40 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static void
-hg_core_destroy(struct hg_core_handle *hg_core_handle)
+hg_core_destroy(struct hg_core_private_handle *hg_core_handle)
 {
-    na_return_t na_ret;
-
     if (!hg_core_handle) goto done;
 
-    if (hg_atomic_decr32(&hg_core_handle->ref_count)) {
-        /* Cannot free yet */
-        goto done;
-    }
+    if (hg_atomic_decr32(&hg_core_handle->ref_count))
+        goto done; /* Cannot free yet */
 
     /* Remove handle from list */
-    hg_thread_spin_lock(&hg_core_handle->hg_info.context->created_list_lock);
+    hg_thread_spin_lock(&HG_CORE_HANDLE_CONTEXT(hg_core_handle)->created_list_lock);
     HG_LIST_REMOVE(hg_core_handle, created);
-    hg_thread_spin_unlock(&hg_core_handle->hg_info.context->created_list_lock);
+    hg_thread_spin_unlock(&HG_CORE_HANDLE_CONTEXT(hg_core_handle)->created_list_lock);
 
     /* Decrement N handles from HG context */
-    hg_atomic_decr32(&hg_core_handle->hg_info.context->n_handles);
+    hg_atomic_decr32(&HG_CORE_HANDLE_CONTEXT(hg_core_handle)->n_handles);
 
     /* Remove reference to HG addr */
-    hg_core_addr_free(hg_core_handle->hg_info.hg_core_class, hg_core_handle->hg_info.addr);
-
-    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_send_op_id);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA op ID");
-    NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_recv_op_id);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA op ID");
+    hg_core_addr_free(HG_CORE_HANDLE_CLASS(hg_core_handle),
+        (struct hg_core_private_addr *) hg_core_handle->core_handle.info.addr);
 
     hg_core_header_request_finalize(&hg_core_handle->in_header);
     hg_core_header_response_finalize(&hg_core_handle->out_header);
 
-    na_ret = NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->in_buf,
-        hg_core_handle->in_buf_plugin_data);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA input msg buffer");
-    na_ret = NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->out_buf,
-        hg_core_handle->out_buf_plugin_data);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA output msg buffer");
-
     /* Free extra data here if needed */
-    if (hg_core_handle->hg_info.hg_core_class->more_data_release)
-        hg_core_handle->hg_info.hg_core_class->more_data_release(
+    if (HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_release)
+        HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_release(
             (hg_core_handle_t) hg_core_handle);
-    if (hg_core_handle->ack_buf)
-        NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->ack_buf,
-            hg_core_handle->ack_buf_plugin_data);
 
     /* Free user data */
-    if (hg_core_handle->data_free_callback)
-        hg_core_handle->data_free_callback(hg_core_handle->data);
+    if (hg_core_handle->core_handle.data_free_callback)
+        hg_core_handle->core_handle.data_free_callback(
+            hg_core_handle->core_handle.data);
+
+    /* Free NA resources */
+    hg_core_free_na(hg_core_handle);
 
     free(hg_core_handle);
 
@@ -1868,29 +1789,124 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_reset(struct hg_core_handle *hg_core_handle, hg_bool_t reset_info)
+hg_core_alloc_na(struct hg_core_private_handle *hg_core_handle,
+    hg_bool_t HG_UNUSED use_sm)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (hg_atomic_get32(&hg_core_handle->in_use)) {
-        /* Not safe to reset
-         * TODO could add the ability to defer the reset operation */
-        HG_LOG_ERROR("Cannot reset HG core handle, handle is still in use, "
-            "refcount: %d", hg_atomic_get32(&hg_core_handle->ref_count));
-        ret = HG_PROTOCOL_ERROR;
+    /* Set handle NA class/context */
+    hg_core_handle->na_class =
+#ifdef HG_HAS_SM_ROUTING
+        (use_sm) ? HG_CORE_HANDLE_CLASS(hg_core_handle)->core_class.na_sm_class :
+#endif
+        HG_CORE_HANDLE_CLASS(hg_core_handle)->core_class.na_class;
+    hg_core_handle->na_context =
+#ifdef HG_HAS_SM_ROUTING
+        (use_sm) ? HG_CORE_HANDLE_CONTEXT(hg_core_handle)->core_context.na_sm_context :
+#endif
+        HG_CORE_HANDLE_CONTEXT(hg_core_handle)->core_context.na_context;
+
+    /* Initialize in/out buffers and use unexpected message size */
+    hg_core_handle->core_handle.in_buf_size =
+        NA_Msg_get_max_unexpected_size(hg_core_handle->na_class);
+    hg_core_handle->core_handle.out_buf_size =
+        NA_Msg_get_max_expected_size(hg_core_handle->na_class);
+    hg_core_handle->core_handle.na_in_header_offset =
+        NA_Msg_get_unexpected_header_size(hg_core_handle->na_class);
+    hg_core_handle->core_handle.na_out_header_offset =
+        NA_Msg_get_expected_header_size(hg_core_handle->na_class);
+
+    hg_core_handle->core_handle.in_buf = NA_Msg_buf_alloc(
+        hg_core_handle->na_class, hg_core_handle->core_handle.in_buf_size,
+        &hg_core_handle->in_buf_plugin_data);
+    if (!hg_core_handle->core_handle.in_buf) {
+        HG_LOG_ERROR("Could not allocate buffer for input");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
+    NA_Msg_init_unexpected(hg_core_handle->na_class,
+        hg_core_handle->core_handle.in_buf,
+        hg_core_handle->core_handle.in_buf_size);
+
+    hg_core_handle->core_handle.out_buf = NA_Msg_buf_alloc(
+        hg_core_handle->na_class, hg_core_handle->core_handle.out_buf_size,
+        &hg_core_handle->out_buf_plugin_data);
+    if (!hg_core_handle->core_handle.out_buf) {
+        HG_LOG_ERROR("Could not allocate buffer for output");
+        ret = HG_NOMEM_ERROR;
         goto done;
     }
+    NA_Msg_init_expected(hg_core_handle->na_class,
+        hg_core_handle->core_handle.out_buf,
+        hg_core_handle->core_handle.out_buf_size);
+
+    /* Create NA operation IDs */
+    hg_core_handle->na_send_op_id = NA_Op_create(hg_core_handle->na_class);
+    hg_core_handle->na_recv_op_id = NA_Op_create(hg_core_handle->na_class);
+    if (hg_core_handle->na_recv_op_id || hg_core_handle->na_send_op_id) {
+        if ((hg_core_handle->na_recv_op_id == NA_OP_ID_NULL)
+            || (hg_core_handle->na_send_op_id == NA_OP_ID_NULL)) {
+            HG_LOG_ERROR("NULL operation ID");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
+        hg_core_handle->na_op_id_mine = HG_TRUE;
+    }
+    hg_core_handle->na_op_count = 1; /* Default (no response) */
+    hg_atomic_init32(&hg_core_handle->na_op_completed_count, 0);
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static void
+hg_core_free_na(struct hg_core_private_handle *hg_core_handle)
+{
+    na_return_t na_ret;
+
+    /* Free eventual ack buffer */
+    if (hg_core_handle->ack_buf) {
+        NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->ack_buf,
+            hg_core_handle->ack_buf_plugin_data);
+        hg_core_handle->ack_buf = NULL;
+    }
+
+    /* Destroy NA op IDs */
+    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_send_op_id);
+    if (na_ret != NA_SUCCESS)
+        HG_LOG_ERROR("Could not destroy NA op ID");
+    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_recv_op_id);
+    if (na_ret != NA_SUCCESS)
+        HG_LOG_ERROR("Could not destroy NA op ID");
+
+    /* Free buffers */
+    na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
+        hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_plugin_data);
+    if (na_ret != NA_SUCCESS)
+        HG_LOG_ERROR("Could not destroy NA input msg buffer");
+    na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
+        hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_plugin_data);
+    if (na_ret != NA_SUCCESS)
+        HG_LOG_ERROR("Could not destroy NA output msg buffer");
+}
 
+/*---------------------------------------------------------------------------*/
+static void
+hg_core_reset(struct hg_core_private_handle *hg_core_handle,
+    hg_bool_t reset_info)
+{
     /* Reset source address */
     if (reset_info) {
-        if (hg_core_handle->hg_info.addr != HG_CORE_ADDR_NULL
-            && hg_core_handle->hg_info.addr->na_addr != NA_ADDR_NULL) {
-            NA_Addr_free(hg_core_handle->na_class, hg_core_handle->hg_info.addr->na_addr);
-            hg_core_handle->hg_info.addr->na_addr = NA_ADDR_NULL;
+        if (hg_core_handle->core_handle.info.addr != HG_CORE_ADDR_NULL
+            && hg_core_handle->core_handle.info.addr->na_addr != NA_ADDR_NULL) {
+            NA_Addr_free(hg_core_handle->core_handle.info.addr->na_class,
+                hg_core_handle->core_handle.info.addr->na_addr);
+            hg_core_handle->core_handle.info.addr->na_addr = NA_ADDR_NULL;
         }
-        hg_core_handle->hg_info.id = 0;
+        hg_core_handle->core_handle.info.id = 0;
     }
-    hg_core_handle->hg_info.context_id = 0;
+    hg_core_handle->core_handle.info.context_id = 0;
     hg_core_handle->request_callback = NULL;
     hg_core_handle->request_arg = NULL;
     hg_core_handle->response_callback = NULL;
@@ -1906,8 +1922,8 @@ hg_core_reset(struct hg_core_handle *hg_core_handle, hg_bool_t reset_info)
     hg_core_handle->no_response = HG_FALSE;
 
     /* Free extra data here if needed */
-    if (hg_core_handle->hg_info.hg_core_class->more_data_release)
-        hg_core_handle->hg_info.hg_core_class->more_data_release(
+    if (HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_release)
+        HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_release(
             (hg_core_handle_t) hg_core_handle);
     if (hg_core_handle->ack_buf) {
         NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->ack_buf,
@@ -1918,30 +1934,31 @@ hg_core_reset(struct hg_core_handle *hg_core_handle, hg_bool_t reset_info)
 
     hg_core_header_request_reset(&hg_core_handle->in_header);
     hg_core_header_response_reset(&hg_core_handle->out_header);
-
-done:
-    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_set_rpc(struct hg_core_handle *hg_core_handle, hg_core_addr_t addr, hg_id_t id)
+hg_core_set_rpc(struct hg_core_private_handle *hg_core_handle,
+    struct hg_core_private_addr *addr, hg_id_t id)
 {
-    struct hg_core_info *hg_info = &hg_core_handle->hg_info;
+    struct hg_core_private_addr **handle_addr =
+        (struct hg_core_private_addr **) &hg_core_handle->core_handle.info.addr;
     hg_return_t ret = HG_SUCCESS;
 
     /* We allow for NULL addr to be passed at creation time, this allows
      * for pool of handles to be created and later re-used after a call to
      * HG_Core_reset() */
-    if (addr != HG_CORE_ADDR_NULL && hg_info->addr != addr) {
-        if (hg_info->addr != HG_CORE_ADDR_NULL)
-             hg_core_addr_free(hg_info->hg_core_class, hg_info->addr);
-        hg_info->addr = addr;
-        hg_atomic_incr32(&addr->ref_count); /* Increase ref to addr */
+    if (addr && *handle_addr != addr) {
+        if (*handle_addr)
+             hg_core_addr_free(HG_CORE_HANDLE_CLASS(hg_core_handle),
+                 *handle_addr);
+        *handle_addr = addr;
+        hg_atomic_incr32(&(*addr).ref_count); /* Increase ref to addr */
 
         /* Set forward call depending on address self */
-        hg_core_handle->is_self = NA_Addr_is_self(hg_info->addr->na_class,
-            hg_info->addr->na_addr);
+        hg_core_handle->is_self = NA_Addr_is_self(
+            (*handle_addr)->core_addr.na_class,
+            (*handle_addr)->core_addr.na_addr);
 #ifdef HG_HAS_SELF_FORWARD
         hg_core_handle->forward =
             hg_core_handle->is_self ? hg_core_forward_self : hg_core_forward_na;
@@ -1951,46 +1968,36 @@ hg_core_set_rpc(struct hg_core_handle *hg_core_handle, hg_core_addr_t addr, hg_i
     }
 
     /* We also allow for NULL RPC id to be passed (same reason as above) */
-    if (id && hg_core_handle->hg_info.id != id) {
+    if (id && hg_core_handle->core_handle.info.id != id) {
         struct hg_core_rpc_info *hg_core_rpc_info;
-        hg_core_context_t *context = hg_core_handle->hg_info.context;
 
         /* Retrieve ID function from function map */
-        hg_thread_spin_lock(&context->hg_core_class->func_map_lock);
+        hg_thread_spin_lock(
+            &HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map_lock);
         hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
-            context->hg_core_class->func_map, (hg_hash_table_key_t) &id);
-        hg_thread_spin_unlock(&context->hg_core_class->func_map_lock);
+        HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map,
+            (hg_hash_table_key_t) &id);
+        hg_thread_spin_unlock(
+            &HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map_lock);
         if (!hg_core_rpc_info) {
             /* HG_LOG_ERROR("Could not find RPC ID in function map"); */
             ret = HG_NO_MATCH;
             goto done;
         }
-        hg_core_handle->hg_info.id = id;
+        hg_core_handle->core_handle.info.id = id;
 
         /* Cache RPC info */
-        hg_core_handle->hg_core_rpc_info = hg_core_rpc_info;
+        hg_core_handle->core_handle.rpc_info = hg_core_rpc_info;
     }
 
 done:
     return ret;
 }
 
-/*---------------------------------------------------------------------------*/
-void *
-hg_core_get_rpc_data(struct hg_core_handle *hg_core_handle)
-{
-    void *data = NULL;
-
-    if (hg_core_handle->hg_core_rpc_info)
-        data = hg_core_handle->hg_core_rpc_info->data;
-
-    return data;
-}
-
 /*---------------------------------------------------------------------------*/
 #ifdef HG_HAS_SELF_FORWARD
 static hg_return_t
-hg_core_forward_self(struct hg_core_handle *hg_core_handle)
+hg_core_forward_self(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
@@ -1998,15 +2005,16 @@ hg_core_forward_self(struct hg_core_handle *hg_core_handle)
     hg_core_handle->op_type = HG_CORE_FORWARD_SELF;
 
     /* Initialize thread pool if not initialized yet */
-    if (!hg_core_handle->hg_info.context->self_processing_pool) {
+    if (!HG_CORE_HANDLE_CONTEXT(hg_core_handle)->self_processing_pool) {
         hg_thread_pool_init(HG_CORE_MAX_SELF_THREADS,
-            &hg_core_handle->hg_info.context->self_processing_pool);
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->self_processing_pool);
     }
 
     /* Post operation to self processing pool */
     hg_core_handle->thread_work.func = hg_core_process_thread;
     hg_core_handle->thread_work.args = hg_core_handle;
-    hg_thread_pool_post(hg_core_handle->hg_info.context->self_processing_pool,
+    hg_thread_pool_post(
+        HG_CORE_HANDLE_CONTEXT(hg_core_handle)->self_processing_pool,
         &hg_core_handle->thread_work);
 
     return ret;
@@ -2015,9 +2023,8 @@ hg_core_forward_self(struct hg_core_handle *hg_core_handle)
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_forward_na(struct hg_core_handle *hg_core_handle)
+hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
 {
-    struct hg_core_class *hg_core_class = hg_core_handle->hg_info.hg_core_class;
     na_return_t na_ret;
     hg_return_t ret = HG_SUCCESS;
 
@@ -2025,7 +2032,8 @@ hg_core_forward_na(struct hg_core_handle *hg_core_handle)
     hg_core_handle->op_type = HG_CORE_FORWARD;
 
     /* Generate tag */
-    hg_core_handle->tag = hg_core_gen_request_tag(hg_core_class);
+    hg_core_handle->tag = hg_core_gen_request_tag(
+        HG_CORE_HANDLE_CLASS(hg_core_handle));
 
     if (!hg_core_handle->no_response) {
         /* Increment number of expected NA operations */
@@ -2034,9 +2042,11 @@ hg_core_forward_na(struct hg_core_handle *hg_core_handle)
         /* Pre-post the recv message (output) if response is expected */
         na_ret = NA_Msg_recv_expected(hg_core_handle->na_class,
             hg_core_handle->na_context, hg_core_recv_output_cb, hg_core_handle,
-            hg_core_handle->out_buf, hg_core_handle->out_buf_size,
-            hg_core_handle->out_buf_plugin_data, hg_core_handle->hg_info.addr->na_addr,
-            hg_core_handle->hg_info.context_id, hg_core_handle->tag,
+            hg_core_handle->core_handle.out_buf,
+            hg_core_handle->core_handle.out_buf_size,
+            hg_core_handle->out_buf_plugin_data,
+            hg_core_handle->core_handle.info.addr->na_addr,
+            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
             &hg_core_handle->na_recv_op_id);
         if (na_ret != NA_SUCCESS) {
             HG_LOG_ERROR("Could not post recv for output buffer");
@@ -2046,11 +2056,13 @@ hg_core_forward_na(struct hg_core_handle *hg_core_handle)
     }
 
     /* And post the send message (input) */
-    na_ret = NA_Msg_send_unexpected(hg_core_handle->na_class, hg_core_handle->na_context,
-        hg_core_send_input_cb, hg_core_handle, hg_core_handle->in_buf,
-        hg_core_handle->in_buf_used, hg_core_handle->in_buf_plugin_data,
-        hg_core_handle->hg_info.addr->na_addr, hg_core_handle->hg_info.context_id,
-        hg_core_handle->tag, &hg_core_handle->na_send_op_id);
+    na_ret = NA_Msg_send_unexpected(hg_core_handle->na_class,
+        hg_core_handle->na_context, hg_core_send_input_cb, hg_core_handle,
+        hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_used,
+        hg_core_handle->in_buf_plugin_data,
+        hg_core_handle->core_handle.info.addr->na_addr,
+        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
+        &hg_core_handle->na_send_op_id);
     if (na_ret != NA_SUCCESS) {
         HG_LOG_ERROR("Could not post send for input buffer");
         /* Cancel the above posted recv op */
@@ -2069,8 +2081,8 @@ done:
 
 /*---------------------------------------------------------------------------*/
 #ifdef HG_HAS_SELF_FORWARD
-static hg_return_t
-hg_core_respond_self(struct hg_core_handle *hg_core_handle)
+static HG_INLINE hg_return_t
+hg_core_respond_self(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
@@ -2078,7 +2090,7 @@ hg_core_respond_self(struct hg_core_handle *hg_core_handle)
     hg_core_handle->op_type = HG_CORE_RESPOND_SELF;
 
     /* Complete and add to completion queue */
-    ret = hg_core_complete(hg_core_handle);
+    ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not complete handle");
         goto done;
@@ -2089,8 +2101,8 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_core_no_respond_self(struct hg_core_handle *hg_core_handle)
+static HG_INLINE hg_return_t
+hg_core_no_respond_self(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
@@ -2098,7 +2110,7 @@ hg_core_no_respond_self(struct hg_core_handle *hg_core_handle)
     hg_core_handle->op_type = HG_CORE_FORWARD_SELF;
 
     /* Complete and add to completion queue */
-    ret = hg_core_complete(hg_core_handle);
+    ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not complete handle");
         goto done;
@@ -2111,11 +2123,14 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_respond_na(struct hg_core_handle *hg_core_handle)
+hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
+    /* Increment number of expected NA operations */
+    hg_core_handle->na_op_count++;
+
     /* Set operation type for trigger */
     hg_core_handle->op_type = HG_CORE_RESPOND;
 
@@ -2139,8 +2154,8 @@ hg_core_respond_na(struct hg_core_handle *hg_core_handle)
             hg_core_handle->na_context, hg_core_recv_ack_cb, hg_core_handle,
             hg_core_handle->ack_buf, sizeof(hg_uint8_t),
             hg_core_handle->ack_buf_plugin_data,
-            hg_core_handle->hg_info.addr->na_addr,
-            hg_core_handle->hg_info.context_id, hg_core_handle->tag,
+            hg_core_handle->core_handle.info.addr->na_addr,
+            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
             &hg_core_handle->na_ack_op_id);
         if (na_ret != NA_SUCCESS) {
             HG_LOG_ERROR("Could not post recv for ack buffer");
@@ -2152,10 +2167,10 @@ hg_core_respond_na(struct hg_core_handle *hg_core_handle)
     /* Respond back */
     na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
         hg_core_handle->na_context, hg_core_send_output_cb, hg_core_handle,
-        hg_core_handle->out_buf, hg_core_handle->out_buf_used,
+        hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_used,
         hg_core_handle->out_buf_plugin_data,
-        hg_core_handle->hg_info.addr->na_addr,
-        hg_core_handle->hg_info.context_id, hg_core_handle->tag,
+        hg_core_handle->core_handle.info.addr->na_addr,
+        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
         &hg_core_handle->na_send_op_id);
     if (na_ret != NA_SUCCESS) {
         HG_LOG_ERROR("Could not post send for output buffer");
@@ -2168,15 +2183,15 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_core_no_respond_na(struct hg_core_handle *hg_core_handle)
+static HG_INLINE hg_return_t
+hg_core_no_respond_na(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
     /* Set operation type for trigger */
     hg_core_handle->op_type = HG_CORE_NO_RESPOND;
 
-    ret = hg_core_complete(hg_core_handle);
+    ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not complete operation");
         goto done;
@@ -2187,16 +2202,13 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static int
+static HG_INLINE int
 hg_core_send_input_cb(const struct na_cb_info *callback_info)
 {
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) callback_info->arg;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
-    int ret = 0;
-
-    /* Reset op ID value */
-    if (!hg_core_handle->na_op_id_mine)
-        hg_core_handle->na_send_op_id = NA_OP_ID_NULL;
+    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
@@ -2207,29 +2219,24 @@ hg_core_send_input_cb(const struct na_cb_info *callback_info)
         goto done;
     }
 
-    /* Add handle to completion queue only when all operations have completed */
-    if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
-        == (hg_util_int32_t) hg_core_handle->na_op_count) {
-        /* Mark as completed */
-        if (hg_core_complete(hg_core_handle) != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
-        /* Increment number of entries added to completion queue */
-        ret++;
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_send_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Error in NA callback");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
     }
 
 done:
-    (void) na_ret;
-    return ret;
+    (void) na_ret; /* unused */
+    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
 static int
 hg_core_recv_input_cb(const struct na_cb_info *callback_info)
 {
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) callback_info->arg;
-    struct hg_core_context *hg_core_context = hg_core_handle->hg_info.context;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) callback_info->arg;
     const struct na_cb_info_recv_unexpected *na_cb_info_recv_unexpected =
         &callback_info->info.recv_unexpected;
 #ifndef HG_HAS_POST_LIMIT
@@ -2239,17 +2246,12 @@ hg_core_recv_input_cb(const struct na_cb_info *callback_info)
 # endif
 #endif
     na_return_t na_ret = NA_SUCCESS;
-    hg_bool_t completed = HG_FALSE;
-    int ret = 0;
-
-    /* Reset op ID value */
-    if (!hg_core_handle->na_op_id_mine)
-        hg_core_handle->na_recv_op_id = NA_OP_ID_NULL;
+    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
-        /* May only decrement refcount */
+        /* Only decrement refcount and exit */
         hg_core_destroy(hg_core_handle);
         goto done;
     } else if (callback_info->ret != NA_SUCCESS) {
@@ -2258,13 +2260,12 @@ hg_core_recv_input_cb(const struct na_cb_info *callback_info)
         goto done;
     }
 
-    /* Increment NA completed count */
-    hg_atomic_incr32(&hg_core_handle->na_op_completed_count);
-
     /* Fill unexpected info */
-    hg_core_handle->hg_info.addr->na_addr = na_cb_info_recv_unexpected->source;
+    hg_core_handle->core_handle.info.addr->na_addr =
+        na_cb_info_recv_unexpected->source;
     hg_core_handle->tag = na_cb_info_recv_unexpected->tag;
-    if (na_cb_info_recv_unexpected->actual_buf_size > hg_core_handle->in_buf_size) {
+    if (na_cb_info_recv_unexpected->actual_buf_size >
+    hg_core_handle->core_handle.in_buf_size) {
         HG_LOG_ERROR("Actual transfer size is too large for unexpected recv");
         goto done;
     }
@@ -2272,35 +2273,44 @@ hg_core_recv_input_cb(const struct na_cb_info *callback_info)
 
     /* Remove handle from pending list */
 #ifdef HG_HAS_SM_ROUTING
-    if (hg_core_handle->na_class == hg_core_handle->hg_info.hg_core_class->na_sm_class) {
-        hg_thread_spin_lock(&hg_core_context->sm_pending_list_lock);
+    if (hg_core_handle->na_class ==
+        hg_core_handle->core_handle.info.core_class->na_sm_class) {
+        hg_thread_spin_lock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
         HG_LIST_REMOVE(hg_core_handle, pending);
 # ifndef HG_HAS_POST_LIMIT
-        sm_pending_empty = HG_LIST_IS_EMPTY(&hg_core_context->sm_pending_list);
+        sm_pending_empty = HG_LIST_IS_EMPTY(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list);
 # endif
-        hg_thread_spin_unlock(&hg_core_context->sm_pending_list_lock);
+        hg_thread_spin_unlock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
     } else {
 #endif
-        hg_thread_spin_lock(&hg_core_context->pending_list_lock);
+        hg_thread_spin_lock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
         HG_LIST_REMOVE(hg_core_handle, pending);
 #ifndef HG_HAS_POST_LIMIT
-        pending_empty = HG_LIST_IS_EMPTY(&hg_core_context->pending_list);
+        pending_empty = HG_LIST_IS_EMPTY(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list);
 #endif
-        hg_thread_spin_unlock(&hg_core_context->pending_list_lock);
+        hg_thread_spin_unlock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
 #ifdef HG_HAS_SM_ROUTING
     }
 #endif
 
 #ifndef HG_HAS_POST_LIMIT
     /* If pending list is empty, post more handles */
-    if (pending_empty && hg_core_context_post(hg_core_context,
+    if (pending_empty
+        && hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
         HG_CORE_PENDING_INCR, hg_core_handle->repost, HG_FALSE) != HG_SUCCESS) {
         HG_LOG_ERROR("Could not post additional handles");
         goto done;
     }
 # ifdef HG_HAS_SM_ROUTING
     /* If pending list is empty, post more handles */
-    if (sm_pending_empty && hg_core_context_post(hg_core_context,
+    if (sm_pending_empty
+        && hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
         HG_CORE_PENDING_INCR, hg_core_handle->repost, HG_TRUE) != HG_SUCCESS) {
         HG_LOG_ERROR("Could not post additional SM handles");
         goto done;
@@ -2317,20 +2327,24 @@ hg_core_recv_input_cb(const struct na_cb_info *callback_info)
         goto done;
     }
 
-    /* Increment number of entries added to completion queue */
-    ret = (int) completed;
+    /* Complete operation */
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_recv_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
 done:
-    (void) na_ret;
-    return ret;
+    (void) na_ret; /* unused */
+    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_process_input(struct hg_core_handle *hg_core_handle,
+hg_core_process_input(struct hg_core_private_handle *hg_core_handle,
     hg_bool_t *completed)
 {
-    struct hg_core_context *hg_core_context = hg_core_handle->hg_info.context;
     hg_return_t ret = HG_SUCCESS;
 
 #ifdef HG_HAS_COLLECT_STATS
@@ -2339,7 +2353,7 @@ hg_core_process_input(struct hg_core_handle *hg_core_handle,
 #endif
 
     /* Get and verify input header */
-    ret = hg_core_proc_header_request(hg_core_handle,
+    ret = hg_core_proc_header_request(&hg_core_handle->core_handle,
         &hg_core_handle->in_header, HG_DECODE);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not get request header");
@@ -2347,18 +2361,15 @@ hg_core_process_input(struct hg_core_handle *hg_core_handle,
     }
 
     /* Get operation ID from header */
-    hg_core_handle->hg_info.id = hg_core_handle->in_header.msg.request.id;
+    hg_core_handle->core_handle.info.id =
+        hg_core_handle->in_header.msg.request.id;
     hg_core_handle->cookie = hg_core_handle->in_header.msg.request.cookie;
     /* TODO assign target ID from cookie directly for now */
-    hg_core_handle->hg_info.context_id = hg_core_handle->cookie;
+    hg_core_handle->core_handle.info.context_id = hg_core_handle->cookie;
 
     /* Parse flags */
     hg_core_handle->no_response = hg_core_handle->in_header.msg.request.flags
         & HG_CORE_NO_RESPONSE;
-    if (!hg_core_handle->no_response) {
-        /* Increment number of expected NA operations */
-        hg_core_handle->na_op_count++;
-    }
 #ifdef HG_HAS_SELF_FORWARD
     hg_core_handle->respond = hg_core_handle->in_header.msg.request.flags
         & HG_CORE_SELF_FORWARD ? hg_core_respond_self : hg_core_respond_na;
@@ -2371,7 +2382,7 @@ hg_core_process_input(struct hg_core_handle *hg_core_handle,
 
     /* Must let upper layer get extra payload if HG_CORE_MORE_DATA is set */
     if (hg_core_handle->in_header.msg.request.flags & HG_CORE_MORE_DATA) {
-        if (!hg_core_context->hg_core_class->more_data_acquire) {
+        if (!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire) {
             HG_LOG_ERROR("No callback defined for acquiring more data");
             ret = HG_PROTOCOL_ERROR;
             goto done;
@@ -2380,37 +2391,28 @@ hg_core_process_input(struct hg_core_handle *hg_core_handle,
         /* Increment counter */
         hg_core_stat_incr(&hg_core_rpc_extra_count_g);
 #endif
-        ret = hg_core_context->hg_core_class->more_data_acquire(
+        ret = HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire(
             (hg_core_handle_t) hg_core_handle, HG_INPUT, hg_core_complete);
         if (ret != HG_SUCCESS) {
             HG_LOG_ERROR("Error in HG core handle more data acquire callback");
             goto done;
         }
         *completed = HG_FALSE;
-    } else {
-        ret = hg_core_complete(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
+    } else
         *completed = HG_TRUE;
-    }
 
 done:
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
-static int
+static HG_INLINE int
 hg_core_send_output_cb(const struct na_cb_info *callback_info)
 {
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) callback_info->arg;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
-    int ret = 0;
-
-    /* Reset op ID value */
-    if (!hg_core_handle->na_op_id_mine)
-        hg_core_handle->na_send_op_id = NA_OP_ID_NULL;
+    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
@@ -2421,37 +2423,27 @@ hg_core_send_output_cb(const struct na_cb_info *callback_info)
         goto done;
     }
 
-    /* TODO common code with hg_core_no_respond_na */
-
-    /* Mark as completed (sanity check for NA op completed count) */
-    if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
-        == (hg_util_int32_t) hg_core_handle->na_op_count) {
-        if (hg_core_complete(hg_core_handle) != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
-        /* Increment number of entries added to completion queue */
-        ret++;
+    /* Complete operation */
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_send_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
     }
 
 done:
-    (void) na_ret;
-    return ret;
+    (void) na_ret; /* unused */
+    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
-static int
+static HG_INLINE int
 hg_core_recv_output_cb(const struct na_cb_info *callback_info)
 {
-    struct hg_core_handle *hg_core_handle =
-        (struct hg_core_handle *) callback_info->arg;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
-    hg_bool_t completed = HG_FALSE;
-    int ret = 0;
-
-    /* Reset op ID value */
-    if (!hg_core_handle->na_op_id_mine)
-        hg_core_handle->na_recv_op_id = NA_OP_ID_NULL;
+    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
@@ -2463,30 +2455,37 @@ hg_core_recv_output_cb(const struct na_cb_info *callback_info)
     }
 
     /* Process output information */
-    if (hg_core_process_output(hg_core_handle, &completed) != HG_SUCCESS) {
+    if (hg_core_handle->ret != HG_CANCELED
+        && hg_core_process_output(hg_core_handle, &completed, hg_core_send_ack)
+            != HG_SUCCESS) {
         HG_LOG_ERROR("Could not process output");
         goto done;
     }
 
-    /* Increment number of entries added to completion queue */
-    ret = (int) completed;
+    /* Complete operation */
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_recv_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
 done:
-    (void) na_ret;
-    return ret;
+    (void) na_ret; /* unused */
+    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_process_output(struct hg_core_handle *hg_core_handle,
-    hg_bool_t *completed)
+hg_core_process_output(struct hg_core_private_handle *hg_core_handle,
+    hg_bool_t *completed,
+    hg_return_t (*done_callback)(hg_core_handle_t))
 {
-    struct hg_core_context *hg_core_context = hg_core_handle->hg_info.context;
     hg_return_t ret = HG_SUCCESS;
 
     /* Get and verify output header */
-    if (hg_core_proc_header_response(hg_core_handle, &hg_core_handle->out_header,
-        HG_DECODE) != HG_SUCCESS) {
+    if (hg_core_proc_header_response(&hg_core_handle->core_handle,
+        &hg_core_handle->out_header, HG_DECODE) != HG_SUCCESS) {
         HG_LOG_ERROR("Could not decode header");
         goto done;
     }
@@ -2499,30 +2498,20 @@ hg_core_process_output(struct hg_core_handle *hg_core_handle,
 
     /* Must let upper layer get extra payload if HG_CORE_MORE_DATA is set */
     if (hg_core_handle->out_header.msg.response.flags & HG_CORE_MORE_DATA) {
-        if (!hg_core_context->hg_core_class->more_data_acquire) {
+        if (!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire) {
             HG_LOG_ERROR("No callback defined for acquiring more data");
             ret = HG_PROTOCOL_ERROR;
             goto done;
         }
-        ret = hg_core_context->hg_core_class->more_data_acquire(
-            (hg_core_handle_t) hg_core_handle, HG_OUTPUT, hg_core_send_ack);
+        ret = HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire(
+            (hg_core_handle_t) hg_core_handle, HG_OUTPUT, done_callback);
         if (ret != HG_SUCCESS) {
             HG_LOG_ERROR("Error in HG core handle more data acquire callback");
             goto done;
         }
         *completed = HG_FALSE;
-        goto done;
-    } else if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
-        == (hg_util_int32_t) hg_core_handle->na_op_count) {
-        /* Add handle to completion queue when all operations have completed */
-        ret = hg_core_complete(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
-        *completed = HG_TRUE;
     } else
-        *completed = HG_FALSE;
+        *completed = HG_TRUE;
 
 done:
     return ret;
@@ -2530,11 +2519,16 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_send_ack(struct hg_core_handle *hg_core_handle)
+hg_core_send_ack(hg_core_handle_t handle)
 {
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
+    /* Increment number of expected NA operations */
+    hg_core_handle->na_op_count++;
+
     /* Allocate buffer for ack */
     hg_core_handle->ack_buf = NA_Msg_buf_alloc(hg_core_handle->na_class,
         sizeof(hg_uint8_t), &hg_core_handle->ack_buf_plugin_data);
@@ -2551,8 +2545,8 @@ hg_core_send_ack(struct hg_core_handle *hg_core_handle)
         hg_core_handle->na_context, hg_core_send_ack_cb, hg_core_handle,
         hg_core_handle->ack_buf, sizeof(hg_uint8_t),
         hg_core_handle->ack_buf_plugin_data,
-        hg_core_handle->hg_info.addr->na_addr,
-        hg_core_handle->hg_info.context_id, hg_core_handle->tag,
+        hg_core_handle->core_handle.info.addr->na_addr,
+        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
         &hg_core_handle->na_ack_op_id);
     if (na_ret != NA_SUCCESS) {
         HG_LOG_ERROR("Could not post send for ack buffer");
@@ -2565,17 +2559,13 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static int
+static HG_INLINE int
 hg_core_send_ack_cb(const struct na_cb_info *callback_info)
 {
-    struct hg_core_handle *hg_core_handle =
-        (struct hg_core_handle *) callback_info->arg;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
-    hg_bool_t completed = HG_FALSE;
-    int ret = 0;
-
-    /* Reset op ID value */
-    hg_core_handle->na_ack_op_id = NA_OP_ID_NULL;
+    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
@@ -2586,35 +2576,27 @@ hg_core_send_ack_cb(const struct na_cb_info *callback_info)
         goto done;
     }
 
-    /* Add handle to completion queue when all operations have completed */
-    if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
-        == (hg_util_int32_t) hg_core_handle->na_op_count) {
-        if (hg_core_complete(hg_core_handle) != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
-        completed = HG_TRUE;
+    /* Complete operation */
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_ack_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
     }
 
-    /* Increment number of entries added to completion queue */
-    ret = (int) completed;
-
 done:
-    (void) na_ret;
-    return ret;
+    (void) na_ret; /* unused */
+    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
-static int
+static HG_INLINE int
 hg_core_recv_ack_cb(const struct na_cb_info *callback_info)
 {
-    struct hg_core_handle *hg_core_handle =
-        (struct hg_core_handle *) callback_info->arg;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) callback_info->arg;
     na_return_t na_ret = NA_SUCCESS;
-    int ret = 0;
-
-    /* Reset op ID value */
-    hg_core_handle->na_ack_op_id = NA_OP_ID_NULL;
+    hg_bool_t completed = HG_TRUE;
 
     if (callback_info->ret == NA_CANCELED) {
         /* If canceled, mark handle as canceled */
@@ -2625,22 +2607,17 @@ hg_core_recv_ack_cb(const struct na_cb_info *callback_info)
         goto done;
     }
 
-    /* TODO common code with hg_core_no_respond_na */
-
-    /* Mark as completed (sanity check for NA op completed count) */
-    if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
-        == (hg_util_int32_t) hg_core_handle->na_op_count) {
-        if (hg_core_complete(hg_core_handle) != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
-        /* Increment number of entries added to completion queue */
-        ret++;
+    /* Complete operation */
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_ack_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
     }
 
 done:
-    (void) na_ret;
-    return ret;
+    (void) na_ret; /* unused */
+    return (int) completed;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2648,9 +2625,10 @@ done:
 static hg_return_t
 hg_core_self_cb(const struct hg_core_cb_info *callback_info)
 {
-    struct hg_core_handle *hg_core_handle =
-        (struct hg_core_handle *) callback_info->info.respond.handle;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) callback_info->info.respond.handle;
     hg_return_t ret;
+    hg_bool_t completed = HG_TRUE;
 
     /* First execute response callback */
     if (hg_core_handle->response_callback) {
@@ -2664,18 +2642,23 @@ hg_core_self_cb(const struct hg_core_cb_info *callback_info)
         hg_core_handle->response_callback(&hg_core_cb_info);
     }
 
-    /* TODO response check header */
-
     /* Assign forward callback back to handle */
     hg_core_handle->op_type = HG_CORE_FORWARD_SELF;
 
     /* Increment refcount and push handle back to completion queue */
     hg_atomic_incr32(&hg_core_handle->ref_count);
 
-    ret = hg_core_complete(hg_core_handle);
+    /* Process output */
+    ret = hg_core_process_output(hg_core_handle, &completed, hg_core_complete);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete handle");
-        goto done;
+       HG_LOG_ERROR("Could not process output");
+       goto done;
+   }
+
+    /* Mark as completed */
+    if (completed
+        && hg_core_complete((hg_core_handle_t) hg_core_handle) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
     }
 
 done:
@@ -2687,7 +2670,8 @@ static HG_INLINE HG_THREAD_RETURN_TYPE
 hg_core_process_thread(void *arg)
 {
     hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) arg;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) arg;
     hg_bool_t completed = HG_FALSE;
 
     /* Set operation type for trigger */
@@ -2697,7 +2681,12 @@ hg_core_process_thread(void *arg)
    if (hg_core_process_input(hg_core_handle, &completed) != HG_SUCCESS) {
        HG_LOG_ERROR("Could not process input");
    }
-   (void) completed;
+
+   /* Mark as completed */
+    if (completed
+        && hg_core_complete((hg_core_handle_t) hg_core_handle) != HG_SUCCESS) {
+       HG_LOG_ERROR("Could not complete operation");
+   }
 
    return thread_ret;
 }
@@ -2705,17 +2694,17 @@ hg_core_process_thread(void *arg)
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_process(struct hg_core_handle *hg_core_handle)
+hg_core_process(struct hg_core_private_handle *hg_core_handle)
 {
-    struct hg_core_class *hg_core_class = hg_core_handle->hg_info.hg_core_class;
     struct hg_core_rpc_info *hg_core_rpc_info;
     hg_return_t ret = HG_SUCCESS;
 
     /* Retrieve exe function from function map */
-    hg_thread_spin_lock(&hg_core_class->func_map_lock);
+    hg_thread_spin_lock(&HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map_lock);
     hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
-        hg_core_class->func_map, (hg_hash_table_key_t) &hg_core_handle->hg_info.id);
-    hg_thread_spin_unlock(&hg_core_class->func_map_lock);
+        HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map,
+        (hg_hash_table_key_t) &hg_core_handle->core_handle.info.id);
+    hg_thread_spin_unlock(&HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map_lock);
     if (!hg_core_rpc_info) {
         HG_LOG_WARNING("Could not find RPC ID in function map");
         ret = HG_NO_MATCH;
@@ -2729,7 +2718,7 @@ hg_core_process(struct hg_core_handle *hg_core_handle)
     }
 
     /* Cache RPC info */
-    hg_core_handle->hg_core_rpc_info = hg_core_rpc_info;
+    hg_core_handle->core_handle.rpc_info = hg_core_rpc_info;
 
     /* Increment ref count here so that a call to HG_Destroy in user's RPC
      * callback does not free the handle but only schedules its completion */
@@ -2748,15 +2737,45 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static HG_INLINE hg_return_t
-hg_core_complete(struct hg_core_handle *hg_core_handle)
+hg_core_complete_na(struct hg_core_private_handle *hg_core_handle,
+    na_op_id_t *op_id, hg_bool_t *completed)
+{
+    hg_return_t ret = HG_SUCCESS;
+
+    /* Reset op ID value */
+    if (!hg_core_handle->na_op_id_mine)
+        *op_id = NA_OP_ID_NULL;
+
+    /* Add handle to completion queue when expected operations have completed */
+    if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
+        == (hg_util_int32_t) hg_core_handle->na_op_count && *completed) {
+        /* Mark as completed */
+        if (hg_core_complete((hg_core_handle_t) hg_core_handle) != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not complete operation");
+            goto done;
+        }
+        /* Increment number of entries added to completion queue */
+        *completed = HG_TRUE;
+    } else
+        *completed = HG_FALSE;
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+hg_core_complete(hg_core_handle_t handle)
 {
-    struct hg_core_context *context = hg_core_handle->hg_info.context;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) handle;
+    struct hg_core_context *context = hg_core_handle->core_handle.info.context;
     struct hg_completion_entry *hg_completion_entry =
         &hg_core_handle->hg_completion_entry;
     hg_return_t ret = HG_SUCCESS;
 
     hg_completion_entry->op_type = HG_RPC;
-    hg_completion_entry->op_id.hg_core_handle = hg_core_handle;
+    hg_completion_entry->op_id.hg_core_handle = handle;
 
     ret = hg_core_completion_add(context, hg_completion_entry,
         hg_core_handle->is_self);
@@ -2774,6 +2793,8 @@ hg_return_t
 hg_core_completion_add(struct hg_core_context *context,
     struct hg_completion_entry *hg_completion_entry, hg_bool_t self_notify)
 {
+    struct hg_core_private_context *private_context =
+        (struct hg_core_private_context *) context;
     hg_return_t ret = HG_SUCCESS;
 
 #ifdef HG_HAS_COLLECT_STATS
@@ -2782,28 +2803,28 @@ hg_core_completion_add(struct hg_core_context *context,
         hg_core_stat_incr(&hg_core_bulk_count_g);
 #endif
 
-    if (hg_atomic_queue_push(context->completion_queue, hg_completion_entry)
+    if (hg_atomic_queue_push(private_context->completion_queue, hg_completion_entry)
         != HG_UTIL_SUCCESS) {
         /* Queue is full */
-        hg_thread_mutex_lock(&context->completion_queue_mutex);
-        HG_QUEUE_PUSH_TAIL(&context->backfill_queue, hg_completion_entry,
+        hg_thread_mutex_lock(&private_context->completion_queue_mutex);
+        HG_QUEUE_PUSH_TAIL(&private_context->backfill_queue, hg_completion_entry,
             entry);
-        hg_atomic_incr32(&context->backfill_queue_count);
-        hg_thread_mutex_unlock(&context->completion_queue_mutex);
+        hg_atomic_incr32(&private_context->backfill_queue_count);
+        hg_thread_mutex_unlock(&private_context->completion_queue_mutex);
     }
 
-    if (hg_atomic_get32(&context->trigger_waiting)) {
-        hg_thread_mutex_lock(&context->completion_queue_mutex);
+    if (hg_atomic_get32(&private_context->trigger_waiting)) {
+        hg_thread_mutex_lock(&private_context->completion_queue_mutex);
         /* Callback is pushed to the completion queue when something completes
          * so wake up anyone waiting in the trigger */
-        hg_thread_cond_signal(&context->completion_queue_cond);
-        hg_thread_mutex_unlock(&context->completion_queue_mutex);
+        hg_thread_cond_signal(&private_context->completion_queue_cond);
+        hg_thread_mutex_unlock(&private_context->completion_queue_mutex);
     }
 
 #ifdef HG_HAS_SELF_FORWARD
     /* TODO could prevent from self notifying if hg_poll_wait() not entered */
-    if (self_notify && context->completion_queue_notify
-        && hg_event_set(context->completion_queue_notify) != HG_UTIL_SUCCESS) {
+    if (self_notify && private_context->completion_queue_notify
+        && hg_event_set(private_context->completion_queue_notify) != HG_UTIL_SUCCESS) {
         HG_LOG_ERROR("Could not signal completion queue");
         ret = HG_PROTOCOL_ERROR;
     }
@@ -2816,16 +2837,16 @@ hg_core_completion_add(struct hg_core_context *context,
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_context_post(struct hg_core_context *context, unsigned int request_count,
-    hg_bool_t repost, hg_bool_t use_sm)
+hg_core_context_post(struct hg_core_private_context *context,
+    unsigned int request_count, hg_bool_t repost, hg_bool_t use_sm)
 {
     unsigned int nentry = 0;
     hg_return_t ret = HG_SUCCESS;
 
     /* Create a bunch of handles and post unexpected receives */
     for (nentry = 0; nentry < request_count; nentry++) {
-        struct hg_core_handle *hg_core_handle = NULL;
-        struct hg_core_addr *hg_core_addr = NULL;
+        struct hg_core_private_handle *hg_core_handle = NULL;
+        struct hg_core_private_addr *hg_core_addr = NULL;
 
         /* Create a new handle */
         hg_core_handle = hg_core_create(context, use_sm);
@@ -2838,7 +2859,7 @@ hg_core_context_post(struct hg_core_context *context, unsigned int request_count
         /* Execute class callback on handle, this allows upper layers to
          * allocate private data on handle creation */
         if (context->handle_create) {
-            ret = context->handle_create(hg_core_handle,
+            ret = context->handle_create((hg_core_handle_t) hg_core_handle,
                 context->handle_create_arg);
             if (ret != HG_SUCCESS) {
                 HG_LOG_ERROR("Error in HG core handle create callback");
@@ -2847,7 +2868,7 @@ hg_core_context_post(struct hg_core_context *context, unsigned int request_count
         }
 
         /* Create internal addresses */
-        hg_core_addr = hg_core_addr_create(context->hg_core_class,
+        hg_core_addr = hg_core_addr_create(HG_CORE_CONTEXT_CLASS(context),
             hg_core_handle->na_class);
         if (!hg_core_addr) {
             HG_LOG_ERROR("Could not create HG addr");
@@ -2856,7 +2877,7 @@ hg_core_context_post(struct hg_core_context *context, unsigned int request_count
         }
         /* To safely repost handle and prevent externally referenced address */
         hg_core_addr->is_mine = HG_TRUE;
-        hg_core_handle->hg_info.addr = hg_core_addr;
+        hg_core_handle->core_handle.info.addr = (hg_core_addr_t) hg_core_addr;
 
         /* Repost handle on completion if told so */
         hg_core_handle->repost = repost;
@@ -2874,9 +2895,8 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_post(struct hg_core_handle *hg_core_handle)
+hg_core_post(struct hg_core_private_handle *hg_core_handle)
 {
-    struct hg_core_context *context = hg_core_handle->hg_info.context;
     na_return_t na_ret;
     hg_return_t ret = HG_SUCCESS;
 
@@ -2884,24 +2904,34 @@ hg_core_post(struct hg_core_handle *hg_core_handle)
     hg_atomic_set32(&hg_core_handle->in_use, HG_TRUE);
 
 #ifdef HG_HAS_SM_ROUTING
-    if (hg_core_handle->na_class == hg_core_handle->hg_info.hg_core_class->na_sm_class) {
-        hg_thread_spin_lock(&context->sm_pending_list_lock);
-        HG_LIST_INSERT_HEAD(&context->sm_pending_list, hg_core_handle, pending);
-        hg_thread_spin_unlock(&context->sm_pending_list_lock);
+    if (hg_core_handle->na_class ==
+        hg_core_handle->core_handle.info.core_class->na_sm_class) {
+        hg_thread_spin_lock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
+        HG_LIST_INSERT_HEAD(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list,
+            hg_core_handle, pending);
+        hg_thread_spin_unlock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
     } else {
 #endif
-        hg_thread_spin_lock(&context->pending_list_lock);
-        HG_LIST_INSERT_HEAD(&context->pending_list, hg_core_handle, pending);
-        hg_thread_spin_unlock(&context->pending_list_lock);
+        hg_thread_spin_lock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+        HG_LIST_INSERT_HEAD(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list,
+            hg_core_handle, pending);
+        hg_thread_spin_unlock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
 #ifdef HG_HAS_SM_ROUTING
     }
 #endif
 
     /* Post a new unexpected receive */
-    na_ret = NA_Msg_recv_unexpected(hg_core_handle->na_class, hg_core_handle->na_context,
-        hg_core_recv_input_cb, hg_core_handle, hg_core_handle->in_buf,
-        hg_core_handle->in_buf_size, hg_core_handle->in_buf_plugin_data,
-        &hg_core_handle->na_recv_op_id);
+    na_ret = NA_Msg_recv_unexpected(hg_core_handle->na_class,
+        hg_core_handle->na_context, hg_core_recv_input_cb, hg_core_handle,
+        hg_core_handle->core_handle.in_buf,
+        hg_core_handle->core_handle.in_buf_size,
+        hg_core_handle->in_buf_plugin_data, &hg_core_handle->na_recv_op_id);
     if (na_ret != NA_SUCCESS) {
         HG_LOG_ERROR("Could not post unexpected recv for input buffer");
         ret = HG_NA_ERROR;
@@ -2914,7 +2944,7 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_reset_post(struct hg_core_handle *hg_core_handle)
+hg_core_reset_post(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
@@ -2922,14 +2952,11 @@ hg_core_reset_post(struct hg_core_handle *hg_core_handle)
         goto done;
 
     /* Reset the handle */
-    ret = hg_core_reset(hg_core_handle, HG_TRUE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Cannot reset handle");
-        goto done;
-    }
+    hg_core_reset(hg_core_handle, HG_TRUE);
+
     /* Also reset additional handle parameters */
     hg_atomic_set32(&hg_core_handle->ref_count, 1);
-    hg_core_handle->hg_core_rpc_info = NULL;
+    hg_core_handle->core_handle.rpc_info = NULL;
 
     /* Safe to repost */
     ret = hg_core_post(hg_core_handle);
@@ -2944,11 +2971,12 @@ done:
 
 /*---------------------------------------------------------------------------*/
 #ifdef HG_HAS_SELF_FORWARD
-static int
+static HG_INLINE int
 hg_core_completion_queue_notify_cb(void *arg, unsigned int timeout,
     int HG_UNUSED error, hg_util_bool_t *progressed)
 {
-    struct hg_core_context *context = (struct hg_core_context *) arg;
+    struct hg_core_private_context *context =
+        (struct hg_core_private_context *) arg;
     hg_util_bool_t notified = HG_UTIL_FALSE;
     int ret = HG_UTIL_SUCCESS;
 
@@ -2976,16 +3004,17 @@ static int
 hg_core_progress_na_cb(void *arg, unsigned int timeout, int HG_UNUSED error,
     hg_util_bool_t *progressed)
 {
-    struct hg_core_context *context = (struct hg_core_context *) arg;
-    struct hg_core_class *hg_core_class = context->hg_core_class;
-    unsigned int actual_count = 0;
+    struct hg_core_private_context *context =
+        (struct hg_core_private_context *) arg;
+     unsigned int actual_count = 0;
     na_return_t na_ret;
     unsigned int completed_count = 0;
-    int cb_ret[1] = {0};
+    int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
     int ret = HG_UTIL_SUCCESS;
 
     /* Check progress on NA (no need to call try_wait here) */
-    na_ret = NA_Progress(hg_core_class->na_class, context->na_context, timeout);
+    na_ret = NA_Progress(HG_CORE_CONTEXT_CLASS(context)->core_class.na_class,
+        context->core_context.na_context, timeout);
     if (na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT) {
         HG_LOG_ERROR("Could not make progress on NA");
         ret = HG_UTIL_FAIL;
@@ -3000,10 +3029,14 @@ hg_core_progress_na_cb(void *arg, unsigned int timeout, int HG_UNUSED error,
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
     do {
-        na_ret = NA_Trigger(context->na_context, 0, 1, cb_ret, &actual_count);
+        unsigned int i;
+
+        na_ret = NA_Trigger(context->core_context.na_context, 0,
+            HG_CORE_MAX_TRIGGER_COUNT, cb_ret, &actual_count);
 
         /* Return value of callback is completion count */
-        completed_count += (unsigned int) cb_ret[0];
+        for (i = 0; i < actual_count; i++)
+            completed_count += (unsigned int) cb_ret[i];
     } while ((na_ret == NA_SUCCESS) && actual_count);
 
     /* We can't only verify that the completion queue is not empty, we need
@@ -3028,16 +3061,17 @@ static int
 hg_core_progress_na_sm_cb(void *arg, unsigned int timeout, int HG_UNUSED error,
     hg_util_bool_t *progressed)
 {
-    struct hg_core_context *context = (struct hg_core_context *) arg;
-    struct hg_core_class *hg_core_class = context->hg_core_class;
+    struct hg_core_private_context *context =
+        (struct hg_core_private_context *) arg;
     unsigned int actual_count = 0;
     na_return_t na_ret;
     unsigned int completed_count = 0;
-    int cb_ret[1] = {0};
+    int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
     int ret = HG_UTIL_SUCCESS;
 
     /* Check progress on NA SM (no need to call try_wait here) */
-    na_ret = NA_Progress(hg_core_class->na_sm_class, context->na_sm_context, timeout);
+    na_ret = NA_Progress(HG_CORE_CONTEXT_CLASS(context)->core_class.na_sm_class,
+        context->core_context.na_sm_context, timeout);
     if (na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT) {
         HG_LOG_ERROR("Could not make progress on NA SM");
         ret = HG_UTIL_FAIL;
@@ -3052,10 +3086,14 @@ hg_core_progress_na_sm_cb(void *arg, unsigned int timeout, int HG_UNUSED error,
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
     do {
-        na_ret = NA_Trigger(context->na_sm_context, 0, 1, cb_ret, &actual_count);
+        unsigned int i;
+
+        na_ret = NA_Trigger(context->core_context.na_sm_context, 0,
+            HG_CORE_MAX_TRIGGER_COUNT, cb_ret, &actual_count);
 
         /* Return value of callback is completion count */
-        completed_count += (unsigned int) cb_ret[0];
+        for (i = 0; i < actual_count; i++)
+            completed_count += (unsigned int)cb_ret[i];
     } while ((na_ret == NA_SUCCESS) && actual_count);
 
     /* We can't only verify that the completion queue is not empty, we need
@@ -3077,13 +3115,14 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_progress_na(struct hg_core_context *context, unsigned int timeout)
+hg_core_progress_na(struct hg_core_private_context *context,
+    unsigned int timeout)
 {
     double remaining;
     hg_return_t ret = HG_TIMEOUT;
 
     /* Do not block if NA_NO_BLOCK option is passed */
-    if (context->hg_core_class->progress_mode == NA_NO_BLOCK) {
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
     } else {
@@ -3091,9 +3130,8 @@ hg_core_progress_na(struct hg_core_context *context, unsigned int timeout)
     }
 
     for (;;) {
-        struct hg_core_class *hg_core_class = context->hg_core_class;
         unsigned int actual_count = 0;
-        int cb_ret[1] = {0};
+        int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
         unsigned int completed_count = 0;
         unsigned int progress_timeout;
         na_return_t na_ret;
@@ -3102,11 +3140,14 @@ hg_core_progress_na(struct hg_core_context *context, unsigned int timeout)
         /* Trigger everything we can from NA, if something completed it will
          * be moved to the HG context completion queue */
         do {
-            na_ret = NA_Trigger(context->na_context, 0, 1, cb_ret,
-                &actual_count);
+            unsigned int i;
+
+            na_ret = NA_Trigger(context->core_context.na_context, 0,
+                HG_CORE_MAX_TRIGGER_COUNT, cb_ret, &actual_count);
 
             /* Return value of callback is completion count */
-            completed_count += (unsigned int)cb_ret[0];
+            for (i = 0; i < actual_count; i++)
+                completed_count += (unsigned int)cb_ret[i];
         } while ((na_ret == NA_SUCCESS) && actual_count);
 
         /* We can't only verify that the completion queue is not empty, we need
@@ -3126,15 +3167,17 @@ hg_core_progress_na(struct hg_core_context *context, unsigned int timeout)
             hg_time_get_current(&t1);
 
         /* Make sure that it is safe to block */
-        if (timeout &&
-            NA_Poll_try_wait(hg_core_class->na_class, context->na_context))
+        if (timeout && NA_Poll_try_wait(
+            HG_CORE_CONTEXT_CLASS(context)->core_class.na_class,
+            context->core_context.na_context))
             progress_timeout = (unsigned int) (remaining * 1000.0);
         else
             progress_timeout = 0;
 
         /* Otherwise try to make progress on NA */
-        na_ret = NA_Progress(hg_core_class->na_class, context->na_context,
-            progress_timeout);
+        na_ret = NA_Progress(
+            HG_CORE_CONTEXT_CLASS(context)->core_class.na_class,
+            context->core_context.na_context, progress_timeout);
 
         if (timeout) {
             hg_time_get_current(&t2);
@@ -3161,40 +3204,43 @@ done:
 static HG_INLINE hg_util_bool_t
 hg_core_poll_try_wait_cb(void *arg)
 {
-    struct hg_core_context *hg_core_context = (struct hg_core_context *) arg;
+    struct hg_core_private_context *context =
+        (struct hg_core_private_context *) arg;
 
     /* Do not try to wait if NA_NO_BLOCK is set */
-    if (hg_core_context->hg_core_class->progress_mode == NA_NO_BLOCK)
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
         return NA_FALSE;
 
     /* Something is in one of the completion queues */
-    if (!hg_atomic_queue_is_empty(hg_core_context->completion_queue) ||
-        hg_atomic_get32(&hg_core_context->backfill_queue_count)) {
+    if (!hg_atomic_queue_is_empty(context->completion_queue) ||
+        hg_atomic_get32(&context->backfill_queue_count)) {
         return NA_FALSE;
     }
 
 #ifdef HG_HAS_SM_ROUTING
-    if (hg_core_context->hg_core_class->na_sm_class) {
-        na_bool_t ret = NA_Poll_try_wait(hg_core_context->hg_core_class->na_sm_class,
-            hg_core_context->na_sm_context);
+    if (context->core_context.core_class->na_sm_class) {
+        na_bool_t ret = NA_Poll_try_wait(
+            context->core_context.core_class->na_sm_class,
+            context->core_context.na_sm_context);
         if (ret)
             return ret;
     }
 #endif
 
-    return NA_Poll_try_wait(hg_core_context->hg_core_class->na_class,
-        hg_core_context->na_context);
+    return NA_Poll_try_wait(context->core_context.core_class->na_class,
+        context->core_context.na_context);
 }
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_progress_poll(struct hg_core_context *context, unsigned int timeout)
+hg_core_progress_poll(struct hg_core_private_context *context,
+    unsigned int timeout)
 {
     double remaining;
     hg_return_t ret = HG_TIMEOUT;
 
     /* Do not block if NA_NO_BLOCK option is passed */
-    if (context->hg_core_class->progress_mode == NA_NO_BLOCK) {
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
     } else {
@@ -3234,7 +3280,7 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_trigger(struct hg_core_context *context, unsigned int timeout,
+hg_core_trigger(struct hg_core_private_context *context, unsigned int timeout,
     unsigned int max_count, unsigned int *actual_count)
 {
     double remaining;
@@ -3242,7 +3288,7 @@ hg_core_trigger(struct hg_core_context *context, unsigned int timeout,
     hg_return_t ret = HG_SUCCESS;
 
     /* Do not block if NA_NO_BLOCK option is passed */
-    if (context->hg_core_class->progress_mode == NA_NO_BLOCK) {
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
     } else {
@@ -3313,21 +3359,24 @@ hg_core_trigger(struct hg_core_context *context, unsigned int timeout,
         /* Trigger entry */
         switch(hg_completion_entry->op_type) {
             case HG_ADDR:
-                ret = hg_core_trigger_lookup_entry(hg_completion_entry->op_id.hg_core_op_id);
+                ret = hg_core_trigger_lookup_entry(
+                    hg_completion_entry->op_id.hg_core_op_id);
                 if (ret != HG_SUCCESS) {
                     HG_LOG_ERROR("Could not trigger completion entry");
                     goto done;
                 }
                 break;
             case HG_RPC:
-                ret = hg_core_trigger_entry(hg_completion_entry->op_id.hg_core_handle);
+                ret = hg_core_trigger_entry((struct hg_core_private_handle *)
+                    hg_completion_entry->op_id.hg_core_handle);
                 if (ret != HG_SUCCESS) {
                     HG_LOG_ERROR("Could not trigger completion entry");
                     goto done;
                 }
                 break;
             case HG_BULK:
-                ret = hg_bulk_trigger_entry(hg_completion_entry->op_id.hg_bulk_op_id);
+                ret = hg_bulk_trigger_entry(
+                    hg_completion_entry->op_id.hg_bulk_op_id);
                 if (ret != HG_SUCCESS) {
                     HG_LOG_ERROR("Could not trigger completion entry");
                     goto done;
@@ -3361,7 +3410,8 @@ hg_core_trigger_lookup_entry(struct hg_core_op_id *hg_core_op_id)
         hg_core_cb_info.arg = hg_core_op_id->arg;
         hg_core_cb_info.ret =  HG_SUCCESS; /* TODO report failure */
         hg_core_cb_info.type = HG_CB_LOOKUP;
-        hg_core_cb_info.info.lookup.addr = hg_core_op_id->info.lookup.hg_core_addr;
+        hg_core_cb_info.info.lookup.addr =
+            (hg_core_addr_t) hg_core_op_id->info.lookup.hg_core_addr;
 
         hg_core_op_id->callback(&hg_core_cb_info);
     }
@@ -3373,20 +3423,24 @@ hg_core_trigger_lookup_entry(struct hg_core_op_id *hg_core_op_id)
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_trigger_entry(struct hg_core_handle *hg_core_handle)
+hg_core_trigger_entry(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
     if (hg_core_handle->op_type == HG_CORE_PROCESS) {
+        /* Take another reference to make sure the handle does not get freed */
+        hg_atomic_incr32(&hg_core_handle->ref_count);
+
         /* Run RPC callback */
         ret = hg_core_process(hg_core_handle);
         if (ret != HG_SUCCESS && !hg_core_handle->no_response) {
             hg_size_t header_size = hg_core_header_response_get_size() +
-                hg_core_handle->na_out_header_offset;
+                hg_core_handle->core_handle.na_out_header_offset;
 
             /* Respond in case of error */
             hg_core_handle->ret = ret;
-            ret = HG_Core_respond(hg_core_handle, NULL, NULL, 0, header_size);
+            ret = HG_Core_respond((hg_core_handle_t) hg_core_handle, NULL, NULL,
+                0, header_size);
             if (ret != HG_SUCCESS) {
                 HG_LOG_ERROR("Could not respond");
                 goto done;
@@ -3412,25 +3466,29 @@ hg_core_trigger_entry(struct hg_core_handle *hg_core_handle)
         switch (hg_core_handle->op_type) {
 #ifdef HG_HAS_SELF_FORWARD
             case HG_CORE_FORWARD_SELF:
+                HG_FALLTHROUGH();
 #endif
             case HG_CORE_FORWARD:
                 hg_cb = hg_core_handle->request_callback;
                 hg_core_cb_info.arg = hg_core_handle->request_arg;
                 hg_core_cb_info.type = HG_CB_FORWARD;
-                hg_core_cb_info.info.forward.handle = (hg_core_handle_t) hg_core_handle;
+                hg_core_cb_info.info.forward.handle =
+                    (hg_core_handle_t) hg_core_handle;
                 break;
             case HG_CORE_RESPOND:
                 hg_cb = hg_core_handle->response_callback;
                 hg_core_cb_info.arg = hg_core_handle->response_arg;
                 hg_core_cb_info.type = HG_CB_RESPOND;
-                hg_core_cb_info.info.respond.handle = (hg_core_handle_t) hg_core_handle;
+                hg_core_cb_info.info.respond.handle =
+                    (hg_core_handle_t) hg_core_handle;
                 break;
 #ifdef HG_HAS_SELF_FORWARD
             case HG_CORE_RESPOND_SELF:
                 hg_cb = hg_core_self_cb;
                 hg_core_cb_info.arg = hg_core_handle->response_arg;
                 hg_core_cb_info.type = HG_CB_RESPOND;
-                hg_core_cb_info.info.respond.handle = (hg_core_handle_t) hg_core_handle;
+                hg_core_cb_info.info.respond.handle =
+                    (hg_core_handle_t) hg_core_handle;
                 break;
 #endif
             case HG_CORE_NO_RESPOND:
@@ -3446,29 +3504,36 @@ hg_core_trigger_entry(struct hg_core_handle *hg_core_handle)
         /* Execute user callback */
         if (hg_cb)
             hg_cb(&hg_core_cb_info);
-
-        /* Repost handle if we were listening, otherwise destroy it */
-        if (hg_core_handle->repost && !hg_core_handle->hg_info.context->finalizing) {
-            /* Repost handle */
-            ret = hg_core_reset_post(hg_core_handle);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Cannot repost handle");
-                goto done;
-            }
-        } else
-            hg_core_destroy(hg_core_handle);
     }
 
+    /* Repost handle if we were listening, otherwise destroy it */
+    if (hg_core_handle->repost
+        && !HG_CORE_HANDLE_CONTEXT(hg_core_handle)->finalizing) {
+        /* Repost handle */
+        ret = hg_core_reset_post(hg_core_handle);
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Cannot repost handle");
+            goto done;
+        }
+    } else
+        hg_core_destroy(hg_core_handle);
+
 done:
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_cancel(struct hg_core_handle *hg_core_handle)
+hg_core_cancel(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
+    if (hg_core_handle->is_self) {
+        HG_LOG_ERROR("Local cancelation is not supported");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
+
     /* Cancel all NA operations issued */
     if (hg_core_handle->na_recv_op_id != NA_OP_ID_NULL) {
         na_return_t na_ret;
@@ -3494,6 +3559,20 @@ hg_core_cancel(struct hg_core_handle *hg_core_handle)
         }
     }
 
+    /* TODO
+    if (hg_core_handle->na_ack_op_id != NA_OP_ID_NULL) {
+        na_return_t na_ret;
+
+        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
+            hg_core_handle->na_ack_op_id);
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not cancel ack op id");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
+    }
+    */
+
 done:
     return ret;
 }
@@ -3510,7 +3589,7 @@ hg_core_class_t *
 HG_Core_init_opt(const char *na_info_string, hg_bool_t na_listen,
     const struct hg_init_info *hg_init_info)
 {
-    struct hg_core_class *hg_core_class = NULL;
+    struct hg_core_private_class *hg_core_class = NULL;
     hg_return_t ret = HG_SUCCESS;
 
     hg_core_class = hg_core_init(na_info_string, na_listen, hg_init_info);
@@ -3524,7 +3603,7 @@ done:
     if (ret != HG_SUCCESS) {
         /* Nothing */
     }
-    return hg_core_class;
+    return (hg_core_class_t *) hg_core_class;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3533,7 +3612,7 @@ HG_Core_finalize(hg_core_class_t *hg_core_class)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    ret = hg_core_finalize(hg_core_class);
+    ret = hg_core_finalize((struct hg_core_private_class *) hg_core_class);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Cannot finalize HG core layer");
         goto done;
@@ -3557,6 +3636,8 @@ HG_Core_set_more_data_callback(struct hg_core_class *hg_core_class,
         hg_return_t (*done_callback)(hg_core_handle_t)),
     void (*more_data_release_callback)(hg_core_handle_t))
 {
+    struct hg_core_private_class *private_class =
+        (struct hg_core_private_class *) hg_core_class;
     hg_return_t ret = HG_SUCCESS;
 
     if (!hg_core_class) {
@@ -3565,255 +3646,92 @@ HG_Core_set_more_data_callback(struct hg_core_class *hg_core_class,
         goto done;
     }
 
-    hg_core_class->more_data_acquire = more_data_acquire_callback;
-    hg_core_class->more_data_release = more_data_release_callback;
+    private_class->more_data_acquire = more_data_acquire_callback;
+    private_class->more_data_release = more_data_release_callback;
 
 done:
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
-const char *
-HG_Core_class_get_name(const hg_core_class_t *hg_core_class)
+hg_core_context_t *
+HG_Core_context_create(hg_core_class_t *hg_core_class)
 {
-    const char *ret = NULL;
-
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        goto done;
-    }
-
-    ret = NA_Get_class_name(hg_core_class->na_class);
-
-done:
-    return ret;
+    return HG_Core_context_create_id(hg_core_class, 0);
 }
 
 /*---------------------------------------------------------------------------*/
-const char *
-HG_Core_class_get_protocol(const hg_core_class_t *hg_core_class)
+hg_core_context_t *
+HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
 {
-    const char *ret = NULL;
+    hg_return_t ret = HG_SUCCESS;
+    struct hg_core_private_context *context = NULL;
+    int na_poll_fd;
+#ifdef HG_HAS_SELF_FORWARD
+    int fd;
+#endif
 
     if (!hg_core_class) {
         HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
         goto done;
     }
 
-    ret = NA_Get_class_protocol(hg_core_class->na_class);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_bool_t
-HG_Core_class_is_listening(const hg_core_class_t *hg_core_class)
-{
-    hg_bool_t ret = HG_FALSE;
-
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
+    context = (struct hg_core_private_context *) malloc(
+        sizeof(struct hg_core_private_context));
+    if (!context) {
+        HG_LOG_ERROR("Could not allocate HG context");
+        ret = HG_NOMEM_ERROR;
         goto done;
     }
-
-    ret = NA_Is_listening(hg_core_class->na_class);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_class_t *
-HG_Core_class_get_na(const hg_core_class_t *hg_core_class)
-{
-    na_class_t *ret = NULL;
-
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
+    memset(context, 0, sizeof(struct hg_core_private_context));
+    context->core_context.core_class = hg_core_class;
+    context->completion_queue =
+        hg_atomic_queue_alloc(HG_CORE_ATOMIC_QUEUE_SIZE);
+    if (!context->completion_queue) {
+        HG_LOG_ERROR("Could not allocate queue");
+        ret = HG_NOMEM_ERROR;
         goto done;
     }
+    HG_QUEUE_INIT(&context->backfill_queue);
+    hg_atomic_init32(&context->backfill_queue_count, 0);
+    HG_LIST_INIT(&context->pending_list);
+#ifdef HG_HAS_SM_ROUTING
+    HG_LIST_INIT(&context->sm_pending_list);
+#endif
+    HG_LIST_INIT(&context->created_list);
 
-    ret = hg_core_class->na_class;
+    /* No handle created yet */
+    hg_atomic_init32(&context->n_handles, 0);
 
-done:
-    return ret;
-}
+    /* Initialize completion queue mutex/cond */
+    hg_thread_mutex_init(&context->completion_queue_mutex);
+    hg_thread_cond_init(&context->completion_queue_cond);
+    hg_atomic_init32(&context->trigger_waiting, 0);
 
-/*---------------------------------------------------------------------------*/
+    hg_thread_spin_init(&context->pending_list_lock);
 #ifdef HG_HAS_SM_ROUTING
-na_class_t *
-HG_Core_class_get_na_sm(const hg_core_class_t *hg_core_class)
-{
-    na_class_t *ret = NULL;
+    hg_thread_spin_init(&context->sm_pending_list_lock);
+#endif
+    hg_thread_spin_init(&context->created_list_lock);
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
+    context->core_context.na_context = NA_Context_create_id(
+        hg_core_class->na_class, id);
+    if (!context->core_context.na_context) {
+        HG_LOG_ERROR("Could not create NA context");
+        ret = HG_NA_ERROR;
         goto done;
     }
-
-    ret = hg_core_class->na_sm_class;
-
-done:
-    return ret;
-}
-#endif
-
-/*---------------------------------------------------------------------------*/
-hg_size_t
-HG_Core_class_get_input_eager_size(const hg_core_class_t *hg_core_class)
-{
-    hg_size_t ret = 0, unexp, header;
-
-    if (hg_core_class == NULL) {
-        HG_LOG_ERROR("NULL HG core class");
-        goto done;
-    }
-
-    unexp  = NA_Msg_get_max_unexpected_size(hg_core_class->na_class);
-    header = hg_core_header_request_get_size() +
-        NA_Msg_get_unexpected_header_size(hg_core_class->na_class);
-    if (unexp > header)
-        ret = unexp - header;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_size_t
-HG_Core_class_get_output_eager_size(const hg_core_class_t *hg_core_class)
-{
-    hg_size_t ret = 0, exp, header;
-
-    if (hg_core_class == NULL) {
-        HG_LOG_ERROR("NULL HG core class");
-        goto done;
-    }
-
-    exp    = NA_Msg_get_max_expected_size(hg_core_class->na_class);
-    header = hg_core_header_response_get_size() +
-        NA_Msg_get_expected_header_size(hg_core_class->na_class);
-    if (exp > header)
-        ret = exp - header;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Core_class_set_data(hg_core_class_t *hg_core_class, void *data,
-    void (*free_callback)(void *))
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    hg_core_class->data = data;
-    hg_core_class->data_free_callback = free_callback;
-
- done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-void *
-HG_Core_class_get_data(const hg_core_class_t *hg_core_class)
-{
-    void *ret = NULL;
-
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        goto done;
-    }
-
-    ret = hg_core_class->data;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_core_context_t *
-HG_Core_context_create(hg_core_class_t *hg_core_class)
-{
-    return HG_Core_context_create_id(hg_core_class, 0);
-}
-
-/*---------------------------------------------------------------------------*/
-hg_core_context_t *
-HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
-{
-    hg_return_t ret = HG_SUCCESS;
-    struct hg_core_context *context = NULL;
-    int na_poll_fd;
-#ifdef HG_HAS_SELF_FORWARD
-    int fd;
-#endif
-
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    context = (struct hg_core_context *) malloc(sizeof(struct hg_core_context));
-    if (!context) {
-        HG_LOG_ERROR("Could not allocate HG context");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    memset(context, 0, sizeof(struct hg_core_context));
-    context->hg_core_class = hg_core_class;
-    context->completion_queue =
-        hg_atomic_queue_alloc(HG_CORE_ATOMIC_QUEUE_SIZE);
-    if (!context->completion_queue) {
-        HG_LOG_ERROR("Could not allocate queue");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    HG_QUEUE_INIT(&context->backfill_queue);
-    hg_atomic_init32(&context->backfill_queue_count, 0);
-    HG_LIST_INIT(&context->pending_list);
-#ifdef HG_HAS_SM_ROUTING
-    HG_LIST_INIT(&context->sm_pending_list);
-#endif
-    HG_LIST_INIT(&context->created_list);
-
-    /* No handle created yet */
-    hg_atomic_init32(&context->n_handles, 0);
-
-    /* Initialize completion queue mutex/cond */
-    hg_thread_mutex_init(&context->completion_queue_mutex);
-    hg_thread_cond_init(&context->completion_queue_cond);
-    hg_atomic_init32(&context->trigger_waiting, 0);
-
-    hg_thread_spin_init(&context->pending_list_lock);
-#ifdef HG_HAS_SM_ROUTING
-    hg_thread_spin_init(&context->sm_pending_list_lock);
-#endif
-    hg_thread_spin_init(&context->created_list_lock);
-
-    context->na_context = NA_Context_create_id(hg_core_class->na_class, id);
-    if (!context->na_context) {
-        HG_LOG_ERROR("Could not create NA context");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
-#ifdef HG_HAS_SM_ROUTING
-    if (hg_core_class->na_sm_class) {
-        context->na_sm_context = NA_Context_create(hg_core_class->na_sm_class);
-        if (!context->na_sm_context) {
-            HG_LOG_ERROR("Could not create NA SM context");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
-    }
+#ifdef HG_HAS_SM_ROUTING
+    if (hg_core_class->na_sm_class) {
+        context->core_context.na_sm_context = NA_Context_create(
+            hg_core_class->na_sm_class);
+        if (!context->core_context.na_sm_context) {
+            HG_LOG_ERROR("Could not create NA SM context");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
+    }
 #endif
 
     /* Create poll set */
@@ -3839,13 +3757,14 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
         hg_core_completion_queue_notify_cb, context);
 #endif
 
-    if (context->hg_core_class->progress_mode == NA_NO_BLOCK)
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
         /* Force to use progress poll */
         na_poll_fd = 0;
     else
         /* If NA plugin exposes fd, add it to poll set and use appropriate
          * progress function */
-        na_poll_fd = NA_Poll_get_fd(hg_core_class->na_class, context->na_context);
+        na_poll_fd = NA_Poll_get_fd(hg_core_class->na_class,
+            context->core_context.na_context);
     if (na_poll_fd >= 0) {
         hg_poll_add(context->poll_set, na_poll_fd, HG_POLLIN,
             hg_core_progress_na_cb, context);
@@ -3857,18 +3776,18 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
 
 #ifdef HG_HAS_SM_ROUTING
     /* Auto SM requires hg_core_progress_poll */
-    if (context->na_sm_context) {
+    if (context->core_context.na_sm_context) {
         if (context->progress != hg_core_progress_poll) {
             HG_LOG_ERROR("Auto SM mode not supported with selected plugin");
             ret = HG_PROTOCOL_ERROR;
             goto done;
         }
-        if (context->hg_core_class->progress_mode == NA_NO_BLOCK)
+        if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
             /* Force to use progress poll */
             na_poll_fd = 0;
         else {
             na_poll_fd = NA_Poll_get_fd(hg_core_class->na_sm_class,
-                context->na_sm_context);
+                context->core_context.na_sm_context);
             if (na_poll_fd < 0) {
                 HG_LOG_ERROR("Could not get NA SM poll fd");
                 ret = HG_NA_ERROR;
@@ -3881,23 +3800,25 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
 #endif
 
     /* Assign context ID */
-    context->id = id;
+    context->core_context.id = id;
 
     /* Increment context count of parent class */
-    hg_atomic_incr32(&hg_core_class->n_contexts);
+    hg_atomic_incr32(&HG_CORE_CONTEXT_CLASS(context)->n_contexts);
 
 done:
     if (ret != HG_SUCCESS && context) {
-        HG_Core_context_destroy(context);
+        HG_Core_context_destroy((hg_core_context_t *) context);
         context = NULL;
     }
-    return context;
+    return (hg_core_context_t *) context;
 }
 
 /*---------------------------------------------------------------------------*/
 hg_return_t
 HG_Core_context_destroy(hg_core_context_t *context)
 {
+    struct hg_core_private_context *private_context =
+        (struct hg_core_private_context *) context;
     na_return_t na_ret;
     hg_return_t ret = HG_SUCCESS;
     unsigned int actual_count;
@@ -3907,11 +3828,11 @@ HG_Core_context_destroy(hg_core_context_t *context)
     if (!context) goto done;
 
     /* Prevent repost of handles */
-    context->finalizing = HG_TRUE;
+    private_context->finalizing = HG_TRUE;
 
     /* Check pending list and cancel posted handles */
-    if (!HG_LIST_IS_EMPTY(&context->pending_list)) {
-        ret = hg_core_pending_list_cancel(context);
+    if (!HG_LIST_IS_EMPTY(&private_context->pending_list)) {
+        ret = hg_core_pending_list_cancel(private_context);
         if (ret != HG_SUCCESS) {
             HG_LOG_ERROR("Cannot cancel list of pending entries");
             goto done;
@@ -3919,8 +3840,8 @@ HG_Core_context_destroy(hg_core_context_t *context)
     }
 #ifdef HG_HAS_SM_ROUTING
     /* Check pending list and cancel posted handles */
-    if (!HG_LIST_IS_EMPTY(&context->sm_pending_list)) {
-        ret = hg_core_sm_pending_list_cancel(context);
+    if (!HG_LIST_IS_EMPTY(&private_context->sm_pending_list)) {
+        ret = hg_core_sm_pending_list_cancel(private_context);
         if (ret != HG_SUCCESS) {
             HG_LOG_ERROR("Cannot cancel list of SM pending entries");
             goto done;
@@ -3937,13 +3858,14 @@ HG_Core_context_destroy(hg_core_context_t *context)
 #ifdef HG_HAS_SM_ROUTING
     if (context->na_sm_context) {
         do {
-            na_ret = NA_Trigger(context->na_sm_context, 0, 1, NULL, &actual_count);
+            na_ret = NA_Trigger(context->na_sm_context, 0, 1, NULL,
+                &actual_count);
         } while ((na_ret == NA_SUCCESS) && actual_count);
     }
 #endif
 
     /* Check that operations have completed */
-    ret = hg_core_created_list_wait(context);
+    ret = hg_core_created_list_wait(private_context);
     if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
         HG_LOG_ERROR("Could not wait on HG core handle list");
         goto done;
@@ -3951,52 +3873,53 @@ HG_Core_context_destroy(hg_core_context_t *context)
 
 #ifdef HG_HAS_SELF_FORWARD
     /* Destroy self processing pool if created */
-    hg_thread_pool_destroy(context->self_processing_pool);
+    hg_thread_pool_destroy(private_context->self_processing_pool);
 #endif
 
     /* Number of handles for that context should be 0 */
-    n_handles = hg_atomic_get32(&context->n_handles);
+    n_handles = hg_atomic_get32(&private_context->n_handles);
     if (n_handles != 0) {
-        struct hg_core_handle *hg_core_handle = NULL;
+        struct hg_core_private_handle *hg_core_handle = NULL;
         HG_LOG_ERROR("HG core handles must be freed before destroying context "
             "(%d remaining)", n_handles);
-        hg_thread_spin_lock(&context->created_list_lock);
-        HG_LIST_FOREACH(hg_core_handle, &context->created_list, created) {
+        hg_thread_spin_lock(&private_context->created_list_lock);
+        HG_LIST_FOREACH(hg_core_handle, &private_context->created_list, created) {
             HG_LOG_ERROR("HG core handle at address %p was not destroyed",
                 hg_core_handle);
         }
-        hg_thread_spin_unlock(&context->created_list_lock);
+        hg_thread_spin_unlock(&private_context->created_list_lock);
         ret = HG_PROTOCOL_ERROR;
         goto done;
     }
 
     /* Check that completion queue is empty now */
-    if (!hg_atomic_queue_is_empty(context->completion_queue)) {
+    if (!hg_atomic_queue_is_empty(private_context->completion_queue)) {
         HG_LOG_ERROR("Completion queue should be empty");
         ret = HG_PROTOCOL_ERROR;
         goto done;
     }
-    hg_atomic_queue_free(context->completion_queue);
+    hg_atomic_queue_free(private_context->completion_queue);
 
     /* Check that completion queue is empty now */
-    hg_thread_mutex_lock(&context->completion_queue_mutex);
-    if (!HG_QUEUE_IS_EMPTY(&context->backfill_queue)) {
+    hg_thread_mutex_lock(&private_context->completion_queue_mutex);
+    if (!HG_QUEUE_IS_EMPTY(&private_context->backfill_queue)) {
         HG_LOG_ERROR("Completion queue should be empty");
         ret = HG_PROTOCOL_ERROR;
-        hg_thread_mutex_unlock(&context->completion_queue_mutex);
+        hg_thread_mutex_unlock(&private_context->completion_queue_mutex);
         goto done;
     }
-    hg_thread_mutex_unlock(&context->completion_queue_mutex);
+    hg_thread_mutex_unlock(&private_context->completion_queue_mutex);
 
 #ifdef HG_HAS_SELF_FORWARD
-    if (context->completion_queue_notify > 0) {
-        if (hg_poll_remove(context->poll_set, context->completion_queue_notify)
-            != HG_UTIL_SUCCESS) {
+    if (private_context->completion_queue_notify > 0) {
+        if (hg_poll_remove(private_context->poll_set,
+            private_context->completion_queue_notify) != HG_UTIL_SUCCESS) {
             HG_LOG_ERROR("Could not remove self processing event from poll set");
             ret = HG_PROTOCOL_ERROR;
             goto done;
         }
-        if (hg_event_destroy(context->completion_queue_notify) != HG_UTIL_SUCCESS) {
+        if (hg_event_destroy(private_context->completion_queue_notify)
+            != HG_UTIL_SUCCESS) {
             HG_LOG_ERROR("Could not destroy self processing event");
             ret = HG_PROTOCOL_ERROR;
             goto done;
@@ -4004,15 +3927,16 @@ HG_Core_context_destroy(hg_core_context_t *context)
     }
 #endif
 
-    if (context->hg_core_class->progress_mode == NA_NO_BLOCK)
+    if (HG_CORE_CONTEXT_CLASS(private_context)->progress_mode == NA_NO_BLOCK)
         /* Was forced to use progress poll */
         na_poll_fd = 0;
     else
         /* If NA plugin exposes fd, remove it from poll set */
-        na_poll_fd = NA_Poll_get_fd(context->hg_core_class->na_class,
+        na_poll_fd = NA_Poll_get_fd(context->core_class->na_class,
             context->na_context);
     if ((na_poll_fd >= 0)
-        && hg_poll_remove(context->poll_set, na_poll_fd) != HG_UTIL_SUCCESS) {
+        && hg_poll_remove(private_context->poll_set, na_poll_fd)
+        != HG_UTIL_SUCCESS) {
         HG_LOG_ERROR("Could not remove NA poll descriptor from poll set");
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -4020,15 +3944,16 @@ HG_Core_context_destroy(hg_core_context_t *context)
 
 #ifdef HG_HAS_SM_ROUTING
     if (context->na_sm_context) {
-        if (context->hg_core_class->progress_mode == NA_NO_BLOCK)
+        if (HG_CORE_CONTEXT_CLASS(private_context)->progress_mode == NA_NO_BLOCK)
             /* Was forced to use progress poll */
             na_poll_fd = 0;
         else
             /* If NA plugin exposes fd, remove it from poll set */
-            na_poll_fd = NA_Poll_get_fd(context->hg_core_class->na_sm_class,
+            na_poll_fd = NA_Poll_get_fd(context->core_class->na_sm_class,
                 context->na_sm_context);
         if ((na_poll_fd >= 0)
-            && hg_poll_remove(context->poll_set, na_poll_fd) != HG_UTIL_SUCCESS) {
+            && hg_poll_remove(private_context->poll_set, na_poll_fd)
+            != HG_UTIL_SUCCESS) {
             HG_LOG_ERROR("Could not remove NA poll descriptor from poll set");
             ret = HG_PROTOCOL_ERROR;
             goto done;
@@ -4037,14 +3962,14 @@ HG_Core_context_destroy(hg_core_context_t *context)
 #endif
 
     /* Destroy poll set */
-    if (hg_poll_destroy(context->poll_set) != HG_UTIL_SUCCESS) {
+    if (hg_poll_destroy(private_context->poll_set) != HG_UTIL_SUCCESS) {
         HG_LOG_ERROR("Could not destroy poll set");
         ret = HG_PROTOCOL_ERROR;
         goto done;
     }
 
     /* Destroy NA context */
-    if (context->na_context && NA_Context_destroy(context->hg_core_class->na_class,
+    if (context->na_context && NA_Context_destroy(context->core_class->na_class,
             context->na_context) != NA_SUCCESS) {
         HG_LOG_ERROR("Could not destroy NA context");
         ret = HG_NA_ERROR;
@@ -4054,7 +3979,7 @@ HG_Core_context_destroy(hg_core_context_t *context)
 #ifdef HG_HAS_SM_ROUTING
     /* Destroy NA SM context */
     if (context->na_sm_context && NA_Context_destroy(
-        context->hg_core_class->na_sm_class, context->na_sm_context) != NA_SUCCESS) {
+        context->core_class->na_sm_class, context->na_sm_context) != NA_SUCCESS) {
         HG_LOG_ERROR("Could not destroy NA SM context");
         ret = HG_NA_ERROR;
         goto done;
@@ -4066,126 +3991,18 @@ HG_Core_context_destroy(hg_core_context_t *context)
         context->data_free_callback(context->data);
 
     /* Destroy completion queue mutex/cond */
-    hg_thread_mutex_destroy(&context->completion_queue_mutex);
-    hg_thread_cond_destroy(&context->completion_queue_cond);
-    hg_thread_spin_destroy(&context->pending_list_lock);
+    hg_thread_mutex_destroy(&private_context->completion_queue_mutex);
+    hg_thread_cond_destroy(&private_context->completion_queue_cond);
+    hg_thread_spin_destroy(&private_context->pending_list_lock);
 #ifdef HG_HAS_SM_ROUTING
-    hg_thread_spin_destroy(&context->sm_pending_list_lock);
+    hg_thread_spin_destroy(&private_context->sm_pending_list_lock);
 #endif
-    hg_thread_spin_destroy(&context->created_list_lock);
+    hg_thread_spin_destroy(&private_context->created_list_lock);
 
     /* Decrement context count of parent class */
-    hg_atomic_decr32(&context->hg_core_class->n_contexts);
-
-    free(context);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_core_class_t *
-HG_Core_context_get_class(const hg_core_context_t *context)
-{
-    hg_core_class_t *ret = NULL;
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        goto done;
-    }
-
-    ret = context->hg_core_class;
-
- done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_context_t *
-HG_Core_context_get_na(const hg_core_context_t *context)
-{
-    na_context_t *ret = NULL;
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        goto done;
-    }
-
-    ret = context->na_context;
-
- done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-#ifdef HG_HAS_SM_ROUTING
-na_context_t *
-HG_Core_context_get_na_sm(const hg_core_context_t *context)
-{
-    na_context_t *ret = NULL;
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        goto done;
-    }
+    hg_atomic_decr32(&HG_CORE_CONTEXT_CLASS(private_context)->n_contexts);
 
-    ret = context->na_sm_context;
-
-done:
-    return ret;
-}
-#endif
-
-/*---------------------------------------------------------------------------*/
-hg_uint8_t
-HG_Core_context_get_id(const hg_core_context_t *context)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    ret = context->id;
-
- done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Core_context_set_data(hg_core_context_t *context, void *data,
-    void (*free_callback)(void *))
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    context->data = data;
-    context->data_free_callback = free_callback;
-
- done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-void *
-HG_Core_context_get_data(const hg_core_context_t *context)
-{
-    void *ret = NULL;
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        goto done;
-    }
-
-    ret = context->data;
+    free(private_context);
 
 done:
     return ret;
@@ -4196,6 +4013,8 @@ hg_return_t
 HG_Core_context_set_handle_create_callback(hg_core_context_t *context,
     hg_return_t (*callback)(hg_core_handle_t, void *), void *arg)
 {
+    struct hg_core_private_context *private_context =
+        (struct hg_core_private_context *) context;
     hg_return_t ret = HG_SUCCESS;
 
     if (!context) {
@@ -4204,8 +4023,8 @@ HG_Core_context_set_handle_create_callback(hg_core_context_t *context,
         goto done;
     }
 
-    context->handle_create = callback;
-    context->handle_create_arg = arg;
+    private_context->handle_create = callback;
+    private_context->handle_create_arg = arg;
 
  done:
     return ret;
@@ -4233,7 +4052,8 @@ HG_Core_context_post(hg_core_context_t *context, unsigned int request_count,
 #ifdef HG_HAS_SM_ROUTING
     do {
 #endif
-        ret = hg_core_context_post(context, request_count, repost, use_sm);
+        ret = hg_core_context_post((struct hg_core_private_context *) context,
+            request_count, repost, use_sm);
         if (ret != HG_SUCCESS) {
             HG_LOG_ERROR("Could not post requests on context");
             goto done;
@@ -4253,6 +4073,8 @@ hg_return_t
 HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
     hg_core_rpc_cb_t rpc_cb)
 {
+    struct hg_core_private_class *private_class =
+        (struct hg_core_private_class *) hg_core_class;
     hg_id_t *func_key = NULL;
     struct hg_core_rpc_info *hg_core_rpc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
@@ -4265,12 +4087,12 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
     }
 
     /* Check if registered and set RPC CB */
-    hg_thread_spin_lock(&hg_core_class->func_map_lock);
+    hg_thread_spin_lock(&private_class->func_map_lock);
     hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
-            hg_core_class->func_map, (hg_hash_table_key_t) &id);
+            private_class->func_map, (hg_hash_table_key_t) &id);
     if (hg_core_rpc_info && rpc_cb)
         hg_core_rpc_info->rpc_cb = rpc_cb;
-    hg_thread_spin_unlock(&hg_core_class->func_map_lock);
+    hg_thread_spin_unlock(&private_class->func_map_lock);
 
     if (!hg_core_rpc_info) {
         /* Allocate the key */
@@ -4283,7 +4105,8 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
         *func_key = id;
 
         /* Fill info and store it into the function map */
-        hg_core_rpc_info = (struct hg_core_rpc_info *) malloc(sizeof(struct hg_core_rpc_info));
+        hg_core_rpc_info = (struct hg_core_rpc_info *) malloc(
+            sizeof(struct hg_core_rpc_info));
         if (!hg_core_rpc_info) {
             HG_LOG_ERROR("Could not allocate HG info");
             ret = HG_NOMEM_ERROR;
@@ -4294,10 +4117,10 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
         hg_core_rpc_info->data = NULL;
         hg_core_rpc_info->free_callback = NULL;
 
-        hg_thread_spin_lock(&hg_core_class->func_map_lock);
-        hash_ret = hg_hash_table_insert(hg_core_class->func_map,
+        hg_thread_spin_lock(&private_class->func_map_lock);
+        hash_ret = hg_hash_table_insert(private_class->func_map,
             (hg_hash_table_key_t) func_key, hg_core_rpc_info);
-        hg_thread_spin_unlock(&hg_core_class->func_map_lock);
+        hg_thread_spin_unlock(&private_class->func_map_lock);
         if (!hash_ret) {
             HG_LOG_ERROR("Could not insert RPC ID into function map (already registered?)");
             ret = HG_INVALID_PARAM;
@@ -4317,6 +4140,8 @@ done:
 hg_return_t
 HG_Core_deregister(hg_core_class_t *hg_core_class, hg_id_t id)
 {
+    struct hg_core_private_class *private_class =
+        (struct hg_core_private_class *) hg_core_class;
     hg_return_t ret = HG_SUCCESS;
     int hash_ret;
 
@@ -4326,10 +4151,10 @@ HG_Core_deregister(hg_core_class_t *hg_core_class, hg_id_t id)
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_core_class->func_map_lock);
-    hash_ret = hg_hash_table_remove(hg_core_class->func_map,
+    hg_thread_spin_lock(&private_class->func_map_lock);
+    hash_ret = hg_hash_table_remove(private_class->func_map,
         (hg_hash_table_key_t) &id);
-    hg_thread_spin_unlock(&hg_core_class->func_map_lock);
+    hg_thread_spin_unlock(&private_class->func_map_lock);
     if (!hash_ret) {
         HG_LOG_ERROR("Could not deregister RPC ID from function map");
         ret = HG_INVALID_PARAM;
@@ -4344,6 +4169,8 @@ done:
 hg_return_t
 HG_Core_registered(hg_core_class_t *hg_core_class, hg_id_t id, hg_bool_t *flag)
 {
+    struct hg_core_private_class *private_class =
+        (struct hg_core_private_class *) hg_core_class;
     hg_return_t ret = HG_SUCCESS;
 
     if (!hg_core_class) {
@@ -4357,10 +4184,10 @@ HG_Core_registered(hg_core_class_t *hg_core_class, hg_id_t id, hg_bool_t *flag)
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_core_class->func_map_lock);
-    *flag = (hg_bool_t) (hg_hash_table_lookup(hg_core_class->func_map,
+    hg_thread_spin_lock(&private_class->func_map_lock);
+    *flag = (hg_bool_t) (hg_hash_table_lookup(private_class->func_map,
             (hg_hash_table_key_t) &id) != HG_HASH_TABLE_NULL);
-    hg_thread_spin_unlock(&hg_core_class->func_map_lock);
+    hg_thread_spin_unlock(&private_class->func_map_lock);
 
 done:
     return ret;
@@ -4371,6 +4198,8 @@ hg_return_t
 HG_Core_register_data(hg_core_class_t *hg_core_class, hg_id_t id, void *data,
     void (*free_callback)(void *))
 {
+    struct hg_core_private_class *private_class =
+        (struct hg_core_private_class *) hg_core_class;
     struct hg_core_rpc_info *hg_core_rpc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
@@ -4380,10 +4209,10 @@ HG_Core_register_data(hg_core_class_t *hg_core_class, hg_id_t id, void *data,
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_core_class->func_map_lock);
-    hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(hg_core_class->func_map,
-            (hg_hash_table_key_t) &id);
-    hg_thread_spin_unlock(&hg_core_class->func_map_lock);
+    hg_thread_spin_lock(&private_class->func_map_lock);
+    hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
+        private_class->func_map, (hg_hash_table_key_t) &id);
+    hg_thread_spin_unlock(&private_class->func_map_lock);
     if (!hg_core_rpc_info) {
         HG_LOG_ERROR("Could not find RPC ID in function map");
         ret = HG_NO_MATCH;
@@ -4403,6 +4232,8 @@ done:
 void *
 HG_Core_registered_data(hg_core_class_t *hg_core_class, hg_id_t id)
 {
+    struct hg_core_private_class *private_class =
+        (struct hg_core_private_class *) hg_core_class;
     struct hg_core_rpc_info *hg_core_rpc_info = NULL;
     void *data = NULL;
 
@@ -4411,10 +4242,10 @@ HG_Core_registered_data(hg_core_class_t *hg_core_class, hg_id_t id)
         goto done;
     }
 
-    hg_thread_spin_lock(&hg_core_class->func_map_lock);
-    hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(hg_core_class->func_map,
-            (hg_hash_table_key_t) &id);
-    hg_thread_spin_unlock(&hg_core_class->func_map_lock);
+    hg_thread_spin_lock(&private_class->func_map_lock);
+    hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
+        private_class->func_map, (hg_hash_table_key_t) &id);
+    hg_thread_spin_unlock(&private_class->func_map_lock);
     if (!hg_core_rpc_info) {
         HG_LOG_ERROR("Could not find RPC ID in function map");
         goto done;
@@ -4428,8 +4259,8 @@ done:
 
 /*---------------------------------------------------------------------------*/
 hg_return_t
-HG_Core_addr_lookup(hg_core_context_t *context, hg_core_cb_t callback, void *arg,
-    const char *name, hg_core_op_id_t *op_id)
+HG_Core_addr_lookup(hg_core_context_t *context, hg_core_cb_t callback,
+    void *arg, const char *name, hg_core_op_id_t *op_id)
 {
     hg_return_t ret = HG_SUCCESS;
 
@@ -4449,7 +4280,8 @@ HG_Core_addr_lookup(hg_core_context_t *context, hg_core_cb_t callback, void *arg
         goto done;
     }
 
-    ret = hg_core_addr_lookup(context, callback, arg, name, op_id);
+    ret = hg_core_addr_lookup((struct hg_core_private_context *) context,
+        callback, arg, name, op_id);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not lookup address");
         goto done;
@@ -4459,34 +4291,29 @@ done:
     return ret;
 }
 
-/*---------------------------------------------------------------------------*/
-hg_core_addr_t
-HG_Core_addr_create(hg_core_class_t *core_class)
-{
-    if (core_class == NULL) {
-        HG_LOG_ERROR("NULL HG core class");
-        return HG_CORE_ADDR_NULL;
-    }
-
-    return hg_core_addr_create(core_class, core_class->na_class);
-
-}
-
 /*---------------------------------------------------------------------------*/
 hg_return_t
-HG_Core_addr_free(hg_core_class_t *hg_core_class, hg_core_addr_t addr)
+HG_Core_addr_create(hg_core_class_t *hg_core_class, hg_core_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
+    if (hg_core_class == NULL) {
         HG_LOG_ERROR("NULL HG core class");
         ret = HG_INVALID_PARAM;
         goto done;
     }
+    if (!addr) {
+        HG_LOG_ERROR("NULL pointer to address");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
-    ret = hg_core_addr_free(hg_core_class, addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free address");
+    *addr = (hg_core_addr_t) hg_core_addr_create(
+        (struct hg_core_private_class *) hg_core_class,
+        hg_core_class->na_class);
+    if (*addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("Could not create address");
+        ret = HG_NOMEM_ERROR;
         goto done;
     }
 
@@ -4495,47 +4322,26 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-void
-HG_Core_addr_set_na(hg_core_addr_t core_addr, na_addr_t na_addr)
-{
-    if (core_addr == HG_CORE_ADDR_NULL)
-        return;
-
-    core_addr->na_addr = na_addr;
-}
-
-/*---------------------------------------------------------------------------*/
-na_addr_t
-HG_Core_addr_get_na(hg_core_addr_t addr)
+hg_return_t
+HG_Core_addr_free(hg_core_class_t *hg_core_class, hg_core_addr_t addr)
 {
-    na_addr_t ret = NA_ADDR_NULL;
+    hg_return_t ret = HG_SUCCESS;
 
-    if (addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL addr");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
         goto done;
     }
 
-    ret = addr->na_addr;
-
-done:
-     return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_class_t *
-HG_Core_addr_get_na_class(hg_core_addr_t addr)
-{
-    na_class_t *ret = NULL;
-
-    if (addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL addr");
+    ret = hg_core_addr_free((struct hg_core_private_class *) hg_core_class,
+        (struct hg_core_private_addr *) addr);
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not free address");
         goto done;
     }
 
-    ret = addr->na_class;
-
 done:
-     return ret;
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4555,7 +4361,8 @@ HG_Core_addr_self(hg_core_class_t *hg_core_class, hg_core_addr_t *addr)
         goto done;
     }
 
-    ret = hg_core_addr_self(hg_core_class, addr);
+    ret = hg_core_addr_self((struct hg_core_private_class *) hg_core_class,
+        (struct hg_core_private_addr **) addr);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not get self address");
         goto done;
@@ -4567,7 +4374,8 @@ done:
 
 /*---------------------------------------------------------------------------*/
 hg_return_t
-HG_Core_addr_dup(hg_core_class_t *hg_core_class, hg_core_addr_t addr, hg_core_addr_t *new_addr)
+HG_Core_addr_dup(hg_core_class_t *hg_core_class, hg_core_addr_t addr,
+    hg_core_addr_t *new_addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
@@ -4587,7 +4395,9 @@ HG_Core_addr_dup(hg_core_class_t *hg_core_class, hg_core_addr_t addr, hg_core_ad
         goto done;
     }
 
-    ret = hg_core_addr_dup(hg_core_class, addr, new_addr);
+    ret = hg_core_addr_dup((struct hg_core_private_class *) hg_core_class,
+        (struct hg_core_private_addr *) addr,
+        (struct hg_core_private_addr **) new_addr);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not duplicate address");
         goto done;
@@ -4599,8 +4409,8 @@ done:
 
 /*---------------------------------------------------------------------------*/
 hg_return_t
-HG_Core_addr_to_string(hg_core_class_t *hg_core_class, char *buf, hg_size_t *buf_size,
-    hg_core_addr_t addr)
+HG_Core_addr_to_string(hg_core_class_t *hg_core_class, char *buf,
+    hg_size_t *buf_size, hg_core_addr_t addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
@@ -4610,7 +4420,8 @@ HG_Core_addr_to_string(hg_core_class_t *hg_core_class, char *buf, hg_size_t *buf
         goto done;
     }
 
-    ret = hg_core_addr_to_string(hg_core_class, buf, buf_size, addr);
+    ret = hg_core_addr_to_string((struct hg_core_private_class *) hg_core_class,
+        buf, buf_size, (struct hg_core_private_addr *) addr);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not convert address to string");
         goto done;
@@ -4625,10 +4436,11 @@ hg_return_t
 HG_Core_create(hg_core_context_t *context, hg_core_addr_t addr, hg_id_t id,
     hg_core_handle_t *handle)
 {
-    struct hg_core_handle *hg_core_handle = NULL;
-#ifdef HG_HAS_SM_ROUTING
-    struct hg_core_addr *hg_core_addr = addr;
-#endif
+    struct hg_core_private_context *private_context =
+        (struct hg_core_private_context *) context;
+    struct hg_core_private_handle *hg_core_handle = NULL;
+    struct hg_core_private_addr *private_addr =
+        (struct hg_core_private_addr *) addr;
     hg_bool_t use_sm = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
@@ -4644,12 +4456,13 @@ HG_Core_create(hg_core_context_t *context, hg_core_addr_t addr, hg_id_t id,
     }
 
 #ifdef HG_HAS_SM_ROUTING
-    if (hg_core_addr && (hg_core_addr->na_class == context->hg_core_class->na_sm_class))
+    if (private_addr
+        && (private_addr->core_addr.na_class == context->core_class->na_sm_class))
         use_sm = HG_TRUE;
 #endif
 
     /* Create new handle */
-    hg_core_handle = hg_core_create(context, use_sm);
+    hg_core_handle = hg_core_create(private_context, use_sm);
     if (!hg_core_handle) {
         HG_LOG_ERROR("Could not create HG core handle");
         ret = HG_NOMEM_ERROR;
@@ -4657,7 +4470,7 @@ HG_Core_create(hg_core_context_t *context, hg_core_addr_t addr, hg_id_t id,
     }
 
     /* Set addr / RPC ID */
-    ret = hg_core_set_rpc(hg_core_handle, addr, id);
+    ret = hg_core_set_rpc(hg_core_handle, private_addr, id);
     if (ret != HG_SUCCESS) {
         if (ret != HG_NO_MATCH) /* silence error if invalid ID is used */
             HG_LOG_ERROR("Could not set rpc to handle");
@@ -4666,9 +4479,9 @@ HG_Core_create(hg_core_context_t *context, hg_core_addr_t addr, hg_id_t id,
 
     /* Execute class callback on handle, this allows upper layers to
      * allocate private data on handle creation */
-    if (context->handle_create) {
-        ret = context->handle_create(hg_core_handle,
-            context->handle_create_arg);
+    if (private_context->handle_create) {
+        ret = private_context->handle_create((hg_core_handle_t) hg_core_handle,
+            private_context->handle_create_arg);
         if (ret != HG_SUCCESS) {
             HG_LOG_ERROR("Error in HG core handle create callback");
             goto done;
@@ -4688,7 +4501,8 @@ done:
 hg_return_t
 HG_Core_destroy(hg_core_handle_t handle)
 {
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
     if (!hg_core_handle) {
@@ -4698,7 +4512,8 @@ HG_Core_destroy(hg_core_handle_t handle)
     }
 
     /* Repost handle if we were listening, otherwise destroy it */
-    if (hg_core_handle->repost && !hg_core_handle->hg_info.context->finalizing) {
+    if (hg_core_handle->repost
+        && !HG_CORE_HANDLE_CONTEXT(hg_core_handle)->finalizing) {
         /* Repost handle */
         ret = hg_core_reset_post(hg_core_handle);
         if (ret != HG_SUCCESS) {
@@ -4716,10 +4531,10 @@ done:
 hg_return_t
 HG_Core_reset(hg_core_handle_t handle, hg_core_addr_t addr, hg_id_t id)
 {
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
-#ifdef HG_HAS_SM_ROUTING
-    struct hg_core_addr *hg_core_addr = addr;
-#endif
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) handle;
+    struct hg_core_private_addr *hg_core_addr =
+        (struct hg_core_private_addr *) addr;
     hg_return_t ret = HG_SUCCESS;
 
     if (!handle) {
@@ -4727,23 +4542,39 @@ HG_Core_reset(hg_core_handle_t handle, hg_core_addr_t addr, hg_id_t id)
         ret = HG_INVALID_PARAM;
         goto done;
     }
+    /* Not safe to reset
+     * TODO could add the ability to defer the reset operation */
+    if (hg_atomic_get32(&hg_core_handle->in_use)) {
+        HG_LOG_ERROR("Cannot reset HG core handle, handle is still in use, "
+            "refcount: %d",
+            hg_atomic_get32(&hg_core_handle->ref_count));
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
 #ifdef HG_HAS_SM_ROUTING
-    if (hg_core_addr && (hg_core_addr->na_class != hg_core_handle->na_class)) {
-        HG_LOG_ERROR("Cannot reset handle to a different address NA class");
-        ret = HG_INVALID_PARAM;
-        goto done;
+    if (hg_core_addr
+        && (hg_core_addr->core_addr.na_class != hg_core_handle->na_class)) {
+        struct hg_core_private_context *private_context =
+            (struct hg_core_private_context *) hg_core_handle->core_handle.info.context;
+        hg_bool_t use_sm =
+            (private_context->core_context.core_class->na_sm_class
+                == hg_core_addr->core_addr.na_class);
+        /* In that case, we must free and re-allocate NA resources */
+        hg_core_free_na(hg_core_handle);
+        ret = hg_core_alloc_na(hg_core_handle, use_sm);
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not re-allocate handle NA resources");
+            goto done;
+        }
     }
 #endif
 
-    ret = hg_core_reset(hg_core_handle, HG_FALSE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset HG core handle");
-        goto done;
-    }
+    /* Reset handle */
+    hg_core_reset(hg_core_handle, HG_FALSE);
 
     /* Set addr / RPC ID */
-    ret = hg_core_set_rpc(hg_core_handle, addr, id);
+    ret = hg_core_set_rpc(hg_core_handle, hg_core_addr, id);
     if (ret != HG_SUCCESS) {
         goto done;
     }
@@ -4756,163 +4587,32 @@ done:
 hg_return_t
 HG_Core_ref_incr(hg_core_handle_t handle)
 {
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!hg_core_handle) {
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) handle;
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
         HG_LOG_ERROR("NULL pointer to HG core handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
+        return HG_INVALID_PARAM;
     }
-
+#endif
     hg_atomic_incr32(&hg_core_handle->ref_count);
 
-done:
-    return ret;
+    return HG_SUCCESS;
 }
 
 /*---------------------------------------------------------------------------*/
 hg_int32_t
 HG_Core_ref_get(hg_core_handle_t handle)
 {
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
-    hg_int32_t ret = -1;
-
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        goto done;
-    }
-
-    ret = (hg_int32_t) hg_atomic_get32(&hg_core_handle->ref_count);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Core_set_data(hg_core_handle_t handle, void *data,
-    void (*free_callback)(void *))
-{
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    hg_core_handle->data = data;
-    hg_core_handle->data_free_callback = free_callback;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-void *
-HG_Core_get_data(hg_core_handle_t handle)
-{
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
-    void *ret = NULL;
-
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        goto done;
-    }
-
-    ret = hg_core_handle->data;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-const struct hg_core_info *
-HG_Core_get_info(hg_core_handle_t handle)
-{
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
-    struct hg_core_info *ret = NULL;
-
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL handle");
-        goto done;
-    }
-
-    ret = &hg_core_handle->hg_info;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Core_set_target_id(hg_core_handle_t handle, hg_uint8_t id)
-{
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
-    hg_return_t ret = HG_SUCCESS;
-
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) handle;
+#ifdef HG_HAS_VERBOSE_ERROR
     if (!handle) {
-        HG_LOG_ERROR("NULL HG core handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    hg_core_handle->hg_info.context_id = id;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Core_get_input(hg_core_handle_t handle, void **in_buf, hg_size_t *in_buf_size)
-{
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!in_buf || !in_buf_size) {
-        HG_LOG_ERROR("NULL pointer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    hg_core_get_input(hg_core_handle, in_buf, in_buf_size);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-hg_return_t
-HG_Core_get_output(hg_core_handle_t handle, void **out_buf, hg_size_t *out_buf_size)
-{
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!out_buf || !out_buf_size) {
-        HG_LOG_ERROR("NULL pointer");
-        ret = HG_INVALID_PARAM;
-        goto done;
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return -1;
     }
-
-    hg_core_get_output(hg_core_handle, out_buf, out_buf_size);
-
-done:
-    return ret;
+#endif
+    return (hg_int32_t) hg_atomic_get32(&hg_core_handle->ref_count);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4920,7 +4620,8 @@ hg_return_t
 HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     hg_uint8_t flags, hg_size_t payload_size)
 {
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) handle;
     hg_size_t header_size;
     hg_return_t ret = HG_SUCCESS;
 
@@ -4929,19 +4630,18 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
         ret = HG_INVALID_PARAM;
         goto done;
     }
-    if (hg_core_handle->hg_info.addr == HG_CORE_ADDR_NULL) {
+    if (hg_core_handle->core_handle.info.addr == HG_CORE_ADDR_NULL) {
         HG_LOG_ERROR("NULL target addr");
         ret = HG_INVALID_PARAM;
         goto done;
     }
-    if (!hg_core_handle->hg_info.id) {
+    if (!hg_core_handle->core_handle.info.id) {
         HG_LOG_ERROR("NULL RPC ID");
         ret = HG_INVALID_PARAM;
         goto done;
     }
 #ifndef HG_HAS_SELF_FORWARD
-    if (NA_Addr_is_self(hg_core_handle->hg_info.addr->na_class,
-        hg_core_handle->hg_info.addr->na_addr)) {
+    if (hg_core_handle->is_self) {
         HG_LOG_ERROR("Not enabled, please enable HG_USE_SELF_FORWARD");
         ret = HG_INVALID_PARAM;
         goto done;
@@ -4952,7 +4652,8 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
         /* Not safe to reset
          * TODO could add the ability to defer the reset operation */
         HG_LOG_ERROR("Not safe to use HG core handle, handle is still in use, "
-            "refcount: %d", hg_atomic_get32(&hg_core_handle->ref_count));
+            "refcount: %d", hg_atomic_get32(
+                &hg_core_handle->ref_count));
         ret = HG_PROTOCOL_ERROR;
         goto done;
     }
@@ -4968,11 +4669,11 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
 
     /* Set header size */
     header_size = hg_core_header_request_get_size() +
-        hg_core_handle->na_in_header_offset;
+        hg_core_handle->core_handle.na_in_header_offset;
 
     /* Set the actual size of the msg that needs to be transmitted */
     hg_core_handle->in_buf_used = header_size + payload_size;
-    if (hg_core_handle->in_buf_used > hg_core_handle->in_buf_size) {
+    if (hg_core_handle->in_buf_used > hg_core_handle->core_handle.in_buf_size) {
         HG_LOG_ERROR("Exceeding input buffer size");
         ret = HG_SIZE_ERROR;
         /* Handle is no longer in use */
@@ -4992,16 +4693,17 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     hg_core_handle->request_arg = arg;
 
     /* Set header */
-    hg_core_handle->in_header.msg.request.id = hg_core_handle->hg_info.id;
+    hg_core_handle->in_header.msg.request.id =
+        hg_core_handle->core_handle.info.id;
     hg_core_handle->in_header.msg.request.flags = flags;
     /* Set the cookie as origin context ID, so that when the cookie is unpacked
      * by the target and assigned to HG info context_id, the NA layer knows
      * which context ID it needs to send the response to. */
     hg_core_handle->in_header.msg.request.cookie =
-        hg_core_handle->hg_info.context->id;
+        hg_core_handle->core_handle.info.context->id;
 
     /* Encode request header */
-    ret = hg_core_proc_header_request(hg_core_handle,
+    ret = hg_core_proc_header_request(&hg_core_handle->core_handle,
         &hg_core_handle->in_header, HG_ENCODE);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not encode header");
@@ -5036,7 +4738,8 @@ hg_return_t
 HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     hg_uint8_t flags, hg_size_t payload_size)
 {
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
+    struct hg_core_private_handle *hg_core_handle =
+        (struct hg_core_private_handle *) handle;
     hg_size_t header_size;
     hg_return_t ret = HG_SUCCESS;
 
@@ -5046,8 +4749,8 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
         goto done;
     }
 #ifndef HG_HAS_SELF_FORWARD
-    if (NA_Addr_is_self(hg_core_handle->hg_info.addr->na_class,
-        hg_core_handle->hg_info.addr->na_addr)) {
+    if (NA_Addr_is_self(hg_core_handle->core_handle.info.addr->na_class,
+        hg_core_handle->core_handle.info.addr->na_addr)) {
         HG_LOG_ERROR("Not enabled, please enable HG_USE_SELF_FORWARD");
         ret = HG_INVALID_PARAM;
         goto done;
@@ -5062,11 +4765,12 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
 
     /* Set header size */
     header_size = hg_core_header_response_get_size() +
-        hg_core_handle->na_out_header_offset;
+        hg_core_handle->core_handle.na_out_header_offset;
 
     /* Set the actual size of the msg that needs to be transmitted */
     hg_core_handle->out_buf_used = header_size + payload_size;
-    if (hg_core_handle->out_buf_used > hg_core_handle->out_buf_size) {
+    if (hg_core_handle->out_buf_used
+        > hg_core_handle->core_handle.out_buf_size) {
         HG_LOG_ERROR("Exceeding output buffer size");
         ret = HG_SIZE_ERROR;
         goto done;
@@ -5083,7 +4787,7 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     hg_core_handle->out_header.msg.response.cookie = hg_core_handle->cookie;
 
     /* Encode response header */
-    ret = hg_core_proc_header_response(hg_core_handle,
+    ret = hg_core_proc_header_response(&hg_core_handle->core_handle,
         &hg_core_handle->out_header, HG_ENCODE);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not encode header");
@@ -5106,6 +4810,8 @@ done:
 hg_return_t
 HG_Core_progress(hg_core_context_t *context, unsigned int timeout)
 {
+    struct hg_core_private_context *private_context =
+        (struct hg_core_private_context *) context;
     hg_return_t ret = HG_SUCCESS;
 
     if (!context) {
@@ -5115,7 +4821,7 @@ HG_Core_progress(hg_core_context_t *context, unsigned int timeout)
     }
 
     /* Make progress on the HG layer */
-    ret = context->progress(context, timeout);
+    ret = private_context->progress(private_context, timeout);
     if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
         HG_LOG_ERROR("Could not make progress");
         goto done;
@@ -5138,7 +4844,8 @@ HG_Core_trigger(hg_core_context_t *context, unsigned int timeout,
         goto done;
     }
 
-    ret = hg_core_trigger(context, timeout, max_count, actual_count);
+    ret = hg_core_trigger((struct hg_core_private_context *) context, timeout,
+        max_count, actual_count);
     if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
         HG_LOG_ERROR("Could not trigger callbacks");
         goto done;
@@ -5152,16 +4859,15 @@ done:
 hg_return_t
 HG_Core_cancel(hg_core_handle_t handle)
 {
-    struct hg_core_handle *hg_core_handle = (struct hg_core_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_handle) {
+    if (!handle) {
         HG_LOG_ERROR("NULL handle");
         ret = HG_INVALID_PARAM;
         goto done;
     }
 
-    ret = hg_core_cancel(hg_core_handle);
+    ret = hg_core_cancel((struct hg_core_private_handle *) handle);
     if (ret != HG_SUCCESS) {
         HG_LOG_ERROR("Could not cancel handle");
         goto done;
diff --git a/src/mercury_core.h b/src/mercury_core.h
index 91d72f8..ebb18e9 100644
--- a/src/mercury_core.h
+++ b/src/mercury_core.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -12,6 +12,10 @@
 #define MERCURY_CORE_H
 
 #include "mercury_core_types.h"
+#include "mercury_core_header.h"
+#include "mercury_error.h"
+
+#include "na.h"
 
 /*************************************/
 /* Public Type and Struct Definition */
@@ -25,7 +29,7 @@ typedef struct hg_core_op_id *hg_core_op_id_t;    /* Abstract operation id */
 
 /* HG info struct */
 struct hg_core_info {
-    hg_core_class_t *hg_core_class; /* HG core class */
+    hg_core_class_t *core_class;    /* HG core class */
     hg_core_context_t *context;     /* HG core context */
     hg_core_addr_t addr;            /* HG address at target/origin */
     hg_uint8_t context_id;          /* Context ID at target/origin */
@@ -172,7 +176,7 @@ HG_Core_set_more_data_callback(
  *
  * \return the name of the class, or NULL if not a valid class
  */
-HG_EXPORT const char *
+static HG_INLINE const char *
 HG_Core_class_get_name(
         const hg_core_class_t *hg_core_class
         );
@@ -184,7 +188,7 @@ HG_Core_class_get_name(
  *
  * \return the protocol of the class, or NULL if not a valid class
  */
-HG_EXPORT const char *
+static HG_INLINE const char *
 HG_Core_class_get_protocol(
         const hg_core_class_t *hg_core_class
         );
@@ -196,7 +200,7 @@ HG_Core_class_get_protocol(
  *
  * \return HG_TRUE if listening or HG_FALSE if not, or not a valid class
  */
-HG_EXPORT hg_bool_t
+static HG_INLINE hg_bool_t
 HG_Core_class_is_listening(
         const hg_core_class_t *hg_core_class
         );
@@ -208,7 +212,7 @@ HG_Core_class_is_listening(
  *
  * \return Pointer to NA class or NULL if not a valid class
  */
-HG_EXPORT na_class_t *
+static HG_INLINE na_class_t *
 HG_Core_class_get_na(
         const hg_core_class_t *hg_core_class
         );
@@ -221,7 +225,7 @@ HG_Core_class_get_na(
  *
  * \return Pointer to NA SM class or NULL if not a valid class
  */
-HG_EXPORT na_class_t *
+static HG_INLINE na_class_t *
 HG_Core_class_get_na_sm(
         const hg_core_class_t *hg_core_class
         );
@@ -235,7 +239,7 @@ HG_Core_class_get_na_sm(
  * \return the maximum size, or 0 if hg_core_class is not a valid class or
  * XDR is being used
  */
-HG_EXPORT hg_size_t
+static HG_INLINE hg_size_t
 HG_Core_class_get_input_eager_size(
         const hg_core_class_t *hg_core_class
         );
@@ -248,7 +252,7 @@ HG_Core_class_get_input_eager_size(
  * \return the maximum size, or 0 if hg_core_class is not a valid class or XDR is
  * being used
  */
-HG_EXPORT hg_size_t
+static HG_INLINE hg_size_t
 HG_Core_class_get_output_eager_size(
         const hg_core_class_t *hg_core_class
         );
@@ -263,7 +267,7 @@ HG_Core_class_get_output_eager_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Core_class_set_data(
         hg_core_class_t *hg_core_class,
         void *data,
@@ -277,7 +281,7 @@ HG_Core_class_set_data(
  *
  * \return Pointer to user data or NULL if not set or any error has occurred
  */
-HG_EXPORT void *
+static HG_INLINE void *
 HG_Core_class_get_data(
         const hg_core_class_t *hg_core_class
         );
@@ -330,7 +334,7 @@ HG_Core_context_destroy(
  *
  * \return the associated class
  */
-HG_EXPORT hg_core_class_t *
+static HG_INLINE hg_core_class_t *
 HG_Core_context_get_class(
         const hg_core_context_t *context
         );
@@ -342,7 +346,7 @@ HG_Core_context_get_class(
  *
  * \return the associated context
  */
-HG_EXPORT na_context_t *
+static HG_INLINE na_context_t *
 HG_Core_context_get_na(
         const hg_core_context_t *context
         );
@@ -355,7 +359,7 @@ HG_Core_context_get_na(
  *
  * \return the associated context
  */
-HG_EXPORT na_context_t *
+static HG_INLINE na_context_t *
 HG_Core_context_get_na_sm(
         const hg_core_context_t *context
         );
@@ -368,7 +372,7 @@ HG_Core_context_get_na_sm(
  *
  * \return Non-negative integer (max value of 255) or 0 if no ID has been set
  */
-HG_EXPORT hg_uint8_t
+static HG_INLINE hg_uint8_t
 HG_Core_context_get_id(
         const hg_core_context_t *context
         );
@@ -383,7 +387,7 @@ HG_Core_context_get_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Core_context_set_data(
         hg_core_context_t *context,
         void *data,
@@ -397,7 +401,7 @@ HG_Core_context_set_data(
  *
  * \return Pointer to user data or NULL if not set or any error has occurred
  */
-HG_EXPORT void *
+static HG_INLINE void *
 HG_Core_context_get_data(
         const hg_core_context_t *context
         );
@@ -551,12 +555,14 @@ HG_Core_addr_lookup(
  * Create a HG core address.
  *
  * \param hg_core_class [IN]    pointer to HG core class
+ * \param new_addr [OUT]        pointer to abstract address
  *
- * \return created abstract HG core address or HG_CORE_ADDR_NULL if failed.
+ * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_core_addr_t
+HG_EXPORT hg_return_t
 HG_Core_addr_create(
-        hg_core_class_t *hg_core_class
+        hg_core_class_t *hg_core_class,
+        hg_core_addr_t *addr
         );
 
 /**
@@ -578,8 +584,10 @@ HG_Core_addr_free(
  *
  * \param core_addr [IN]        abstract address that not set NA address before
  * \param na_addr [IN]          abstract NA addr
+ *
+ * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT void
+static HG_INLINE hg_return_t
 HG_Core_addr_set_na(
         hg_core_addr_t core_addr,
         na_addr_t na_addr
@@ -592,7 +600,7 @@ HG_Core_addr_set_na(
  *
  * \return abstract NA addr or NA_ADDR_NULL if not a valid HG address
  */
-HG_EXPORT na_addr_t
+static HG_INLINE na_addr_t
 HG_Core_addr_get_na(
         hg_core_addr_t addr
         );
@@ -604,7 +612,7 @@ HG_Core_addr_get_na(
  *
  * \return Pointer to NA class or NULL if not a valid HG address
  */
-na_class_t *
+static HG_INLINE na_class_t *
 HG_Core_addr_get_na_class(
         hg_core_addr_t addr
         );
@@ -751,7 +759,7 @@ HG_Core_ref_get(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-hg_return_t
+static HG_INLINE hg_return_t
 HG_Core_set_data(
         hg_core_handle_t handle,
         void *data,
@@ -766,7 +774,7 @@ HG_Core_set_data(
  *
  * \return Pointer to user data or NULL if not set or any error has occurred
  */
-void *
+static HG_INLINE void *
 HG_Core_get_data(
         hg_core_handle_t handle
         );
@@ -780,11 +788,24 @@ HG_Core_get_data(
  *
  * \return Pointer to info or NULL in case of failure
  */
-HG_EXPORT const struct hg_core_info *
+static HG_INLINE const struct hg_core_info *
 HG_Core_get_info(
         hg_core_handle_t handle
         );
 
+/**
+ * Allows upper layers to retrieve cached RPC data from an existing HG handle.
+ * Only valid if HG_Core_register_data() has been previously called.
+ *
+ * \param handle [IN]           HG handle
+ *
+ * \return Pointer to user data or NULL if not set or any error has occurred
+ */
+static HG_INLINE const void *
+HG_Core_get_rpc_data(
+        hg_core_handle_t handle
+        );
+
 /**
  * Set target context ID that will receive and process the RPC request
  * (ID is defined on target context creation, see HG_Core_context_create_id()).
@@ -794,7 +815,7 @@ HG_Core_get_info(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Core_set_target_id(
         hg_core_handle_t handle,
         hg_uint8_t id
@@ -810,7 +831,7 @@ HG_Core_set_target_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Core_get_input(
         hg_core_handle_t handle,
         void **in_buf,
@@ -827,7 +848,7 @@ HG_Core_get_input(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+static HG_INLINE hg_return_t
 HG_Core_get_output(
         hg_core_handle_t handle,
         void **out_buf,
@@ -931,6 +952,449 @@ HG_Core_cancel(
         hg_core_handle_t handle
         );
 
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
+
+/* HG core class */
+struct hg_core_class {
+    na_class_t *na_class;               /* NA class */
+#ifdef HG_HAS_SM_ROUTING
+    na_class_t *na_sm_class;            /* NA SM class */
+#endif
+    void *data;                         /* User data */
+    void (*data_free_callback)(void *); /* User data free callback */
+};
+
+/* HG core context */
+struct hg_core_context {
+    struct hg_core_class *core_class;   /* HG core class */
+    na_context_t *na_context;           /* NA context */
+#ifdef HG_HAS_SM_ROUTING
+    na_context_t *na_sm_context;        /* NA SM context */
+#endif
+    hg_uint8_t id;                      /* Context ID */
+    void *data;                         /* User data */
+    void (*data_free_callback)(void *); /* User data free callback */
+};
+
+/* HG core addr */
+struct hg_core_addr {
+    na_class_t *na_class;               /* NA class from NA address */
+    na_addr_t na_addr;                  /* NA address */
+#ifdef HG_HAS_SM_ROUTING
+    na_addr_t na_sm_addr;               /* NA SM address */
+#endif
+};
+
+/* HG core RPC registration info */
+struct hg_core_rpc_info {
+    hg_core_rpc_cb_t rpc_cb;            /* RPC callback */
+    void *data;                         /* User data */
+    void (*free_callback)(void *);      /* User data free callback */
+};
+
+/* HG core handle */
+struct hg_core_handle {
+    struct hg_core_info info;           /* HG info */
+    struct hg_core_rpc_info *rpc_info;  /* Associated RPC registration info */
+    void *in_buf;                       /* Input buffer */
+    void *out_buf;                      /* Output buffer */
+    na_size_t in_buf_size;              /* Input buffer size */
+    na_size_t out_buf_size;             /* Output buffer size */
+    na_size_t na_in_header_offset;      /* Input NA header offset */
+    na_size_t na_out_header_offset;     /* Output NA header offset */
+    void *data;                         /* User data */
+    void (*data_free_callback)(void *); /* User data free callback */
+};
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE const char *
+HG_Core_class_get_name(const hg_core_class_t *hg_core_class)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return NULL;
+    }
+#endif
+    return NA_Get_class_name(hg_core_class->na_class);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE const char *
+HG_Core_class_get_protocol(const hg_core_class_t *hg_core_class)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return NULL;
+    }
+#endif
+    return NA_Get_class_protocol(hg_core_class->na_class);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_bool_t
+HG_Core_class_is_listening(const hg_core_class_t *hg_core_class)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return HG_FALSE;
+    }
+#endif
+    return NA_Is_listening(hg_core_class->na_class);
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE na_class_t *
+HG_Core_class_get_na(const hg_core_class_t *hg_core_class)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return NULL;
+    }
+#endif
+    return hg_core_class->na_class;
+}
+
+/*---------------------------------------------------------------------------*/
+#ifdef HG_HAS_SM_ROUTING
+static HG_INLINE na_class_t *
+HG_Core_class_get_na_sm(const hg_core_class_t *hg_core_class)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return NULL;
+    }
+#endif
+    return hg_core_class->na_sm_class;
+}
+#endif
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_size_t
+HG_Core_class_get_input_eager_size(const hg_core_class_t *hg_core_class)
+{
+    hg_size_t unexp, header;
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (hg_core_class == NULL) {
+        HG_LOG_ERROR("NULL HG core class");
+        return 0;
+    }
+#endif
+    unexp  = NA_Msg_get_max_unexpected_size(hg_core_class->na_class);
+    header = hg_core_header_request_get_size() +
+        NA_Msg_get_unexpected_header_size(hg_core_class->na_class);
+
+    return (unexp > header) ? unexp - header : 0;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_size_t
+HG_Core_class_get_output_eager_size(const hg_core_class_t *hg_core_class)
+{
+    hg_size_t exp, header;
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (hg_core_class == NULL) {
+        HG_LOG_ERROR("NULL HG core class");
+        return 0;
+    }
+#endif
+    exp    = NA_Msg_get_max_expected_size(hg_core_class->na_class);
+    header = hg_core_header_response_get_size() +
+        NA_Msg_get_expected_header_size(hg_core_class->na_class);
+
+    return (exp > header) ? exp - header : 0;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Core_class_set_data(hg_core_class_t *hg_core_class, void *data,
+    void (*free_callback)(void *))
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    hg_core_class->data = data;
+    hg_core_class->data_free_callback = free_callback;
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE void *
+HG_Core_class_get_data(const hg_core_class_t *hg_core_class)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return NULL;
+    }
+#endif
+    return hg_core_class->data;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_core_class_t *
+HG_Core_context_get_class(const hg_core_context_t *context)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return NULL;
+    }
+#endif
+    return context->core_class;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE na_context_t *
+HG_Core_context_get_na(const hg_core_context_t *context)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return NULL;
+    }
+#endif
+    return context->na_context;
+}
+
+/*---------------------------------------------------------------------------*/
+#ifdef HG_HAS_SM_ROUTING
+static HG_INLINE na_context_t *
+HG_Core_context_get_na_sm(const hg_core_context_t *context)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return NULL;
+    }
+#endif
+    return context->na_sm_context;
+}
+#endif
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_uint8_t
+HG_Core_context_get_id(const hg_core_context_t *context)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    return context->id;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Core_context_set_data(hg_core_context_t *context, void *data,
+    void (*free_callback)(void *))
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    context->data = data;
+    context->data_free_callback = free_callback;
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE void *
+HG_Core_context_get_data(const hg_core_context_t *context)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return NULL;
+    }
+#endif
+    return context->data;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Core_addr_set_na(hg_core_addr_t core_addr, na_addr_t na_addr)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (core_addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("NULL HG core address");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    core_addr->na_addr = na_addr;
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE na_addr_t
+HG_Core_addr_get_na(hg_core_addr_t addr)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("NULL addr");
+        return NA_ADDR_NULL;
+    }
+#endif
+    return addr->na_addr;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE na_class_t *
+HG_Core_addr_get_na_class(hg_core_addr_t addr)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("NULL addr");
+        return NULL;
+    }
+#endif
+    return addr->na_class;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Core_set_data(hg_core_handle_t handle, void *data,
+    void (*free_callback)(void *))
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    handle->data = data;
+    handle->data_free_callback = free_callback;
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE void *
+HG_Core_get_data(hg_core_handle_t handle)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return NULL;
+    }
+#endif
+    return handle->data;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE const struct hg_core_info *
+HG_Core_get_info(hg_core_handle_t handle)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return NULL;
+    }
+#endif
+    return &handle->info;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE const void *
+HG_Core_get_rpc_data(hg_core_handle_t handle)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return NULL;
+    }
+#endif
+    return (handle->rpc_info) ? handle->rpc_info->data : NULL;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Core_set_target_id(hg_core_handle_t handle, hg_uint8_t id)
+{
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG core handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
+    handle->info.context_id = id;
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_INLINE hg_return_t
+HG_Core_get_input(hg_core_handle_t handle, void **in_buf,
+    hg_size_t *in_buf_size)
+{
+    hg_size_t header_offset;
+
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL handle");
+        return HG_INVALID_PARAM;
+    }
+
+    if (!in_buf || !in_buf_size) {
+        HG_LOG_ERROR("NULL pointer");
+        return HG_INVALID_PARAM;
+    }
+#endif
+
+    header_offset = hg_core_header_request_get_size() +
+        handle->na_in_header_offset;
+
+    /* Space must be left for request header */
+    *in_buf = (char *) handle->in_buf + header_offset;
+    *in_buf_size = handle->in_buf_size - header_offset;
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
+HG_Core_get_output(hg_core_handle_t handle, void **out_buf,
+    hg_size_t *out_buf_size)
+{
+    hg_size_t header_offset;
+
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL handle");
+        return HG_INVALID_PARAM;
+    }
+
+    if (!out_buf || !out_buf_size) {
+        HG_LOG_ERROR("NULL pointer");
+        return HG_INVALID_PARAM;
+    }
+#endif
+
+    header_offset = hg_core_header_response_get_size() +
+        handle->na_out_header_offset;
+
+    /* Space must be left for response header */
+    *out_buf = (char *) handle->out_buf + header_offset;
+    *out_buf_size = handle->out_buf_size - header_offset;
+
+    return HG_SUCCESS;
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/mercury_core_header.c b/src/mercury_core_header.c
index 9940dc6..8794f69 100644
--- a/src/mercury_core_header.c
+++ b/src/mercury_core_header.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -12,6 +12,10 @@
 #include "mercury_proc_buf.h"
 #include "mercury_error.h"
 
+#ifdef HG_HAS_CHECKSUMS
+# include <mchecksum.h>
+#endif
+
 #ifdef _WIN32
 # include <winsock2.h>
 #else
diff --git a/src/mercury_core_header.h b/src/mercury_core_header.h
index d37ecf9..a72e24f 100644
--- a/src/mercury_core_header.h
+++ b/src/mercury_core_header.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -13,10 +13,6 @@
 
 #include "mercury_core_types.h"
 
-#ifdef HG_HAS_CHECKSUMS
-# include <mchecksum.h>
-#endif
-
 /*************************************/
 /* Public Type and Struct Definition */
 /*************************************/
@@ -66,7 +62,7 @@ struct hg_core_header {
         struct hg_core_header_response response;
     } msg;
 #ifdef HG_HAS_CHECKSUMS
-    mchecksum_object_t checksum;        /* Checksum of header */
+    void *checksum;        /* Checksum of header */
 #endif
 };
 
@@ -196,7 +192,6 @@ hg_core_header_response_reset(
         struct hg_core_header *hg_core_header
         );
 
-
 /**
  * Process private information for sending/receiving RPC request.
  *
diff --git a/src/mercury_core_types.h b/src/mercury_core_types.h
index e0d00e4..8e5d6ac 100644
--- a/src/mercury_core_types.h
+++ b/src/mercury_core_types.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -12,7 +12,7 @@
 #define MERCURY_CORE_TYPES_H
 
 #include "mercury_config.h"
-#include "na.h"
+#include "na_types.h"
 
 /*************************************/
 /* Public Type and Struct Definition */
diff --git a/src/mercury_error.h b/src/mercury_error.h
index 4cbcb9e..5b49a1b 100644
--- a/src/mercury_error.h
+++ b/src/mercury_error.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_header.c b/src/mercury_header.c
index 44d6646..296092b 100644
--- a/src/mercury_header.c
+++ b/src/mercury_header.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_header.h b/src/mercury_header.h
index 54a0083..74c458f 100644
--- a/src/mercury_header.h
+++ b/src/mercury_header.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_hl.c b/src/mercury_hl.c
index 284cab5..4cbd025 100644
--- a/src/mercury_hl.c
+++ b/src/mercury_hl.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_hl.h b/src/mercury_hl.h
index 1faadce..27938f3 100644
--- a/src/mercury_hl.h
+++ b/src/mercury_hl.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_hl_macros.h b/src/mercury_hl_macros.h
index 7ec184a..49d983b 100644
--- a/src/mercury_hl_macros.h
+++ b/src/mercury_hl_macros.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_macros.h b/src/mercury_macros.h
index 406e828..8f4e330 100644
--- a/src/mercury_macros.h
+++ b/src/mercury_macros.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_private.h b/src/mercury_private.h
index 40b9c4b..781d906 100644
--- a/src/mercury_private.h
+++ b/src/mercury_private.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -31,7 +31,7 @@ struct hg_completion_entry {
     hg_op_type_t op_type;
     union {
         struct hg_core_op_id *hg_core_op_id;
-        struct hg_core_handle *hg_core_handle;
+        hg_core_handle_t hg_core_handle;
         struct hg_bulk_op_id *hg_bulk_op_id;
     } op_id;
     HG_QUEUE_ENTRY(hg_completion_entry) entry;
diff --git a/src/mercury_proc.c b/src/mercury_proc.c
index 644e767..94fd0ca 100644
--- a/src/mercury_proc.c
+++ b/src/mercury_proc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_proc.h b/src/mercury_proc.h
index 446fb15..5553f7d 100644
--- a/src/mercury_proc.h
+++ b/src/mercury_proc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_proc_buf.h b/src/mercury_proc_buf.h
index 31a99c2..531a0e3 100644
--- a/src/mercury_proc_buf.h
+++ b/src/mercury_proc_buf.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_proc_bulk.h b/src/mercury_proc_bulk.h
index 739bec0..fccbe9c 100644
--- a/src/mercury_proc_bulk.h
+++ b/src/mercury_proc_bulk.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/mercury_types.h b/src/mercury_types.h
index 426bd18..d853875 100644
--- a/src/mercury_types.h
+++ b/src/mercury_types.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/na/CMakeLists.txt b/src/na/CMakeLists.txt
index f341a40..c2ee09c 100644
--- a/src/na/CMakeLists.txt
+++ b/src/na/CMakeLists.txt
@@ -325,9 +325,10 @@ install(
 # Specify project header files to be installed
 #-----------------------------------------------------------------------------
 set(NA_HEADERS
+  ${CMAKE_CURRENT_BINARY_DIR}/na_config.h
   ${CMAKE_CURRENT_SOURCE_DIR}/na.h
   ${CMAKE_CURRENT_SOURCE_DIR}/na_error.h
-  ${CMAKE_CURRENT_BINARY_DIR}/na_config.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/na_types.h
 )
 
 if(NA_HAS_MPI)
diff --git a/src/na/na.c b/src/na/na.c
index d128be5..013d8ec 100644
--- a/src/na/na.c
+++ b/src/na/na.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -8,16 +8,10 @@
  * found at the root of the source code distribution tree.
  */
 
-#include "na_private.h"
-#include "na_error.h"
+#include "na_plugin.h"
 
-#include "mercury_queue.h"
-#include "mercury_thread_mutex.h"
-#include "mercury_thread_condition.h"
 #include "mercury_time.h"
-#include "mercury_atomic.h"
 #include "mercury_mem.h"
-#include "mercury_atomic_queue.h"
 
 #include <stdlib.h>
 #include <string.h>
@@ -47,26 +41,23 @@
 
 struct na_private_class {
     struct na_class na_class;                   /* Must remain as first field */
-    char * protocol_name;                       /* Name of protocol */
-    na_bool_t listen;                           /* Listen for connections */
-    na_progress_mode_t progress_mode;           /* NA progress mode */
 };
 
 /* Private context / do not expose private members to plugins */
 struct na_private_context {
     struct na_context context;                  /* Must remain as first field */
     na_class_t *na_class;                       /* Pointer to NA class */
-    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
-    HG_QUEUE_HEAD(na_cb_completion_data) backfill_queue; /* Backfill completion queue */
-    hg_atomic_int32_t backfill_queue_count;     /* Number of entries in backfill queue */
-    hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
-    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
-    hg_atomic_int32_t trigger_waiting;          /* Polling/waiting in trigger */
 #ifdef NA_HAS_MULTI_PROGRESS
     hg_thread_mutex_t progress_mutex;           /* Progress mutex */
     hg_thread_cond_t  progress_cond;            /* Progress cond */
     hg_atomic_int32_t progressing;              /* Progressing count */
 #endif
+    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
+    hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
+    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
+    HG_QUEUE_HEAD(na_cb_completion_data) backfill_queue; /* Backfill completion queue */
+    hg_atomic_int32_t backfill_queue_count;     /* Number of entries in backfill queue */
+    hg_atomic_int32_t trigger_waiting;          /* Polling/waiting in trigger */
 };
 
 /********************/
@@ -95,37 +86,22 @@ na_info_print(struct na_info *na_info);
 /*******************/
 /* Local Variables */
 /*******************/
-#ifdef NA_HAS_SM
-extern na_class_t na_sm_class_g;
-#endif
-#ifdef NA_HAS_BMI
-extern na_class_t na_bmi_class_g;
-#endif
-#ifdef NA_HAS_MPI
-extern na_class_t na_mpi_class_g;
-#endif
-#ifdef NA_HAS_CCI
-extern na_class_t na_cci_class_g;
-#endif
-#ifdef NA_HAS_OFI
-extern na_class_t na_ofi_class_g;
-#endif
 
-static const na_class_t *na_class_table[] = {
+static const struct na_class_ops *na_class_table[] = {
 #ifdef NA_HAS_SM
-    &na_sm_class_g, /* Keep NA SM first for protocol selection */
+    &na_sm_class_ops_g, /* Keep NA SM first for protocol selection */
 #endif
 #ifdef NA_HAS_BMI
-    &na_bmi_class_g,
+    &na_bmi_class_ops_g,
 #endif
 #ifdef NA_HAS_MPI
-    &na_mpi_class_g,
+    &na_mpi_class_ops_g,
 #endif
 #ifdef NA_HAS_CCI
-    &na_cci_class_g,
+    &na_cci_class_ops_g,
 #endif
 #ifdef NA_HAS_OFI
-    &na_ofi_class_g,
+    &na_ofi_class_ops_g,
 #endif
     NULL
 };
@@ -301,7 +277,7 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
     }
     na_info->na_init_info = na_init_info;
     if (na_init_info)
-        na_private_class->progress_mode = na_init_info->progress_mode;
+        na_private_class->na_class.progress_mode = na_init_info->progress_mode;
 
 #ifdef NA_DEBUG
     na_info_print(na_info);
@@ -368,30 +344,30 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
         goto done;
     }
 
-    na_private_class->na_class = *na_class_table[plugin_index];
-    if (!na_private_class->na_class.initialize) {
+    na_private_class->na_class.ops = na_class_table[plugin_index];
+    if (!na_private_class->na_class.ops->initialize) {
         NA_LOG_ERROR("initialize plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
-    ret = na_private_class->na_class.initialize(&na_private_class->na_class,
-        na_info, listen);
+    ret = na_private_class->na_class.ops->initialize(
+        &na_private_class->na_class, na_info, listen);
     if (ret != NA_SUCCESS) {
         NA_LOG_ERROR("Could not initialize plugin");
         goto done;
     }
-    na_private_class->protocol_name = strdup(na_info->protocol_name);
-    if (!na_private_class->protocol_name) {
+    na_private_class->na_class.protocol_name = strdup(na_info->protocol_name);
+    if (!na_private_class->na_class.protocol_name) {
         NA_LOG_ERROR("Could not duplicate protocol name");
         ret = NA_NOMEM_ERROR;
         goto done;
     }
-    na_private_class->listen = listen;
+    na_private_class->na_class.listen = listen;
 
 done:
     if (ret != NA_SUCCESS) {
         if (na_private_class) {
-            free(na_private_class->protocol_name);
+            free(na_private_class->na_class.protocol_name);
         }
         free(na_private_class);
         na_private_class = NULL;
@@ -409,15 +385,15 @@ NA_Finalize(na_class_t *na_class)
     na_return_t ret = NA_SUCCESS;
 
     if (!na_private_class) goto done;
-    if (!na_class->finalize) {
+    if (!na_class->ops->finalize) {
         NA_LOG_ERROR("finalize plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_private_class->na_class.finalize(&na_private_class->na_class);
+    ret = na_class->ops->finalize(&na_private_class->na_class);
 
-    free(na_private_class->protocol_name);
+    free(na_private_class->na_class.protocol_name);
     free(na_private_class);
 
 done:
@@ -440,61 +416,6 @@ NA_Cleanup(void)
     }
 }
 
-/*---------------------------------------------------------------------------*/
-const char *
-NA_Get_class_name(const na_class_t *na_class)
-{
-    const char *ret = NULL;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-
-    ret = na_class->class_name;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-const char *
-NA_Get_class_protocol(const na_class_t *na_class)
-{
-    const char *ret = NULL;
-    const struct na_private_class *na_private_class =
-        (const struct na_private_class *) na_class;
-
-    if (!na_private_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-
-    ret = na_private_class->protocol_name;
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_bool_t
-NA_Is_listening(const na_class_t *na_class)
-{
-    const struct na_private_class *na_private_class =
-        (const struct na_private_class *) na_class;
-    na_bool_t ret = NA_FALSE;
-
-    if (!na_private_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-
-    ret = na_private_class->listen;
-
-done:
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 na_context_t *
 NA_Context_create(na_class_t *na_class)
@@ -524,8 +445,8 @@ NA_Context_create_id(na_class_t *na_class, na_uint8_t id)
     }
     na_private_context->na_class = na_class;
 
-    if (na_class->context_create) {
-        ret = na_class->context_create(na_class,
+    if (na_class->ops->context_create) {
+        ret = na_class->ops->context_create(na_class,
             &na_private_context->context.plugin_context, id);
         if (ret != NA_SUCCESS) {
             goto done;
@@ -601,8 +522,8 @@ NA_Context_destroy(na_class_t *na_class, na_context_t *context)
     hg_thread_cond_destroy(&na_private_context->completion_queue_cond);
 
     /* Destroy NA plugin context */
-    if (na_class->context_destroy) {
-        ret = na_class->context_destroy(na_class,
+    if (na_class->ops->context_destroy) {
+        ret = na_class->ops->context_destroy(na_class,
             na_private_context->context.plugin_context);
         if (ret != NA_SUCCESS) {
             goto done;
@@ -631,12 +552,12 @@ NA_Op_create(na_class_t *na_class)
         NA_LOG_ERROR("NULL NA class");
         goto done;
     }
-    if (!na_class->op_create) {
+    if (!na_class->ops->op_create) {
         /* Not provided */
         goto done;
     }
 
-    ret = na_class->op_create(na_class);
+    ret = na_class->ops->op_create(na_class);
 
 done:
     return ret;
@@ -657,12 +578,12 @@ NA_Op_destroy(na_class_t *na_class, na_op_id_t op_id)
         /* Nothing to do */
         goto done;
     }
-    if (!na_class->op_destroy) {
+    if (!na_class->ops->op_destroy) {
         /* Not provided */
         goto done;
     }
 
-    ret = na_class->op_destroy(na_class, op_id);
+    ret = na_class->ops->op_destroy(na_class, op_id);
 
 done:
     return ret;
@@ -692,7 +613,7 @@ NA_Addr_lookup(na_class_t *na_class, na_context_t *context, na_cb_t callback,
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->addr_lookup) {
+    if (!na_class->ops->addr_lookup) {
         NA_LOG_ERROR("addr_lookup plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
@@ -713,8 +634,8 @@ NA_Addr_lookup(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     else
         short_name = name_string;
 
-    ret = na_class->addr_lookup(na_class, context, callback, arg, short_name,
-        op_id);
+    ret = na_class->ops->addr_lookup(na_class, context, callback, arg,
+        short_name, op_id);
     if (ret != NA_SUCCESS) {
         goto done;
     }
@@ -740,13 +661,13 @@ NA_Addr_self(na_class_t *na_class, na_addr_t *addr)
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->addr_self) {
+    if (!na_class->ops->addr_self) {
         NA_LOG_ERROR("addr_self plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->addr_self(na_class, addr);
+    ret = na_class->ops->addr_self(na_class, addr);
 
 done:
     return ret;
@@ -773,13 +694,13 @@ NA_Addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr)
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->addr_dup) {
+    if (!na_class->ops->addr_dup) {
         NA_LOG_ERROR("addr_dup plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->addr_dup(na_class, addr, new_addr);
+    ret = na_class->ops->addr_dup(na_class, addr, new_addr);
 
 done:
     return ret;
@@ -799,34 +720,13 @@ NA_Addr_free(na_class_t *na_class, na_addr_t addr)
     if (addr == NA_ADDR_NULL)
         /* Nothing to do */
         goto done;
-    if (!na_class->addr_free) {
+    if (!na_class->ops->addr_free) {
         NA_LOG_ERROR("addr_free plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->addr_free(na_class, addr);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_bool_t
-NA_Addr_is_self(na_class_t *na_class, na_addr_t addr)
-{
-    na_bool_t ret = NA_FALSE;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!na_class->addr_is_self) {
-        NA_LOG_ERROR("addr_is_self plugin callback is not defined");
-        goto done;
-    }
-
-    ret = na_class->addr_is_self(na_class, addr);
+    ret = na_class->ops->addr_free(na_class, addr);
 
 done:
     return ret;
@@ -857,7 +757,7 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->addr_to_string) {
+    if (!na_class->ops->addr_to_string) {
         NA_LOG_ERROR("addr_to_string plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
@@ -865,14 +765,14 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
 
     /* Automatically prepend string by plugin name with class delimiter,
      * except for MPI plugin (special case, because of generated string) */
-    if (strcmp(na_class->class_name, "mpi") == 0) {
+    if (strcmp(na_class->ops->class_name, "mpi") == 0) {
         buf_size_used = 0;
         plugin_buf_size = *buf_size;
     } else {
-        buf_size_used = strlen(na_class->class_name) + 1;
+        buf_size_used = strlen(na_class->ops->class_name) + 1;
         if (buf_ptr) {
             if (*buf_size > buf_size_used) {
-                strcpy(buf_ptr, na_class->class_name);
+                strcpy(buf_ptr, na_class->ops->class_name);
                 strcat(buf_ptr, NA_CLASS_DELIMITER);
                 buf_ptr += buf_size_used;
                 plugin_buf_size = *buf_size - buf_size_used;
@@ -886,7 +786,8 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
         }
     }
 
-    ret = na_class->addr_to_string(na_class, buf_ptr, &plugin_buf_size, addr);
+    ret = na_class->ops->addr_to_string(na_class, buf_ptr, &plugin_buf_size,
+        addr);
 
     *buf_size = buf_size_used + plugin_buf_size;
 
@@ -894,31 +795,6 @@ done:
     return ret;
 }
 
-/*---------------------------------------------------------------------------*/
-na_size_t
-NA_Addr_get_serialize_size(na_class_t *na_class, na_addr_t addr)
-{
-    na_size_t ret = 0;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        goto done;
-    }
-    if (!na_class->addr_get_serialize_size) {
-        NA_LOG_ERROR("addr_get_serialize_size plugin callback is not defined");
-        goto done;
-    }
-
-    ret = na_class->addr_get_serialize_size(na_class, addr);
-
-done:
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 na_return_t
 NA_Addr_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
@@ -946,13 +822,13 @@ NA_Addr_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->addr_serialize) {
+    if (!na_class->ops->addr_serialize) {
         NA_LOG_ERROR("addr_serialize plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->addr_serialize(na_class, buf, buf_size, addr);
+    ret = na_class->ops->addr_serialize(na_class, buf, buf_size, addr);
 
 done:
     return ret;
@@ -985,112 +861,13 @@ NA_Addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->addr_deserialize) {
+    if (!na_class->ops->addr_deserialize) {
         NA_LOG_ERROR("addr_deserialize plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->addr_deserialize(na_class, addr, buf, buf_size);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_size_t
-NA_Msg_get_max_unexpected_size(const na_class_t *na_class)
-{
-    na_size_t ret = 0;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!na_class->msg_get_max_unexpected_size) {
-        NA_LOG_ERROR("msg_get_max_unexpected_size plugin callback is not defined");
-        goto done;
-    }
-
-    ret = na_class->msg_get_max_unexpected_size(na_class);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_size_t
-NA_Msg_get_max_expected_size(const na_class_t *na_class)
-{
-    na_size_t ret = 0;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!na_class->msg_get_max_expected_size) {
-        NA_LOG_ERROR("msg_get_max_expected_size plugin callback is not defined");
-        goto done;
-    }
-
-    ret = na_class->msg_get_max_expected_size(na_class);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_size_t
-NA_Msg_get_unexpected_header_size(const na_class_t *na_class)
-{
-    na_size_t ret = 0;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-
-    if (na_class->msg_get_unexpected_header_size)
-        ret = na_class->msg_get_unexpected_header_size(na_class);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_size_t
-NA_Msg_get_expected_header_size(const na_class_t *na_class)
-{
-    na_size_t ret = 0;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-
-    if (na_class->msg_get_expected_header_size)
-        ret = na_class->msg_get_expected_header_size(na_class);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_tag_t
-NA_Msg_get_max_tag(const na_class_t *na_class)
-{
-    na_tag_t ret = 0;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!na_class->msg_get_max_tag) {
-        NA_LOG_ERROR("msg_get_max_tag plugin callback is not defined");
-        goto done;
-    }
-
-    ret = na_class->msg_get_max_tag(na_class);
+    ret = na_class->ops->addr_deserialize(na_class, addr, buf, buf_size);
 
 done:
     return ret;
@@ -1115,8 +892,8 @@ NA_Msg_buf_alloc(na_class_t *na_class, na_size_t buf_size, void **plugin_data)
         goto done;
     }
 
-    if (na_class->msg_buf_alloc)
-        ret = na_class->msg_buf_alloc(na_class, buf_size, plugin_data);
+    if (na_class->ops->msg_buf_alloc)
+        ret = na_class->ops->msg_buf_alloc(na_class, buf_size, plugin_data);
     else {
         na_size_t page_size = (na_size_t) hg_mem_get_page_size();
 
@@ -1150,8 +927,8 @@ NA_Msg_buf_free(na_class_t *na_class, void *buf, void *plugin_data)
         goto done;
     }
 
-    if (na_class->msg_buf_free)
-        ret = na_class->msg_buf_free(na_class, buf, plugin_data);
+    if (na_class->ops->msg_buf_free)
+        ret = na_class->ops->msg_buf_free(na_class, buf, plugin_data);
     else {
         if (plugin_data != (void *)1) {
             NA_LOG_ERROR("Invalid plugin data value");
@@ -1187,96 +964,8 @@ NA_Msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
         goto done;
     }
 
-    if (na_class->msg_init_unexpected)
-        ret = na_class->msg_init_unexpected(na_class, buf, buf_size);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_return_t
-NA_Msg_send_unexpected(na_class_t *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
-    void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
-    na_op_id_t *op_id)
-{
-    na_return_t ret = NA_SUCCESS;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (dest_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->msg_send_unexpected) {
-        NA_LOG_ERROR("msg_send_unexpected plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    ret = na_class->msg_send_unexpected(na_class, context, callback, arg, buf,
-        buf_size, plugin_data, dest_addr, dest_id, tag, op_id);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_return_t
-NA_Msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
-    void *plugin_data, na_op_id_t *op_id)
-{
-    na_return_t ret = NA_SUCCESS;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->msg_recv_unexpected) {
-        NA_LOG_ERROR("msg_recv_unexpected plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    ret = na_class->msg_recv_unexpected(na_class, context, callback, arg, buf,
-        buf_size, plugin_data, op_id);
+    if (na_class->ops->msg_init_unexpected)
+        ret = na_class->ops->msg_init_unexpected(na_class, buf, buf_size);
 
 done:
     return ret;
@@ -1304,102 +993,8 @@ NA_Msg_init_expected(na_class_t *na_class, void *buf, na_size_t buf_size)
         goto done;
     }
 
-    if (na_class->msg_init_expected)
-        ret = na_class->msg_init_expected(na_class, buf, buf_size);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_return_t
-NA_Msg_send_expected(na_class_t *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
-    void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
-    na_op_id_t *op_id)
-{
-    na_return_t ret = NA_SUCCESS;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (dest_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->msg_send_expected) {
-        NA_LOG_ERROR("msg_send_expected plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    ret = na_class->msg_send_expected(na_class, context, callback, arg, buf,
-        buf_size, plugin_data, dest_addr, dest_id, tag, op_id);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_return_t
-NA_Msg_recv_expected(na_class_t *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
-    void *plugin_data, na_addr_t source_addr, na_uint8_t source_id,
-    na_tag_t tag, na_op_id_t *op_id)
-{
-    na_return_t ret = NA_SUCCESS;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (source_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->msg_recv_expected) {
-        NA_LOG_ERROR("msg_recv_expected plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    ret = na_class->msg_recv_expected(na_class, context, callback, arg, buf,
-        buf_size, plugin_data, source_addr, source_id, tag, op_id);
+    if (na_class->ops->msg_init_expected)
+        ret = na_class->ops->msg_init_expected(na_class, buf, buf_size);
 
 done:
     return ret;
@@ -1427,13 +1022,13 @@ NA_Mem_handle_create(na_class_t *na_class, void *buf, na_size_t buf_size,
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->mem_handle_create) {
+    if (!na_class->ops->mem_handle_create) {
         NA_LOG_ERROR("mem_handle_create plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->mem_handle_create(na_class, buf, buf_size, flags,
+    ret = na_class->ops->mem_handle_create(na_class, buf, buf_size, flags,
         mem_handle);
 
 done:
@@ -1463,13 +1058,13 @@ NA_Mem_handle_create_segments(na_class_t *na_class, struct na_segment *segments,
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->mem_handle_create_segments) {
+    if (!na_class->ops->mem_handle_create_segments) {
         NA_LOG_ERROR("mem_handle_create_segments plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->mem_handle_create_segments(na_class, segments,
+    ret = na_class->ops->mem_handle_create_segments(na_class, segments,
         segment_count, flags, mem_handle);
 
 done:
@@ -1492,13 +1087,13 @@ NA_Mem_handle_free(na_class_t *na_class, na_mem_handle_t mem_handle)
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->mem_handle_free) {
+    if (!na_class->ops->mem_handle_free) {
         NA_LOG_ERROR("mem_handle_free plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->mem_handle_free(na_class, mem_handle);
+    ret = na_class->ops->mem_handle_free(na_class, mem_handle);
 
 done:
     return ret;
@@ -1521,9 +1116,9 @@ NA_Mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
         goto done;
     }
 
-    if (na_class->mem_register) {
+    if (na_class->ops->mem_register) {
         /* Optional */
-        ret = na_class->mem_register(na_class, mem_handle);
+        ret = na_class->ops->mem_register(na_class, mem_handle);
     }
 
 done:
@@ -1547,9 +1142,9 @@ NA_Mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
         goto done;
     }
 
-    if (na_class->mem_deregister) {
+    if (na_class->ops->mem_deregister) {
         /* Optional */
-        ret = na_class->mem_deregister(na_class, mem_handle);
+        ret = na_class->ops->mem_deregister(na_class, mem_handle);
     }
 
 done:
@@ -1573,9 +1168,9 @@ NA_Mem_publish(na_class_t *na_class, na_mem_handle_t mem_handle)
         goto done;
     }
 
-    if (na_class->mem_publish) {
+    if (na_class->ops->mem_publish) {
         /* Optional */
-        ret = na_class->mem_publish(na_class, mem_handle);
+        ret = na_class->ops->mem_publish(na_class, mem_handle);
     }
 
 done:
@@ -1599,39 +1194,11 @@ NA_Mem_unpublish(na_class_t *na_class, na_mem_handle_t mem_handle)
         goto done;
     }
 
-    if (na_class->mem_unpublish) {
+    if (na_class->ops->mem_unpublish) {
         /* Optional */
-        ret = na_class->mem_unpublish(na_class, mem_handle);
-    }
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_size_t
-NA_Mem_handle_get_serialize_size(na_class_t *na_class,
-    na_mem_handle_t mem_handle)
-{
-    na_size_t ret = 0;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    /* mem_handle parameter is optional */
-    if (!na_class->mem_handle_get_serialize_size) {
-        NA_LOG_ERROR("mem_handle_get_serialize_size plugin callback is not defined");
-        goto done;
+        ret = na_class->ops->mem_unpublish(na_class, mem_handle);
     }
 
-    ret = na_class->mem_handle_get_serialize_size(na_class, mem_handle);
-
 done:
     return ret;
 }
@@ -1663,13 +1230,14 @@ NA_Mem_handle_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->mem_handle_serialize) {
+    if (!na_class->ops->mem_handle_serialize) {
         NA_LOG_ERROR("mem_handle_serialize plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->mem_handle_serialize(na_class, buf, buf_size, mem_handle);
+    ret = na_class->ops->mem_handle_serialize(na_class, buf, buf_size,
+        mem_handle);
 
 done:
     return ret;
@@ -1702,145 +1270,14 @@ NA_Mem_handle_deserialize(na_class_t *na_class, na_mem_handle_t *mem_handle,
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->mem_handle_deserialize) {
+    if (!na_class->ops->mem_handle_deserialize) {
         NA_LOG_ERROR("mem_handle_deserialize plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->mem_handle_deserialize(na_class, mem_handle, buf, buf_size);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_return_t
-NA_Put(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
-    na_mem_handle_t local_mem_handle, na_offset_t local_offset,
-    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset,
-    na_size_t data_size, na_addr_t remote_addr, na_uint8_t remote_id,
-    na_op_id_t *op_id)
-{
-    na_return_t ret = NA_SUCCESS;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (local_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (remote_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!data_size) {
-        NA_LOG_ERROR("NULL data size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (remote_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->put) {
-        NA_LOG_ERROR("put plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    ret = na_class->put(na_class, context, callback, arg, local_mem_handle,
-        local_offset, remote_mem_handle, remote_offset, data_size,
-        remote_addr, remote_id, op_id);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-na_return_t
-NA_Get(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
-    na_mem_handle_t local_mem_handle, na_offset_t local_offset,
-    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset,
-    na_size_t data_size, na_addr_t remote_addr, na_uint8_t remote_id,
-    na_op_id_t *op_id)
-{
-    na_return_t ret = NA_SUCCESS;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (local_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (remote_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!data_size) {
-        NA_LOG_ERROR("NULL data size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (remote_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->get) {
-        NA_LOG_ERROR("get plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    ret = na_class->get(na_class, context, callback, arg, local_mem_handle,
-        local_offset, remote_mem_handle, remote_offset, data_size,
-        remote_addr, remote_id, op_id);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-int
-NA_Poll_get_fd(na_class_t *na_class, na_context_t *context)
-{
-    int ret = -1;
-
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        goto done;
-    }
-    if (!na_class->na_poll_get_fd) {
-        goto done;
-    }
-
-    ret = na_class->na_poll_get_fd(na_class, context);
+    ret = na_class->ops->mem_handle_deserialize(na_class, mem_handle, buf,
+        buf_size);
 
 done:
     return ret;
@@ -1850,11 +1287,9 @@ done:
 na_bool_t
 NA_Poll_try_wait(na_class_t *na_class, na_context_t *context)
 {
-    struct na_private_class *na_private_class =
-        (struct na_private_class *) na_class;
     struct na_private_context *na_private_context =
         (struct na_private_context *) context;
-
+#ifdef NA_HAS_VERBOSE_ERROR
     if (!na_class) {
         NA_LOG_ERROR("NULL NA class");
         return NA_FALSE;
@@ -1863,9 +1298,9 @@ NA_Poll_try_wait(na_class_t *na_class, na_context_t *context)
         NA_LOG_ERROR("NULL context");
         return NA_FALSE;
     }
-
+#endif
     /* Do not try to wait if NA_NO_BLOCK is set */
-    if (na_private_class->progress_mode == NA_NO_BLOCK)
+    if (na_class->progress_mode == NA_NO_BLOCK)
         return NA_FALSE;
 
     /* Something is in one of the completion queues */
@@ -1875,8 +1310,8 @@ NA_Poll_try_wait(na_class_t *na_class, na_context_t *context)
     }
 
     /* Check plugin try wait */
-    if (na_class->na_poll_try_wait)
-        return na_class->na_poll_try_wait(na_class, context);
+    if (na_class->ops->na_poll_try_wait)
+        return na_class->ops->na_poll_try_wait(na_class, context);
 
     return NA_TRUE;
 }
@@ -1905,14 +1340,14 @@ NA_Progress(na_class_t *na_class, na_context_t *context, unsigned int timeout)
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->progress) {
+    if (!na_class->ops->progress) {
         NA_LOG_ERROR("progress plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
     /* Do not block if NA_NO_BLOCK option is passed */
-    if (na_private_class->progress_mode == NA_NO_BLOCK) {
+    if (na_private_class->na_class.progress_mode == NA_NO_BLOCK) {
         remaining = 0;
     } else {
         remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
@@ -1964,8 +1399,8 @@ NA_Progress(na_class_t *na_class, na_context_t *context, unsigned int timeout)
 #endif
 
     /* Something is in one of the completion queues */
-    if (!hg_atomic_queue_is_empty(na_private_context->completion_queue) ||
-        hg_atomic_get32(&na_private_context->backfill_queue_count)) {
+    if (!hg_atomic_queue_is_empty(na_private_context->completion_queue)
+        || hg_atomic_get32(&na_private_context->backfill_queue_count)) {
         ret = NA_SUCCESS; /* Progressed */
 #ifdef NA_HAS_MULTI_PROGRESS
         goto unlock;
@@ -1975,7 +1410,7 @@ NA_Progress(na_class_t *na_class, na_context_t *context, unsigned int timeout)
     }
 
     /* Try to make progress for remaining time */
-    ret = na_class->progress(na_class, context,
+    ret = na_class->ops->progress(na_class, context,
         (unsigned int) (remaining * 1000.0));
 
 #ifdef NA_HAS_MULTI_PROGRESS
@@ -2017,7 +1452,7 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
 
     /* Do not block if NA_NO_BLOCK option is passed */
     na_private_class = (struct na_private_class *) na_private_context->na_class;
-    if (na_private_class->progress_mode == NA_NO_BLOCK) {
+    if (na_private_class->na_class.progress_mode == NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
     } else {
@@ -2027,16 +1462,17 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
     while (count < max_count) {
         struct na_cb_completion_data *completion_data = NULL;
 
-        completion_data =
-            hg_atomic_queue_pop_mc(na_private_context->completion_queue);
+        completion_data = hg_atomic_queue_pop_mc(
+            na_private_context->completion_queue);
         if (!completion_data) {
             /* Check backfill queue */
             if (hg_atomic_get32(&na_private_context->backfill_queue_count)) {
                 hg_thread_mutex_lock(
                     &na_private_context->completion_queue_mutex);
-                completion_data =
-                    HG_QUEUE_FIRST(&na_private_context->backfill_queue);
-                HG_QUEUE_POP_HEAD(&na_private_context->backfill_queue, entry);
+                completion_data = HG_QUEUE_FIRST(
+                    &na_private_context->backfill_queue);
+                HG_QUEUE_POP_HEAD(&na_private_context->backfill_queue,
+                    entry);
                 hg_atomic_decr32(&na_private_context->backfill_queue_count);
                 hg_thread_mutex_unlock(
                     &na_private_context->completion_queue_mutex);
@@ -2067,8 +1503,8 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
                         &na_private_context->backfill_queue_count)) {
                     if (hg_thread_cond_timedwait(
                         &na_private_context->completion_queue_cond,
-                        &na_private_context->completion_queue_mutex, timeout)
-                        != HG_UTIL_SUCCESS) {
+                        &na_private_context->completion_queue_mutex,
+                        timeout) != HG_UTIL_SUCCESS) {
                         /* Timeout occurred so leave */
                         ret = NA_TIMEOUT;
                         break;
@@ -2141,13 +1577,13 @@ NA_Cancel(na_class_t *na_class, na_context_t *context, na_op_id_t op_id)
         ret = NA_INVALID_PARAM;
         goto done;
     }
-    if (!na_class->cancel) {
+    if (!na_class->ops->cancel) {
         NA_LOG_ERROR("cancel plugin callback is not defined");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    ret = na_class->cancel(na_class, context, op_id);
+    ret = na_class->ops->cancel(na_class, context, op_id);
 
 done:
     return ret;
diff --git a/src/na/na.h b/src/na/na.h
index 4a9c7c3..ada6784 100644
--- a/src/na/na.h
+++ b/src/na/na.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -11,116 +11,20 @@
 #ifndef NA_H
 #define NA_H
 
-#include "na_config.h"
-
-#include <limits.h>
+#include "na_types.h"
+#include "na_error.h"
 
 /*************************************/
 /* Public Type and Struct Definition */
 /*************************************/
 
-typedef struct na_class na_class_t;     /* Opaque NA class */
-typedef struct na_context na_context_t; /* Opaque NA execution context */
-typedef void *na_addr_t;                /* Abstract NA address */
-typedef na_uint64_t na_size_t;          /* Size */
-typedef na_uint32_t na_tag_t;           /* Tag */
-typedef void *na_op_id_t;               /* Abstract operation id */
-
-typedef void *na_mem_handle_t;          /* Abstract memory handle */
-typedef na_uint64_t na_offset_t;        /* Offset */
-
-/* Progress mode */
-typedef enum na_progress_mode {
-    NA_DEFAULT,     /*!< blocking progress, depending on timeout value */
-    NA_NO_BLOCK     /*!< no blocking progress, independent of timeout value */
-} na_progress_mode_t;
-
-/* Init info */
-struct na_init_info {
-    na_progress_mode_t progress_mode;   /* Progress mode */
-    na_uint8_t max_contexts;            /* Max contexts */
-    const char *auth_key;               /* Authorization key */
-};
-
-/* Segment */
-struct na_segment {
-    na_ptr_t address;   /* Address of the segment */
-    na_size_t size;     /* Size of the segment in bytes */
-};
-
-/* Error return codes:
- * Functions return 0 for success or NA_XXX_ERROR for failure */
-typedef enum na_return {
-    NA_SUCCESS,             /*!< operation succeeded */
-    NA_TIMEOUT,             /*!< reached timeout */
-    NA_INVALID_PARAM,       /*!< invalid parameter */
-    NA_SIZE_ERROR,          /*!< message size error */
-    NA_ALIGNMENT_ERROR,     /*!< alignment error */
-    NA_PERMISSION_ERROR,    /*!< read/write permission error */
-    NA_NOMEM_ERROR,         /*!< no memory error */
-    NA_PROTOCOL_ERROR,      /*!< unknown error reported from the protocol layer */
-    NA_CANCELED,            /*!< operation was canceled */
-    NA_ADDRINUSE_ERROR      /*!< address already in use */
-} na_return_t;
-
-/* Callback operation type */
-typedef enum na_cb_type {
-    NA_CB_LOOKUP,           /*!< lookup callback */
-    NA_CB_SEND_UNEXPECTED,  /*!< unexpected send callback */
-    NA_CB_RECV_UNEXPECTED,  /*!< unexpected recv callback */
-    NA_CB_SEND_EXPECTED,    /*!< expected send callback */
-    NA_CB_RECV_EXPECTED,    /*!< expected recv callback */
-    NA_CB_PUT,              /*!< put callback */
-    NA_CB_GET               /*!< get callback */
-} na_cb_type_t;
-
-/* Callback info structs */
-struct na_cb_info_lookup {
-    na_addr_t addr;
-};
-
-struct na_cb_info_recv_unexpected {
-    na_size_t actual_buf_size;
-    na_addr_t source;
-    na_tag_t  tag;
-};
-
-/* Callback info struct */
-struct na_cb_info {
-    void *arg;          /* User data */
-    na_return_t ret;    /* Return value */
-    na_cb_type_t type;  /* Callback type */
-    union {             /* Union of callback info structures */
-        struct na_cb_info_lookup lookup;
-        struct na_cb_info_recv_unexpected recv_unexpected;
-    } info;
-};
-
-/* Callback type */
-typedef int (*na_cb_t)(const struct na_cb_info *callback_info);
+/* See na_types.h */
 
 /*****************/
 /* Public Macros */
 /*****************/
 
-/* Constant values */
-#define NA_ADDR_NULL       ((na_addr_t)0)
-#define NA_OP_ID_NULL      ((na_op_id_t)0)
-#define NA_OP_ID_IGNORE    ((na_op_id_t *)1)
-#define NA_MEM_HANDLE_NULL ((na_mem_handle_t)0)
-
-/* Max timeout */
-#define NA_MAX_IDLE_TIME (3600*1000)
-
-/* Tag upper bound
- * \remark This is not the user tag limit but only the limit imposed by the type */
-#define NA_TAG_UB UINT_MAX
-
-/* The memory attributes associated with the memory handle
- * can be defined as read only, write only or read/write */
-#define NA_MEM_READ_ONLY   0x01
-#define NA_MEM_WRITE_ONLY  0x02
-#define NA_MEM_READWRITE   0x03
+/* See na_types.h */
 
 /*********************/
 /* Public Prototypes */
@@ -197,7 +101,7 @@ NA_Cleanup(
  *
  * \return Pointer to NA class name or NULL in case of failure
  */
-NA_EXPORT const char *
+static NA_INLINE const char *
 NA_Get_class_name(
         const na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -209,7 +113,7 @@ NA_Get_class_name(
  *
  * \return Pointer to NA class protocol or NULL in case of failure
  */
-NA_EXPORT const char *
+static NA_INLINE const char *
 NA_Get_class_protocol(
         const na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -221,7 +125,7 @@ NA_Get_class_protocol(
  *
  * \return NA_TRUE if listening or NA_FALSE if not
  */
-NA_EXPORT na_bool_t
+static NA_INLINE na_bool_t
 NA_Is_listening(
         const na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -381,7 +285,7 @@ NA_Addr_dup(
  *
  * \return NA_TRUE if self or NA_FALSE if not
  */
-NA_EXPORT na_bool_t
+static NA_INLINE na_bool_t
 NA_Addr_is_self(
         na_class_t *na_class,
         na_addr_t   addr
@@ -417,7 +321,7 @@ NA_Addr_to_string(
  *
  * \return Non-negative value
  */
-NA_EXPORT na_size_t
+static NA_INLINE na_size_t
 NA_Addr_get_serialize_size(
         na_class_t  *na_class,
         na_addr_t    addr
@@ -468,7 +372,7 @@ NA_Addr_deserialize(
  *
  * \return Non-negative value
  */
-NA_EXPORT na_size_t
+static NA_INLINE na_size_t
 NA_Msg_get_max_unexpected_size(
         const na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -481,7 +385,7 @@ NA_Msg_get_max_unexpected_size(
  *
  * \return Non-negative value
  */
-NA_EXPORT na_size_t
+static NA_INLINE na_size_t
 NA_Msg_get_max_expected_size(
         const na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -494,7 +398,7 @@ NA_Msg_get_max_expected_size(
  *
  * \return Non-negative value
  */
-NA_EXPORT na_size_t
+static NA_INLINE na_size_t
 NA_Msg_get_unexpected_header_size(
         const na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -507,7 +411,7 @@ NA_Msg_get_unexpected_header_size(
  *
  * \return Non-negative value
  */
-NA_EXPORT na_size_t
+static NA_INLINE na_size_t
 NA_Msg_get_expected_header_size(
         const na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -520,7 +424,7 @@ NA_Msg_get_expected_header_size(
  *
  * \return Non-negative value
  */
-NA_EXPORT na_tag_t
+static NA_INLINE na_tag_t
 NA_Msg_get_max_tag(
         const na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -612,7 +516,7 @@ NA_Msg_init_unexpected(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+static NA_INLINE na_return_t
 NA_Msg_send_unexpected(
         na_class_t   *na_class,
         na_context_t *context,
@@ -652,7 +556,7 @@ NA_Msg_send_unexpected(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+static NA_INLINE na_return_t
 NA_Msg_recv_unexpected(
         na_class_t   *na_class,
         na_context_t *context,
@@ -713,7 +617,7 @@ NA_Msg_init_expected(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+static NA_INLINE na_return_t
 NA_Msg_send_expected(
         na_class_t   *na_class,
         na_context_t *context,
@@ -755,7 +659,7 @@ NA_Msg_send_expected(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+static NA_INLINE na_return_t
 NA_Msg_recv_expected(
         na_class_t   *na_class,
         na_context_t *context,
@@ -906,7 +810,7 @@ NA_Mem_unpublish(
  *
  * \return Non-negative value
  */
-NA_EXPORT na_size_t
+static NA_INLINE na_size_t
 NA_Mem_handle_get_serialize_size(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -981,7 +885,7 @@ NA_Mem_handle_deserialize(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+static NA_INLINE na_return_t
 NA_Put(
         na_class_t      *na_class,
         na_context_t    *context,
@@ -1021,7 +925,7 @@ NA_Put(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+static NA_INLINE na_return_t
 NA_Get(
         na_class_t      *na_class,
         na_context_t    *context,
@@ -1048,7 +952,7 @@ NA_Get(
  * \return Non-negative integer if supported, 0 if not implemented and negative
  * in case of error.
  */
-NA_EXPORT int
+static NA_INLINE int
 NA_Poll_get_fd(
         na_class_t      *na_class,
         na_context_t    *context
@@ -1139,6 +1043,766 @@ NA_Error_to_string(
         na_return_t errnum
         ) NA_WARN_UNUSED_RESULT;
 
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
+
+/* NA info definition */
+struct na_info {
+    char *class_name;    /* Class name (e.g., bmi) */
+    char *protocol_name; /* Protocol (e.g., tcp, ib) */
+    char *host_name;     /* Host (may be NULL in anonymous mode) */
+    /* Additional init info (NULL if no info) */
+    const struct na_init_info *na_init_info;
+};
+
+/* NA class definition */
+struct na_class {
+    const struct na_class_ops *ops;             /* Class operations */
+    char *protocol_name;                        /* Name of protocol */
+    na_bool_t listen;                           /* Listen for connections */
+    na_progress_mode_t progress_mode;           /* NA progress mode */
+    void *plugin_class;                         /* Plugin private class */
+};
+
+/* NA context definition */
+struct na_context {
+    void *plugin_context;                       /* Plugin private context */
+};
+
+/* NA plugin callbacks */
+struct na_class_ops {
+    const char *class_name;
+    na_bool_t
+    (*check_protocol)(
+            const char *protocol_name
+            );
+    na_return_t
+    (*initialize)(
+            na_class_t *na_class,
+            const struct na_info *na_info,
+            na_bool_t listen
+            );
+    na_return_t
+    (*finalize)(
+            na_class_t *na_class
+            );
+    void
+    (*cleanup)(
+            void
+            );
+    na_return_t
+    (*context_create)(
+            na_class_t *na_class,
+            void **plugin_context,
+            na_uint8_t id
+            );
+    na_return_t
+    (*context_destroy)(
+            na_class_t *na_class,
+            void *plugin_context
+            );
+    na_op_id_t
+    (*op_create)(
+            na_class_t *na_class
+            );
+    na_return_t
+    (*op_destroy)(
+            na_class_t *na_class,
+            na_op_id_t op_id
+            );
+    na_return_t
+    (*addr_lookup)(
+            na_class_t   *na_class,
+            na_context_t *context,
+            na_cb_t       callback,
+            void         *arg,
+            const char   *name,
+            na_op_id_t   *op_id
+            );
+    na_return_t
+    (*addr_free)(
+            na_class_t *na_class,
+            na_addr_t   addr
+            );
+    na_return_t
+    (*addr_self)(
+            na_class_t *na_class,
+            na_addr_t  *addr
+            );
+    na_return_t
+    (*addr_dup)(
+            na_class_t *na_class,
+            na_addr_t   addr,
+            na_addr_t  *new_addr
+            );
+    na_bool_t
+    (*addr_is_self)(
+            na_class_t *na_class,
+            na_addr_t   addr
+            );
+    na_return_t
+    (*addr_to_string)(
+            na_class_t *na_class,
+            char       *buf,
+            na_size_t  *buf_size,
+            na_addr_t   addr
+            );
+    na_size_t
+    (*addr_get_serialize_size)(
+            na_class_t      *na_class,
+            na_addr_t        addr
+            );
+    na_return_t
+    (*addr_serialize)(
+            na_class_t      *na_class,
+            void            *buf,
+            na_size_t        buf_size,
+            na_addr_t        addr
+    );
+    na_return_t
+    (*addr_deserialize)(
+            na_class_t      *na_class,
+            na_addr_t       *addr,
+            const void      *buf,
+            na_size_t        buf_size
+    );
+    na_size_t
+    (*msg_get_max_unexpected_size)(
+            const na_class_t *na_class
+            );
+    na_size_t
+    (*msg_get_max_expected_size)(
+            const na_class_t *na_class
+            );
+    na_size_t
+    (*msg_get_unexpected_header_size)(
+            const na_class_t *na_class
+            );
+    na_size_t
+    (*msg_get_expected_header_size)(
+            const na_class_t *na_class
+            );
+    na_tag_t
+    (*msg_get_max_tag)(
+            const na_class_t *na_class
+            );
+    void *
+    (*msg_buf_alloc)(
+            na_class_t *na_class,
+            na_size_t buf_size,
+            void **plugin_data
+            );
+    na_return_t
+    (*msg_buf_free)(
+            na_class_t *na_class,
+            void *buf,
+            void *plugin_data
+            );
+    na_return_t
+    (*msg_init_unexpected)(
+            na_class_t *na_class,
+            void *buf,
+            na_size_t buf_size
+            );
+    na_return_t
+    (*msg_send_unexpected)(
+            na_class_t   *na_class,
+            na_context_t *context,
+            na_cb_t       callback,
+            void         *arg,
+            const void   *buf,
+            na_size_t     buf_size,
+            void         *plugin_data,
+            na_addr_t     dest_addr,
+            na_uint8_t    dest_id,
+            na_tag_t      tag,
+            na_op_id_t   *op_id
+            );
+    na_return_t
+    (*msg_recv_unexpected)(
+            na_class_t   *na_class,
+            na_context_t *context,
+            na_cb_t       callback,
+            void         *arg,
+            void         *buf,
+            na_size_t     buf_size,
+            void         *plugin_data,
+            na_op_id_t   *op_id
+            );
+    na_return_t
+    (*msg_init_expected)(
+            na_class_t *na_class,
+            void *buf,
+            na_size_t buf_size
+            );
+    na_return_t
+    (*msg_send_expected)(
+            na_class_t   *na_class,
+            na_context_t *context,
+            na_cb_t       callback,
+            void         *arg,
+            const void   *buf,
+            na_size_t     buf_size,
+            void         *plugin_data,
+            na_addr_t     dest_addr,
+            na_uint8_t    dest_id,
+            na_tag_t      tag,
+            na_op_id_t   *op_id
+            );
+    na_return_t
+    (*msg_recv_expected)(
+            na_class_t   *na_class,
+            na_context_t *context,
+            na_cb_t       callback,
+            void         *arg,
+            void         *buf,
+            na_size_t     buf_size,
+            void         *plugin_data,
+            na_addr_t     source_addr,
+            na_uint8_t    source_id,
+            na_tag_t      tag,
+            na_op_id_t   *op_id
+            );
+    na_return_t
+    (*mem_handle_create)(
+            na_class_t      *na_class,
+            void            *buf,
+            na_size_t        buf_size,
+            unsigned long    flags,
+            na_mem_handle_t *mem_handle
+            );
+    na_return_t
+    (*mem_handle_create_segments)(
+            na_class_t        *na_class,
+            struct na_segment *segments,
+            na_size_t          segment_count,
+            unsigned long      flags,
+            na_mem_handle_t   *mem_handle
+            );
+    na_return_t
+    (*mem_handle_free)(
+            na_class_t      *na_class,
+            na_mem_handle_t  mem_handle
+            );
+    na_return_t
+    (*mem_register)(
+            na_class_t      *na_class,
+            na_mem_handle_t  mem_handle
+            );
+    na_return_t
+    (*mem_deregister)(
+            na_class_t      *na_class,
+            na_mem_handle_t  mem_handle
+            );
+    na_return_t
+    (*mem_publish)(
+            na_class_t      *na_class,
+            na_mem_handle_t  mem_handle
+            );
+    na_return_t
+    (*mem_unpublish)(
+            na_class_t      *na_class,
+            na_mem_handle_t  mem_handle
+            );
+    na_size_t
+    (*mem_handle_get_serialize_size)(
+            na_class_t      *na_class,
+            na_mem_handle_t  mem_handle
+            );
+    na_return_t
+    (*mem_handle_serialize)(
+            na_class_t      *na_class,
+            void            *buf,
+            na_size_t        buf_size,
+            na_mem_handle_t  mem_handle
+            );
+    na_return_t
+    (*mem_handle_deserialize)(
+            na_class_t      *na_class,
+            na_mem_handle_t *mem_handle,
+            const void      *buf,
+            na_size_t        buf_size
+            );
+    na_return_t
+    (*put)(
+            na_class_t      *na_class,
+            na_context_t    *context,
+            na_cb_t          callback,
+            void            *arg,
+            na_mem_handle_t  local_mem_handle,
+            na_offset_t      local_offset,
+            na_mem_handle_t  remote_mem_handle,
+            na_offset_t      remote_offset,
+            na_size_t        length,
+            na_addr_t        remote_addr,
+            na_uint8_t       remote_id,
+            na_op_id_t      *op_id
+            );
+    na_return_t
+    (*get)(
+            na_class_t      *na_class,
+            na_context_t    *context,
+            na_cb_t          callback,
+            void            *arg,
+            na_mem_handle_t  local_mem_handle,
+            na_offset_t      local_offset,
+            na_mem_handle_t  remote_mem_handle,
+            na_offset_t      remote_offset,
+            na_size_t        length,
+            na_addr_t        remote_addr,
+            na_uint8_t       remote_id,
+            na_op_id_t      *op_id
+            );
+    int
+    (*na_poll_get_fd)(
+            na_class_t      *na_class,
+            na_context_t    *context
+            );
+    na_bool_t
+    (*na_poll_try_wait)(
+            na_class_t      *na_class,
+            na_context_t    *context
+            );
+    na_return_t
+    (*progress)(
+            na_class_t   *na_class,
+            na_context_t *context,
+            unsigned int  timeout
+            );
+    na_return_t
+    (*cancel)(
+            na_class_t   *na_class,
+            na_context_t *context,
+            na_op_id_t    op_id
+            );
+};
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE const char *
+NA_Get_class_name(const na_class_t *na_class)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return NULL;
+    }
+#endif
+    return na_class->ops->class_name;
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE const char *
+NA_Get_class_protocol(const na_class_t *na_class)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return NULL;
+    }
+#endif
+    return na_class->protocol_name;
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_bool_t
+NA_Is_listening(const na_class_t *na_class)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return NA_FALSE;
+    }
+#endif
+    return na_class->listen;
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_bool_t
+NA_Addr_is_self(na_class_t *na_class, na_addr_t addr)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return NA_FALSE;
+    }
+    if (!na_class->ops->addr_is_self) {
+        NA_LOG_ERROR("addr_is_self plugin callback is not defined");
+        return NA_FALSE;
+    }
+#endif
+    return na_class->ops->addr_is_self(na_class, addr);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_size_t
+NA_Addr_get_serialize_size(na_class_t *na_class, na_addr_t addr)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return 0;
+    }
+    if (addr == NA_ADDR_NULL) {
+        NA_LOG_ERROR("NULL addr");
+        return 0;
+    }
+    if (!na_class->ops->addr_get_serialize_size) {
+        NA_LOG_ERROR("addr_get_serialize_size plugin callback is not defined");
+        return 0;
+    }
+#endif
+    return na_class->ops->addr_get_serialize_size(na_class, addr);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_size_t
+NA_Msg_get_max_unexpected_size(const na_class_t *na_class)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return 0;
+    }
+    if (!na_class->ops->msg_get_max_unexpected_size) {
+        NA_LOG_ERROR("msg_get_max_unexpected_size plugin callback is not defined");
+        return 0;
+    }
+#endif
+    return na_class->ops->msg_get_max_unexpected_size(na_class);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_size_t
+NA_Msg_get_max_expected_size(const na_class_t *na_class)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return 0;
+    }
+    if (!na_class->ops->msg_get_max_expected_size) {
+        NA_LOG_ERROR("msg_get_max_expected_size plugin callback is not defined");
+        return 0;
+    }
+#endif
+    return na_class->ops->msg_get_max_expected_size(na_class);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_size_t
+NA_Msg_get_unexpected_header_size(const na_class_t *na_class)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return 0;
+    }
+#endif
+    return (na_class->ops->msg_get_unexpected_header_size) ?
+        na_class->ops->msg_get_unexpected_header_size(na_class) : 0;
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_size_t
+NA_Msg_get_expected_header_size(const na_class_t *na_class)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return 0;
+    }
+#endif
+    return (na_class->ops->msg_get_expected_header_size) ?
+        na_class->ops->msg_get_expected_header_size(na_class) : 0;
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_tag_t
+NA_Msg_get_max_tag(const na_class_t *na_class)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return 0;
+    }
+    if (!na_class->ops->msg_get_max_tag) {
+        NA_LOG_ERROR("msg_get_max_tag plugin callback is not defined");
+        return 0;
+    }
+#endif
+    return na_class->ops->msg_get_max_tag(na_class);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
+NA_Msg_send_unexpected(na_class_t *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
+    void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
+    na_op_id_t *op_id)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return NA_INVALID_PARAM;
+    }
+    if (!context) {
+        NA_LOG_ERROR("NULL context");
+        return NA_INVALID_PARAM;
+    }
+    if (!buf) {
+        NA_LOG_ERROR("NULL buffer");
+        return NA_INVALID_PARAM;
+    }
+    if (!buf_size) {
+        NA_LOG_ERROR("NULL buffer size");
+        return NA_INVALID_PARAM;
+    }
+    if (dest_addr == NA_ADDR_NULL) {
+        NA_LOG_ERROR("NULL NA address");
+        return NA_INVALID_PARAM;
+    }
+    if (!na_class->ops->msg_send_unexpected) {
+        NA_LOG_ERROR("msg_send_unexpected plugin callback is not defined");
+        return NA_PROTOCOL_ERROR;
+    }
+#endif
+    return na_class->ops->msg_send_unexpected(na_class, context, callback,
+        arg, buf, buf_size, plugin_data, dest_addr, dest_id, tag, op_id);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
+NA_Msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
+    void *plugin_data, na_op_id_t *op_id)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return NA_INVALID_PARAM;
+    }
+    if (!context) {
+        NA_LOG_ERROR("NULL context");
+        return NA_INVALID_PARAM;
+    }
+    if (!buf) {
+        NA_LOG_ERROR("NULL buffer");
+        return NA_INVALID_PARAM;
+    }
+    if (!buf_size) {
+        NA_LOG_ERROR("NULL buffer size");
+        return NA_INVALID_PARAM;
+    }
+    if (!na_class->ops->msg_recv_unexpected) {
+        NA_LOG_ERROR("msg_recv_unexpected plugin callback is not defined");
+        return NA_PROTOCOL_ERROR;
+    }
+#endif
+    return na_class->ops->msg_recv_unexpected(na_class, context, callback,
+        arg, buf, buf_size, plugin_data, op_id);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
+NA_Msg_send_expected(na_class_t *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
+    void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
+    na_op_id_t *op_id)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return NA_INVALID_PARAM;
+    }
+    if (!context) {
+        NA_LOG_ERROR("NULL context");
+        return NA_INVALID_PARAM;
+    }
+    if (!buf) {
+        NA_LOG_ERROR("NULL buffer");
+        return NA_INVALID_PARAM;
+    }
+    if (!buf_size) {
+        NA_LOG_ERROR("NULL buffer size");
+        return NA_INVALID_PARAM;
+    }
+    if (dest_addr == NA_ADDR_NULL) {
+        NA_LOG_ERROR("NULL NA address");
+        return NA_INVALID_PARAM;
+    }
+    if (!na_class->ops->msg_send_expected) {
+        NA_LOG_ERROR("msg_send_expected plugin callback is not defined");
+        return NA_PROTOCOL_ERROR;
+    }
+#endif
+    return na_class->ops->msg_send_expected(na_class, context, callback,
+        arg, buf, buf_size, plugin_data, dest_addr, dest_id, tag, op_id);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
+NA_Msg_recv_expected(na_class_t *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
+    void *plugin_data, na_addr_t source_addr, na_uint8_t source_id,
+    na_tag_t tag, na_op_id_t *op_id)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return NA_INVALID_PARAM;
+    }
+    if (!context) {
+        NA_LOG_ERROR("NULL context");
+        return NA_INVALID_PARAM;
+    }
+    if (!buf) {
+        NA_LOG_ERROR("NULL buffer");
+        return NA_INVALID_PARAM;
+    }
+    if (!buf_size) {
+        NA_LOG_ERROR("NULL buffer size");
+        return NA_INVALID_PARAM;
+    }
+    if (source_addr == NA_ADDR_NULL) {
+        NA_LOG_ERROR("NULL NA address");
+        return NA_INVALID_PARAM;
+    }
+    if (!na_class->ops->msg_recv_expected) {
+        NA_LOG_ERROR("msg_recv_expected plugin callback is not defined");
+        return NA_PROTOCOL_ERROR;
+    }
+#endif
+    return na_class->ops->msg_recv_expected(na_class, context, callback,
+        arg, buf, buf_size, plugin_data, source_addr, source_id, tag, op_id);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_size_t
+NA_Mem_handle_get_serialize_size(na_class_t *na_class,
+    na_mem_handle_t mem_handle)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return 0;
+    }
+    if (mem_handle == NA_MEM_HANDLE_NULL) {
+        NA_LOG_ERROR("NULL memory handle");
+        return 0;
+    }
+    if (!na_class->ops->mem_handle_get_serialize_size) {
+        NA_LOG_ERROR("mem_handle_get_serialize_size plugin callback is not defined");
+        return 0;
+    }
+#endif
+    return na_class->ops->mem_handle_get_serialize_size(na_class, mem_handle);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
+NA_Put(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
+    na_mem_handle_t local_mem_handle, na_offset_t local_offset,
+    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset,
+    na_size_t data_size, na_addr_t remote_addr, na_uint8_t remote_id,
+    na_op_id_t *op_id)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return NA_INVALID_PARAM;
+    }
+    if (!context) {
+        NA_LOG_ERROR("NULL context");
+        return NA_INVALID_PARAM;
+    }
+    if (local_mem_handle == NA_MEM_HANDLE_NULL) {
+        NA_LOG_ERROR("NULL memory handle");
+        return NA_INVALID_PARAM;
+    }
+    if (remote_mem_handle == NA_MEM_HANDLE_NULL) {
+        NA_LOG_ERROR("NULL memory handle");
+        return NA_INVALID_PARAM;
+    }
+    if (!data_size) {
+        NA_LOG_ERROR("NULL data size");
+        return NA_INVALID_PARAM;
+    }
+    if (remote_addr == NA_ADDR_NULL) {
+        NA_LOG_ERROR("NULL addr");
+        return NA_INVALID_PARAM;
+    }
+    if (!na_class->ops->put) {
+        NA_LOG_ERROR("put plugin callback is not defined");
+        return NA_PROTOCOL_ERROR;
+    }
+#endif
+    return na_class->ops->put(na_class, context, callback, arg,
+        local_mem_handle, local_offset, remote_mem_handle, remote_offset,
+        data_size, remote_addr, remote_id, op_id);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
+NA_Get(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
+    na_mem_handle_t local_mem_handle, na_offset_t local_offset,
+    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset,
+    na_size_t data_size, na_addr_t remote_addr, na_uint8_t remote_id,
+    na_op_id_t *op_id)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return NA_INVALID_PARAM;
+    }
+    if (!context) {
+        NA_LOG_ERROR("NULL context");
+        return NA_INVALID_PARAM;
+    }
+    if (local_mem_handle == NA_MEM_HANDLE_NULL) {
+        NA_LOG_ERROR("NULL memory handle");
+        return NA_INVALID_PARAM;
+    }
+    if (remote_mem_handle == NA_MEM_HANDLE_NULL) {
+        NA_LOG_ERROR("NULL memory handle");
+        return NA_INVALID_PARAM;
+    }
+    if (!data_size) {
+        NA_LOG_ERROR("NULL data size");
+        return NA_INVALID_PARAM;
+    }
+    if (remote_addr == NA_ADDR_NULL) {
+        NA_LOG_ERROR("NULL addr");
+        return NA_INVALID_PARAM;
+    }
+    if (!na_class->ops->get) {
+        NA_LOG_ERROR("get plugin callback is not defined");
+        return NA_PROTOCOL_ERROR;
+    }
+#endif
+    return na_class->ops->get(na_class, context, callback, arg,
+        local_mem_handle, local_offset, remote_mem_handle, remote_offset,
+        data_size, remote_addr, remote_id, op_id);
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE int
+NA_Poll_get_fd(na_class_t *na_class, na_context_t *context)
+{
+#ifdef NA_HAS_VERBOSE_ERROR
+    if (!na_class) {
+        NA_LOG_ERROR("NULL NA class");
+        return -1;
+    }
+    if (!context) {
+        NA_LOG_ERROR("NULL context");
+        return -1;
+    }
+#endif
+    return (na_class->ops->na_poll_get_fd) ?
+        na_class->ops->na_poll_get_fd(na_class, context) : -1;
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/na/na_bmi.c b/src/na/na_bmi.c
index 3cf8ce0..84daf0f 100644
--- a/src/na/na_bmi.c
+++ b/src/na/na_bmi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -8,13 +8,9 @@
  * found at the root of the source code distribution tree.
  */
 
-#include "na_private.h"
-#include "na_error.h"
+#include "na_plugin.h"
 
-#include "mercury_queue.h"
-#include "mercury_thread_mutex.h"
 #include "mercury_time.h"
-#include "mercury_atomic.h"
 
 #include <bmi.h>
 
@@ -46,8 +42,8 @@
 #define NA_BMI_RMA_TAG (NA_BMI_RMA_REQUEST_TAG + 1)
 #define NA_BMI_MAX_RMA_TAG (NA_TAG_UB >> 1)
 
-#define NA_BMI_PRIVATE_DATA(na_class) \
-    ((struct na_bmi_private_data *)(na_class->private_data))
+#define NA_BMI_CLASS(na_class) \
+    ((struct na_bmi_class *)(na_class->plugin_class))
 
 #define NA_BMI_CANCEL_R (1 << 0)
 #define NA_BMI_CANCEL_C (1 << 1)
@@ -156,7 +152,7 @@ struct na_bmi_op_id {
     HG_QUEUE_ENTRY(na_bmi_op_id) entry;
 };
 
-struct na_bmi_private_data {
+struct na_bmi_class {
     char *listen_addr;                               /* Listen addr */
     int port;                                        /* Port used */
     char *protocol_name;                             /* Protocol used for this class */
@@ -506,8 +502,7 @@ na_bmi_cancel(
 /* Local Variables */
 /*******************/
 
-const na_class_t na_bmi_class_g = {
-        NULL,                                 /* private_data */
+NA_PLUGIN_OPS(bmi) = {
         "bmi",                                /* name */
         na_bmi_check_protocol,                /* check_protocol */
         na_bmi_initialize,                    /* initialize */
@@ -568,12 +563,12 @@ na_bmi_gen_rma_tag(na_class_t *na_class, uint8_t step)
     bmi_msg_tag_t tag;
 
     /* Compare and swap tag if reached max tag */
-    if (hg_atomic_cas32(&NA_BMI_PRIVATE_DATA(na_class)->rma_tag,
+    if (hg_atomic_cas32(&NA_BMI_CLASS(na_class)->rma_tag,
             NA_BMI_MAX_RMA_TAG, NA_BMI_RMA_TAG)) {
         tag = NA_BMI_RMA_TAG;
     } else {
         /* Increment tag */
-        tag = hg_atomic_incr32(&NA_BMI_PRIVATE_DATA(na_class)->rma_tag);
+        tag = hg_atomic_incr32(&NA_BMI_CLASS(na_class)->rma_tag);
     }
 
     /* NOTE: the "step" argument is used to classify which step of an
@@ -652,17 +647,17 @@ na_bmi_initialize(na_class_t * na_class, const struct na_info *na_info,
     int port = 0;
 
     /* Allocate private data */
-    na_class->private_data = malloc(sizeof(struct na_bmi_private_data));
-    if (!na_class->private_data) {
+    na_class->plugin_class = malloc(sizeof(struct na_bmi_class));
+    if (!na_class->plugin_class) {
         NA_LOG_ERROR("Could not allocate NA private data class");
         ret = NA_NOMEM_ERROR;
         goto done;
     }
-    memset(na_class->private_data, 0, sizeof(struct na_bmi_private_data));
-    NA_BMI_PRIVATE_DATA(na_class)->protocol_name =
+    memset(na_class->plugin_class, 0, sizeof(struct na_bmi_class));
+    NA_BMI_CLASS(na_class)->protocol_name =
         strdup(na_info->protocol_name);
-    HG_QUEUE_INIT(&NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue);
-    HG_QUEUE_INIT(&NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue);
+    HG_QUEUE_INIT(&NA_BMI_CLASS(na_class)->unexpected_msg_queue);
+    HG_QUEUE_INIT(&NA_BMI_CLASS(na_class)->unexpected_op_queue);
 
     if (listen) {
         int desc_len = 0;
@@ -728,24 +723,22 @@ again:
         ret = NA_SUCCESS;
 
     /* Keep listen_addr and port */
-    NA_BMI_PRIVATE_DATA(na_class)->listen_addr = (listen) ?
+    NA_BMI_CLASS(na_class)->listen_addr = (listen) ?
             strdup(listen_addr_p) : NULL;
-    NA_BMI_PRIVATE_DATA(na_class)->port = port;
+    NA_BMI_CLASS(na_class)->port = port;
 
     /* Initialize mutex/cond */
-    hg_thread_mutex_init(&NA_BMI_PRIVATE_DATA(na_class)->test_unexpected_mutex);
-    hg_thread_mutex_init(
-        &NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
-    hg_thread_mutex_init(
-        &NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_init(&NA_BMI_CLASS(na_class)->test_unexpected_mutex);
+    hg_thread_mutex_init(&NA_BMI_CLASS(na_class)->unexpected_msg_queue_mutex);
+    hg_thread_mutex_init(&NA_BMI_CLASS(na_class)->unexpected_op_queue_mutex);
 
     /* Initialize atomic op */
-    hg_atomic_set32(&NA_BMI_PRIVATE_DATA(na_class)->rma_tag, NA_BMI_RMA_TAG);
+    hg_atomic_set32(&NA_BMI_CLASS(na_class)->rma_tag, NA_BMI_RMA_TAG);
 
 done:
     if (ret != NA_SUCCESS) {
-        free(NA_BMI_PRIVATE_DATA(na_class)->listen_addr);
-        free(na_class->private_data);
+        free(NA_BMI_CLASS(na_class)->listen_addr);
+        free(na_class->plugin_class);
     }
     return ret;
 }
@@ -757,20 +750,18 @@ na_bmi_finalize(na_class_t *na_class)
     na_return_t ret = NA_SUCCESS;
     int bmi_ret;
 
-    if (!na_class->private_data) {
+    if (!na_class->plugin_class) {
         goto done;
     }
 
     /* Check that unexpected op queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(
-            &NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue)) {
+    if (!HG_QUEUE_IS_EMPTY(&NA_BMI_CLASS(na_class)->unexpected_op_queue)) {
         NA_LOG_ERROR("Unexpected op queue should be empty");
         ret = NA_PROTOCOL_ERROR;
     }
 
     /* Check that unexpected message queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(
-            &NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue)) {
+    if (!HG_QUEUE_IS_EMPTY(&NA_BMI_CLASS(na_class)->unexpected_msg_queue)) {
         NA_LOG_ERROR("Unexpected msg queue should be empty");
         ret = NA_PROTOCOL_ERROR;
     }
@@ -783,16 +774,14 @@ na_bmi_finalize(na_class_t *na_class)
     }
 
     /* Destroy mutex/cond */
+    hg_thread_mutex_destroy(&NA_BMI_CLASS(na_class)->test_unexpected_mutex);
     hg_thread_mutex_destroy(
-            &NA_BMI_PRIVATE_DATA(na_class)->test_unexpected_mutex);
-    hg_thread_mutex_destroy(
-            &NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
-    hg_thread_mutex_destroy(
-            &NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+        &NA_BMI_CLASS(na_class)->unexpected_msg_queue_mutex);
+    hg_thread_mutex_destroy(&NA_BMI_CLASS(na_class)->unexpected_op_queue_mutex);
 
-    free(NA_BMI_PRIVATE_DATA(na_class)->listen_addr);
-    free(NA_BMI_PRIVATE_DATA(na_class)->protocol_name);
-    free(na_class->private_data);
+    free(NA_BMI_CLASS(na_class)->listen_addr);
+    free(NA_BMI_CLASS(na_class)->protocol_name);
+    free(na_class->plugin_class);
 
 done:
     return ret;
@@ -1040,7 +1029,7 @@ na_bmi_addr_to_string(na_class_t *na_class, char *buf,
     na_bmi_addr = (struct na_bmi_addr *) addr;
 
     if (na_bmi_addr->self) {
-        bmi_rev_addr = NA_BMI_PRIVATE_DATA(na_class)->listen_addr;
+        bmi_rev_addr = NA_BMI_CLASS(na_class)->listen_addr;
         if (!bmi_rev_addr) {
             NA_LOG_ERROR("Cannot convert addr to string if not listening");
             ret = NA_PROTOCOL_ERROR;
@@ -1054,8 +1043,8 @@ na_bmi_addr_to_string(na_class_t *na_class, char *buf,
 
             /* Work around address returned in different format */
             desc_len = snprintf(full_rev_addr, NA_BMI_MAX_ADDR_NAME, "%s://%s:%d",
-                NA_BMI_PRIVATE_DATA(na_class)->protocol_name, bmi_rev_addr,
-                NA_BMI_PRIVATE_DATA(na_class)->port);
+                NA_BMI_CLASS(na_class)->protocol_name, bmi_rev_addr,
+                NA_BMI_CLASS(na_class)->port);
             if (desc_len > NA_BMI_MAX_ADDR_NAME) {
                 NA_LOG_ERROR("Exceeding max addr name");
                 ret = NA_SIZE_ERROR;
@@ -1260,14 +1249,12 @@ na_bmi_msg_unexpected_push(na_class_t *na_class,
         goto done;
     }
 
-    hg_thread_mutex_lock(
-            &NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
+    hg_thread_mutex_lock(&NA_BMI_CLASS(na_class)->unexpected_msg_queue_mutex);
 
-    HG_QUEUE_PUSH_TAIL(&NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue,
+    HG_QUEUE_PUSH_TAIL(&NA_BMI_CLASS(na_class)->unexpected_msg_queue,
         unexpected_info, entry);
 
-    hg_thread_mutex_unlock(
-            &NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
+    hg_thread_mutex_unlock(&NA_BMI_CLASS(na_class)->unexpected_msg_queue_mutex);
 
 done:
     return ret;
@@ -1279,14 +1266,13 @@ na_bmi_msg_unexpected_pop(na_class_t *na_class)
 {
     struct na_bmi_unexpected_info *unexpected_info;
 
-    hg_thread_mutex_lock(
-            &NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
+    hg_thread_mutex_lock(&NA_BMI_CLASS(na_class)->unexpected_msg_queue_mutex);
 
-    unexpected_info = HG_QUEUE_FIRST(&NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue);
-    HG_QUEUE_POP_HEAD(&NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue, entry);
+    unexpected_info = HG_QUEUE_FIRST(
+        &NA_BMI_CLASS(na_class)->unexpected_msg_queue);
+    HG_QUEUE_POP_HEAD(&NA_BMI_CLASS(na_class)->unexpected_msg_queue, entry);
 
-    hg_thread_mutex_unlock(
-            &NA_BMI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
+    hg_thread_mutex_unlock(&NA_BMI_CLASS(na_class)->unexpected_msg_queue_mutex);
 
     return unexpected_info;
 }
@@ -1304,13 +1290,12 @@ na_bmi_msg_unexpected_op_push(na_class_t *na_class,
         goto done;
     }
 
-    hg_thread_mutex_lock(&NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_lock(&NA_BMI_CLASS(na_class)->unexpected_op_queue_mutex);
 
-    HG_QUEUE_PUSH_TAIL(&NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue,
+    HG_QUEUE_PUSH_TAIL(&NA_BMI_CLASS(na_class)->unexpected_op_queue,
         na_bmi_op_id, entry);
 
-    hg_thread_mutex_unlock(
-            &NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_unlock(&NA_BMI_CLASS(na_class)->unexpected_op_queue_mutex);
 
 done:
     return ret;
@@ -1322,16 +1307,12 @@ na_bmi_msg_unexpected_op_pop(na_class_t *na_class)
 {
     struct na_bmi_op_id *na_bmi_op_id;
 
-    hg_thread_mutex_lock(
-        &NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_lock(&NA_BMI_CLASS(na_class)->unexpected_op_queue_mutex);
 
-    na_bmi_op_id = HG_QUEUE_FIRST(
-        &NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue);
-    HG_QUEUE_POP_HEAD(&NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue,
-        entry);
+    na_bmi_op_id = HG_QUEUE_FIRST(&NA_BMI_CLASS(na_class)->unexpected_op_queue);
+    HG_QUEUE_POP_HEAD(&NA_BMI_CLASS(na_class)->unexpected_op_queue, entry);
 
-    hg_thread_mutex_unlock(
-        &NA_BMI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_unlock(&NA_BMI_CLASS(na_class)->unexpected_op_queue_mutex);
 
     return na_bmi_op_id;
 }
@@ -1912,14 +1893,13 @@ na_bmi_progress_unexpected(na_class_t *na_class, na_context_t *context,
     int bmi_ret;
 
     /* Prevent multiple threads from calling BMI_testunexpected concurrently */
-    hg_thread_mutex_lock(&NA_BMI_PRIVATE_DATA(na_class)->test_unexpected_mutex);
+    hg_thread_mutex_lock(&NA_BMI_CLASS(na_class)->test_unexpected_mutex);
 
     /* Test unexpected message */
     bmi_ret = BMI_testunexpected(1, &outcount, &test_unexpected_info,
             (int) timeout);
 
-    hg_thread_mutex_unlock(
-            &NA_BMI_PRIVATE_DATA(na_class)->test_unexpected_mutex);
+    hg_thread_mutex_unlock(&NA_BMI_CLASS(na_class)->test_unexpected_mutex);
 
     if (bmi_ret < 0) {
         NA_LOG_ERROR("BMI_testunexpected failed");
diff --git a/src/na/na_cci.c b/src/na/na_cci.c
index 160a44d..2758ad8 100644
--- a/src/na/na_cci.c
+++ b/src/na/na_cci.c
@@ -8,14 +8,10 @@
  * root of the source code distribution tree.
  */
 
-#include "na_private.h"
-#include "na_error.h"
+#include "na_plugin.h"
 
-#include "mercury_queue.h"
-#include "mercury_list.h"
-#include "mercury_thread_mutex.h"
 #include "mercury_time.h"
-#include "mercury_atomic.h"
+#include "mercury_list.h"
 
 #include <cci.h>
 
@@ -45,10 +41,10 @@ typedef uintptr_t cci_op_id_t;
 typedef struct na_cci_addr na_cci_addr_t;
 typedef struct na_cci_op_id na_cci_op_id_t;
 typedef struct na_cci_mem_handle na_cci_mem_handle_t;
-typedef struct na_cci_private_data na_cci_private_data_t;
+typedef struct na_cci_class na_cci_class_t;
 
-#define NA_CCI_PRIVATE_DATA(na_class) \
-    ((struct na_cci_private_data *)(na_class->private_data))
+#define NA_CCI_CLASS(na_class) \
+    ((struct na_cci_class *)(na_class->plugin_class))
 
 /* na_cci_addr */
 struct na_cci_addr {
@@ -148,7 +144,7 @@ struct na_cci_op_id {
     struct na_cb_completion_data completion_data;
 };
 
-struct na_cci_private_data {
+struct na_cci_class {
     cci_endpoint_t *endpoint;
     HG_QUEUE_HEAD(na_cci_op_id) early; /* Unexpected rxs not yet posted */
     hg_thread_mutex_t test_unexpected_mutex; /* Mutex */
@@ -364,8 +360,7 @@ na_cci_cancel(na_class_t * na_class, na_context_t * context, na_op_id_t op_id);
 /* Local Variables */
 /*******************/
 
-const na_class_t na_cci_class_g = {
-    NULL,                                   /* private_data */
+NA_PLUGIN_OPS(cci) = {
     "cci",                                  /* name */
     na_cci_check_protocol,                  /* check_protocol */
     na_cci_initialize,                      /* initialize */
@@ -623,13 +618,13 @@ na_cci_initialize(na_class_t * na_class, const struct na_info *na_info,
         goto out;
     }
 
-    na_class->private_data = malloc(sizeof(struct na_cci_private_data));
-    if (!na_class->private_data) {
+    na_class->plugin_class = malloc(sizeof(struct na_cci_class));
+    if (!na_class->plugin_class) {
         NA_LOG_ERROR("Could not allocate NA private data class");
         ret = NA_NOMEM_ERROR;
         goto out;
     }
-    memset(na_class->private_data, 0, sizeof(struct na_cci_private_data));
+    memset(na_class->plugin_class, 0, sizeof(struct na_cci_class));
     if (na_info->na_init_info
         && na_info->na_init_info->progress_mode == NA_NO_BLOCK)
         fd_p = NULL;
@@ -645,8 +640,8 @@ na_cci_initialize(na_class_t * na_class, const struct na_info *na_info,
         ret = NA_PROTOCOL_ERROR;
         goto out;
     }
-    NA_CCI_PRIVATE_DATA(na_class)->endpoint = endpoint;
-    NA_CCI_PRIVATE_DATA(na_class)->fd = fd;
+    NA_CCI_CLASS(na_class)->endpoint = endpoint;
+    NA_CCI_CLASS(na_class)->fd = fd;
 
     rc = cci_get_opt(endpoint, CCI_OPT_ENDPT_URI, &uri);
     if (rc) {
@@ -656,7 +651,7 @@ na_cci_initialize(na_class_t * na_class, const struct na_info *na_info,
         goto out;
     }
 
-    NA_CCI_PRIVATE_DATA(na_class)->uri = strdup(uri);
+    NA_CCI_CLASS(na_class)->uri = strdup(uri);
     free(uri);
 
     ret = na_cci_init(na_class);
@@ -673,18 +668,18 @@ na_cci_init(na_class_t * na_class)
 {
     na_return_t ret = NA_SUCCESS;
 
-    HG_QUEUE_INIT(&NA_CCI_PRIVATE_DATA(na_class)->unexpected_msg_queue);
-    HG_QUEUE_INIT(&NA_CCI_PRIVATE_DATA(na_class)->unexpected_op_queue);
-    HG_LIST_INIT(&NA_CCI_PRIVATE_DATA(na_class)->accept_conn_list);
+    HG_QUEUE_INIT(&NA_CCI_CLASS(na_class)->unexpected_msg_queue);
+    HG_QUEUE_INIT(&NA_CCI_CLASS(na_class)->unexpected_op_queue);
+    HG_LIST_INIT(&NA_CCI_CLASS(na_class)->accept_conn_list);
 
     /* Initialize mutex/cond */
-    hg_thread_mutex_init(&NA_CCI_PRIVATE_DATA(na_class)->test_unexpected_mutex);
+    hg_thread_mutex_init(&NA_CCI_CLASS(na_class)->test_unexpected_mutex);
     hg_thread_mutex_init(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
+        &NA_CCI_CLASS(na_class)->unexpected_msg_queue_mutex);
     hg_thread_mutex_init(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+        &NA_CCI_CLASS(na_class)->unexpected_op_queue_mutex);
     hg_thread_mutex_init(
-        &NA_CCI_PRIVATE_DATA(na_class)->accept_conn_list_mutex);
+        &NA_CCI_CLASS(na_class)->accept_conn_list_mutex);
 
     if (ret != NA_SUCCESS) {
         na_cci_finalize(na_class);
@@ -696,7 +691,7 @@ na_cci_init(na_class_t * na_class)
 static na_return_t
 na_cci_finalize(na_class_t * na_class)
 {
-    na_cci_private_data_t *priv = na_class->private_data;
+    na_cci_class_t *priv = na_class->plugin_class;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
@@ -741,7 +736,7 @@ na_cci_finalize(na_class_t * na_class)
     hg_thread_mutex_destroy(&priv->unexpected_op_queue_mutex);
     hg_thread_mutex_destroy(&priv->accept_conn_list_mutex);
 
-    free(na_class->private_data);
+    free(na_class->plugin_class);
 
     return ret;
 }
@@ -783,8 +778,8 @@ static na_return_t
 na_cci_addr_lookup(na_class_t * na_class, na_context_t * context,
     na_cb_t callback, void *arg, const char *name, na_op_id_t * op_id)
 {
-    cci_endpoint_t *e = NA_CCI_PRIVATE_DATA(na_class)->endpoint;
-    char *uri = NA_CCI_PRIVATE_DATA(na_class)->uri;
+    cci_endpoint_t *e = NA_CCI_CLASS(na_class)->endpoint;
+    char *uri = NA_CCI_CLASS(na_class)->uri;
     struct na_cci_op_id *na_cci_op_id = NULL;
     na_cci_addr_t *na_cci_addr = NULL;
     na_return_t ret = NA_SUCCESS;
@@ -868,7 +863,7 @@ na_cci_addr_self(na_class_t * na_class, na_addr_t * addr)
         goto out;
     }
     na_cci_addr->cci_addr = 0;
-    na_cci_addr->uri = strdup(NA_CCI_PRIVATE_DATA(na_class)->uri);
+    na_cci_addr->uri = strdup(NA_CCI_CLASS(na_class)->uri);
     na_cci_addr->unexpected = NA_FALSE;
     na_cci_addr->self = NA_TRUE;
     na_cci_addr->na_cci_op_id = NULL;
@@ -1005,7 +1000,7 @@ na_cci_addr_to_string(na_class_t NA_UNUSED * na_class, char *buf,
 static na_size_t
 na_cci_msg_get_max_unexpected_size(const na_class_t *na_class)
 {
-    cci_endpoint_t *e = NA_CCI_PRIVATE_DATA(na_class)->endpoint;
+    cci_endpoint_t *e = NA_CCI_CLASS(na_class)->endpoint;
     cci_msg_t msg;
     na_size_t max_unexpected_size = e->device->max_send_size - sizeof(msg.size);
 
@@ -1016,7 +1011,7 @@ na_cci_msg_get_max_unexpected_size(const na_class_t *na_class)
 static na_size_t
 na_cci_msg_get_max_expected_size(const na_class_t *na_class)
 {
-    cci_endpoint_t *e = NA_CCI_PRIVATE_DATA(na_class)->endpoint;
+    cci_endpoint_t *e = NA_CCI_CLASS(na_class)->endpoint;
     cci_msg_t msg;
     na_size_t max_expected_size = e->device->max_send_size - sizeof(msg.size);
 
@@ -1090,7 +1085,7 @@ na_cci_msg_send_unexpected(na_class_t *na_class, na_context_t * context,
     /* Post the CCI unexpected send request */
     rc = cci_sendv(na_cci_addr->cci_addr, iov, 2, na_cci_op_id, 0);
     if (rc) {
-        cci_endpoint_t *endpoint = NA_CCI_PRIVATE_DATA(na_class)->endpoint;
+        cci_endpoint_t *endpoint = NA_CCI_CLASS(na_class)->endpoint;
         NA_LOG_ERROR("cci_sendv() failed with %s", cci_strerror(endpoint, rc));
         ret = NA_PROTOCOL_ERROR;
         goto out;
@@ -1189,13 +1184,13 @@ na_cci_msg_unexpected_push(na_class_t * na_class,
         goto out;
     }
     hg_thread_mutex_lock(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
+        &NA_CCI_CLASS(na_class)->unexpected_msg_queue_mutex);
 
-    HG_QUEUE_PUSH_TAIL(&NA_CCI_PRIVATE_DATA(na_class)->unexpected_msg_queue,
+    HG_QUEUE_PUSH_TAIL(&NA_CCI_CLASS(na_class)->unexpected_msg_queue,
         rx, entry);
 
     hg_thread_mutex_unlock(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
+        &NA_CCI_CLASS(na_class)->unexpected_msg_queue_mutex);
 
 out:
     return ret;
@@ -1207,15 +1202,12 @@ na_cci_msg_unexpected_pop(na_class_t * na_class)
 {
     struct na_cci_info_recv_unexpected *rx;
 
-    hg_thread_mutex_lock(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
+    hg_thread_mutex_lock(&NA_CCI_CLASS(na_class)->unexpected_msg_queue_mutex);
 
-    rx = HG_QUEUE_FIRST(&NA_CCI_PRIVATE_DATA(na_class)->unexpected_msg_queue);
-    HG_QUEUE_POP_HEAD(&NA_CCI_PRIVATE_DATA(na_class)->unexpected_msg_queue,
-        entry);
+    rx = HG_QUEUE_FIRST(&NA_CCI_CLASS(na_class)->unexpected_msg_queue);
+    HG_QUEUE_POP_HEAD(&NA_CCI_CLASS(na_class)->unexpected_msg_queue, entry);
 
-    hg_thread_mutex_unlock(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_msg_queue_mutex);
+    hg_thread_mutex_unlock(&NA_CCI_CLASS(na_class)->unexpected_msg_queue_mutex);
 
     return rx;
 }
@@ -1232,14 +1224,12 @@ na_cci_msg_unexpected_op_push(na_class_t * na_class,
         ret = NA_INVALID_PARAM;
         goto out;
     }
-    hg_thread_mutex_lock(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_lock(&NA_CCI_CLASS(na_class)->unexpected_op_queue_mutex);
 
-    HG_QUEUE_PUSH_TAIL(&NA_CCI_PRIVATE_DATA(na_class)->unexpected_op_queue,
+    HG_QUEUE_PUSH_TAIL(&NA_CCI_CLASS(na_class)->unexpected_op_queue,
         na_cci_op_id, entry);
 
-    hg_thread_mutex_unlock(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_unlock(&NA_CCI_CLASS(na_class)->unexpected_op_queue_mutex);
 
 out:
     return ret;
@@ -1251,16 +1241,12 @@ na_cci_msg_unexpected_op_pop(na_class_t * na_class)
 {
     na_cci_op_id_t *na_cci_op_id;
 
-    hg_thread_mutex_lock(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_lock(&NA_CCI_CLASS(na_class)->unexpected_op_queue_mutex);
 
-    na_cci_op_id = HG_QUEUE_FIRST(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_op_queue);
-    HG_QUEUE_POP_HEAD(&NA_CCI_PRIVATE_DATA(na_class)->unexpected_op_queue,
-        entry);
+    na_cci_op_id = HG_QUEUE_FIRST(&NA_CCI_CLASS(na_class)->unexpected_op_queue);
+    HG_QUEUE_POP_HEAD(&NA_CCI_CLASS(na_class)->unexpected_op_queue, entry);
 
-    hg_thread_mutex_unlock(
-        &NA_CCI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_unlock(&NA_CCI_CLASS(na_class)->unexpected_op_queue_mutex);
 
     return na_cci_op_id;
 }
@@ -1323,7 +1309,7 @@ na_cci_msg_send_expected(na_class_t *na_class, na_context_t * context,
     /* Post the CCI send request */
     rc = cci_sendv(na_cci_addr->cci_addr, iov, 2, na_cci_op_id, 0);
     if (rc) {
-        cci_endpoint_t *endpoint = NA_CCI_PRIVATE_DATA(na_class)->endpoint;
+        cci_endpoint_t *endpoint = NA_CCI_CLASS(na_class)->endpoint;
         NA_LOG_ERROR("cci_sendv() failed with %s", cci_strerror(endpoint, rc));
         ret = NA_PROTOCOL_ERROR;
         goto out;
@@ -1467,7 +1453,7 @@ static na_return_t
 na_cci_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_cci_mem_handle_t *na_cci_mem_handle = mem_handle;
-    cci_endpoint_t *e = NA_CCI_PRIVATE_DATA(na_class)->endpoint;
+    cci_endpoint_t *e = NA_CCI_CLASS(na_class)->endpoint;
     cci_rma_handle_t *h = NULL;
     int rc = 0, flags = 0;
     na_return_t ret = NA_SUCCESS;
@@ -1507,7 +1493,7 @@ static na_return_t
 na_cci_mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_cci_mem_handle_t *na_cci_mem_handle = mem_handle;
-    cci_endpoint_t *e = NA_CCI_PRIVATE_DATA(na_class)->endpoint;
+    cci_endpoint_t *e = NA_CCI_CLASS(na_class)->endpoint;
     int rc = 0;
     na_return_t ret = NA_SUCCESS;
 
@@ -1612,7 +1598,7 @@ na_cci_put(na_class_t * na_class, na_context_t * context, na_cb_t callback,
     na_cci_op_id_t *na_cci_op_id = NULL;
     na_return_t ret = NA_SUCCESS;
     int rc;
-    cci_endpoint_t *e = NA_CCI_PRIVATE_DATA(na_class)->endpoint;
+    cci_endpoint_t *e = NA_CCI_CLASS(na_class)->endpoint;
     cci_connection_t *c = na_cci_addr->cci_addr;
     cci_rma_handle_t *local = &cci_local_mem_handle->h;
     cci_rma_handle_t *remote = &cci_remote_mem_handle->h;
@@ -1690,7 +1676,7 @@ na_cci_get(na_class_t * na_class, na_context_t * context, na_cb_t callback,
     na_cci_op_id_t *na_cci_op_id = NULL;
     na_return_t ret = NA_SUCCESS;
     int rc;
-    cci_endpoint_t *e = NA_CCI_PRIVATE_DATA(na_class)->endpoint;
+    cci_endpoint_t *e = NA_CCI_CLASS(na_class)->endpoint;
     cci_connection_t *c = na_cci_addr->cci_addr;
     cci_rma_handle_t *local = &cci_local_mem_handle->h;
     cci_rma_handle_t *remote = &cci_remote_mem_handle->h;
@@ -1752,7 +1738,7 @@ out:
 static int
 na_cci_poll_get_fd(na_class_t *na_class, na_context_t NA_UNUSED *context)
 {
-    return NA_CCI_PRIVATE_DATA(na_class)->fd;
+    return NA_CCI_CLASS(na_class)->fd;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2024,11 +2010,11 @@ handle_accept(na_class_t NA_UNUSED *na_class, na_context_t NA_UNUSED *context,
 
     /* Add address to accepted connection list */
     hg_thread_mutex_lock(
-        &NA_CCI_PRIVATE_DATA(na_class)->accept_conn_list_mutex);
-    HG_LIST_INSERT_HEAD(&NA_CCI_PRIVATE_DATA(na_class)->accept_conn_list,
+        &NA_CCI_CLASS(na_class)->accept_conn_list_mutex);
+    HG_LIST_INSERT_HEAD(&NA_CCI_CLASS(na_class)->accept_conn_list,
         na_cci_addr, entry);
     hg_thread_mutex_unlock(
-        &NA_CCI_PRIVATE_DATA(na_class)->accept_conn_list_mutex);
+        &NA_CCI_CLASS(na_class)->accept_conn_list_mutex);
 
     return;
 }
@@ -2040,7 +2026,7 @@ na_cci_progress(na_class_t * na_class, na_context_t * context,
 {
     double remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
     na_return_t ret = NA_TIMEOUT;
-    cci_endpoint_t *e = NA_CCI_PRIVATE_DATA(na_class)->endpoint;
+    cci_endpoint_t *e = NA_CCI_CLASS(na_class)->endpoint;
 
     do {
         int rc;
diff --git a/src/na/na_config.h.in b/src/na/na_config.h.in
index 1880d58..effe390 100644
--- a/src/na/na_config.h.in
+++ b/src/na/na_config.h.in
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -13,6 +13,7 @@
 #ifndef NA_CONFIG_H
 #define NA_CONFIG_H
 
+/* Import/export declarations */
 #if defined(_WIN32)
     #define NA_ABI_IMPORT __declspec(dllimport)
     #define NA_ABI_EXPORT __declspec(dllexport)
@@ -52,8 +53,10 @@
 #cmakedefine NA_HAS_MULTI_PROGRESS
 #cmakedefine NA_HAS_VERBOSE_ERROR
 
+/* Define if build shared libraries */
 #cmakedefine NA_BUILD_SHARED_LIBS
 
+/* Define export declaration */
 #ifdef NA_BUILD_SHARED_LIBS
     #ifdef na_EXPORTS
       #define NA_EXPORT NA_ABI_EXPORT
@@ -64,6 +67,7 @@
     #define NA_EXPORT
 #endif
 
+/* Standard types */
 #ifdef _WIN32
     typedef signed   __int64 na_int64_t;
     typedef signed   __int32 na_int32_t;
@@ -75,6 +79,7 @@
     typedef unsigned __int8  na_uint8_t;
 #else
     #include <stdint.h>
+    #include <stddef.h>
     typedef int64_t  na_int64_t;
     typedef int32_t  na_int32_t;
     typedef int16_t  na_int16_t;
@@ -84,22 +89,26 @@
     typedef uint16_t na_uint16_t;
     typedef uint8_t  na_uint8_t;
 #endif
-typedef na_uint64_t  na_ptr_t;
 typedef na_uint8_t   na_bool_t;
-#define NA_TRUE     1
-#define NA_FALSE    0
+typedef na_uint64_t  na_ptr_t;
 
+/* Inline declarations */
 #ifdef _WIN32
    #define NA_INLINE __inline
 #else
    #define NA_INLINE __inline__
 #endif
 
+/* Unused return values */
 #if defined(__GNUC__)
     #define NA_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
 #else
     #define NA_WARN_UNUSED_RESULT
 #endif
 
+/* Return codes */
+#define NA_TRUE     1
+#define NA_FALSE    0
+
 #endif /* NA_CONFIG_H */
 
diff --git a/src/na/na_error.h b/src/na/na_error.h
index aec5455..f04adb0 100644
--- a/src/na/na_error.h
+++ b/src/na/na_error.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/na/na_mpi.c b/src/na/na_mpi.c
index ccdac8a..2ad315a 100644
--- a/src/na/na_mpi.c
+++ b/src/na/na_mpi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -9,16 +9,10 @@
  */
 
 #include "na_mpi.h"
-#include "na_private.h"
-#include "na_error.h"
+#include "na_plugin.h"
 
 #include "mercury_list.h"
-#include "mercury_queue.h"
-#include "mercury_thread.h"
-#include "mercury_thread_mutex.h"
-#include "mercury_thread_condition.h"
 #include "mercury_time.h"
-#include "mercury_atomic.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -48,8 +42,8 @@ static int MPI_MAX_TAG = 32767;
 #define NA_MPI_RMA_TAG (NA_MPI_RMA_REQUEST_TAG + 1)
 #define NA_MPI_MAX_RMA_TAG (MPI_MAX_TAG >> 1)
 
-#define NA_MPI_PRIVATE_DATA(na_class) \
-    ((struct na_mpi_private_data *)(na_class->private_data))
+#define NA_MPI_CLASS(na_class) \
+    ((struct na_mpi_class *)(na_class->plugin_class))
 
 #ifdef _WIN32
 #  define strtok_r strtok_s
@@ -162,7 +156,7 @@ struct na_mpi_op_id {
     struct na_cb_completion_data completion_data;
 };
 
-struct na_mpi_private_data {
+struct na_mpi_class {
     na_bool_t listening;                    /* Used in server mode */
     na_bool_t mpi_ext_initialized;          /* MPI externally initialized */
     na_bool_t use_static_inter_comm;         /* Use static inter-communicator */
@@ -537,8 +531,7 @@ na_mpi_cancel(
 /* Local Variables */
 /*******************/
 
-const na_class_t na_mpi_class_g = {
-        NULL,                                 /* private_data */
+NA_PLUGIN_OPS(mpi) = {
         "mpi",                                /* name */
         na_mpi_check_protocol,                /* check_protocol */
         na_mpi_initialize,                    /* initialize */
@@ -625,10 +618,10 @@ na_mpi_open_port(na_class_t *na_class)
     int mpi_ret;
     na_return_t ret = NA_SUCCESS;
 
-    memset(NA_MPI_PRIVATE_DATA(na_class)->port_name, '\0', MPI_MAX_PORT_NAME);
+    memset(NA_MPI_CLASS(na_class)->port_name, '\0', MPI_MAX_PORT_NAME);
     memset(mpi_port_name, '\0', MPI_MAX_PORT_NAME);
 
-    MPI_Comm_rank(NA_MPI_PRIVATE_DATA(na_class)->intra_comm, &my_rank);
+    MPI_Comm_rank(NA_MPI_CLASS(na_class)->intra_comm, &my_rank);
     if (my_rank == 0) {
         mpi_ret = MPI_Open_port(MPI_INFO_NULL, mpi_port_name);
         if (mpi_ret != MPI_SUCCESS) {
@@ -638,14 +631,14 @@ na_mpi_open_port(na_class_t *na_class)
         }
     }
     mpi_ret = MPI_Bcast(mpi_port_name, MPI_MAX_PORT_NAME, MPI_BYTE, 0,
-            NA_MPI_PRIVATE_DATA(na_class)->intra_comm);
+            NA_MPI_CLASS(na_class)->intra_comm);
     if (mpi_ret != MPI_SUCCESS) {
         NA_LOG_ERROR("MPI_Bcast() failed");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
-    strcpy(NA_MPI_PRIVATE_DATA(na_class)->port_name, mpi_port_name);
+    strcpy(NA_MPI_CLASS(na_class)->port_name, mpi_port_name);
 
 done:
     return ret;
@@ -703,15 +696,15 @@ na_mpi_accept(na_class_t *na_class)
     na_return_t ret = NA_SUCCESS;
     int mpi_ret;
 
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->accept_mutex);
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->accept_mutex);
 
-    if (NA_MPI_PRIVATE_DATA(na_class)->use_static_inter_comm) {
+    if (NA_MPI_CLASS(na_class)->use_static_inter_comm) {
         int global_size, intra_size;
 
         MPI_Comm_size(MPI_COMM_WORLD, &global_size);
-        MPI_Comm_size(NA_MPI_PRIVATE_DATA(na_class)->intra_comm, &intra_size);
+        MPI_Comm_size(NA_MPI_CLASS(na_class)->intra_comm, &intra_size);
         mpi_ret = MPI_Intercomm_create(
-                NA_MPI_PRIVATE_DATA(na_class)->intra_comm, 0, MPI_COMM_WORLD,
+                NA_MPI_CLASS(na_class)->intra_comm, 0, MPI_COMM_WORLD,
                 global_size - (global_size - intra_size), 0, &new_comm);
         if (mpi_ret != MPI_SUCCESS) {
             NA_LOG_ERROR("MPI_Intercomm_create failed");
@@ -719,8 +712,8 @@ na_mpi_accept(na_class_t *na_class)
             goto done;
         }
     } else {
-        mpi_ret = MPI_Comm_accept(NA_MPI_PRIVATE_DATA(na_class)->port_name,
-                MPI_INFO_NULL, 0, NA_MPI_PRIVATE_DATA(na_class)->intra_comm,
+        mpi_ret = MPI_Comm_accept(NA_MPI_CLASS(na_class)->port_name,
+                MPI_INFO_NULL, 0, NA_MPI_CLASS(na_class)->intra_comm,
                 &new_comm);
         if (mpi_ret != MPI_SUCCESS) {
             NA_LOG_ERROR("MPI_Comm_accept failed");
@@ -738,10 +731,10 @@ na_mpi_accept(na_class_t *na_class)
         goto done;
     }
 
-    NA_MPI_PRIVATE_DATA(na_class)->accepting = NA_FALSE;
-    hg_thread_cond_signal(&NA_MPI_PRIVATE_DATA(na_class)->accept_cond);
+    NA_MPI_CLASS(na_class)->accepting = NA_FALSE;
+    hg_thread_cond_signal(&NA_MPI_CLASS(na_class)->accept_cond);
 
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->accept_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->accept_mutex);
 
     na_mpi_addr = (struct na_mpi_addr *) malloc(sizeof(struct na_mpi_addr));
     if (!na_mpi_addr) {
@@ -754,14 +747,14 @@ na_mpi_accept(na_class_t *na_class)
     na_mpi_addr->rank = MPI_ANY_SOURCE;
     na_mpi_addr->unexpected = NA_FALSE;
     na_mpi_addr->dynamic = (na_bool_t)
-            (!NA_MPI_PRIVATE_DATA(na_class)->use_static_inter_comm);
+            (!NA_MPI_CLASS(na_class)->use_static_inter_comm);
     memset(na_mpi_addr->port_name, '\0', MPI_MAX_PORT_NAME);
 
     /* Add comms to list of connected remotes */
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
-    HG_LIST_INSERT_HEAD(&NA_MPI_PRIVATE_DATA(na_class)->remote_list,
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->remote_list_mutex);
+    HG_LIST_INSERT_HEAD(&NA_MPI_CLASS(na_class)->remote_list,
         na_mpi_addr, entry);
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->remote_list_mutex);
 
 done:
     return ret;
@@ -802,12 +795,12 @@ na_mpi_remote_list_disconnect(na_class_t *na_class)
 {
     na_return_t ret = NA_SUCCESS;
 
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->remote_list_mutex);
 
     /* Process list of communicators */
-    while (!HG_LIST_IS_EMPTY(&NA_MPI_PRIVATE_DATA(na_class)->remote_list)) {
+    while (!HG_LIST_IS_EMPTY(&NA_MPI_CLASS(na_class)->remote_list)) {
         struct na_mpi_addr *na_mpi_addr =
-            HG_LIST_FIRST(&NA_MPI_PRIVATE_DATA(na_class)->remote_list);
+            HG_LIST_FIRST(&NA_MPI_CLASS(na_class)->remote_list);
         HG_LIST_REMOVE(na_mpi_addr, entry);
 
         ret = na_mpi_disconnect(na_class, na_mpi_addr);
@@ -817,7 +810,7 @@ na_mpi_remote_list_disconnect(na_class_t *na_class)
     }
 
  done:
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->remote_list_mutex);
     return ret;
 }
 
@@ -828,14 +821,12 @@ na_mpi_msg_unexpected_op_push(na_class_t *na_class,
 {
     na_return_t ret = NA_SUCCESS;
 
-    hg_thread_mutex_lock(
-            &NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->unexpected_op_queue_mutex);
 
-    HG_QUEUE_PUSH_TAIL(&NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue,
+    HG_QUEUE_PUSH_TAIL(&NA_MPI_CLASS(na_class)->unexpected_op_queue,
         na_mpi_op_id, entry);
 
-    hg_thread_mutex_unlock(
-            &NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->unexpected_op_queue_mutex);
 
     return ret;
 }
@@ -846,16 +837,12 @@ na_mpi_msg_unexpected_op_pop(na_class_t *na_class)
 {
     struct na_mpi_op_id *na_mpi_op_id;
 
-    hg_thread_mutex_lock(
-            &NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->unexpected_op_queue_mutex);
 
-    na_mpi_op_id = HG_QUEUE_FIRST(
-        &NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue);
-    HG_QUEUE_POP_HEAD(&NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue,
-        entry);
+    na_mpi_op_id = HG_QUEUE_FIRST(&NA_MPI_CLASS(na_class)->unexpected_op_queue);
+    HG_QUEUE_POP_HEAD(&NA_MPI_CLASS(na_class)->unexpected_op_queue, entry);
 
-    hg_thread_mutex_unlock(
-            &NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->unexpected_op_queue_mutex);
 
     return na_mpi_op_id;
 }
@@ -867,12 +854,12 @@ na_mpi_gen_rma_tag(na_class_t *na_class)
     na_tag_t tag;
 
     /* Compare and swap tag if reached max tag */
-    if (hg_atomic_cas32(&NA_MPI_PRIVATE_DATA(na_class)->rma_tag,
+    if (hg_atomic_cas32(&NA_MPI_CLASS(na_class)->rma_tag,
             NA_MPI_MAX_RMA_TAG, NA_MPI_RMA_TAG)) {
         tag = (na_tag_t) NA_MPI_RMA_TAG;
     } else {
         /* Increment tag */
-        tag = (na_tag_t) hg_atomic_incr32(&NA_MPI_PRIVATE_DATA(na_class)->rma_tag);
+        tag = (na_tag_t) hg_atomic_incr32(&NA_MPI_CLASS(na_class)->rma_tag);
     }
 
     return tag;
@@ -894,14 +881,14 @@ NA_MPI_Get_port_name(na_class_t *na_class)
     int my_rank;
     static char port_name[MPI_MAX_PORT_NAME + 16];
 
-    MPI_Comm_rank(NA_MPI_PRIVATE_DATA(na_class)->intra_comm, &my_rank);
+    MPI_Comm_rank(NA_MPI_CLASS(na_class)->intra_comm, &my_rank);
 
     /* Append rank info to port name */
-    if (NA_MPI_PRIVATE_DATA(na_class)->use_static_inter_comm)
+    if (NA_MPI_CLASS(na_class)->use_static_inter_comm)
         sprintf(port_name, "rank#%d$", my_rank);
     else
         sprintf(port_name, "%s;rank#%d$",
-            NA_MPI_PRIVATE_DATA(na_class)->port_name, my_rank);
+            NA_MPI_CLASS(na_class)->port_name, my_rank);
 
     return port_name;
 }
@@ -1011,16 +998,16 @@ na_mpi_initialize(na_class_t *na_class, const struct na_info *na_info,
     int *attr_val, attr_flag;
     na_return_t ret = NA_SUCCESS;
 
-    na_class->private_data = malloc(sizeof(struct na_mpi_private_data));
-    if (!na_class->private_data) {
+    na_class->plugin_class = malloc(sizeof(struct na_mpi_class));
+    if (!na_class->plugin_class) {
         NA_LOG_ERROR("Could not allocate NA private data class");
         ret = NA_NOMEM_ERROR;
         goto done;
     }
-    NA_MPI_PRIVATE_DATA(na_class)->accept_thread = 0;
-    HG_LIST_INIT(&NA_MPI_PRIVATE_DATA(na_class)->remote_list);
-    HG_LIST_INIT(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list);
-    HG_QUEUE_INIT(&NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue);
+    NA_MPI_CLASS(na_class)->accept_thread = 0;
+    HG_LIST_INIT(&NA_MPI_CLASS(na_class)->remote_list);
+    HG_LIST_INIT(&NA_MPI_CLASS(na_class)->op_id_list);
+    HG_QUEUE_INIT(&NA_MPI_CLASS(na_class)->unexpected_op_queue);
 
     /* Check flags */
     if (strcmp(na_info->protocol_name, "static") == 0)
@@ -1038,10 +1025,10 @@ na_mpi_initialize(na_class_t *na_class, const struct na_info *na_info,
     }
 
     listening = (na_bool_t) (flags & MPI_INIT_SERVER);
-    NA_MPI_PRIVATE_DATA(na_class)->listening = listening;
+    NA_MPI_CLASS(na_class)->listening = listening;
 
     use_static_inter_comm = (na_bool_t) (flags & MPI_INIT_STATIC);
-    NA_MPI_PRIVATE_DATA(na_class)->use_static_inter_comm = use_static_inter_comm;
+    NA_MPI_CLASS(na_class)->use_static_inter_comm = use_static_inter_comm;
 
     /* Initialize MPI */
     mpi_ret = MPI_Initialized(&mpi_ext_initialized);
@@ -1050,7 +1037,7 @@ na_mpi_initialize(na_class_t *na_class, const struct na_info *na_info,
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
-    NA_MPI_PRIVATE_DATA(na_class)->mpi_ext_initialized =
+    NA_MPI_CLASS(na_class)->mpi_ext_initialized =
             (na_bool_t) mpi_ext_initialized;
 
     if (!mpi_ext_initialized) {
@@ -1084,7 +1071,7 @@ na_mpi_initialize(na_class_t *na_class, const struct na_info *na_info,
         MPI_Comm comm = (na_mpi_init_comm_g != MPI_COMM_NULL) ?
                 na_mpi_init_comm_g : MPI_COMM_WORLD;
 
-        mpi_ret = MPI_Comm_dup(comm, &NA_MPI_PRIVATE_DATA(na_class)->intra_comm);
+        mpi_ret = MPI_Comm_dup(comm, &NA_MPI_CLASS(na_class)->intra_comm);
         if (mpi_ret != MPI_SUCCESS) {
             NA_LOG_ERROR("Could not duplicate communicator");
             ret = NA_PROTOCOL_ERROR;
@@ -1100,7 +1087,7 @@ na_mpi_initialize(na_class_t *na_class, const struct na_info *na_info,
 
         /* Assume that the application did not split MPI_COMM_WORLD already */
         mpi_ret = MPI_Comm_split(MPI_COMM_WORLD, color, global_rank,
-                &NA_MPI_PRIVATE_DATA(na_class)->intra_comm);
+                &NA_MPI_CLASS(na_class)->intra_comm);
         if (mpi_ret != MPI_SUCCESS) {
             NA_LOG_ERROR("Could not split communicator");
             ret = NA_PROTOCOL_ERROR;
@@ -1109,19 +1096,19 @@ na_mpi_initialize(na_class_t *na_class, const struct na_info *na_info,
     }
 
     /* Initialize mutex/cond */
-    hg_thread_mutex_init(&NA_MPI_PRIVATE_DATA(na_class)->accept_mutex);
-    hg_thread_cond_init(&NA_MPI_PRIVATE_DATA(na_class)->accept_cond);
-    hg_thread_mutex_init(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
-    hg_thread_mutex_init(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
+    hg_thread_mutex_init(&NA_MPI_CLASS(na_class)->accept_mutex);
+    hg_thread_cond_init(&NA_MPI_CLASS(na_class)->accept_cond);
+    hg_thread_mutex_init(&NA_MPI_CLASS(na_class)->remote_list_mutex);
+    hg_thread_mutex_init(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
     hg_thread_mutex_init(
-            &NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+            &NA_MPI_CLASS(na_class)->unexpected_op_queue_mutex);
 
     /* Initialize atomic op */
-    hg_atomic_set32(&NA_MPI_PRIVATE_DATA(na_class)->rma_tag, NA_MPI_RMA_TAG);
+    hg_atomic_set32(&NA_MPI_CLASS(na_class)->rma_tag, NA_MPI_RMA_TAG);
 
     /* If server opens a port */
     if (listening) {
-        NA_MPI_PRIVATE_DATA(na_class)->accepting = NA_TRUE;
+        NA_MPI_CLASS(na_class)->accepting = NA_TRUE;
         if (!use_static_inter_comm && (ret = na_mpi_open_port(na_class)) != NA_SUCCESS) {
             NA_LOG_ERROR("Cannot open port");
             goto done;
@@ -1130,16 +1117,16 @@ na_mpi_initialize(na_class_t *na_class, const struct na_info *na_info,
         /* We need to create a thread here if we want to allow
          * connection / disconnection since MPI does not provide any
          * service for that and MPI_Comm_accept is blocking */
-        hg_thread_create(&NA_MPI_PRIVATE_DATA(na_class)->accept_thread,
+        hg_thread_create(&NA_MPI_CLASS(na_class)->accept_thread,
                 &na_mpi_accept_service,
                 (void *) na_class);
     } else {
-        NA_MPI_PRIVATE_DATA(na_class)->accepting = NA_FALSE;
+        NA_MPI_CLASS(na_class)->accepting = NA_FALSE;
     }
 
     /* MPI implementation typically provides a "max tag" far larger than
      * standard demands */
-    MPI_Comm_get_attr(NA_MPI_PRIVATE_DATA(na_class)->intra_comm, MPI_TAG_UB,
+    MPI_Comm_get_attr(NA_MPI_CLASS(na_class)->intra_comm, MPI_TAG_UB,
             &attr_val, &attr_flag);
     if (attr_flag) MPI_MAX_TAG = *attr_val;
 
@@ -1159,17 +1146,17 @@ na_mpi_finalize(na_class_t *na_class)
     int mpi_ext_finalized = 0;
     int mpi_ret;
 
-    if (!na_class->private_data) {
+    if (!na_class->plugin_class) {
         goto done;
     }
 
-    if (NA_MPI_PRIVATE_DATA(na_class)->listening) {
+    if (NA_MPI_CLASS(na_class)->listening) {
         /* No more connection accepted after this point */
-        hg_thread_join(NA_MPI_PRIVATE_DATA(na_class)->accept_thread);
+        hg_thread_join(NA_MPI_CLASS(na_class)->accept_thread);
 
         /* If server opened a port */
-        if (!NA_MPI_PRIVATE_DATA(na_class)->use_static_inter_comm) {
-            mpi_ret = MPI_Close_port(NA_MPI_PRIVATE_DATA(na_class)->port_name);
+        if (!NA_MPI_CLASS(na_class)->use_static_inter_comm) {
+            mpi_ret = MPI_Close_port(NA_MPI_CLASS(na_class)->port_name);
             if (mpi_ret != MPI_SUCCESS) {
                 NA_LOG_ERROR("Could not close port");
                 ret = NA_PROTOCOL_ERROR;
@@ -1182,13 +1169,13 @@ na_mpi_finalize(na_class_t *na_class)
 
     /* Check that unexpected op queue is empty */
     if (!HG_QUEUE_IS_EMPTY(
-            &NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue)) {
+            &NA_MPI_CLASS(na_class)->unexpected_op_queue)) {
         NA_LOG_ERROR("Unexpected op queue should be empty");
         ret = NA_PROTOCOL_ERROR;
     }
 
     /* Free the private dup'ed comm */
-    mpi_ret = MPI_Comm_free(&NA_MPI_PRIVATE_DATA(na_class)->intra_comm);
+    mpi_ret = MPI_Comm_free(&NA_MPI_CLASS(na_class)->intra_comm);
     if (mpi_ret != MPI_SUCCESS) {
         NA_LOG_ERROR("Could not free intra_comm");
         ret = NA_PROTOCOL_ERROR;
@@ -1203,7 +1190,7 @@ na_mpi_finalize(na_class_t *na_class)
         goto done;
     }
 
-    if (!NA_MPI_PRIVATE_DATA(na_class)->mpi_ext_initialized &&
+    if (!NA_MPI_CLASS(na_class)->mpi_ext_initialized &&
             !mpi_ext_finalized) {
         mpi_ret = MPI_Finalize();
         if (mpi_ret != MPI_SUCCESS) {
@@ -1214,14 +1201,14 @@ na_mpi_finalize(na_class_t *na_class)
     }
 
     /* Destroy mutex/cond */
-    hg_thread_mutex_destroy(&NA_MPI_PRIVATE_DATA(na_class)->accept_mutex);
-    hg_thread_cond_destroy(&NA_MPI_PRIVATE_DATA(na_class)->accept_cond);
-    hg_thread_mutex_destroy(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
-    hg_thread_mutex_destroy(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
+    hg_thread_mutex_destroy(&NA_MPI_CLASS(na_class)->accept_mutex);
+    hg_thread_cond_destroy(&NA_MPI_CLASS(na_class)->accept_cond);
+    hg_thread_mutex_destroy(&NA_MPI_CLASS(na_class)->remote_list_mutex);
+    hg_thread_mutex_destroy(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
     hg_thread_mutex_destroy(
-            &NA_MPI_PRIVATE_DATA(na_class)->unexpected_op_queue_mutex);
+            &NA_MPI_CLASS(na_class)->unexpected_op_queue_mutex);
 
-    free(na_class->private_data);
+    free(na_class->plugin_class);
 
  done:
     return ret;
@@ -1274,15 +1261,15 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
 
     /* Try to connect, must prevent concurrent threads to
      * create new communicators */
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->accept_mutex);
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->accept_mutex);
 
     /* TODO A listening process can only "connect" to one of his pairs ? */
-    if (NA_MPI_PRIVATE_DATA(na_class)->listening) {
-        while (NA_MPI_PRIVATE_DATA(na_class)->accepting) {
-            hg_thread_cond_wait(&NA_MPI_PRIVATE_DATA(na_class)->accept_cond,
-                    &NA_MPI_PRIVATE_DATA(na_class)->accept_mutex);
+    if (NA_MPI_CLASS(na_class)->listening) {
+        while (NA_MPI_CLASS(na_class)->accepting) {
+            hg_thread_cond_wait(&NA_MPI_CLASS(na_class)->accept_cond,
+                    &NA_MPI_CLASS(na_class)->accept_mutex);
         }
-        mpi_ret = MPI_Comm_dup(NA_MPI_PRIVATE_DATA(na_class)->intra_comm,
+        mpi_ret = MPI_Comm_dup(NA_MPI_CLASS(na_class)->intra_comm,
                 &na_mpi_addr->comm);
         if (mpi_ret != MPI_SUCCESS) {
             NA_LOG_ERROR("MPI_Comm_dup() failed");
@@ -1290,9 +1277,9 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
             goto done;
         }
     } else {
-        if (NA_MPI_PRIVATE_DATA(na_class)->use_static_inter_comm) {
+        if (NA_MPI_CLASS(na_class)->use_static_inter_comm) {
             mpi_ret = MPI_Intercomm_create(
-                    NA_MPI_PRIVATE_DATA(na_class)->intra_comm, 0,
+                    NA_MPI_CLASS(na_class)->intra_comm, 0,
                     MPI_COMM_WORLD, 0, 0, &na_mpi_addr->comm);
             if (mpi_ret != MPI_SUCCESS) {
                 NA_LOG_ERROR("MPI_Intercomm_create() failed");
@@ -1302,7 +1289,7 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
         } else {
             na_mpi_addr->dynamic = NA_TRUE;
             mpi_ret = MPI_Comm_connect(na_mpi_addr->port_name, MPI_INFO_NULL, 0,
-                    NA_MPI_PRIVATE_DATA(na_class)->intra_comm,
+                    NA_MPI_CLASS(na_class)->intra_comm,
                     &na_mpi_addr->comm);
             if (mpi_ret != MPI_SUCCESS) {
                 NA_LOG_ERROR("MPI_Comm_connect() failed");
@@ -1321,13 +1308,13 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
         goto done;
     }
 
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->accept_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->accept_mutex);
 
     /* Add addr to list of addresses */
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
-    HG_LIST_INSERT_HEAD(&NA_MPI_PRIVATE_DATA(na_class)->remote_list,
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->remote_list_mutex);
+    HG_LIST_INSERT_HEAD(&NA_MPI_CLASS(na_class)->remote_list,
         na_mpi_addr, entry);
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->remote_list_mutex);
 
     /* TODO MPI calls are blocking and so is na_mpi_addr_lookup,
      * i.e. we always complete here for now */
@@ -1367,9 +1354,9 @@ na_mpi_addr_self(na_class_t *na_class, na_addr_t *addr)
     na_mpi_addr->self = NA_TRUE;
     na_mpi_addr->dynamic = NA_FALSE;
     memset(na_mpi_addr->port_name, '\0', MPI_MAX_PORT_NAME);
-    if (!NA_MPI_PRIVATE_DATA(na_class)->use_static_inter_comm
-            && NA_MPI_PRIVATE_DATA(na_class)->listening)
-        strcpy(na_mpi_addr->port_name, NA_MPI_PRIVATE_DATA(na_class)->port_name);
+    if (!NA_MPI_CLASS(na_class)->use_static_inter_comm
+            && NA_MPI_CLASS(na_class)->listening)
+        strcpy(na_mpi_addr->port_name, NA_MPI_CLASS(na_class)->port_name);
 
     *addr = (na_addr_t) na_mpi_addr;
 
@@ -1399,14 +1386,14 @@ na_mpi_addr_free(na_class_t *na_class, na_addr_t addr)
         struct na_mpi_addr *var = NULL;
 
         /* Remove addr from list of addresses */
-        hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
-        HG_LIST_FOREACH(var, &NA_MPI_PRIVATE_DATA(na_class)->remote_list, entry) {
+        hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->remote_list_mutex);
+        HG_LIST_FOREACH(var, &NA_MPI_CLASS(na_class)->remote_list, entry) {
             if (var == na_mpi_addr) {
                 HG_LIST_REMOVE(var, entry);
                 break;
             }
         }
-        hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
+        hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->remote_list_mutex);
 
         /* Free addr */
         ret = na_mpi_disconnect(na_class, na_mpi_addr);
@@ -1438,7 +1425,7 @@ na_mpi_addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
 
     mpi_addr = (struct na_mpi_addr *) addr;
 
-    if (NA_MPI_PRIVATE_DATA(na_class)->use_static_inter_comm) {
+    if (NA_MPI_CLASS(na_class)->use_static_inter_comm) {
         sprintf(port_name, "rank#%d$", mpi_addr->rank);
     } else {
         sprintf(port_name, "%s;rank#%d$", mpi_addr->port_name, mpi_addr->rank);
@@ -1527,10 +1514,10 @@ na_mpi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     }
 
     /* Append op_id to op_id list */
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
-    HG_LIST_INSERT_HEAD(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list,
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
+    HG_LIST_INSERT_HEAD(&NA_MPI_CLASS(na_class)->op_id_list,
         na_mpi_op_id, entry);
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
 
 done:
     if (ret != NA_SUCCESS) {
@@ -1637,10 +1624,10 @@ na_mpi_msg_send_expected(na_class_t *na_class, na_context_t *context,
     }
 
     /* Append op_id to op_id list assign op_id */
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
-    HG_LIST_INSERT_HEAD(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list,
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
+    HG_LIST_INSERT_HEAD(&NA_MPI_CLASS(na_class)->op_id_list,
         na_mpi_op_id, entry);
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
 
 done:
     if (ret != NA_SUCCESS) {
@@ -1693,10 +1680,10 @@ na_mpi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     }
 
     /* Append op_id to op_id list */
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
-    HG_LIST_INSERT_HEAD(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list,
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
+    HG_LIST_INSERT_HEAD(&NA_MPI_CLASS(na_class)->op_id_list,
         na_mpi_op_id, entry);
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
 
 done:
     if (ret != NA_SUCCESS) {
@@ -1916,10 +1903,10 @@ na_mpi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     }
 
     /* Append op_id to op_id list */
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
-    HG_LIST_INSERT_HEAD(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list,
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
+    HG_LIST_INSERT_HEAD(&NA_MPI_CLASS(na_class)->op_id_list,
         na_mpi_op_id, entry);
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
 
 done:
     if (ret != NA_SUCCESS) {
@@ -2022,10 +2009,10 @@ na_mpi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     }
 
     /* Append op_id to op_id list */
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
-    HG_LIST_INSERT_HEAD(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list,
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
+    HG_LIST_INSERT_HEAD(&NA_MPI_CLASS(na_class)->op_id_list,
         na_mpi_op_id, entry);
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
 
 done:
     if (ret != NA_SUCCESS) {
@@ -2090,9 +2077,9 @@ na_mpi_progress_unexpected(na_class_t *na_class, na_context_t *context,
     int mpi_ret;
 
     /* Process list of communicators */
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->remote_list_mutex);
 
-    HG_LIST_FOREACH(probe_addr, &NA_MPI_PRIVATE_DATA(na_class)->remote_list, entry) {
+    HG_LIST_FOREACH(probe_addr, &NA_MPI_CLASS(na_class)->remote_list, entry) {
         MPI_Status status1, status2;
         int flag = 0;
 
@@ -2137,7 +2124,7 @@ na_mpi_progress_unexpected(na_class_t *na_class, na_context_t *context,
         }
     }
 
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->remote_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->remote_list_mutex);
 
 done:
     return ret;
@@ -2289,10 +2276,10 @@ na_mpi_progress_unexpected_rma(na_class_t *na_class, na_context_t *context,
     }
 
     /* Add op_id to list */
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
-    HG_LIST_INSERT_HEAD(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list,
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
+    HG_LIST_INSERT_HEAD(&NA_MPI_CLASS(na_class)->op_id_list,
         na_mpi_op_id, entry);
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
 
 done:
     if (ret != NA_SUCCESS) {
@@ -2310,9 +2297,9 @@ na_mpi_progress_expected(na_class_t *na_class, na_context_t NA_UNUSED *context,
     struct na_mpi_op_id *na_mpi_op_id = NULL;
     na_return_t ret = NA_TIMEOUT;
 
-    hg_thread_mutex_lock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
+    hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
 
-    na_mpi_op_id = HG_LIST_FIRST(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list);
+    na_mpi_op_id = HG_LIST_FIRST(&NA_MPI_CLASS(na_class)->op_id_list);
     while (na_mpi_op_id) {
         MPI_Request *request = NULL;
         na_bool_t internal = NA_FALSE; /* Only used to complete internal ops */
@@ -2428,7 +2415,7 @@ na_mpi_progress_expected(na_class_t *na_class, na_context_t NA_UNUSED *context,
     }
 
 done:
-    hg_thread_mutex_unlock(&NA_MPI_PRIVATE_DATA(na_class)->op_id_list_mutex);
+    hg_thread_mutex_unlock(&NA_MPI_CLASS(na_class)->op_id_list_mutex);
     return ret;
 }
 
diff --git a/src/na/na_mpi.h b/src/na/na_mpi.h
index 7772ee8..7014760 100644
--- a/src/na/na_mpi.h
+++ b/src/na/na_mpi.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/na/na_ofi.c b/src/na/na_ofi.c
index 5494e89..77015c6 100644
--- a/src/na/na_ofi.c
+++ b/src/na/na_ofi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -46,16 +46,13 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "na_private.h"
-#include "na_error.h"
+#include "na_plugin.h"
 
 #include "mercury_list.h"
-#include "mercury_thread_mutex.h"
 #include "mercury_thread_spin.h"
 #include "mercury_thread_rwlock.h"
 #include "mercury_hash_table.h"
 #include "mercury_time.h"
-#include "mercury_atomic.h"
 #include "mercury_mem.h"
 
 #include <rdma/fabric.h>
@@ -227,8 +224,8 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 #define NA_OFI_SEP_RX_CTX_BITS  (8)
 
 /* Private data access */
-#define NA_OFI_PRIVATE_DATA(na_class) \
-    ((struct na_ofi_private_data *)((na_class)->private_data))
+#define NA_OFI_CLASS(na_class) \
+    ((struct na_ofi_class *)((na_class)->plugin_class))
 #define NA_OFI_CONTEXT(na_context)    \
     ((struct na_ofi_context *)((na_context)->plugin_context))
 
@@ -407,7 +404,7 @@ struct na_ofi_mem_pool {
 };
 
 /* Private data */
-struct na_ofi_private_data {
+struct na_ofi_class {
     struct na_ofi_domain *nop_domain; /* Point back to access domain */
     struct na_ofi_endpoint *nop_endpoint;
     na_bool_t nop_listen; /* flag of listening, true for server */
@@ -539,7 +536,7 @@ na_ofi_gni_set_domain_op_value(struct na_ofi_domain *na_ofi_domain, int op,
  * Open domain.
  */
 static na_return_t
-na_ofi_domain_open(struct na_ofi_private_data *priv,
+na_ofi_domain_open(struct na_ofi_class *priv,
     enum na_ofi_prov_type prov_type,
     const char *domain_name, const char *auth_key,
     struct na_ofi_domain **na_ofi_domain_p);
@@ -939,8 +936,7 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context, na_op_id_t op_id);
 /* Local Variables */
 /*******************/
 
-const na_class_t na_ofi_class_g = {
-    NULL,                                   /* private_data */
+NA_PLUGIN_OPS(ofi) = {
     "ofi",                                  /* name */
     na_ofi_check_protocol,                  /* check_protocol */
     na_ofi_initialize,                      /* initialize */
@@ -1033,7 +1029,7 @@ na_ofi_domain_unlock(struct na_ofi_domain *domain)
 static NA_INLINE na_bool_t
 na_ofi_with_sep(const na_class_t *na_class)
 {
-    struct na_ofi_endpoint *ep = NA_OFI_PRIVATE_DATA(na_class)->nop_endpoint;
+    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->nop_endpoint;
 
     return ep->noe_sep;
 }
@@ -1042,7 +1038,7 @@ na_ofi_with_sep(const na_class_t *na_class)
 static NA_INLINE na_bool_t
 na_ofi_with_msg_hdr(const na_class_t *na_class)
 {
-    struct na_ofi_domain *domain = NA_OFI_PRIVATE_DATA(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
 
     return (na_ofi_prov_addr_format[domain->nod_prov_type] == FI_SOCKADDR_IN);
 }
@@ -1274,7 +1270,7 @@ static na_return_t
 na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
     const void *addr, na_size_t addrlen, fi_addr_t *fi_addr)
 {
-    struct na_ofi_domain *domain = NA_OFI_PRIVATE_DATA(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
     na_uint64_t addr_key;
     hg_hash_table_key_t ht_key = NULL;
     hg_hash_table_value_t ht_value = NULL;
@@ -1608,7 +1604,7 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_domain_open(struct na_ofi_private_data *priv, 
+na_ofi_domain_open(struct na_ofi_class *priv,
     enum na_ofi_prov_type prov_type,
     const char *domain_name, const char *auth_key,
     struct na_ofi_domain **na_ofi_domain_p)
@@ -2245,7 +2241,7 @@ out:
 static na_return_t
 na_ofi_get_ep_addr(na_class_t *na_class, struct na_ofi_addr **na_ofi_addr_ptr)
 {
-    struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_domain *na_ofi_domain = priv->nop_domain;
     struct na_ofi_endpoint *na_ofi_endpoint = priv->nop_endpoint;
     struct na_ofi_addr *na_ofi_addr = NULL;
@@ -2310,7 +2306,7 @@ out:
 static na_return_t
 na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
 {
-    struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_domain *na_ofi_domain = priv->nop_domain;
     char addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         fi_addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
@@ -2454,7 +2450,7 @@ na_ofi_mem_pool_destroy(struct na_ofi_mem_pool *na_ofi_mem_pool)
 static NA_INLINE void *
 na_ofi_mem_alloc(na_class_t *na_class, na_size_t size, struct fid_mr **mr_hdl)
 {
-    struct na_ofi_domain *domain = NA_OFI_PRIVATE_DATA(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
     na_size_t page_size = (na_size_t) hg_mem_get_page_size();
     void *mem_ptr = NULL;
 
@@ -2514,16 +2510,16 @@ na_ofi_mem_pool_alloc(na_class_t *na_class, na_size_t size,
 
 retry:
     /* Check whether we can get a block from one of the pools */
-    hg_thread_spin_lock(&NA_OFI_PRIVATE_DATA(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
     HG_QUEUE_FOREACH(na_ofi_mem_pool,
-        &NA_OFI_PRIVATE_DATA(na_class)->nop_buf_pool, entry) {
+        &NA_OFI_CLASS(na_class)->nop_buf_pool, entry) {
         hg_thread_spin_lock(&na_ofi_mem_pool->node_list_lock);
         found = !HG_QUEUE_IS_EMPTY(&na_ofi_mem_pool->node_list);
         hg_thread_spin_unlock(&na_ofi_mem_pool->node_list_lock);
         if (found)
             break;
     }
-    hg_thread_spin_unlock(&NA_OFI_PRIVATE_DATA(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
 
     /* If not, allocate and register a new pool */
     if (!found) {
@@ -2531,10 +2527,10 @@ retry:
             na_ofi_mem_pool_create(na_class,
                 na_ofi_msg_get_max_unexpected_size(na_class),
                 NA_OFI_MEM_BLOCK_COUNT);
-        hg_thread_spin_lock(&NA_OFI_PRIVATE_DATA(na_class)->nop_buf_pool_lock);
-        HG_QUEUE_PUSH_TAIL(&NA_OFI_PRIVATE_DATA(na_class)->nop_buf_pool,
+        hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+        HG_QUEUE_PUSH_TAIL(&NA_OFI_CLASS(na_class)->nop_buf_pool,
             na_ofi_mem_pool, entry);
-        hg_thread_spin_unlock(&NA_OFI_PRIVATE_DATA(na_class)->nop_buf_pool_lock);
+        hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
     }
 
     if (size > na_ofi_mem_pool->block_size) {
@@ -2567,9 +2563,9 @@ na_ofi_mem_pool_free(na_class_t *na_class, void *mem_ptr, struct fid_mr *mr_hdl)
         container_of(mem_ptr, struct na_ofi_mem_node, block);
 
     /* Put the node back to the pool */
-    hg_thread_spin_lock(&NA_OFI_PRIVATE_DATA(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
     HG_QUEUE_FOREACH(na_ofi_mem_pool,
-        &NA_OFI_PRIVATE_DATA(na_class)->nop_buf_pool, entry) {
+        &NA_OFI_CLASS(na_class)->nop_buf_pool, entry) {
         /* If MR handle is NULL, it does not really matter which pool we push
          * the node back to.
          */
@@ -2580,7 +2576,7 @@ na_ofi_mem_pool_free(na_class_t *na_class, void *mem_ptr, struct fid_mr *mr_hdl)
             break;
         }
     }
-    hg_thread_spin_unlock(&NA_OFI_PRIVATE_DATA(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2728,7 +2724,7 @@ na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
              */
             goto out;
         case FI_EADDRNOTAVAIL: {
-            struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+            struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
             struct fid_av *av_hdl = priv->nop_domain->nod_av;
             void *err_addr = NULL;
             size_t err_addrlen;
@@ -2798,8 +2794,10 @@ na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
         ret = NA_PROTOCOL_ERROR;
         goto out;
     }
-    if (hg_atomic_get32(&na_ofi_op_id->noo_canceled))
-        goto out;
+    if (hg_atomic_get32(&na_ofi_op_id->noo_canceled)) {
+        ret = NA_CANCELED;
+        goto complete;
+    }
     if (hg_atomic_get32(&na_ofi_op_id->noo_completed)) {
         NA_LOG_ERROR("Ignoring CQ event as the op is completed.");
         ret = NA_PROTOCOL_ERROR;
@@ -2849,6 +2847,7 @@ na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
             goto out;
     };
 
+complete:
     /* Complete operation */
     ret = na_ofi_complete(na_ofi_op_id, ret);
     if (ret != NA_SUCCESS) {
@@ -3109,7 +3108,7 @@ static na_return_t
 na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     na_bool_t listen)
 {
-    struct na_ofi_private_data *priv;
+    struct na_ofi_class *priv;
     void *src_addr = NULL;
     na_size_t src_addrlen = 0;
     char *resolve_name = NULL;
@@ -3242,15 +3241,15 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     }
 
     /* Create private data */
-    na_class->private_data = (struct na_ofi_private_data *) malloc(
-        sizeof(struct na_ofi_private_data));
-    if (!na_class->private_data) {
+    na_class->plugin_class = (struct na_ofi_class *) malloc(
+        sizeof(struct na_ofi_class));
+    if (!na_class->plugin_class) {
         NA_LOG_ERROR("Could not allocate NA private data class");
         ret = NA_NOMEM_ERROR;
         goto out;
     }
-    memset(na_class->private_data, 0, sizeof(struct na_ofi_private_data));
-    priv = NA_OFI_PRIVATE_DATA(na_class);
+    memset(na_class->plugin_class, 0, sizeof(struct na_ofi_class));
+    priv = NA_OFI_CLASS(na_class);
     priv->no_wait = no_wait;
     priv->nop_listen = listen;
     priv->nop_max_contexts = max_contexts;
@@ -3264,7 +3263,7 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     HG_QUEUE_INIT(&priv->nop_buf_pool);
 
     /* Create domain */
-    ret = na_ofi_domain_open(na_class->private_data, prov_type, domain_name,
+    ret = na_ofi_domain_open(na_class->plugin_class, prov_type, domain_name,
         auth_key, &priv->nop_domain);
     if (ret != NA_SUCCESS) {
         NA_LOG_ERROR("Could not open domain for %s, %s", na_ofi_prov_name[prov_type],
@@ -3290,9 +3289,9 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
 out:
     if (ret != NA_SUCCESS) {
         free(src_addr);
-        if (na_class->private_data) {
+        if (na_class->plugin_class) {
             na_ofi_finalize(na_class);
-            na_class->private_data = NULL;
+            na_class->plugin_class = NULL;
         }
     }
     free(resolve_name);
@@ -3303,7 +3302,7 @@ out:
 static na_return_t
 na_ofi_finalize(na_class_t *na_class)
 {
-    struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     na_return_t ret = NA_SUCCESS;
 
     if (priv == NULL)
@@ -3328,7 +3327,7 @@ na_ofi_finalize(na_class_t *na_class)
 
         na_ofi_mem_pool_destroy(na_ofi_mem_pool);
     }
-    hg_thread_spin_destroy(&NA_OFI_PRIVATE_DATA(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_destroy(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
 
     /* Close domain */
     if (priv->nop_domain) {
@@ -3343,7 +3342,7 @@ na_ofi_finalize(na_class_t *na_class)
     /* Close mutex / free private data */
     hg_thread_mutex_destroy(&priv->nop_mutex);
     free(priv);
-    na_class->private_data = NULL;
+    na_class->plugin_class = NULL;
 
 out:
     return ret;
@@ -3353,7 +3352,7 @@ out:
 static na_return_t
 na_ofi_context_create(na_class_t *na_class, void **context, na_uint8_t id)
 {
-    struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_domain *domain = priv->nop_domain;
     struct na_ofi_endpoint *ep = priv->nop_endpoint;
     struct na_ofi_context *ctx = NULL;
@@ -3518,7 +3517,7 @@ out:
 static na_return_t
 na_ofi_context_destroy(na_class_t *na_class, void *context)
 {
-    struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_context *ctx = (struct na_ofi_context *) context;
     na_return_t ret = NA_SUCCESS;
     int rc;
@@ -3634,7 +3633,7 @@ static na_return_t
 na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const char *name, na_op_id_t *op_id)
 {
-    struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_op_id *na_ofi_op_id = NULL;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
@@ -3730,7 +3729,7 @@ out:
 static NA_INLINE na_return_t
 na_ofi_addr_self(na_class_t *na_class, na_addr_t *addr)
 {
-    struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_endpoint *ep = priv->nop_endpoint;
 
     na_ofi_addr_addref(ep->noe_addr); /* decref in na_ofi_addr_free() */
@@ -3838,7 +3837,7 @@ static na_return_t
 na_ofi_addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
     na_size_t NA_UNUSED buf_size)
 {
-    struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
 
@@ -3887,7 +3886,7 @@ na_ofi_msg_get_max_unexpected_size(const na_class_t NA_UNUSED *na_class)
 {
     na_size_t max_unexpected_size = NA_OFI_UNEXPECTED_SIZE;
 #ifdef NA_OFI_HAS_EXT_GNI_H
-    struct na_ofi_domain *domain = NA_OFI_PRIVATE_DATA(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
 
     if (domain->nod_prov_type == NA_OFI_PROV_GNI) {
         struct fi_gni_ops_domain *gni_domain_ops;
@@ -3926,7 +3925,7 @@ na_ofi_msg_get_max_expected_size(const na_class_t NA_UNUSED *na_class)
     struct fi_ep_attr *ep_attr;
     na_size_t max_expected_size;
 
-    ep_attr = NA_OFI_PRIVATE_DATA(na_class)->nop_domain->nod_prov->ep_attr;
+    ep_attr = NA_OFI_CLASS(na_class)->nop_domain->nod_prov->ep_attr;
     max_expected_size = ep_attr->max_msg_size - ep_attr->msg_prefix_size;
 
     return max_expected_size;
@@ -4002,7 +4001,7 @@ na_ofi_msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
      * the msg header to piggyback the source address for unexpected message.
      */
     if (na_ofi_with_msg_hdr(na_class)) {
-        struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+        struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
         struct na_ofi_sin_addr *na_ofi_sin_addr =
             (struct na_ofi_sin_addr *) priv->nop_endpoint->noe_addr->addr;
 
@@ -4341,7 +4340,7 @@ static na_return_t
 na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     struct na_ofi_mem_handle *na_ofi_mem_handle = mem_handle;
-    struct na_ofi_domain *domain = NA_OFI_PRIVATE_DATA(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
     na_uint64_t access;
     int rc = 0;
     na_return_t ret = NA_SUCCESS;
@@ -4389,7 +4388,7 @@ static na_return_t
 na_ofi_mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     struct na_ofi_mem_handle *na_ofi_mem_handle = mem_handle;
-    struct na_ofi_domain *domain = NA_OFI_PRIVATE_DATA(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
     int rc;
 
     /* nothing to do for scalable memory registration mode */
@@ -4484,7 +4483,7 @@ na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_size_t length, na_addr_t remote_addr, na_uint8_t remote_id,
     na_op_id_t *op_id)
 {
-    struct na_ofi_domain *domain = NA_OFI_PRIVATE_DATA(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     struct fid_ep *ep_hdl = ctx->noc_tx;
     struct na_ofi_mem_handle *ofi_local_mem_handle =
@@ -4584,7 +4583,7 @@ na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_size_t length, na_addr_t remote_addr, na_uint8_t remote_id,
     na_op_id_t *op_id)
 {
-    struct na_ofi_domain *domain = NA_OFI_PRIVATE_DATA(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     struct fid_ep *ep_hdl = ctx->noc_tx;
     struct na_ofi_mem_handle *ofi_local_mem_handle =
@@ -4666,7 +4665,7 @@ out:
 static NA_INLINE int
 na_ofi_poll_get_fd(na_class_t *na_class, na_context_t *context)
 {
-    struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     int fd = -1, rc;
 
@@ -4691,7 +4690,7 @@ out:
 static NA_INLINE na_bool_t
 na_ofi_poll_try_wait(na_class_t *na_class, na_context_t *context)
 {
-    struct na_ofi_private_data *priv = NA_OFI_PRIVATE_DATA(na_class);
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     struct fid *fids[1];
     int rc;
@@ -4859,21 +4858,20 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context,
     case NA_CB_SEND_EXPECTED:
     case NA_CB_PUT:
     case NA_CB_GET:
+        /* May or may not be canceled in that case */
         rc = fi_cancel(&NA_OFI_CONTEXT(context)->noc_tx->fid,
             &na_ofi_op_id->noo_fi_ctx);
-        if (rc != 0)
-            NA_LOG_ERROR("fi_cancel (op type %d) failed, rc: %d(%s).",
-                na_ofi_op_id->noo_completion_data.callback_info.type, rc,
-                fi_strerror((int) -rc));
-
-        ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
+        if (rc == 0) {
+            /* Complete only if successfully canceled */
+            ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
+        }
         break;
     default:
         break;
     }
 
     /* Work around segfault on fi_cq_signal() in some providers */
-    if (!(na_ofi_prov_flags[NA_OFI_PRIVATE_DATA(na_class)->nop_domain->nod_prov_type]
+    if (!(na_ofi_prov_flags[NA_OFI_CLASS(na_class)->nop_domain->nod_prov_type]
         & NA_OFI_SKIP_SIGNAL)) {
         /* signal the cq to make the wait FD can work */
         rc = fi_cq_signal(NA_OFI_CONTEXT(context)->noc_cq);
diff --git a/src/na/na_plugin.h b/src/na/na_plugin.h
new file mode 100644
index 0000000..2db9207
--- /dev/null
+++ b/src/na/na_plugin.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#ifndef NA_PLUGIN_H
+#define NA_PLUGIN_H
+
+#include "na.h"
+
+#include "mercury_atomic_queue.h"
+#include "mercury_queue.h"
+#include "mercury_thread_mutex.h"
+#include "mercury_thread_condition.h"
+
+/*************************************/
+/* Public Type and Struct Definition */
+/*************************************/
+
+/* Private callback type for NA plugins */
+typedef void (*na_plugin_cb_t)(void *arg);
+
+/* Completion data stored in completion queue */
+struct na_cb_completion_data {
+    na_cb_t callback;                   /* Pointer to function */
+    struct na_cb_info callback_info;    /* Callback info struct */
+    na_plugin_cb_t plugin_callback;     /* Callback which will be called after
+                                         * the user callback returns. */
+    void *plugin_callback_args;         /* Argument to plugin_callback */
+    HG_QUEUE_ENTRY(na_cb_completion_data) entry; /* Completion queue entry */
+};
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Remove warnings when plugin does not use callback arguments */
+#if defined(__cplusplus)
+# define NA_UNUSED
+#elif defined(__GNUC__) && (__GNUC__ >= 4)
+# define NA_UNUSED __attribute__((unused))
+#else
+# define NA_UNUSED
+#endif
+
+/**
+ * container_of - cast a member of a structure out to the containing structure
+ * \ptr:        the pointer to the member.
+ * \type:       the type of the container struct this is embedded in.
+ * \member:     the name of the member within the struct.
+ *
+ */
+#if !defined(container_of)
+# define container_of(ptr, type, member) \
+    ((type *) ((char *) ptr - offsetof(type, member)))
+#endif
+
+/**
+ * Min/max macros
+ */
+#ifndef MAX
+# define MAX(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+#ifndef MIN
+# define MIN(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+/**
+ * Plugin ops definition
+ */
+#define NA_PLUGIN_OPS(plugin_name) \
+    const struct na_class_ops na_ ##plugin_name ##_class_ops_g
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Private routines for use inside NA plugins */
+
+/**
+ * Add callback to context completion queue.
+ *
+ * \param context [IN/OUT]              pointer to context of execution
+ * \param na_cb_completion_data [IN]    pointer to completion data
+ *
+ * \return NA_SUCCESS or corresponding NA error code (failure is not an option)
+ */
+NA_EXPORT na_return_t
+na_cb_completion_add(
+        na_context_t                 *context,
+        struct na_cb_completion_data *na_cb_completion_data
+        );
+
+/*********************/
+/* Public Variables */
+/*********************/
+#ifdef NA_HAS_SM
+NA_EXPORT NA_PLUGIN_OPS(sm);
+#endif
+#ifdef NA_HAS_BMI
+NA_EXPORT NA_PLUGIN_OPS(bmi);
+#endif
+#ifdef NA_HAS_MPI
+NA_EXPORT NA_PLUGIN_OPS(mpi);
+#endif
+#ifdef NA_HAS_CCI
+NA_EXPORT NA_PLUGIN_OPS(cci);
+#endif
+#ifdef NA_HAS_OFI
+NA_EXPORT NA_PLUGIN_OPS(ofi);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NA_PLUGIN_H */
diff --git a/src/na/na_private.h b/src/na/na_private.h
deleted file mode 100644
index bf0e015..0000000
--- a/src/na/na_private.h
+++ /dev/null
@@ -1,425 +0,0 @@
-/*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#ifndef NA_PRIVATE_H
-#define NA_PRIVATE_H
-
-#include "na.h"
-#include "mercury_queue.h"
-
-#include <stddef.h>
-
-/*************************************/
-/* Public Type and Struct Definition */
-/*************************************/
-
-/* NA info definition */
-struct na_info {
-    char *class_name;    /* Class name (e.g., bmi) */
-    char *protocol_name; /* Protocol (e.g., tcp, ib) */
-    char *host_name;     /* Host (may be NULL in anonymous mode) */
-    /* Additional init info (NULL if no info) */
-    const struct na_init_info *na_init_info;
-};
-
-/* Private callback type for NA plugins */
-typedef void (*na_plugin_cb_t)(void *arg);
-
-/* NA execution context, plugins may use plugin context if protocol supports
- * progress on separate contexts/queues/etc */
-struct na_context {
-    void *plugin_context;
-};
-
-/* Completion data stored in completion queue */
-struct na_cb_completion_data {
-    na_cb_t callback;                   /* Pointer to function */
-    struct na_cb_info callback_info;    /* Callback info struct */
-    na_plugin_cb_t plugin_callback;     /* Callback which will be called after
-                                         * the user callback returns. */
-    void *plugin_callback_args;         /* Argument to plugin_callback */
-    HG_QUEUE_ENTRY(na_cb_completion_data) entry; /* Completion queue entry */
-};
-
-/* NA class definition */
-struct na_class {
-    void *private_data;     /* Plugin private data */
-    const char *class_name; /* Class name */
-
-    /* plugin callbacks */
-    na_bool_t
-    (*check_protocol)(
-            const char *protocol_name
-            );
-    na_return_t
-    (*initialize)(
-            na_class_t *na_class,
-            const struct na_info *na_info,
-            na_bool_t listen
-            );
-    na_return_t
-    (*finalize)(
-            na_class_t *na_class
-            );
-    void
-    (*cleanup)(
-            void
-            );
-    na_return_t
-    (*context_create)(
-            na_class_t *na_class,
-            void **plugin_context,
-            na_uint8_t id
-            );
-    na_return_t
-    (*context_destroy)(
-            na_class_t *na_class,
-            void *plugin_context
-            );
-    na_op_id_t
-    (*op_create)(
-            na_class_t *na_class
-            );
-    na_return_t
-    (*op_destroy)(
-            na_class_t *na_class,
-            na_op_id_t op_id
-            );
-    na_return_t
-    (*addr_lookup)(
-            na_class_t   *na_class,
-            na_context_t *context,
-            na_cb_t       callback,
-            void         *arg,
-            const char   *name,
-            na_op_id_t   *op_id
-            );
-    na_return_t
-    (*addr_free)(
-            na_class_t *na_class,
-            na_addr_t   addr
-            );
-    na_return_t
-    (*addr_self)(
-            na_class_t *na_class,
-            na_addr_t  *addr
-            );
-    na_return_t
-    (*addr_dup)(
-            na_class_t *na_class,
-            na_addr_t   addr,
-            na_addr_t  *new_addr
-            );
-    na_bool_t
-    (*addr_is_self)(
-            na_class_t *na_class,
-            na_addr_t   addr
-            );
-    na_return_t
-    (*addr_to_string)(
-            na_class_t *na_class,
-            char       *buf,
-            na_size_t  *buf_size,
-            na_addr_t   addr
-            );
-    na_size_t
-    (*addr_get_serialize_size)(
-            na_class_t      *na_class,
-            na_addr_t        addr
-            );
-    na_return_t
-    (*addr_serialize)(
-            na_class_t      *na_class,
-            void            *buf,
-            na_size_t        buf_size,
-            na_addr_t        addr
-    );
-    na_return_t
-    (*addr_deserialize)(
-            na_class_t      *na_class,
-            na_addr_t       *addr,
-            const void      *buf,
-            na_size_t        buf_size
-    );
-    na_size_t
-    (*msg_get_max_unexpected_size)(
-            const na_class_t *na_class
-            );
-    na_size_t
-    (*msg_get_max_expected_size)(
-            const na_class_t *na_class
-            );
-    na_size_t
-    (*msg_get_unexpected_header_size)(
-            const na_class_t *na_class
-            );
-    na_size_t
-    (*msg_get_expected_header_size)(
-            const na_class_t *na_class
-            );
-    na_tag_t
-    (*msg_get_max_tag)(
-            const na_class_t *na_class
-            );
-    void *
-    (*msg_buf_alloc)(
-            na_class_t *na_class,
-            na_size_t buf_size,
-            void **plugin_data
-            );
-    na_return_t
-    (*msg_buf_free)(
-            na_class_t *na_class,
-            void *buf,
-            void *plugin_data
-            );
-    na_return_t
-    (*msg_init_unexpected)(
-            na_class_t *na_class,
-            void *buf,
-            na_size_t buf_size
-            );
-    na_return_t
-    (*msg_send_unexpected)(
-            na_class_t   *na_class,
-            na_context_t *context,
-            na_cb_t       callback,
-            void         *arg,
-            const void   *buf,
-            na_size_t     buf_size,
-            void         *plugin_data,
-            na_addr_t     dest_addr,
-            na_uint8_t    dest_id,
-            na_tag_t      tag,
-            na_op_id_t   *op_id
-            );
-    na_return_t
-    (*msg_recv_unexpected)(
-            na_class_t   *na_class,
-            na_context_t *context,
-            na_cb_t       callback,
-            void         *arg,
-            void         *buf,
-            na_size_t     buf_size,
-            void         *plugin_data,
-            na_op_id_t   *op_id
-            );
-    na_return_t
-    (*msg_init_expected)(
-            na_class_t *na_class,
-            void *buf,
-            na_size_t buf_size
-            );
-    na_return_t
-    (*msg_send_expected)(
-            na_class_t   *na_class,
-            na_context_t *context,
-            na_cb_t       callback,
-            void         *arg,
-            const void   *buf,
-            na_size_t     buf_size,
-            void         *plugin_data,
-            na_addr_t     dest_addr,
-            na_uint8_t    dest_id,
-            na_tag_t      tag,
-            na_op_id_t   *op_id
-            );
-    na_return_t
-    (*msg_recv_expected)(
-            na_class_t   *na_class,
-            na_context_t *context,
-            na_cb_t       callback,
-            void         *arg,
-            void         *buf,
-            na_size_t     buf_size,
-            void         *plugin_data,
-            na_addr_t     source_addr,
-            na_uint8_t    source_id,
-            na_tag_t      tag,
-            na_op_id_t   *op_id
-            );
-    na_return_t
-    (*mem_handle_create)(
-            na_class_t      *na_class,
-            void            *buf,
-            na_size_t        buf_size,
-            unsigned long    flags,
-            na_mem_handle_t *mem_handle
-            );
-    na_return_t
-    (*mem_handle_create_segments)(
-            na_class_t        *na_class,
-            struct na_segment *segments,
-            na_size_t          segment_count,
-            unsigned long      flags,
-            na_mem_handle_t   *mem_handle
-            );
-    na_return_t
-    (*mem_handle_free)(
-            na_class_t      *na_class,
-            na_mem_handle_t  mem_handle
-            );
-    na_return_t
-    (*mem_register)(
-            na_class_t      *na_class,
-            na_mem_handle_t  mem_handle
-            );
-    na_return_t
-    (*mem_deregister)(
-            na_class_t      *na_class,
-            na_mem_handle_t  mem_handle
-            );
-    na_return_t
-    (*mem_publish)(
-            na_class_t      *na_class,
-            na_mem_handle_t  mem_handle
-            );
-    na_return_t
-    (*mem_unpublish)(
-            na_class_t      *na_class,
-            na_mem_handle_t  mem_handle
-            );
-    na_size_t
-    (*mem_handle_get_serialize_size)(
-            na_class_t      *na_class,
-            na_mem_handle_t  mem_handle
-            );
-    na_return_t
-    (*mem_handle_serialize)(
-            na_class_t      *na_class,
-            void            *buf,
-            na_size_t        buf_size,
-            na_mem_handle_t  mem_handle
-            );
-    na_return_t
-    (*mem_handle_deserialize)(
-            na_class_t      *na_class,
-            na_mem_handle_t *mem_handle,
-            const void      *buf,
-            na_size_t        buf_size
-            );
-    na_return_t
-    (*put)(
-            na_class_t      *na_class,
-            na_context_t    *context,
-            na_cb_t          callback,
-            void            *arg,
-            na_mem_handle_t  local_mem_handle,
-            na_offset_t      local_offset,
-            na_mem_handle_t  remote_mem_handle,
-            na_offset_t      remote_offset,
-            na_size_t        length,
-            na_addr_t        remote_addr,
-            na_uint8_t       remote_id,
-            na_op_id_t      *op_id
-            );
-    na_return_t
-    (*get)(
-            na_class_t      *na_class,
-            na_context_t    *context,
-            na_cb_t          callback,
-            void            *arg,
-            na_mem_handle_t  local_mem_handle,
-            na_offset_t      local_offset,
-            na_mem_handle_t  remote_mem_handle,
-            na_offset_t      remote_offset,
-            na_size_t        length,
-            na_addr_t        remote_addr,
-            na_uint8_t       remote_id,
-            na_op_id_t      *op_id
-            );
-    int
-    (*na_poll_get_fd)(
-            na_class_t      *na_class,
-            na_context_t    *context
-            );
-    na_bool_t
-    (*na_poll_try_wait)(
-            na_class_t      *na_class,
-            na_context_t    *context
-            );
-    na_return_t
-    (*progress)(
-            na_class_t   *na_class,
-            na_context_t *context,
-            unsigned int  timeout
-            );
-    na_return_t
-    (*cancel)(
-            na_class_t   *na_class,
-            na_context_t *context,
-            na_op_id_t    op_id
-            );
-};
-
-/*****************/
-/* Public Macros */
-/*****************/
-
-/* Remove warnings when plugin does not use callback arguments */
-#if defined(__cplusplus)
-# define NA_UNUSED
-#elif defined(__GNUC__) && (__GNUC__ >= 4)
-# define NA_UNUSED __attribute__((unused))
-#else
-# define NA_UNUSED
-#endif
-
-/**
- * container_of - cast a member of a structure out to the containing structure
- * \ptr:        the pointer to the member.
- * \type:       the type of the container struct this is embedded in.
- * \member:     the name of the member within the struct.
- *
- */
-#if !defined(container_of)
-# define container_of(ptr, type, member) \
-    ((type *) ((char *) ptr - offsetof(type, member)))
-#endif
-
-/**
- * Min/max macros
- */
-#ifndef MAX
-# define MAX(a, b) (((a) > (b)) ? (a) : (b))
-#endif
-#ifndef MIN
-# define MIN(a, b) (((a) < (b)) ? (a) : (b))
-#endif
-
-/*********************/
-/* Public Prototypes */
-/*********************/
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Private routines for use inside NA plugins */
-
-/**
- * Add callback to context completion queue.
- *
- * \param context [IN/OUT]              pointer to context of execution
- * \param na_cb_completion_data [IN]    pointer to completion data
- *
- * \return NA_SUCCESS or corresponding NA error code (failure is not an option)
- */
-NA_EXPORT na_return_t
-na_cb_completion_add(
-        na_context_t                 *context,
-        struct na_cb_completion_data *na_cb_completion_data
-        );
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* NA_PRIVATE_H */
diff --git a/src/na/na_sm.c b/src/na/na_sm.c
index 00cd27c..5103ace 100644
--- a/src/na/na_sm.c
+++ b/src/na/na_sm.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -11,16 +11,10 @@
 #if !defined(_WIN32) && !defined(_GNU_SOURCE)
 #define _GNU_SOURCE
 #endif
-#include "na_private.h"
-#include "na_error.h"
+#include "na_plugin.h"
 
-#include "mercury_queue.h"
-#include "mercury_thread_mutex.h"
 #include "mercury_thread_spin.h"
 #include "mercury_time.h"
-#include "mercury_atomic.h"
-#include "mercury_atomic_queue.h"
-#include "mercury_thread.h"
 #include "mercury_poll.h"
 #include "mercury_event.h"
 #include "mercury_mem.h"
@@ -72,8 +66,8 @@
 #define NA_SM_MAX_TAG           NA_TAG_UB
 
 /* Private data access */
-#define NA_SM_PRIVATE_DATA(na_class) \
-    ((struct na_sm_private_data *)(na_class->private_data))
+#define NA_SM_CLASS(na_class) \
+    ((struct na_sm_class *)(na_class->plugin_class))
 
 /* Min macro */
 #define NA_SM_MIN(a, b) \
@@ -257,7 +251,7 @@ struct na_sm_op_id {
 };
 
 /* Private data */
-struct na_sm_private_data {
+struct na_sm_class {
     struct na_sm_addr *self_addr;
     hg_poll_set_t *poll_set;
     HG_QUEUE_HEAD(na_sm_addr) accepted_addr_queue;
@@ -594,7 +588,7 @@ na_sm_complete(
 /**
  * Release memory.
  */
-static void
+static NA_INLINE void
 na_sm_release(
     void *arg
     );
@@ -672,7 +666,7 @@ na_sm_addr_dup(
     );
 
 /* addr_is_self */
-static na_bool_t
+static NA_INLINE na_bool_t
 na_sm_addr_is_self(
     na_class_t *na_class,
     na_addr_t addr
@@ -688,19 +682,19 @@ na_sm_addr_to_string(
     );
 
 /* msg_get_max_unexpected_size */
-static na_size_t
+static NA_INLINE na_size_t
 na_sm_msg_get_max_unexpected_size(
     const na_class_t *na_class
     );
 
 /* msg_get_max_expected_size */
-static na_size_t
+static NA_INLINE na_size_t
 na_sm_msg_get_max_expected_size(
     const na_class_t *na_class
     );
 
 /* msg_get_max_tag */
-static na_tag_t
+static NA_INLINE na_tag_t
 na_sm_msg_get_max_tag(
     const na_class_t *na_class
     );
@@ -796,7 +790,7 @@ na_sm_mem_handle_free(
     );
 
 /* mem_handle_get_serialize_size */
-static na_size_t
+static NA_INLINE na_size_t
 na_sm_mem_handle_get_serialize_size(
     na_class_t *na_class,
     na_mem_handle_t mem_handle
@@ -855,14 +849,14 @@ na_sm_get(
     );
 
 /* poll_get_fd */
-static int
+static NA_INLINE int
 na_sm_poll_get_fd(
     na_class_t      *na_class,
     na_context_t    *context
     );
 
 /* poll_try_wait */
-static na_bool_t
+static NA_INLINE na_bool_t
 na_sm_poll_try_wait(
     na_class_t      *na_class,
     na_context_t    *context
@@ -888,8 +882,7 @@ na_sm_cancel(
 /* Local Variables */
 /*******************/
 
-const na_class_t na_sm_class_g = {
-    NULL,                                   /* private_data */
+NA_PLUGIN_OPS(sm) = {
     "na",                                   /* name */
     na_sm_check_protocol,                   /* check_protocol */
     na_sm_initialize,                       /* initialize */
@@ -976,20 +969,20 @@ na_sm_print_addr(struct na_sm_addr *na_sm_addr)
 static void *
 na_sm_open_shared_buf(const char *name, size_t buf_size, na_bool_t create)
 {
-    na_size_t page_size = (na_size_t) hg_mem_get_page_size();
+//    na_size_t page_size = (na_size_t) hg_mem_get_page_size();
     void *ret = NULL;
 
     /* Check alignment */
-    if (buf_size / page_size * page_size != buf_size) {
-        NA_LOG_ERROR(
-            "Not aligned properly, page size=%zu bytes, buf size=%zu bytes",
-            page_size, buf_size);
-        goto done;
-    }
+//    if (buf_size / page_size * page_size != buf_size) {
+//        NA_LOG_ERROR(
+//            "Not aligned properly, page size=%zu bytes, buf size=%zu bytes",
+//            page_size, buf_size);
+//        goto done;
+//    }
 
     ret = hg_mem_shm_map(name, buf_size, create);
 
-done:
+//done:
     return ret;
 }
 
@@ -1301,7 +1294,7 @@ na_sm_poll_register(na_class_t *na_class, na_sm_poll_type_t poll_type,
     na_sm_poll_data->addr = na_sm_addr;
     *na_sm_poll_data_ptr = na_sm_poll_data;
 
-    if (hg_poll_add(NA_SM_PRIVATE_DATA(na_class)->poll_set, fd, flags,
+    if (hg_poll_add(NA_SM_CLASS(na_class)->poll_set, fd, flags,
         na_sm_progress_cb, na_sm_poll_data) != HG_UTIL_SUCCESS) {
         NA_LOG_ERROR("hg_poll_add failed");
         ret = NA_PROTOCOL_ERROR;
@@ -1340,7 +1333,7 @@ na_sm_poll_deregister(na_class_t *na_class, na_sm_poll_type_t poll_type,
             goto done;
     }
 
-    if (hg_poll_remove(NA_SM_PRIVATE_DATA(na_class)->poll_set,
+    if (hg_poll_remove(NA_SM_CLASS(na_class)->poll_set,
         fd) != HG_UTIL_SUCCESS) {
         NA_LOG_ERROR("hg_poll_remove failed");
         ret = NA_PROTOCOL_ERROR;
@@ -1404,9 +1397,9 @@ na_sm_send_addr_info(na_class_t *na_class, struct na_sm_addr *na_sm_addr)
     na_return_t ret = NA_SUCCESS;
 
     /* Send local PID / ID */
-    iovec[0].iov_base = &NA_SM_PRIVATE_DATA(na_class)->self_addr->pid;
+    iovec[0].iov_base = &NA_SM_CLASS(na_class)->self_addr->pid;
     iovec[0].iov_len = sizeof(pid_t);
-    iovec[1].iov_base = &NA_SM_PRIVATE_DATA(na_class)->self_addr->id;
+    iovec[1].iov_base = &NA_SM_CLASS(na_class)->self_addr->id;
     iovec[1].iov_len = sizeof(unsigned int);
     msg.msg_iov = iovec;
     msg.msg_iovlen = 2;
@@ -1627,7 +1620,7 @@ na_sm_reserve_and_copy_buf(na_class_t *na_class,
     na_return_t ret = NA_SIZE_ERROR;
     unsigned int i = 0;
 
-    hg_thread_spin_lock(&NA_SM_PRIVATE_DATA(na_class)->copy_buf_lock);
+    hg_thread_spin_lock(&NA_SM_CLASS(na_class)->copy_buf_lock);
 
     do {
         hg_util_int64_t available = hg_atomic_get64(
@@ -1657,7 +1650,7 @@ na_sm_reserve_and_copy_buf(na_class_t *na_class,
          * fails, we should be able to pick the next one available */
     } while (i < (NA_SM_NUM_BUFS - 1));
 
-    hg_thread_spin_unlock(&NA_SM_PRIVATE_DATA(na_class)->copy_buf_lock);
+    hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->copy_buf_lock);
     return ret;
 }
 
@@ -1672,7 +1665,7 @@ na_sm_copy_and_free_buf(na_class_t *na_class,
     hg_util_int64_t available;
 #endif
 
-    hg_thread_spin_lock(&NA_SM_PRIVATE_DATA(na_class)->copy_buf_lock);
+    hg_thread_spin_lock(&NA_SM_CLASS(na_class)->copy_buf_lock);
 
     memcpy(buf, na_sm_copy_buf->buf[idx_reserved], buf_size);
 
@@ -1685,7 +1678,7 @@ na_sm_copy_and_free_buf(na_class_t *na_class,
         (available | bits)));
 #endif
 
-    hg_thread_spin_unlock(&NA_SM_PRIVATE_DATA(na_class)->copy_buf_lock);
+    hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->copy_buf_lock);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1716,7 +1709,7 @@ na_sm_msg_insert(na_class_t *na_class, struct na_sm_op_id *na_sm_op_id,
     }
 
     /* Notify remote */
-    if (!NA_SM_PRIVATE_DATA(na_class)->no_wait) {
+    if (!NA_SM_CLASS(na_class)->no_wait) {
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
         if (hg_event_set(na_sm_addr->remote_notify) != HG_UTIL_SUCCESS) {
             NA_LOG_ERROR("Could not send completion notification");
@@ -1733,8 +1726,8 @@ na_sm_msg_insert(na_class_t *na_class, struct na_sm_op_id *na_sm_op_id,
     }
 
     /* Notify local completion */
-    if (!NA_SM_PRIVATE_DATA(na_class)->no_wait
-        && (hg_event_set(NA_SM_PRIVATE_DATA(na_class)->self_addr->local_notify)
+    if (!NA_SM_CLASS(na_class)->no_wait
+        && (hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify)
         != HG_UTIL_SUCCESS)) {
         NA_LOG_ERROR("Could not signal local completion");
         ret = NA_PROTOCOL_ERROR;
@@ -1848,7 +1841,7 @@ na_sm_progress_error(na_class_t *na_class, struct na_sm_addr *poll_addr,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (poll_addr == NA_SM_PRIVATE_DATA(na_class)->self_addr) {
+    if (poll_addr == NA_SM_CLASS(na_class)->self_addr) {
         NA_LOG_ERROR("Unsupported error occurred");
         ret = NA_PROTOCOL_ERROR;
         goto done;
@@ -1876,7 +1869,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     double elapsed_ms;
     na_return_t ret = NA_SUCCESS;
 
-    if (poll_addr != NA_SM_PRIVATE_DATA(na_class)->self_addr) {
+    if (poll_addr != NA_SM_CLASS(na_class)->self_addr) {
         NA_LOG_ERROR("Unrecognized poll addr");
         ret = NA_PROTOCOL_ERROR;
         goto done;
@@ -1885,12 +1878,12 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     /* Prevent from entering accept too often */
     hg_time_get_current(&now);
     elapsed_ms = hg_time_to_double(hg_time_subtract(now,
-        NA_SM_PRIVATE_DATA(na_class)->last_accept_time)) * 1000.0;
+        NA_SM_CLASS(na_class)->last_accept_time)) * 1000.0;
     if (elapsed_ms < NA_SM_ACCEPT_INTERVAL) {
         *progressed = NA_FALSE;
         goto done;
     }
-    NA_SM_PRIVATE_DATA(na_class)->last_accept_time = now;
+    NA_SM_CLASS(na_class)->last_accept_time = now;
 
 #ifdef SOCK_NONBLOCK
     conn_sock = accept4(poll_addr->sock, NULL, NULL, SOCK_NONBLOCK);
@@ -1937,9 +1930,9 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     }
 
     /* Set up ring buffer pair (send/recv) for connection IDs */
-    na_sm_addr->conn_id = NA_SM_PRIVATE_DATA(na_class)->self_addr->conn_id;
+    na_sm_addr->conn_id = NA_SM_CLASS(na_class)->self_addr->conn_id;
     NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME,
-        NA_SM_PRIVATE_DATA(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->self_addr);
     na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(filename,
         NA_SM_RING_BUF_SIZE, NA_TRUE);
     if (!na_sm_ring_buf) {
@@ -1952,7 +1945,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     na_sm_addr->na_sm_send_ring_buf = na_sm_ring_buf;
 
     NA_SM_GEN_RING_NAME(filename, NA_SM_RECV_NAME,
-        NA_SM_PRIVATE_DATA(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->self_addr);
     na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(filename,
         NA_SM_RING_BUF_SIZE, NA_TRUE);
     if (!na_sm_ring_buf) {
@@ -1979,7 +1972,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
      * ancillary data
      */
     NA_SM_GEN_FIFO_NAME(filename, NA_SM_RECV_NAME,
-        NA_SM_PRIVATE_DATA(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->self_addr);
     local_notify = na_sm_event_create(filename);
     if (local_notify == -1) {
         NA_LOG_ERROR("na_sm_event_create() failed");
@@ -2004,7 +1997,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
      * ancillary data
      */
     NA_SM_GEN_FIFO_NAME(filename, NA_SM_SEND_NAME,
-        NA_SM_PRIVATE_DATA(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->self_addr);
     remote_notify = na_sm_event_create(filename);
     if (remote_notify == -1) {
         NA_LOG_ERROR("na_sm_event_create() failed");
@@ -2029,15 +2022,13 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     }
 
     /* Increment connection ID */
-    NA_SM_PRIVATE_DATA(na_class)->self_addr->conn_id++;
+    NA_SM_CLASS(na_class)->self_addr->conn_id++;
 
     /* Push the addr to accepted addr queue so that we can free it later */
-    hg_thread_spin_lock(
-        &NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue_lock);
-    HG_QUEUE_PUSH_TAIL(&NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue,
-        na_sm_addr, entry);
-    hg_thread_spin_unlock(
-        &NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue_lock);
+    hg_thread_spin_lock(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
+    HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->accepted_addr_queue, na_sm_addr,
+        entry);
+    hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
 
     *progressed = NA_TRUE;
 
@@ -2052,7 +2043,7 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (poll_addr == NA_SM_PRIVATE_DATA(na_class)->self_addr) {
+    if (poll_addr == NA_SM_CLASS(na_class)->self_addr) {
         *progressed = NA_FALSE;
         goto done;
     }
@@ -2076,12 +2067,10 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
             poll_addr->sock_progress = NA_SM_SOCK_DONE;
 
             /* Add addr to poll addr queue */
-            hg_thread_spin_lock(
-                &NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue_lock);
-            HG_QUEUE_PUSH_TAIL(&NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue,
+            hg_thread_spin_lock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
+            HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->poll_addr_queue,
                 poll_addr, poll_entry);
-            hg_thread_spin_unlock(
-                &NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue_lock);
+            hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
 
             /* Progressed */
             *progressed = NA_TRUE;
@@ -2107,19 +2096,16 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
             poll_addr->sock_progress = NA_SM_SOCK_DONE;
 
             /* Find op ID that corresponds to addr */
-            hg_thread_spin_lock(
-                &NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue_lock);
+            hg_thread_spin_lock(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
             HG_QUEUE_FOREACH(na_sm_op_id,
-                &NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue, entry) {
+                &NA_SM_CLASS(na_class)->lookup_op_queue, entry) {
                 if (na_sm_op_id->info.lookup.na_sm_addr == poll_addr) {
-                    HG_QUEUE_REMOVE(
-                        &NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue,
+                    HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->lookup_op_queue,
                         na_sm_op_id, na_sm_op_id, entry);
                     break;
                 }
             }
-            hg_thread_spin_unlock(
-                &NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue_lock);
+            hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
 
             if (!na_sm_op_id) {
                 NA_LOG_ERROR("Could not find lookup op ID, conn ID=%u, PID=%u",
@@ -2158,12 +2144,10 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
             }
 
             /* Add addr to poll addr queue */
-            hg_thread_spin_lock(
-                &NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue_lock);
-            HG_QUEUE_PUSH_TAIL(&NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue,
+            hg_thread_spin_lock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
+            HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->poll_addr_queue,
                 poll_addr, poll_entry);
-            hg_thread_spin_unlock(
-                &NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue_lock);
+            hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
 
             /* Completion */
             ret = na_sm_complete(na_sm_op_id);
@@ -2195,9 +2179,9 @@ na_sm_progress_notify(na_class_t *na_class, struct na_sm_addr *poll_addr,
     na_bool_t notified = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
 
-    if (poll_addr == NA_SM_PRIVATE_DATA(na_class)->self_addr) {
+    if (poll_addr == NA_SM_CLASS(na_class)->self_addr) {
         /* Local notification */
-        if (!NA_SM_PRIVATE_DATA(na_class)->no_wait
+        if (!NA_SM_CLASS(na_class)->no_wait
             && (hg_event_get(poll_addr->local_notify, (hg_util_bool_t *) &notified)
             != HG_UTIL_SUCCESS)) {
             NA_LOG_ERROR("Could not get completion notification");
@@ -2214,7 +2198,7 @@ na_sm_progress_notify(na_class_t *na_class, struct na_sm_addr *poll_addr,
     }
 
     /* Remote notification */
-    if (!NA_SM_PRIVATE_DATA(na_class)->no_wait) {
+    if (!NA_SM_CLASS(na_class)->no_wait) {
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
         if (hg_event_get(poll_addr->local_notify, (hg_util_bool_t *) &notified)
             != HG_UTIL_SUCCESS) {
@@ -2274,14 +2258,10 @@ na_sm_progress_unexpected(na_class_t *na_class, struct na_sm_addr *poll_addr,
     na_return_t ret = NA_SUCCESS;
 
     /* Pop op ID from queue */
-    hg_thread_spin_lock(
-        &NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue_lock);
-    na_sm_op_id = HG_QUEUE_FIRST(
-        &NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue);
-    HG_QUEUE_POP_HEAD(&NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue,
-        entry);
-    hg_thread_spin_unlock(
-        &NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue_lock);
+    hg_thread_spin_lock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
+    na_sm_op_id = HG_QUEUE_FIRST(&NA_SM_CLASS(na_class)->unexpected_op_queue);
+    HG_QUEUE_POP_HEAD(&NA_SM_CLASS(na_class)->unexpected_op_queue, entry);
+    hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
 
     if (na_sm_op_id) {
         /* If an op id was pushed, associate unexpected info to this
@@ -2309,12 +2289,11 @@ na_sm_progress_unexpected(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
         /* Otherwise push the unexpected message into our unexpected queue so
          * that we can treat it later when a recv_unexpected is posted */
-        hg_thread_spin_lock(
-            &NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue_lock);
-        HG_QUEUE_PUSH_TAIL(&NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue,
+        hg_thread_spin_lock(&NA_SM_CLASS(na_class)->unexpected_msg_queue_lock);
+        HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->unexpected_msg_queue,
             na_sm_unexpected_info, entry);
         hg_thread_spin_unlock(
-            &NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue_lock);
+            &NA_SM_CLASS(na_class)->unexpected_msg_queue_lock);
     }
 
 done:
@@ -2330,18 +2309,18 @@ na_sm_progress_expected(na_class_t *na_class, struct na_sm_addr *poll_addr,
     na_return_t ret = NA_SUCCESS;
 
     hg_thread_spin_lock(
-        &NA_SM_PRIVATE_DATA(na_class)->expected_op_queue_lock);
+        &NA_SM_CLASS(na_class)->expected_op_queue_lock);
     HG_QUEUE_FOREACH(na_sm_op_id,
-        &NA_SM_PRIVATE_DATA(na_class)->expected_op_queue, entry) {
+        &NA_SM_CLASS(na_class)->expected_op_queue, entry) {
         if (na_sm_op_id->info.recv_expected.na_sm_addr == poll_addr &&
             na_sm_op_id->info.recv_expected.tag == na_sm_hdr.hdr.tag) {
-            HG_QUEUE_REMOVE(&NA_SM_PRIVATE_DATA(na_class)->expected_op_queue,
+            HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->expected_op_queue,
                 na_sm_op_id, na_sm_op_id, entry);
             break;
         }
     }
     hg_thread_spin_unlock(
-        &NA_SM_PRIVATE_DATA(na_class)->expected_op_queue_lock);
+        &NA_SM_CLASS(na_class)->expected_op_queue_lock);
 
     if (!na_sm_op_id) {
         /* No match if either the message was not pre-posted or it was canceled */
@@ -2446,7 +2425,7 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static void
+static NA_INLINE void
 na_sm_release(void *arg)
 {
     struct na_sm_op_id *na_sm_op_id = (struct na_sm_op_id *) arg;
@@ -2498,14 +2477,14 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     errno = 0;
 
     /* Initialize private data */
-    na_class->private_data = malloc(sizeof(struct na_sm_private_data));
-    if (!na_class->private_data) {
+    na_class->plugin_class = malloc(sizeof(struct na_sm_class));
+    if (!na_class->plugin_class) {
         NA_LOG_ERROR("Could not allocate NA private data class");
         ret = NA_NOMEM_ERROR;
         goto done;
     }
-    memset(na_class->private_data, 0, sizeof(struct na_sm_private_data));
-    NA_SM_PRIVATE_DATA(na_class)->no_wait = no_wait;
+    memset(na_class->plugin_class, 0, sizeof(struct na_sm_class));
+    NA_SM_CLASS(na_class)->no_wait = no_wait;
 
     /* Create poll set to wait for events */
     poll_set = hg_poll_create();
@@ -2514,7 +2493,7 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
-    NA_SM_PRIVATE_DATA(na_class)->poll_set = poll_set;
+    NA_SM_CLASS(na_class)->poll_set = poll_set;
 
     /* Create self addr */
     na_sm_addr = (struct na_sm_addr *) malloc(sizeof(struct na_sm_addr));
@@ -2551,31 +2530,24 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
         NA_LOG_ERROR("Could not add notify to poll set");
         goto done;
     }
-    NA_SM_PRIVATE_DATA(na_class)->self_addr = na_sm_addr;
+    NA_SM_CLASS(na_class)->self_addr = na_sm_addr;
 
     /* Initialize queues */
-    HG_QUEUE_INIT(&NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue);
-    HG_QUEUE_INIT(&NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue);
-    HG_QUEUE_INIT(&NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue);
-    HG_QUEUE_INIT(&NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue);
-    HG_QUEUE_INIT(&NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue);
-    HG_QUEUE_INIT(&NA_SM_PRIVATE_DATA(na_class)->expected_op_queue);
+    HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->accepted_addr_queue);
+    HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->poll_addr_queue);
+    HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->unexpected_msg_queue);
+    HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->lookup_op_queue);
+    HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->unexpected_op_queue);
+    HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->expected_op_queue);
 
     /* Initialize mutexes */
-    hg_thread_spin_init(
-            &NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue_lock);
-    hg_thread_spin_init(
-                &NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue_lock);
-    hg_thread_spin_init(
-            &NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue_lock);
-    hg_thread_spin_init(
-            &NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue_lock);
-    hg_thread_spin_init(
-            &NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue_lock);
-    hg_thread_spin_init(
-            &NA_SM_PRIVATE_DATA(na_class)->expected_op_queue_lock);
-    hg_thread_spin_init(
-             &NA_SM_PRIVATE_DATA(na_class)->copy_buf_lock);
+    hg_thread_spin_init(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
+    hg_thread_spin_init(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
+    hg_thread_spin_init(&NA_SM_CLASS(na_class)->unexpected_msg_queue_lock);
+    hg_thread_spin_init(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
+    hg_thread_spin_init(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
+    hg_thread_spin_init(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
+    hg_thread_spin_init(&NA_SM_CLASS(na_class)->copy_buf_lock);
 
 done:
     return ret;
@@ -2587,42 +2559,42 @@ na_sm_finalize(na_class_t *na_class)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class->private_data) {
+    if (!na_class->plugin_class) {
         goto done;
     }
 
     /* Check that lookup op queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue)) {
+    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->lookup_op_queue)) {
         NA_LOG_ERROR("Lookup op queue should be empty");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
     /* Check that unexpected op queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue)) {
+    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->unexpected_op_queue)) {
         NA_LOG_ERROR("Unexpected op queue should be empty");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
     /* Check that unexpected message queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue)) {
+    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->unexpected_msg_queue)) {
         NA_LOG_ERROR("Unexpected msg queue should be empty");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
     /* Check that expected op queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_PRIVATE_DATA(na_class)->expected_op_queue)) {
+    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->expected_op_queue)) {
         NA_LOG_ERROR("Expected op queue should be empty");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
     /* Check that accepted addr queue is empty */
-    while (!HG_QUEUE_IS_EMPTY(&NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue)) {
+    while (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->accepted_addr_queue)) {
         struct na_sm_addr *na_sm_addr = HG_QUEUE_FIRST(
-            &NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue);
+            &NA_SM_CLASS(na_class)->accepted_addr_queue);
         ret = na_sm_addr_free(na_class, na_sm_addr);
         if (ret != NA_SUCCESS) {
             NA_LOG_ERROR("Could not free accepted addr");
@@ -2631,36 +2603,29 @@ na_sm_finalize(na_class_t *na_class)
     }
 
     /* Free self addr */
-    ret = na_sm_addr_free(na_class, NA_SM_PRIVATE_DATA(na_class)->self_addr);
+    ret = na_sm_addr_free(na_class, NA_SM_CLASS(na_class)->self_addr);
     if (ret != NA_SUCCESS) {
         NA_LOG_ERROR("Could not free self addr");
         goto done;
     }
 
     /* Close poll set */
-    if (hg_poll_destroy(NA_SM_PRIVATE_DATA(na_class)->poll_set) != HG_UTIL_SUCCESS) {
+    if (hg_poll_destroy(NA_SM_CLASS(na_class)->poll_set) != HG_UTIL_SUCCESS) {
         NA_LOG_ERROR("hg_poll_destroy() failed");
         ret = NA_PROTOCOL_ERROR;
         goto done;
     }
 
     /* Destroy mutexes */
-    hg_thread_spin_destroy(
-            &NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue_lock);
-    hg_thread_spin_destroy(
-            &NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue_lock);
-    hg_thread_spin_destroy(
-            &NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue_lock);
-    hg_thread_spin_destroy(
-            &NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue_lock);
-    hg_thread_spin_destroy(
-            &NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue_lock);
-    hg_thread_spin_destroy(
-            &NA_SM_PRIVATE_DATA(na_class)->expected_op_queue_lock);
-    hg_thread_spin_destroy(
-             &NA_SM_PRIVATE_DATA(na_class)->copy_buf_lock);
-
-    free(na_class->private_data);
+    hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
+    hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
+    hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->unexpected_msg_queue_lock);
+    hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
+    hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
+    hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
+    hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->copy_buf_lock);
+
+    free(na_class->plugin_class);
 
 done:
     return ret;
@@ -2816,12 +2781,10 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_sm_addr->sock_progress = NA_SM_CONN_ID;
 
     /* Push op ID to lookup op queue */
-    hg_thread_spin_lock(
-        &NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue_lock);
-    HG_QUEUE_PUSH_TAIL(&NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue,
-        na_sm_op_id, entry);
-    hg_thread_spin_unlock(
-        &NA_SM_PRIVATE_DATA(na_class)->lookup_op_queue_lock);
+    hg_thread_spin_lock(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
+    HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->lookup_op_queue, na_sm_op_id,
+        entry);
+    hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
 
     /* Assign op_id */
     if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
@@ -2875,13 +2838,11 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
     }
 
     if (na_sm_addr->accepted) { /* Created by accept */
-        hg_thread_spin_lock(
-            &NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue_lock);
+        hg_thread_spin_lock(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
         /* Remove the addr from accepted addr queue */
-        HG_QUEUE_REMOVE(&NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue,
-            na_sm_addr, na_sm_addr, entry);
-        hg_thread_spin_unlock(
-            &NA_SM_PRIVATE_DATA(na_class)->accepted_addr_queue_lock);
+        HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->accepted_addr_queue, na_sm_addr,
+            na_sm_addr, entry);
+        hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
     }
 
     /* Deregister event file descriptors from poll set */
@@ -2915,22 +2876,20 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
         }
 
         /* Remove addr from poll addr queue */
-        hg_thread_spin_lock(
-            &NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue_lock);
-        HG_QUEUE_REMOVE(&NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue,
-            na_sm_addr, na_sm_addr, poll_entry);
-        hg_thread_spin_unlock(
-            &NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue_lock);
+        hg_thread_spin_lock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
+        HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->poll_addr_queue, na_sm_addr,
+            na_sm_addr, poll_entry);
+        hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
 
         if (na_sm_addr->accepted) { /* Created by accept */
             /* Get file names from ring bufs / events to delete files */
             sprintf(na_sm_send_ring_buf_name, "%s-%d-%d-%d-%s",
-                NA_SM_SHM_PREFIX, NA_SM_PRIVATE_DATA(na_class)->self_addr->pid,
-                NA_SM_PRIVATE_DATA(na_class)->self_addr->id,
+                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->self_addr->pid,
+                NA_SM_CLASS(na_class)->self_addr->id,
                 na_sm_addr->conn_id, NA_SM_SEND_NAME);
             sprintf(na_sm_recv_ring_buf_name, "%s-%d-%d-%d-%s",
-                NA_SM_SHM_PREFIX, NA_SM_PRIVATE_DATA(na_class)->self_addr->pid,
-                NA_SM_PRIVATE_DATA(na_class)->self_addr->id,
+                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->self_addr->pid,
+                NA_SM_CLASS(na_class)->self_addr->id,
                 na_sm_addr->conn_id, NA_SM_RECV_NAME);
             send_ring_buf_name = na_sm_send_ring_buf_name;
             recv_ring_buf_name = na_sm_recv_ring_buf_name;
@@ -2938,13 +2897,13 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
             sprintf(na_sm_local_event_name, "%s/%s/%d/%u/fifo-%u-%s",
                 NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX,
-                NA_SM_PRIVATE_DATA(na_class)->self_addr->pid,
-                NA_SM_PRIVATE_DATA(na_class)->self_addr->id,
+                NA_SM_CLASS(na_class)->self_addr->pid,
+                NA_SM_CLASS(na_class)->self_addr->id,
                 na_sm_addr->conn_id, NA_SM_RECV_NAME);
             sprintf(na_sm_remote_event_name, "%s/%s/%d/%u/fifo-%u-%s",
                 NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX,
-                NA_SM_PRIVATE_DATA(na_class)->self_addr->pid,
-                NA_SM_PRIVATE_DATA(na_class)->self_addr->id,
+                NA_SM_CLASS(na_class)->self_addr->pid,
+                NA_SM_CLASS(na_class)->self_addr->id,
                 na_sm_addr->conn_id, NA_SM_SEND_NAME);
             local_event_name = na_sm_local_event_name;
             remote_event_name = na_sm_remote_event_name;
@@ -3039,7 +2998,7 @@ done:
 static na_return_t
 na_sm_addr_self(na_class_t *na_class, na_addr_t *addr)
 {
-    struct na_sm_addr *na_sm_addr = NA_SM_PRIVATE_DATA(na_class)->self_addr;
+    struct na_sm_addr *na_sm_addr = NA_SM_CLASS(na_class)->self_addr;
     na_return_t ret = NA_SUCCESS;
 
     /* Increment refcount */
@@ -3067,7 +3026,7 @@ na_sm_addr_dup(na_class_t NA_UNUSED *na_class, na_addr_t addr,
 }
 
 /*---------------------------------------------------------------------------*/
-static na_bool_t
+static NA_INLINE na_bool_t
 na_sm_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
     struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) addr;
@@ -3104,21 +3063,21 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static na_size_t
+static NA_INLINE na_size_t
 na_sm_msg_get_max_unexpected_size(const na_class_t NA_UNUSED *na_class)
 {
     return NA_SM_UNEXPECTED_SIZE;
 }
 
 /*---------------------------------------------------------------------------*/
-static na_size_t
+static NA_INLINE na_size_t
 na_sm_msg_get_max_expected_size(const na_class_t NA_UNUSED *na_class)
 {
     return NA_SM_EXPECTED_SIZE;
 }
 
 /*---------------------------------------------------------------------------*/
-static na_tag_t
+static NA_INLINE na_tag_t
 na_sm_msg_get_max_tag(const na_class_t NA_UNUSED *na_class)
 {
     return NA_SM_MAX_TAG;
@@ -3245,14 +3204,11 @@ na_sm_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
         *op_id = na_sm_op_id;
 
     /* Look for an unexpected message already received */
-    hg_thread_spin_lock(
-        &NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue_lock);
+    hg_thread_spin_lock(&NA_SM_CLASS(na_class)->unexpected_msg_queue_lock);
     na_sm_unexpected_info = HG_QUEUE_FIRST(
-        &NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue);
-    HG_QUEUE_POP_HEAD(&NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue,
-        entry);
-    hg_thread_spin_unlock(
-        &NA_SM_PRIVATE_DATA(na_class)->unexpected_msg_queue_lock);
+        &NA_SM_CLASS(na_class)->unexpected_msg_queue);
+    HG_QUEUE_POP_HEAD(&NA_SM_CLASS(na_class)->unexpected_msg_queue, entry);
+    hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->unexpected_msg_queue_lock);
     if (na_sm_unexpected_info) {
         na_sm_op_id->info.recv_unexpected.unexpected_info =
             *na_sm_unexpected_info;
@@ -3265,12 +3221,10 @@ na_sm_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
         }
     } else {
         /* Nothing has been received yet so add op_id to progress queue */
-        hg_thread_spin_lock(
-            &NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue_lock);
-        HG_QUEUE_PUSH_TAIL(&NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue,
+        hg_thread_spin_lock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
+        HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->unexpected_op_queue,
             na_sm_op_id, entry);
-        hg_thread_spin_unlock(
-            &NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue_lock);
+        hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
     }
 
 done:
@@ -3403,12 +3357,10 @@ na_sm_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     /* Expected messages must always be pre-posted, therefore a message should
      * never arrive before that call returns (not completes), simply add
      * op_id to queue */
-    hg_thread_spin_lock(
-        &NA_SM_PRIVATE_DATA(na_class)->expected_op_queue_lock);
-    HG_QUEUE_PUSH_TAIL(&NA_SM_PRIVATE_DATA(na_class)->expected_op_queue,
-        na_sm_op_id, entry);
-    hg_thread_spin_unlock(
-        &NA_SM_PRIVATE_DATA(na_class)->expected_op_queue_lock);
+    hg_thread_spin_lock(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
+    HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->expected_op_queue, na_sm_op_id,
+        entry);
+    hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
 
 done:
     if (ret != NA_SUCCESS) {
@@ -3516,7 +3468,7 @@ na_sm_mem_handle_free(na_class_t NA_UNUSED *na_class,
 }
 
 /*---------------------------------------------------------------------------*/
-static na_size_t
+static NA_INLINE na_size_t
 na_sm_mem_handle_get_serialize_size(na_class_t NA_UNUSED *na_class,
     na_mem_handle_t mem_handle)
 {
@@ -3765,8 +3717,8 @@ na_sm_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     }
 
     /* Notify local completion */
-    if (!NA_SM_PRIVATE_DATA(na_class)->no_wait
-        && (hg_event_set(NA_SM_PRIVATE_DATA(na_class)->self_addr->local_notify)
+    if (!NA_SM_CLASS(na_class)->no_wait
+        && (hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify)
         != HG_UTIL_SUCCESS)) {
         NA_LOG_ERROR("Could not signal local completion");
         ret = NA_PROTOCOL_ERROR;
@@ -3923,8 +3875,8 @@ na_sm_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     }
 
     /* Notify local completion */
-    if (!NA_SM_PRIVATE_DATA(na_class)->no_wait
-        && (hg_event_set(NA_SM_PRIVATE_DATA(na_class)->self_addr->local_notify)
+    if (!NA_SM_CLASS(na_class)->no_wait
+        && (hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify)
         != HG_UTIL_SUCCESS)) {
         NA_LOG_ERROR("Could not signal local completion");
         ret = NA_PROTOCOL_ERROR;
@@ -3939,12 +3891,12 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static int
+static NA_INLINE int
 na_sm_poll_get_fd(na_class_t *na_class, na_context_t NA_UNUSED *context)
 {
     int fd;
 
-    fd = hg_poll_get_fd(NA_SM_PRIVATE_DATA(na_class)->poll_set);
+    fd = hg_poll_get_fd(NA_SM_CLASS(na_class)->poll_set);
     if (fd == HG_UTIL_FAIL) {
         NA_LOG_ERROR("Could not get poll fd from poll set");
     }
@@ -3953,22 +3905,22 @@ na_sm_poll_get_fd(na_class_t *na_class, na_context_t NA_UNUSED *context)
 }
 
 /*---------------------------------------------------------------------------*/
-static na_bool_t
+static NA_INLINE na_bool_t
 na_sm_poll_try_wait(na_class_t *na_class, na_context_t NA_UNUSED *context)
 {
     struct na_sm_addr *na_sm_addr;
     na_bool_t ret = NA_TRUE;
 
     /* Check whether something is in one of the ring buffers */
-    hg_thread_spin_lock(&NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue_lock);
-    HG_QUEUE_FOREACH(na_sm_addr, &NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue,
+    hg_thread_spin_lock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
+    HG_QUEUE_FOREACH(na_sm_addr, &NA_SM_CLASS(na_class)->poll_addr_queue,
         poll_entry) {
         if (!na_sm_ring_buf_is_empty(na_sm_addr->na_sm_recv_ring_buf)) {
             ret = NA_FALSE;
             break;
         }
     }
-    hg_thread_spin_unlock(&NA_SM_PRIVATE_DATA(na_class)->poll_addr_queue_lock);
+    hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
 
     return ret;
 }
@@ -3988,7 +3940,7 @@ na_sm_progress(na_class_t *na_class, na_context_t NA_UNUSED *context,
         if (timeout)
             hg_time_get_current(&t1);
 
-        if (hg_poll_wait(NA_SM_PRIVATE_DATA(na_class)->poll_set,
+        if (hg_poll_wait(NA_SM_CLASS(na_class)->poll_set,
             (unsigned int) (remaining * 1000.0), &progressed) != HG_UTIL_SUCCESS) {
             NA_LOG_ERROR("hg_poll_wait() failed");
             ret = NA_PROTOCOL_ERROR;
@@ -4034,17 +3986,17 @@ na_sm_cancel(na_class_t *na_class, na_context_t NA_UNUSED *context,
 
             /* Must remove op_id from unexpected op_id queue */
             hg_thread_spin_lock(
-                &NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue_lock);
+                &NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
             HG_QUEUE_FOREACH(na_sm_var_op_id,
-                &NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue, entry) {
+                &NA_SM_CLASS(na_class)->unexpected_op_queue, entry) {
                 if (na_sm_var_op_id == na_sm_op_id) {
-                    HG_QUEUE_REMOVE(&NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue,
+                    HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->unexpected_op_queue,
                         na_sm_var_op_id, na_sm_op_id, entry);
                     break;
                 }
             }
             hg_thread_spin_unlock(
-                &NA_SM_PRIVATE_DATA(na_class)->unexpected_op_queue_lock);
+                &NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
 
             /* Cancel op id */
             if (na_sm_var_op_id == na_sm_op_id) {
@@ -4064,18 +4016,17 @@ na_sm_cancel(na_class_t *na_class, na_context_t NA_UNUSED *context,
             struct na_sm_op_id *na_sm_var_op_id = NULL;
 
             /* Must remove op_id from unexpected op_id queue */
-            hg_thread_spin_lock(
-                &NA_SM_PRIVATE_DATA(na_class)->expected_op_queue_lock);
+            hg_thread_spin_lock(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
             HG_QUEUE_FOREACH(na_sm_var_op_id,
-                &NA_SM_PRIVATE_DATA(na_class)->expected_op_queue, entry) {
+                &NA_SM_CLASS(na_class)->expected_op_queue, entry) {
                 if (na_sm_var_op_id == na_sm_op_id) {
-                    HG_QUEUE_REMOVE(&NA_SM_PRIVATE_DATA(na_class)->expected_op_queue,
+                    HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->expected_op_queue,
                         na_sm_var_op_id, na_sm_op_id, entry);
                     break;
                 }
             }
             hg_thread_spin_unlock(
-                &NA_SM_PRIVATE_DATA(na_class)->expected_op_queue_lock);
+                &NA_SM_CLASS(na_class)->expected_op_queue_lock);
 
             /* Cancel op id */
             if (na_sm_var_op_id == na_sm_op_id) {
diff --git a/src/na/na_types.h b/src/na/na_types.h
new file mode 100644
index 0000000..62cfff8
--- /dev/null
+++ b/src/na/na_types.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#ifndef NA_TYPES_H
+#define NA_TYPES_H
+
+#include "na_config.h"
+
+#include <limits.h>
+
+/*************************************/
+/* Public Type and Struct Definition */
+/*************************************/
+
+typedef struct na_class na_class_t;     /* Opaque NA class */
+typedef struct na_context na_context_t; /* Opaque NA execution context */
+typedef void *na_addr_t;                /* Abstract NA address */
+typedef na_uint64_t na_size_t;          /* Size */
+typedef na_uint32_t na_tag_t;           /* Tag */
+typedef void *na_op_id_t;               /* Abstract operation id */
+
+typedef void *na_mem_handle_t;          /* Abstract memory handle */
+typedef na_uint64_t na_offset_t;        /* Offset */
+
+/* Progress mode */
+typedef enum na_progress_mode {
+    NA_DEFAULT,     /*!< blocking progress, depending on timeout value */
+    NA_NO_BLOCK     /*!< no blocking progress, independent of timeout value */
+} na_progress_mode_t;
+
+/* Init info */
+struct na_init_info {
+    na_progress_mode_t progress_mode;   /* Progress mode */
+    na_uint8_t max_contexts;            /* Max contexts */
+    const char *auth_key;               /* Authorization key */
+};
+
+/* Segment */
+struct na_segment {
+    na_ptr_t address;   /* Address of the segment */
+    na_size_t size;     /* Size of the segment in bytes */
+};
+
+/* Error return codes:
+ * Functions return 0 for success or NA_XXX_ERROR for failure */
+typedef enum na_return {
+    NA_SUCCESS,             /*!< operation succeeded */
+    NA_TIMEOUT,             /*!< reached timeout */
+    NA_INVALID_PARAM,       /*!< invalid parameter */
+    NA_SIZE_ERROR,          /*!< message size error */
+    NA_ALIGNMENT_ERROR,     /*!< alignment error */
+    NA_PERMISSION_ERROR,    /*!< read/write permission error */
+    NA_NOMEM_ERROR,         /*!< no memory error */
+    NA_PROTOCOL_ERROR,      /*!< unknown error reported from the protocol layer */
+    NA_CANCELED,            /*!< operation was canceled */
+    NA_ADDRINUSE_ERROR      /*!< address already in use */
+} na_return_t;
+
+/* Callback operation type */
+typedef enum na_cb_type {
+    NA_CB_LOOKUP,           /*!< lookup callback */
+    NA_CB_SEND_UNEXPECTED,  /*!< unexpected send callback */
+    NA_CB_RECV_UNEXPECTED,  /*!< unexpected recv callback */
+    NA_CB_SEND_EXPECTED,    /*!< expected send callback */
+    NA_CB_RECV_EXPECTED,    /*!< expected recv callback */
+    NA_CB_PUT,              /*!< put callback */
+    NA_CB_GET               /*!< get callback */
+} na_cb_type_t;
+
+/* Callback info structs */
+struct na_cb_info_lookup {
+    na_addr_t addr;
+};
+
+struct na_cb_info_recv_unexpected {
+    na_size_t actual_buf_size;
+    na_addr_t source;
+    na_tag_t  tag;
+};
+
+/* Callback info struct */
+struct na_cb_info {
+    void *arg;          /* User data */
+    na_return_t ret;    /* Return value */
+    na_cb_type_t type;  /* Callback type */
+    union {             /* Union of callback info structures */
+        struct na_cb_info_lookup lookup;
+        struct na_cb_info_recv_unexpected recv_unexpected;
+    } info;
+};
+
+/* Callback type */
+typedef int (*na_cb_t)(const struct na_cb_info *callback_info);
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Constant values */
+#define NA_ADDR_NULL        ((na_addr_t)0)
+#define NA_OP_ID_NULL       ((na_op_id_t)0)
+#define NA_OP_ID_IGNORE     ((na_op_id_t *)1)
+#define NA_MEM_HANDLE_NULL  ((na_mem_handle_t)0)
+
+/* Max timeout */
+#define NA_MAX_IDLE_TIME    (3600*1000)
+
+/* Tag upper bound
+ * \remark This is not the user tag limit but only the limit imposed by the type */
+#define NA_TAG_UB           UINT_MAX
+
+/* The memory attributes associated with the memory handle
+ * can be defined as read only, write only or read/write */
+#define NA_MEM_READ_ONLY    0x01
+#define NA_MEM_WRITE_ONLY   0x02
+#define NA_MEM_READWRITE    0x03
+
+#endif /* NA_TYPES_H */
diff --git a/src/proc_extra/mercury_proc_string.h b/src/proc_extra/mercury_proc_string.h
index 3591fba..918dce6 100644
--- a/src/proc_extra/mercury_proc_string.h
+++ b/src/proc_extra/mercury_proc_string.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/proc_extra/mercury_string_object.c b/src/proc_extra/mercury_string_object.c
index 26700e3..76863c2 100644
--- a/src/proc_extra/mercury_string_object.c
+++ b/src/proc_extra/mercury_string_object.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/proc_extra/mercury_string_object.h b/src/proc_extra/mercury_string_object.h
index 02c6755..ab5ae01 100644
--- a/src/proc_extra/mercury_string_object.h
+++ b/src/proc_extra/mercury_string_object.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/CMakeLists.txt b/src/util/CMakeLists.txt
index ee63ab5..69d1dfa 100644
--- a/src/util/CMakeLists.txt
+++ b/src/util/CMakeLists.txt
@@ -136,9 +136,13 @@ set(MERCURY_UTIL_SRCS
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_log.c
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_mem.c
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_poll.c
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_request.c
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread.c
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_condition.c
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_mutex.c
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_pool.c
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_request.c
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_rwlock.c
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_spin.c
 )
 
 #----------------------------------------------------------------------------
@@ -184,6 +188,7 @@ install(
 # Specify project header files to be installed
 #-----------------------------------------------------------------------------
 set(MERCURY_HEADERS
+  ${CMAKE_CURRENT_BINARY_DIR}/mercury_util_config.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_atomic.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_atomic_queue.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_event.h
@@ -195,14 +200,14 @@ set(MERCURY_HEADERS
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_poll.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_queue.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_request.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_condition.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_condition.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_mutex.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_rwlock.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_pool.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_rwlock.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_thread_spin.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_time.h
-  ${CMAKE_CURRENT_BINARY_DIR}/mercury_util_config.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_util_error.h
 )
 
 #-----------------------------------------------------------------------------
diff --git a/src/util/mercury_atomic.h b/src/util/mercury_atomic.h
index 364c537..4533532 100644
--- a/src/util/mercury_atomic.h
+++ b/src/util/mercury_atomic.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -14,32 +14,32 @@
 #include "mercury_util_config.h"
 
 #if defined(_WIN32)
-  #include <windows.h>
-  typedef struct { volatile LONG value; } hg_atomic_int32_t;
-  typedef struct { volatile LONGLONG value; } hg_atomic_int64_t;
-  #define HG_ATOMIC_VAR_INIT(x) { (x) }
+# include <windows.h>
+typedef struct { volatile LONG value; } hg_atomic_int32_t;
+typedef struct { volatile LONGLONG value; } hg_atomic_int64_t;
+# define HG_ATOMIC_VAR_INIT(x) { (x) }
 #elif defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
-  #include <opa_primitives.h>
-  typedef OPA_int_t hg_atomic_int32_t;
-  typedef OPA_ptr_t hg_atomic_int64_t; /* OPA has only limited 64-bit support */
-  #define HG_ATOMIC_VAR_INIT(x) OPA_PTR_T_INITIALIZER(x)
+# include <opa_primitives.h>
+typedef OPA_int_t hg_atomic_int32_t;
+typedef OPA_ptr_t hg_atomic_int64_t; /* OPA has only limited 64-bit support */
+# define HG_ATOMIC_VAR_INIT(x) OPA_PTR_T_INITIALIZER(x)
 #elif defined(HG_UTIL_HAS_STDATOMIC_H)
-  #include <stdatomic.h>
-#ifdef __INTEL_COMPILER
-  typedef atomic_int hg_atomic_int32_t;
-  typedef atomic_llong hg_atomic_int64_t;
-#else
-  typedef _Atomic hg_util_int32_t hg_atomic_int32_t;
-  typedef _Atomic hg_util_int64_t hg_atomic_int64_t;
-#endif
-  #define HG_ATOMIC_VAR_INIT(x) ATOMIC_VAR_INIT(x)
+# include <stdatomic.h>
+# ifdef __INTEL_COMPILER
+typedef atomic_int hg_atomic_int32_t;
+typedef atomic_llong hg_atomic_int64_t;
+# else
+typedef _Atomic hg_util_int32_t hg_atomic_int32_t;
+typedef _Atomic hg_util_int64_t hg_atomic_int64_t;
+# endif
+# define HG_ATOMIC_VAR_INIT(x) ATOMIC_VAR_INIT(x)
 #elif defined(__APPLE__)
-  #include <libkern/OSAtomic.h>
-  typedef struct { volatile hg_util_int32_t value; } hg_atomic_int32_t;
-  typedef struct { volatile hg_util_int64_t value; } hg_atomic_int64_t;
-  #define HG_ATOMIC_VAR_INIT(x) { (x) }
+# include <libkern/OSAtomic.h>
+typedef struct { volatile hg_util_int32_t value; } hg_atomic_int32_t;
+typedef struct { volatile hg_util_int64_t value; } hg_atomic_int64_t;
+# define HG_ATOMIC_VAR_INIT(x) { (x) }
 #else
-  #error "Not supported on this platform."
+# error "Not supported on this platform."
 #endif
 
 #ifdef __cplusplus
diff --git a/src/util/mercury_atomic_queue.c b/src/util/mercury_atomic_queue.c
index e01c9e3..18b1af7 100644
--- a/src/util/mercury_atomic_queue.c
+++ b/src/util/mercury_atomic_queue.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/mercury_atomic_queue.h b/src/util/mercury_atomic_queue.h
index 6c1b0c2..8ea2741 100644
--- a/src/util/mercury_atomic_queue.h
+++ b/src/util/mercury_atomic_queue.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -69,11 +69,11 @@ struct hg_atomic_queue {
 #define HG_ATOMIC_QUEUE_ELT_SIZE sizeof(hg_atomic_int64_t)
 
 #ifndef cpu_spinwait
-#if defined(__x86_64__) || defined(__amd64__)
-#define cpu_spinwait() asm volatile("pause\n": : :"memory");
-#else
-#define cpu_spinwait();
-#endif
+# if defined(__x86_64__) || defined(__amd64__)
+#  define cpu_spinwait() asm volatile("pause\n": : :"memory");
+# else
+#  define cpu_spinwait();
+# endif
 #endif
 
 /*********************/
diff --git a/src/util/mercury_event.c b/src/util/mercury_event.c
index 407e4a9..6100b6a 100644
--- a/src/util/mercury_event.c
+++ b/src/util/mercury_event.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -9,26 +9,6 @@
  */
 
 #include "mercury_event.h"
-#include "mercury_util_error.h"
-
-#ifdef _WIN32
-
-#else
-#include <errno.h>
-#include <string.h>
-#include <unistd.h>
-#if defined(HG_UTIL_HAS_SYSEVENTFD_H)
-#include <sys/eventfd.h>
-#ifndef HG_UTIL_HAS_EVENTFD_T
-typedef uint64_t eventfd_t;
-#endif
-#elif defined(HG_UTIL_HAS_SYSEVENT_H)
-#include <sys/event.h>
-/* User-defined ident */
-#define HG_EVENT_IDENT 42
-#endif
-
-#endif
 
 /*---------------------------------------------------------------------------*/
 int
@@ -89,97 +69,3 @@ hg_event_destroy(int fd)
 done:
     return ret;
 }
-
-/*---------------------------------------------------------------------------*/
-int
-hg_event_set(int fd)
-{
-    int ret = HG_UTIL_SUCCESS;
-#if defined(_WIN32)
-
-#elif defined(HG_UTIL_HAS_SYSEVENTFD_H)
-    eventfd_t count = 1;
-
-#ifdef HG_UTIL_HAS_EVENTFD_T
-    if (eventfd_write(fd, count) == -1) {
-#else
-    ssize_t s;
-
-    s = write(fd, &count, sizeof(eventfd_t));
-    if (s != sizeof(eventfd_t)) {
-#endif
-        if (errno == EAGAIN)
-            goto done;
-        HG_UTIL_LOG_ERROR("write() failed (%s)", strerror(errno));
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-#elif defined(HG_UTIL_HAS_SYSEVENT_H)
-    struct kevent kev;
-    struct timespec timeout = {0, 0};
-
-    EV_SET(&kev, HG_EVENT_IDENT, EVFILT_USER, 0, NOTE_TRIGGER, 0, NULL);
-
-    /* Trigger user-defined event */
-    if (kevent(fd, &kev, 1, NULL, 0, &timeout) == -1) {
-        HG_UTIL_LOG_ERROR("kevent() failed (%s)", strerror(errno));
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-#else
-
-#endif
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-int
-hg_event_get(int fd, hg_util_bool_t *signaled)
-{
-    int ret = HG_UTIL_SUCCESS;
-    hg_util_bool_t event_signal = HG_UTIL_FALSE;
-#if defined(_WIN32)
-
-#elif defined(HG_UTIL_HAS_SYSEVENTFD_H)
-    eventfd_t count = 0;
-
-#ifdef HG_UTIL_HAS_EVENTFD_T
-    if (eventfd_read(fd, &count) == -1) {
-#else
-    ssize_t s;
-
-    s = read(fd, &count, sizeof(eventfd_t));
-    if (s != sizeof(eventfd_t)) {
-#endif
-        if (errno == EAGAIN)
-            goto done;
-        HG_UTIL_LOG_ERROR("read() failed (%s)", strerror(errno));
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-    event_signal = HG_UTIL_TRUE;
-#elif defined(HG_UTIL_HAS_SYSEVENT_H)
-    struct kevent kev;
-    int nfds;
-    struct timespec timeout = {0, 0};
-
-    /* Check user-defined event */
-    nfds = kevent(fd, NULL, 0, &kev, 1, &timeout);
-    if (nfds == -1) {
-        HG_UTIL_LOG_ERROR("kevent() failed (%s)", strerror(errno));
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-    if (nfds > 0 && kev.ident == HG_EVENT_IDENT)
-        event_signal = HG_UTIL_TRUE;
-#else
-
-#endif
-
-    if (signaled) *signaled = event_signal;
-
-done:
-    return ret;
-}
diff --git a/src/util/mercury_event.h b/src/util/mercury_event.h
index 1f0c271..6b2d77d 100644
--- a/src/util/mercury_event.h
+++ b/src/util/mercury_event.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -12,6 +12,25 @@
 #define MERCURY_EVENT_H
 
 #include "mercury_util_config.h"
+#include "mercury_util_error.h"
+
+#ifdef _WIN32
+
+#else
+# include <errno.h>
+# include <string.h>
+# include <unistd.h>
+# if defined(HG_UTIL_HAS_SYSEVENTFD_H)
+#  include <sys/eventfd.h>
+#  ifndef HG_UTIL_HAS_EVENTFD_T
+typedef uint64_t eventfd_t;
+#  endif
+# elif defined(HG_UTIL_HAS_SYSEVENT_H)
+# include <sys/event.h>
+/* User-defined ident */
+# define HG_EVENT_IDENT 42
+# endif
+#endif
 
 /**
  * Purpose: define an event object that can be used as an event
@@ -47,7 +66,7 @@ hg_event_destroy(int fd);
  *
  * \return Non-negative on success or negative on failure
  */
-HG_UTIL_EXPORT int
+static HG_UTIL_INLINE int
 hg_event_set(int fd);
 
 /**
@@ -58,9 +77,120 @@ hg_event_set(int fd);
  *
  * \return Non-negative on success or negative on failure
  */
-HG_UTIL_EXPORT int
+static HG_UTIL_INLINE int
 hg_event_get(int fd, hg_util_bool_t *notified);
 
+/*---------------------------------------------------------------------------*/
+#if defined(_WIN32)
+/* TODO */
+#elif defined(HG_UTIL_HAS_SYSEVENTFD_H)
+static HG_UTIL_INLINE int
+hg_event_set(int fd)
+{
+    int ret = HG_UTIL_SUCCESS;
+    eventfd_t count = 1;
+
+#ifdef HG_UTIL_HAS_EVENTFD_T
+    if (eventfd_write(fd, count) == -1) {
+#else
+    ssize_t s;
+
+    s = write(fd, &count, sizeof(eventfd_t));
+    if (s != sizeof(eventfd_t)) {
+#endif
+        if (errno == EAGAIN)
+            goto done;
+        HG_UTIL_LOG_ERROR("write() failed (%s)", strerror(errno));
+        ret = HG_UTIL_FAIL;
+        goto done;
+    }
+
+done:
+    return ret;
+}
+#elif defined(HG_UTIL_HAS_SYSEVENT_H)
+static HG_UTIL_INLINE int
+hg_event_set(int fd)
+{
+    int ret = HG_UTIL_SUCCESS;
+    struct kevent kev;
+    struct timespec timeout = {0, 0};
+
+    EV_SET(&kev, HG_EVENT_IDENT, EVFILT_USER, 0, NOTE_TRIGGER, 0, NULL);
+
+    /* Trigger user-defined event */
+    if (kevent(fd, &kev, 1, NULL, 0, &timeout) == -1) {
+        HG_UTIL_LOG_ERROR("kevent() failed (%s)", strerror(errno));
+        ret = HG_UTIL_FAIL;
+        goto done;
+    }
+
+done:
+    return ret;
+}
+#else
+# error "Not supported on this platform."
+#endif
+
+/*---------------------------------------------------------------------------*/
+#if defined(_WIN32)
+#elif defined(HG_UTIL_HAS_SYSEVENTFD_H)
+static HG_UTIL_INLINE int
+hg_event_get(int fd, hg_util_bool_t *signaled)
+{
+    int ret = HG_UTIL_SUCCESS;
+    hg_util_bool_t event_signal = HG_UTIL_FALSE;
+    eventfd_t count = 0;
+
+#ifdef HG_UTIL_HAS_EVENTFD_T
+    if (eventfd_read(fd, &count) == -1) {
+#else
+    ssize_t s;
+
+    s = read(fd, &count, sizeof(eventfd_t));
+    if (s != sizeof(eventfd_t)) {
+#endif
+        if (errno == EAGAIN)
+            goto done;
+        HG_UTIL_LOG_ERROR("read() failed (%s)", strerror(errno));
+        ret = HG_UTIL_FAIL;
+        goto done;
+    }
+    event_signal = HG_UTIL_TRUE;
+
+done:
+    if (signaled && ret != HG_UTIL_FAIL)
+        *signaled = event_signal;
+    return ret;
+}
+#elif defined(HG_UTIL_HAS_SYSEVENT_H)
+static HG_UTIL_INLINE int
+hg_event_get(int fd, hg_util_bool_t *signaled)
+{
+    int ret = HG_UTIL_SUCCESS;
+    hg_util_bool_t event_signal = HG_UTIL_FALSE;
+    struct kevent kev;
+    int nfds;
+    struct timespec timeout = {0, 0};
+
+    /* Check user-defined event */
+    nfds = kevent(fd, NULL, 0, &kev, 1, &timeout);
+    if (nfds == -1) {
+        HG_UTIL_LOG_ERROR("kevent() failed (%s)", strerror(errno));
+        ret = HG_UTIL_FAIL;
+        goto done;
+    }
+    if (nfds > 0 && kev.ident == HG_EVENT_IDENT)
+        event_signal = HG_UTIL_TRUE;
+
+    if (signaled) *signaled = event_signal;
+
+done:
+    return ret;
+}
+#else
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/util/mercury_hash_string.h b/src/util/mercury_hash_string.h
index 075cfc6..878fd4f 100644
--- a/src/util/mercury_hash_string.h
+++ b/src/util/mercury_hash_string.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/mercury_list.h b/src/util/mercury_list.h
index a4efc6b..76fb5d1 100644
--- a/src/util/mercury_list.h
+++ b/src/util/mercury_list.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/mercury_log.c b/src/util/mercury_log.c
index ccdf9bb..7e18319 100644
--- a/src/util/mercury_log.c
+++ b/src/util/mercury_log.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/mercury_log.h b/src/util/mercury_log.h
index fd06c6d..bec44c3 100644
--- a/src/util/mercury_log.h
+++ b/src/util/mercury_log.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/mercury_mem.c b/src/util/mercury_mem.c
index b49b398..eb48187 100644
--- a/src/util/mercury_mem.c
+++ b/src/util/mercury_mem.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -12,15 +12,15 @@
 #include "mercury_util_error.h"
 
 #ifdef _WIN32
-  #include <windows.h>
+# include <windows.h>
 #else
-  #include <sys/mman.h>
-  #include <unistd.h>
-  #include <sys/types.h>
-  #include <sys/stat.h>        /* For mode constants */
-  #include <fcntl.h>           /* For O_* constants */
-  #include <string.h>
-  #include <errno.h>
+# include <sys/mman.h>
+# include <unistd.h>
+# include <sys/types.h>
+# include <sys/stat.h>        /* For mode constants */
+# include <fcntl.h>           /* For O_* constants */
+# include <string.h>
+# include <errno.h>
 #endif
 #include <stdlib.h>
 
diff --git a/src/util/mercury_mem.h b/src/util/mercury_mem.h
index e02959d..b416bb0 100644
--- a/src/util/mercury_mem.h
+++ b/src/util/mercury_mem.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -59,7 +59,7 @@ hg_mem_aligned_free(void *mem_ptr);
  *
  * \return a pointer to the mapped memory region, or NULL in case of failure
  */
-void *
+HG_UTIL_EXPORT void *
 hg_mem_shm_map(const char *name, size_t size, hg_util_bool_t create);
 
 /**
@@ -71,7 +71,7 @@ hg_mem_shm_map(const char *name, size_t size, hg_util_bool_t create);
  *
  * \return non-negative on success, or negative in case of failure
  */
-int
+HG_UTIL_EXPORT int
 hg_mem_shm_unmap(const char *name, void *mem_ptr, size_t size);
 
 #ifdef __cplusplus
diff --git a/src/util/mercury_poll.c b/src/util/mercury_poll.c
index 44ba9cd..f7548c0 100644
--- a/src/util/mercury_poll.c
+++ b/src/util/mercury_poll.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/mercury_poll.h b/src/util/mercury_poll.h
index c0f7f61..4762250 100644
--- a/src/util/mercury_poll.h
+++ b/src/util/mercury_poll.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/mercury_queue.h b/src/util/mercury_queue.h
index 7fa65c0..5bc21dc 100644
--- a/src/util/mercury_queue.h
+++ b/src/util/mercury_queue.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/mercury_request.c b/src/util/mercury_request.c
index dd1694a..12b1525 100644
--- a/src/util/mercury_request.c
+++ b/src/util/mercury_request.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -14,8 +14,6 @@
 #include "mercury_time.h"
 #include "mercury_util_error.h"
 
-#include "mercury_atomic.h"
-
 #include <stdlib.h>
 
 struct hg_request_class {
@@ -27,12 +25,6 @@ struct hg_request_class {
     hg_thread_cond_t progress_cond;
 };
 
-struct hg_request {
-    void *data;
-    hg_atomic_int32_t completed;
-    hg_request_class_t *request_class;
-};
-
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_bool_t
 hg_request_check(hg_request_t *request)
@@ -126,28 +118,6 @@ hg_request_destroy(hg_request_t *request)
     return ret;
 }
 
-/*---------------------------------------------------------------------------*/
-int
-hg_request_reset(hg_request_t *request)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-    hg_atomic_set32(&request->completed, HG_UTIL_FALSE);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-int
-hg_request_complete(hg_request_t *request)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-    hg_atomic_incr32(&request->completed);
-
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 /*
  * lock(progress_mutex)
@@ -239,45 +209,3 @@ hg_request_wait(hg_request_t *request, unsigned int timeout, unsigned int *flag)
 
     return ret;
 }
-
-/*---------------------------------------------------------------------------*/
-int
-hg_request_waitall(int count, hg_request_t *request[], unsigned int timeout,
-        unsigned int *flag)
-{
-    /* TODO */
-    int i;
-    for (i = 0; i < count; i++)
-        hg_request_wait(request[i], timeout, flag);
-    return HG_UTIL_SUCCESS;
-}
-
-/*---------------------------------------------------------------------------*/
-//hg_return_t
-//hg_request_complete_cb(const struct hg_cb_info *cb_info)
-//{
-//    int ret = hg_request_complete(cb_info->arg);
-//    return ret == HG_UTIL_SUCCESS ? HG_SUCCESS : HG_OTHER_ERROR;
-//}
-
-/*---------------------------------------------------------------------------*/
-int
-hg_request_set_data(hg_request_t *request, void *data)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-    request->data = data;
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-void *
-hg_request_get_data(hg_request_t *request)
-{
-    void *ret = NULL;
-
-    ret = request->data;
-
-    return ret;
-}
diff --git a/src/util/mercury_request.h b/src/util/mercury_request.h
index f9e8f75..a3ccbdd 100644
--- a/src/util/mercury_request.h
+++ b/src/util/mercury_request.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -12,6 +12,7 @@
 #define MERCURY_REQUEST_H
 
 #include "mercury_util_config.h"
+#include "mercury_atomic.h"
 
 /**
  * Purpose: define a request emulation library on top of the callback model
@@ -24,6 +25,12 @@
 typedef struct hg_request_class  hg_request_class_t;  /* Opaque request class */
 typedef struct hg_request hg_request_t; /* Opaque request object */
 
+struct hg_request {
+    void *data;
+    hg_atomic_int32_t completed;
+    hg_request_class_t *request_class;
+};
+
 /**
  * Progress callback, arg can be used to pass extra parameters required by
  * underlying API.
@@ -107,7 +114,7 @@ hg_request_destroy(hg_request_t *request);
  *
  * \return Pointer to request or NULL in case of failure
  */
-HG_UTIL_EXPORT int
+static HG_UTIL_INLINE int
 hg_request_reset(hg_request_t *request);
 
 /**
@@ -118,7 +125,7 @@ hg_request_reset(hg_request_t *request);
  *
  * \return Non-negative on success or negative on failure
  */
-HG_UTIL_EXPORT int
+static HG_UTIL_INLINE int
 hg_request_complete(hg_request_t *request);
 
 /**
@@ -144,7 +151,7 @@ hg_request_wait(hg_request_t *request, unsigned int timeout,
  *
  * \return Non-negative on success or negative on failure
  */
-HG_UTIL_EXPORT int
+static HG_UTIL_INLINE int
 hg_request_waitall(int count, hg_request_t *request[],  unsigned int timeout,
         unsigned int *flag);
 
@@ -167,7 +174,7 @@ hg_request_waitall(int count, hg_request_t *request[],  unsigned int timeout,
  *
  * \return Non-negative on success or negative on failure
  */
-HG_UTIL_EXPORT int
+static HG_UTIL_INLINE int
 hg_request_set_data(hg_request_t *request, void *data);
 
 /**
@@ -177,7 +184,7 @@ hg_request_set_data(hg_request_t *request, void *data);
  *
  * \return Pointer to data or NULL if nothing was attached by user
  */
-HG_UTIL_EXPORT void *
+static HG_UTIL_INLINE void *
 hg_request_get_data(hg_request_t *request);
 
 /**
@@ -191,6 +198,70 @@ HG_UTIL_EXPORT int
 hg_request_cancel(hg_request_t *request);
  */
 
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE int
+hg_request_reset(hg_request_t *request)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+    hg_atomic_set32(&request->completed, HG_UTIL_FALSE);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE int
+hg_request_complete(hg_request_t *request)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+    hg_atomic_incr32(&request->completed);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE int
+hg_request_waitall(int count, hg_request_t *request[], unsigned int timeout,
+        unsigned int *flag)
+{
+    /* TODO */
+    int i;
+    for (i = 0; i < count; i++)
+        hg_request_wait(request[i], timeout, flag);
+    return HG_UTIL_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+//hg_return_t
+//hg_request_complete_cb(const struct hg_cb_info *cb_info)
+//{
+//    int ret = hg_request_complete(cb_info->arg);
+//    return ret == HG_UTIL_SUCCESS ? HG_SUCCESS : HG_OTHER_ERROR;
+//}
+
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE int
+hg_request_set_data(hg_request_t *request, void *data)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+    request->data = data;
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE void *
+hg_request_get_data(hg_request_t *request)
+{
+    void *ret = NULL;
+
+    ret = request->data;
+
+    return ret;
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/util/mercury_thread.c b/src/util/mercury_thread.c
index 724cd89..fcba0e5 100644
--- a/src/util/mercury_thread.c
+++ b/src/util/mercury_thread.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -9,7 +9,6 @@
  */
 
 #include "mercury_thread.h"
-#include "mercury_util_error.h"
 
 /*---------------------------------------------------------------------------*/
 void
@@ -155,42 +154,6 @@ hg_thread_key_delete(hg_thread_key_t key)
     return ret;
 }
 
-/*---------------------------------------------------------------------------*/
-void *
-hg_thread_getspecific(hg_thread_key_t key)
-{
-    void *ret;
-
-#ifdef _WIN32
-    ret = TlsGetValue(key);
-#else
-    ret = pthread_getspecific(key);
-#endif
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-int
-hg_thread_setspecific(hg_thread_key_t key, const void *value)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-#ifdef _WIN32
-    if (!TlsSetValue(key, (LPVOID) value)) {
-        HG_UTIL_LOG_ERROR("TlsSetValue() failed");
-        ret = HG_UTIL_FAIL;
-    }
-#else
-    if (pthread_setspecific(key, value)) {
-        HG_UTIL_LOG_ERROR("pthread_setspecific() failed");
-        ret = HG_UTIL_FAIL;
-    }
-#endif
-
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 int
 hg_thread_getaffinity(hg_thread_t thread, hg_cpu_set_t *cpu_mask)
diff --git a/src/util/mercury_thread.h b/src/util/mercury_thread.h
index cd76ffa..596c7e3 100644
--- a/src/util/mercury_thread.h
+++ b/src/util/mercury_thread.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -12,37 +12,38 @@
 #define MERCURY_THREAD_H
 
 #if !defined(_WIN32) && !defined(_GNU_SOURCE)
-  #define _GNU_SOURCE
+# define _GNU_SOURCE
 #endif
 #include "mercury_util_config.h"
+#include "mercury_util_error.h"
 
 #ifdef _WIN32
-  #include <windows.h>
-  typedef HANDLE hg_thread_t;
-  typedef LPTHREAD_START_ROUTINE hg_thread_func_t;
-  typedef DWORD hg_thread_ret_t;
-  #define HG_THREAD_RETURN_TYPE hg_thread_ret_t WINAPI
-  typedef DWORD hg_thread_key_t;
-  typedef DWORD_PTR hg_cpu_set_t;
+# include <windows.h>
+typedef HANDLE hg_thread_t;
+typedef LPTHREAD_START_ROUTINE hg_thread_func_t;
+typedef DWORD hg_thread_ret_t;
+# define HG_THREAD_RETURN_TYPE hg_thread_ret_t WINAPI
+typedef DWORD hg_thread_key_t;
+typedef DWORD_PTR hg_cpu_set_t;
 #else
-  #include <pthread.h>
-  typedef pthread_t hg_thread_t;
-  typedef void *(*hg_thread_func_t)(void *);
-  typedef void *hg_thread_ret_t;
-  #define HG_THREAD_RETURN_TYPE hg_thread_ret_t
-  typedef pthread_key_t hg_thread_key_t;
-#ifdef __APPLE__
-  /* Size definition for CPU sets.  */
-  # define HG_CPU_SETSIZE  1024
-  # define HG_NCPUBITS     (8 * sizeof (hg_cpu_mask_t))
-  /* Type for array elements in 'cpu_set_t'.  */
-  typedef hg_util_uint64_t hg_cpu_mask_t;
-  typedef struct {
-      hg_cpu_mask_t bits[HG_CPU_SETSIZE / HG_NCPUBITS];
-  } hg_cpu_set_t;
-#else
-  typedef cpu_set_t hg_cpu_set_t;
-#endif
+# include <pthread.h>
+typedef pthread_t hg_thread_t;
+typedef void *(*hg_thread_func_t)(void *);
+typedef void *hg_thread_ret_t;
+# define HG_THREAD_RETURN_TYPE hg_thread_ret_t
+typedef pthread_key_t hg_thread_key_t;
+# ifdef __APPLE__
+/* Size definition for CPU sets.  */
+#  define HG_CPU_SETSIZE  1024
+#  define HG_NCPUBITS     (8 * sizeof (hg_cpu_mask_t))
+/* Type for array elements in 'cpu_set_t'.  */
+typedef hg_util_uint64_t hg_cpu_mask_t;
+typedef struct {
+    hg_cpu_mask_t bits[HG_CPU_SETSIZE / HG_NCPUBITS];
+} hg_cpu_set_t;
+# else
+typedef cpu_set_t hg_cpu_set_t;
+# endif
 #endif
 
 #ifdef __cplusplus
@@ -135,7 +136,7 @@ hg_thread_key_delete(hg_thread_key_t key);
  *
  * \return Pointer to data associated to the key
  */
-HG_UTIL_EXPORT void *
+static HG_UTIL_INLINE void *
 hg_thread_getspecific(hg_thread_key_t key);
 
 /**
@@ -146,7 +147,7 @@ hg_thread_getspecific(hg_thread_key_t key);
  *
  * \return Non-negative on success or negative on failure
  */
-HG_UTIL_EXPORT int
+static HG_UTIL_INLINE int
 hg_thread_setspecific(hg_thread_key_t key, const void *value);
 
 /**
@@ -171,6 +172,42 @@ hg_thread_getaffinity(hg_thread_t thread, hg_cpu_set_t *cpu_mask);
 HG_UTIL_EXPORT int
 hg_thread_setaffinity(hg_thread_t thread, const hg_cpu_set_t *cpu_mask);
 
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE void *
+hg_thread_getspecific(hg_thread_key_t key)
+{
+    void *ret;
+
+#ifdef _WIN32
+    ret = TlsGetValue(key);
+#else
+    ret = pthread_getspecific(key);
+#endif
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE int
+hg_thread_setspecific(hg_thread_key_t key, const void *value)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+#ifdef _WIN32
+    if (!TlsSetValue(key, (LPVOID) value)) {
+        HG_UTIL_LOG_ERROR("TlsSetValue() failed");
+        ret = HG_UTIL_FAIL;
+    }
+#else
+    if (pthread_setspecific(key, value)) {
+        HG_UTIL_LOG_ERROR("pthread_setspecific() failed");
+        ret = HG_UTIL_FAIL;
+    }
+#endif
+
+    return ret;
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/util/mercury_thread_condition.c b/src/util/mercury_thread_condition.c
new file mode 100644
index 0000000..7771f85
--- /dev/null
+++ b/src/util/mercury_thread_condition.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#include "mercury_thread_condition.h"
+
+/*---------------------------------------------------------------------------*/
+int
+hg_thread_cond_init(hg_thread_cond_t *cond)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+#ifdef _WIN32
+    InitializeConditionVariable(cond);
+#else
+    pthread_condattr_t attr;
+
+    pthread_condattr_init(&attr);
+# if defined(HG_UTIL_HAS_PTHREAD_CONDATTR_SETCLOCK) && defined(HG_UTIL_HAS_CLOCK_MONOTONIC)
+    /* Must set clock ID if using different clock */
+    pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
+# endif
+    if (pthread_cond_init(cond, &attr)) ret = HG_UTIL_FAIL;
+    pthread_condattr_destroy(&attr);
+#endif
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+int
+hg_thread_cond_destroy(hg_thread_cond_t *cond)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+#ifndef _WIN32
+    if (pthread_cond_destroy(cond)) ret = HG_UTIL_FAIL;
+#endif
+
+    return ret;
+}
diff --git a/src/util/mercury_thread_condition.h b/src/util/mercury_thread_condition.h
index dc4027a..8c6c04d 100644
--- a/src/util/mercury_thread_condition.h
+++ b/src/util/mercury_thread_condition.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -36,7 +36,7 @@ extern "C" {
  *
  * \return Non-negative on success or negative on failure
  */
-static HG_UTIL_INLINE int
+HG_UTIL_EXPORT int
 hg_thread_cond_init(hg_thread_cond_t *cond);
 
 /**
@@ -46,7 +46,7 @@ hg_thread_cond_init(hg_thread_cond_t *cond);
  *
  * \return Non-negative on success or negative on failure
  */
-static HG_UTIL_INLINE int
+HG_UTIL_EXPORT int
 hg_thread_cond_destroy(hg_thread_cond_t *cond);
 
 /**
@@ -93,42 +93,6 @@ static HG_UTIL_INLINE int
 hg_thread_cond_timedwait(hg_thread_cond_t *cond, hg_thread_mutex_t *mutex,
         unsigned int timeout);
 
-/*---------------------------------------------------------------------------*/
-static HG_UTIL_INLINE int
-hg_thread_cond_init(hg_thread_cond_t *cond)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-#ifdef _WIN32
-    InitializeConditionVariable(cond);
-#else
-    pthread_condattr_t attr;
-
-    pthread_condattr_init(&attr);
-# if defined(HG_UTIL_HAS_PTHREAD_CONDATTR_SETCLOCK) && defined(HG_UTIL_HAS_CLOCK_MONOTONIC)
-    /* Must set clock ID if using different clock */
-    pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
-# endif
-    if (pthread_cond_init(cond, &attr)) ret = HG_UTIL_FAIL;
-    pthread_condattr_destroy(&attr);
-#endif
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static HG_UTIL_INLINE int
-hg_thread_cond_destroy(hg_thread_cond_t *cond)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-#ifndef _WIN32
-    if (pthread_cond_destroy(cond)) ret = HG_UTIL_FAIL;
-#endif
-
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE int
 hg_thread_cond_signal(hg_thread_cond_t *cond)
diff --git a/src/util/mercury_thread_mutex.c b/src/util/mercury_thread_mutex.c
new file mode 100644
index 0000000..44aa0c1
--- /dev/null
+++ b/src/util/mercury_thread_mutex.c
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#include "mercury_thread_mutex.h"
+
+/*---------------------------------------------------------------------------*/
+int
+hg_thread_mutex_init(hg_thread_mutex_t *mutex)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+#ifdef _WIN32
+    InitializeCriticalSection(mutex);
+#else
+    pthread_mutexattr_t mutex_attr;
+
+    pthread_mutexattr_init(&mutex_attr);
+#ifdef HG_UTIL_HAS_PTHREAD_MUTEX_ADAPTIVE_NP
+    /* Set type to PTHREAD_MUTEX_ADAPTIVE_NP to improve performance */
+    pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_ADAPTIVE_NP);
+#else
+    pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_DEFAULT);
+#endif
+    if (pthread_mutex_init(mutex, &mutex_attr)) ret = HG_UTIL_FAIL;
+
+    pthread_mutexattr_destroy(&mutex_attr);
+#endif
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+int
+hg_thread_mutex_destroy(hg_thread_mutex_t *mutex)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+#ifdef _WIN32
+    DeleteCriticalSection(mutex);
+#else
+    if (pthread_mutex_destroy(mutex)) ret = HG_UTIL_FAIL;
+#endif
+
+    return ret;
+}
diff --git a/src/util/mercury_thread_mutex.h b/src/util/mercury_thread_mutex.h
index 7009bea..b846b10 100644
--- a/src/util/mercury_thread_mutex.h
+++ b/src/util/mercury_thread_mutex.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -34,7 +34,7 @@ extern "C" {
  *
  * \return Non-negative on success or negative on failure
  */
-static HG_UTIL_INLINE int
+HG_UTIL_EXPORT int
 hg_thread_mutex_init(hg_thread_mutex_t *mutex);
 
 /**
@@ -44,7 +44,7 @@ hg_thread_mutex_init(hg_thread_mutex_t *mutex);
  *
  * \return Non-negative on success or negative on failure
  */
-static HG_UTIL_INLINE int
+HG_UTIL_EXPORT int
 hg_thread_mutex_destroy(hg_thread_mutex_t *mutex);
 
 /**
@@ -77,47 +77,6 @@ hg_thread_mutex_try_lock(hg_thread_mutex_t *mutex);
 static HG_UTIL_INLINE int
 hg_thread_mutex_unlock(hg_thread_mutex_t *mutex);
 
-/*---------------------------------------------------------------------------*/
-static HG_UTIL_INLINE int
-hg_thread_mutex_init(hg_thread_mutex_t *mutex)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-#ifdef _WIN32
-    InitializeCriticalSection(mutex);
-#else
-    pthread_mutexattr_t mutex_attr;
-
-    pthread_mutexattr_init(&mutex_attr);
-#ifdef HG_UTIL_HAS_PTHREAD_MUTEX_ADAPTIVE_NP
-    /* Set type to PTHREAD_MUTEX_ADAPTIVE_NP to improve performance */
-    pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_ADAPTIVE_NP);
-#else
-    pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_DEFAULT);
-#endif
-    if (pthread_mutex_init(mutex, &mutex_attr)) ret = HG_UTIL_FAIL;
-
-    pthread_mutexattr_destroy(&mutex_attr);
-#endif
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static HG_UTIL_INLINE int
-hg_thread_mutex_destroy(hg_thread_mutex_t *mutex)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-#ifdef _WIN32
-    DeleteCriticalSection(mutex);
-#else
-    if (pthread_mutex_destroy(mutex)) ret = HG_UTIL_FAIL;
-#endif
-
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE int
 hg_thread_mutex_lock(hg_thread_mutex_t *mutex)
diff --git a/src/util/mercury_thread_pool.c b/src/util/mercury_thread_pool.c
index e8ab105..d68d00f 100644
--- a/src/util/mercury_thread_pool.c
+++ b/src/util/mercury_thread_pool.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -9,19 +9,13 @@
  */
 
 #include "mercury_thread_pool.h"
-#include "mercury_thread_condition.h"
-#include "mercury_util_error.h"
 
 #include <stdlib.h>
 
-struct hg_thread_pool {
-    unsigned int sleeping_worker_count;
+struct hg_thread_pool_private {
+    struct hg_thread_pool pool;
     unsigned int thread_count;
     hg_thread_t *threads;
-    HG_QUEUE_HEAD(hg_thread_work) queue;
-    int shutdown;
-    hg_thread_mutex_t mutex;
-    hg_thread_cond_t cond;
 };
 
 /**
@@ -70,36 +64,37 @@ unlock:
 
 /*---------------------------------------------------------------------------*/
 int
-hg_thread_pool_init(unsigned int thread_count, hg_thread_pool_t **pool)
+hg_thread_pool_init(unsigned int thread_count, hg_thread_pool_t **pool_ptr)
 {
     int ret = HG_UTIL_SUCCESS;
-    hg_thread_pool_t *priv_pool = NULL;
+    struct hg_thread_pool_private *priv_pool = NULL;
     unsigned int i;
 
-    if (!pool) {
+    if (!pool_ptr) {
         HG_UTIL_LOG_ERROR("Cannot pass NULL pointer");
         ret = HG_UTIL_FAIL;
         goto done;
     }
 
-    priv_pool = (hg_thread_pool_t*) malloc(sizeof(hg_thread_pool_t));
+    priv_pool = (struct hg_thread_pool_private *) malloc(
+        sizeof(struct hg_thread_pool_private));
     if (!priv_pool) {
         HG_UTIL_LOG_ERROR("Could not allocate thread pool");
         ret = HG_UTIL_FAIL;
         goto done;
     }
-    priv_pool->sleeping_worker_count = 0;
+    priv_pool->pool.sleeping_worker_count = 0;
     priv_pool->thread_count = thread_count;
     priv_pool->threads = NULL;
-    HG_QUEUE_INIT(&priv_pool->queue);
-    priv_pool->shutdown = 0;
+    HG_QUEUE_INIT(&priv_pool->pool.queue);
+    priv_pool->pool.shutdown = 0;
 
-    if (hg_thread_mutex_init(&priv_pool->mutex) != HG_UTIL_SUCCESS) {
+    if (hg_thread_mutex_init(&priv_pool->pool.mutex) != HG_UTIL_SUCCESS) {
         HG_UTIL_LOG_ERROR("Could not initialize mutex");
         ret = HG_UTIL_FAIL;
         goto done;
     }
-    if (hg_thread_cond_init(&priv_pool->cond) != HG_UTIL_SUCCESS) {
+    if (hg_thread_cond_init(&priv_pool->pool.cond) != HG_UTIL_SUCCESS) {
         HG_UTIL_LOG_ERROR("Could not initialize thread condition");
         ret = HG_UTIL_FAIL;
         goto done;
@@ -122,12 +117,12 @@ hg_thread_pool_init(unsigned int thread_count, hg_thread_pool_t **pool)
         }
     }
 
-    *pool = priv_pool;
+    *pool_ptr = (struct hg_thread_pool *) priv_pool;
 
 done:
     if (ret != HG_UTIL_SUCCESS) {
         if (priv_pool) {
-            hg_thread_pool_destroy(priv_pool);
+            hg_thread_pool_destroy((struct hg_thread_pool *) priv_pool);
         }
         priv_pool = NULL;
     }
@@ -138,27 +133,29 @@ done:
 int
 hg_thread_pool_destroy(hg_thread_pool_t *pool)
 {
+    struct hg_thread_pool_private *priv_pool =
+        (struct hg_thread_pool_private *) pool;
     int ret = HG_UTIL_SUCCESS;
     unsigned int i;
 
-    if (!pool) goto done;
+    if (!priv_pool) goto done;
 
-    if (pool->threads) {
-        hg_thread_mutex_lock(&pool->mutex);
+    if (priv_pool->threads) {
+        hg_thread_mutex_lock(&priv_pool->pool.mutex);
 
-        pool->shutdown = 1;
+        priv_pool->pool.shutdown = 1;
 
-        if (hg_thread_cond_broadcast(&pool->cond) != HG_UTIL_SUCCESS) {
+        if (hg_thread_cond_broadcast(&priv_pool->pool.cond) != HG_UTIL_SUCCESS) {
             HG_UTIL_LOG_ERROR("Could not broadcast condition signal");
             ret = HG_UTIL_FAIL;
         }
 
-        hg_thread_mutex_unlock(&pool->mutex);
+        hg_thread_mutex_unlock(&priv_pool->pool.mutex);
 
         if (ret != HG_UTIL_SUCCESS) goto done;
 
-        for(i = 0; i < pool->thread_count; i++) {
-            if (hg_thread_join(pool->threads[i]) != HG_UTIL_SUCCESS) {
+        for(i = 0; i < priv_pool->thread_count; i++) {
+            if (hg_thread_join(priv_pool->threads[i]) != HG_UTIL_SUCCESS) {
                 HG_UTIL_LOG_ERROR("Could not join thread");
                 ret = HG_UTIL_FAIL;
                 goto done;
@@ -166,72 +163,21 @@ hg_thread_pool_destroy(hg_thread_pool_t *pool)
         }
     }
 
-    free(pool->threads);
-    pool->threads = NULL;
+    free(priv_pool->threads);
+    priv_pool->threads = NULL;
 
-    if (hg_thread_mutex_destroy(&pool->mutex) != HG_UTIL_SUCCESS) {
+    if (hg_thread_mutex_destroy(&priv_pool->pool.mutex) != HG_UTIL_SUCCESS) {
         HG_UTIL_LOG_ERROR("Could not destroy mutex");
         ret = HG_UTIL_FAIL;
         goto done;
     }
-    if (hg_thread_cond_destroy(&pool->cond) != HG_UTIL_SUCCESS){
+    if (hg_thread_cond_destroy(&priv_pool->pool.cond) != HG_UTIL_SUCCESS){
         HG_UTIL_LOG_ERROR("Could not destroy thread condition");
         ret = HG_UTIL_FAIL;
         goto done;
     }
 
-    free(pool);
-
-done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-int
-hg_thread_pool_post(hg_thread_pool_t *pool, struct hg_thread_work *work)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-    if (!pool) {
-        HG_UTIL_LOG_ERROR("Thread pool not initialized");
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-
-    if (!work) {
-        HG_UTIL_LOG_ERROR("Thread work cannot be NULL");
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-
-    if (!work->func) {
-        HG_UTIL_LOG_ERROR("Function pointer cannot be NULL");
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-
-    hg_thread_mutex_lock(&pool->mutex);
-
-    /* Are we shutting down ? */
-    if (pool->shutdown) {
-        HG_UTIL_LOG_ERROR("Pool is shutting down");
-        ret = HG_UTIL_FAIL;
-        goto unlock;
-    }
-
-    /* Add task to task queue */
-    HG_QUEUE_PUSH_TAIL(&pool->queue, work, entry);
-
-    /* Wake up sleeping worker */
-    if (pool->sleeping_worker_count) {
-        if (hg_thread_cond_signal(&pool->cond) != HG_UTIL_SUCCESS) {
-            HG_UTIL_LOG_ERROR("Cannot signal pool condition");
-            ret = HG_UTIL_FAIL;
-        }
-    }
-
-unlock:
-    hg_thread_mutex_unlock(&pool->mutex);
+    free(priv_pool);
 
 done:
     return ret;
diff --git a/src/util/mercury_thread_pool.h b/src/util/mercury_thread_pool.h
index 4705453..d9914ae 100644
--- a/src/util/mercury_thread_pool.h
+++ b/src/util/mercury_thread_pool.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -13,9 +13,19 @@
 
 #include "mercury_thread.h"
 #include "mercury_queue.h"
+#include "mercury_thread_condition.h"
+#include "mercury_util_error.h"
 
 typedef struct hg_thread_pool hg_thread_pool_t;
 
+struct hg_thread_pool {
+    unsigned int sleeping_worker_count;
+    HG_QUEUE_HEAD(hg_thread_work) queue;
+    int shutdown;
+    hg_thread_mutex_t mutex;
+    hg_thread_cond_t cond;
+};
+
 struct hg_thread_work {
     hg_thread_func_t func;
     void *args;
@@ -57,9 +67,60 @@ hg_thread_pool_destroy(hg_thread_pool_t *pool);
  *
  * \return Non-negative on success or negative on failure
  */
-HG_UTIL_EXPORT int
+static HG_UTIL_INLINE int
 hg_thread_pool_post(hg_thread_pool_t *pool, struct hg_thread_work *work);
 
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE int
+hg_thread_pool_post(hg_thread_pool_t *pool, struct hg_thread_work *work)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+    if (!pool) {
+        HG_UTIL_LOG_ERROR("Thread pool not initialized");
+        ret = HG_UTIL_FAIL;
+        goto done;
+    }
+
+    if (!work) {
+        HG_UTIL_LOG_ERROR("Thread work cannot be NULL");
+        ret = HG_UTIL_FAIL;
+        goto done;
+    }
+
+    if (!work->func) {
+        HG_UTIL_LOG_ERROR("Function pointer cannot be NULL");
+        ret = HG_UTIL_FAIL;
+        goto done;
+    }
+
+    hg_thread_mutex_lock(&pool->mutex);
+
+    /* Are we shutting down ? */
+    if (pool->shutdown) {
+        HG_UTIL_LOG_ERROR("Pool is shutting down");
+        ret = HG_UTIL_FAIL;
+        goto unlock;
+    }
+
+    /* Add task to task queue */
+    HG_QUEUE_PUSH_TAIL(&pool->queue, work, entry);
+
+    /* Wake up sleeping worker */
+    if (pool->sleeping_worker_count) {
+        if (hg_thread_cond_signal(&pool->cond) != HG_UTIL_SUCCESS) {
+            HG_UTIL_LOG_ERROR("Cannot signal pool condition");
+            ret = HG_UTIL_FAIL;
+        }
+    }
+
+unlock:
+    hg_thread_mutex_unlock(&pool->mutex);
+
+done:
+    return ret;
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/util/mercury_thread_rwlock.c b/src/util/mercury_thread_rwlock.c
new file mode 100644
index 0000000..4390ad0
--- /dev/null
+++ b/src/util/mercury_thread_rwlock.c
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+/* Copyright (C) 2017 Intel Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted for any purpose (including commercial purposes)
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions, and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions, and the following disclaimer in the
+ *    documentation and/or materials provided with the distribution.
+ *
+ * 3. In addition, redistributions of modified forms of the source or binary
+ *    code must carry prominent notices stating that the original code was
+ *    changed and the date of the change.
+ *
+ *  4. All publications or advertising materials mentioning features or use of
+ *     this software are asked, but not required, to acknowledge that it was
+ *     developed by Intel Corporation and credit the contributors.
+ *
+ * 5. Neither the name of Intel Corporation, nor the name of any Contributor
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "mercury_thread_rwlock.h"
+
+/*---------------------------------------------------------------------------*/
+int
+hg_thread_rwlock_init(hg_thread_rwlock_t *rwlock)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+#ifdef _WIN32
+    InitializeSRWLock(rwlock);
+#else
+    if (pthread_rwlock_init(rwlock, NULL)) ret = HG_UTIL_FAIL;
+#endif
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+int
+hg_thread_rwlock_destroy(hg_thread_rwlock_t *rwlock)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+#ifdef _WIN32
+    /* nothing to do */
+#else
+    if (pthread_rwlock_destroy(rwlock)) ret = HG_UTIL_FAIL;
+#endif
+
+    return ret;
+}
diff --git a/src/util/mercury_thread_rwlock.h b/src/util/mercury_thread_rwlock.h
index eaef55d..7e72da5 100644
--- a/src/util/mercury_thread_rwlock.h
+++ b/src/util/mercury_thread_rwlock.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -70,7 +70,7 @@ extern "C" {
  *
  * \return Non-negative on success or negative on failure
  */
-static HG_UTIL_INLINE int
+HG_UTIL_EXPORT int
 hg_thread_rwlock_init(hg_thread_rwlock_t *rwlock);
 
 /**
@@ -80,7 +80,7 @@ hg_thread_rwlock_init(hg_thread_rwlock_t *rwlock);
  *
  * \return Non-negative on success or negative on failure
  */
-static HG_UTIL_INLINE int
+HG_UTIL_EXPORT int
 hg_thread_rwlock_destroy(hg_thread_rwlock_t *rwlock);
 
 /**
@@ -143,36 +143,6 @@ hg_thread_rwlock_try_wrlock(hg_thread_rwlock_t *rwlock);
 static HG_UTIL_INLINE int
 hg_thread_rwlock_release_wrlock(hg_thread_rwlock_t *rwlock);
 
-/*---------------------------------------------------------------------------*/
-static HG_UTIL_INLINE int
-hg_thread_rwlock_init(hg_thread_rwlock_t *rwlock)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-#ifdef _WIN32
-    InitializeSRWLock(rwlock);
-#else
-    if (pthread_rwlock_init(rwlock, NULL)) ret = HG_UTIL_FAIL;
-#endif
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static HG_UTIL_INLINE int
-hg_thread_rwlock_destroy(hg_thread_rwlock_t *rwlock)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-#ifdef _WIN32
-    /* nothing to do */
-#else
-    if (pthread_rwlock_destroy(rwlock)) ret = HG_UTIL_FAIL;
-#endif
-
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE int
 hg_thread_rwlock_rdlock(hg_thread_rwlock_t *rwlock)
diff --git a/src/util/mercury_thread_spin.c b/src/util/mercury_thread_spin.c
new file mode 100644
index 0000000..70968cf
--- /dev/null
+++ b/src/util/mercury_thread_spin.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#include "mercury_thread_spin.h"
+
+/*---------------------------------------------------------------------------*/
+int
+hg_thread_spin_init(hg_thread_spin_t *lock)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+#if defined(_WIN32)
+    *lock = 0;
+#elif defined(HG_UTIL_HAS_PTHREAD_SPINLOCK_T)
+    if (pthread_spin_init(lock, 0)) ret = HG_UTIL_FAIL;
+#else
+    ret = hg_thread_mutex_init(lock);
+#endif
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+int
+hg_thread_spin_destroy(hg_thread_spin_t *lock)
+{
+    int ret = HG_UTIL_SUCCESS;
+
+#if defined(_WIN32)
+    (void) lock;
+#elif defined(HG_UTIL_HAS_PTHREAD_SPINLOCK_T)
+    if (pthread_spin_destroy(lock)) ret = HG_UTIL_FAIL;
+#else
+    ret = hg_thread_mutex_destroy(lock);
+#endif
+
+    return ret;
+}
diff --git a/src/util/mercury_thread_spin.h b/src/util/mercury_thread_spin.h
index e0eeb11..dd2e262 100644
--- a/src/util/mercury_thread_spin.h
+++ b/src/util/mercury_thread_spin.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -36,7 +36,7 @@ extern "C" {
  *
  * \return Non-negative on success or negative on failure
  */
-static HG_UTIL_INLINE int
+HG_UTIL_EXPORT int
 hg_thread_spin_init(hg_thread_spin_t *lock);
 
 /**
@@ -46,7 +46,7 @@ hg_thread_spin_init(hg_thread_spin_t *lock);
  *
  * \return Non-negative on success or negative on failure
  */
-static HG_UTIL_INLINE int
+HG_UTIL_EXPORT int
 hg_thread_spin_destroy(hg_thread_spin_t *lock);
 
 /**
@@ -79,40 +79,6 @@ hg_thread_spin_try_lock(hg_thread_spin_t *lock);
 static HG_UTIL_INLINE int
 hg_thread_spin_unlock(hg_thread_spin_t *lock);
 
-/*---------------------------------------------------------------------------*/
-static HG_UTIL_INLINE int
-hg_thread_spin_init(hg_thread_spin_t *lock)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-#if defined(_WIN32)
-    *lock = 0;
-#elif defined(HG_UTIL_HAS_PTHREAD_SPINLOCK_T)
-    if (pthread_spin_init(lock, 0)) ret = HG_UTIL_FAIL;
-#else
-    ret = hg_thread_mutex_init(lock);
-#endif
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static HG_UTIL_INLINE int
-hg_thread_spin_destroy(hg_thread_spin_t *lock)
-{
-    int ret = HG_UTIL_SUCCESS;
-
-#if defined(_WIN32)
-    (void) lock;
-#elif defined(HG_UTIL_HAS_PTHREAD_SPINLOCK_T)
-    if (pthread_spin_destroy(lock)) ret = HG_UTIL_FAIL;
-#else
-    ret = hg_thread_mutex_destroy(lock);
-#endif
-
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE int
 hg_thread_spin_lock(hg_thread_spin_t *lock)
diff --git a/src/util/mercury_time.h b/src/util/mercury_time.h
index f8aad3a..7055a35 100644
--- a/src/util/mercury_time.h
+++ b/src/util/mercury_time.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/mercury_util_config.h.in b/src/util/mercury_util_config.h.in
index 09b4b48..034df92 100644
--- a/src/util/mercury_util_config.h.in
+++ b/src/util/mercury_util_config.h.in
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
diff --git a/src/util/mercury_util_error.h b/src/util/mercury_util_error.h
index 9134a67..f22fad0 100644
--- a/src/util/mercury_util_error.h
+++ b/src/util/mercury_util_error.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2018 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
