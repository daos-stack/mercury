From bb3fafb15ffab4c2b7a84d3262cc439435526ee8 Mon Sep 17 00:00:00 2001
From: Yulu Jia <yulu.jia@intel.com>
Date: Tue, 15 Oct 2019 11:00:17 -0700
Subject: [PATCH] NA OFI: use ip addr for psm2

let psm2 uses ip:port address format so that user can specify uri at
init time.

Signed-off-by: Yulu Jia <yulu.jia@intel.com>
---
 Testing/CMakeLists.txt |  11 +-
 Testing/na/na_test.c   |  33 +++++-
 src/na/na_ofi.c        | 221 +++++++++++++++++++++++++++++++++--------
 3 files changed, 215 insertions(+), 50 deletions(-)

diff --git a/Testing/CMakeLists.txt b/Testing/CMakeLists.txt
index 4147f477..5aec2464 100644
--- a/Testing/CMakeLists.txt
+++ b/Testing/CMakeLists.txt
@@ -75,6 +75,9 @@ if(NA_USE_OFI)
   set(NA_OFI_TESTING_PROTOCOL "sockets;tcp" CACHE STRING "Protocol(s) used for testing (e.g., sockets;psm2;verbs).")
   mark_as_advanced(NA_OFI_TESTING_PROTOCOL)
 
+  set(NA_TESTING_HOSTNAME "eth0" CACHE STRING "hostname used for testing (e.g., 192.168.1.100).")
+  mark_as_advanced(NA_TESTING_HOSTNAME)
+
   option(NA_OFI_TESTING_USE_CRAY_DRC
     "Use Cray DRC to allow multi-job communication." OFF)
   mark_as_advanced(NA_OFI_TESTING_USE_CRAY_DRC)
@@ -143,7 +146,7 @@ function(build_mercury_test test_name)
   endif()
 endfunction()
 
-macro(add_mercury_test_comm test_name comm protocol busy)
+macro(add_mercury_test_comm test_name comm protocol hostname busy)
   # Set full test name
   set(full_test_name ${test_name})
   set(opt_names ${comm} ${protocol})
@@ -155,7 +158,7 @@ macro(add_mercury_test_comm test_name comm protocol busy)
   endif()
 
   # Set test arguments
-  set(test_args --comm ${comm} --protocol ${protocol})
+  set(test_args --comm ${comm} --protocol ${protocol} --hostname ${hostname})
   if(${busy})
     set(test_args ${test_args} --busy)
   endif()
@@ -213,8 +216,8 @@ function(add_mercury_test test_name)
   foreach(comm ${NA_PLUGINS})
     string(TOUPPER ${comm} upper_comm)
     foreach(protocol ${NA_${upper_comm}_TESTING_PROTOCOL})
-      add_mercury_test_comm(${test_name} ${comm} ${protocol} false)
-      add_mercury_test_comm(${test_name} ${comm} ${protocol} true)
+      add_mercury_test_comm(${test_name} ${comm} ${protocol} ${NA_TESTING_HOSTNAME} false)
+      add_mercury_test_comm(${test_name} ${comm} ${protocol} ${NA_TESTING_HOSTNAME} true)
     endforeach()
   endforeach()
 endfunction()
diff --git a/Testing/na/na_test.c b/Testing/na/na_test.c
index 2d550555..60296a60 100644
--- a/Testing/na/na_test.c
+++ b/Testing/na/na_test.c
@@ -305,10 +305,18 @@ na_test_gen_config(struct na_test_info *na_test_info)
             /* special-case SM (pid:id) */
             sprintf(info_string_ptr, "%d/%d", (int) getpid(), port_incr);
         }
-    } else if ((strcmp("tcp", na_test_info->protocol) == 0)
+    } else if (strcmp("psm2", na_test_info->protocol) == 0) {
+        if (!na_test_info->listen) {
+            sprintf(info_string_ptr, "%s:%d", na_test_info->hostname,
+                    33333);
+        } else {
+            sprintf(info_string_ptr, "%s:%d", na_test_info->hostname,
+                    22222);
+        }
+
+    } else if((strcmp("tcp", na_test_info->protocol) == 0)
         || (strcmp("verbs;ofi_rxm", na_test_info->protocol) == 0)
         || (strcmp("verbs", na_test_info->protocol) == 0)
-        || (strcmp("psm2", na_test_info->protocol) == 0)
         || (strcmp("sockets", na_test_info->protocol) == 0)) {
         if (!na_test_info->hostname) {
             /* Nothing */
@@ -486,6 +494,27 @@ NA_Test_init(int argc, char *argv[], struct na_test_info *na_test_info)
         }
     }
 
+    {
+        char addr_string[NA_TEST_MAX_ADDR_NAME];
+        na_size_t addr_string_len = NA_TEST_MAX_ADDR_NAME;
+        na_addr_t self_addr;
+        na_return_t nret;
+
+        /* TODO only rank 0 */
+        nret = NA_Addr_self(na_test_info->na_class, &self_addr);
+        if (nret != NA_SUCCESS) {
+            NA_LOG_ERROR("Could not get self addr");
+        }
+
+        nret = NA_Addr_to_string(na_test_info->na_class, addr_string,
+                &addr_string_len, self_addr);
+        if (nret != NA_SUCCESS) {
+            NA_LOG_ERROR("Could not convert addr to string");
+        }
+        NA_LOG_DEBUG("self URI: %s\n", addr_string);
+        NA_Addr_free(na_test_info->na_class, self_addr);
+    }
+
 done:
     if (ret != NA_SUCCESS)
         NA_Test_finalize(na_test_info);
diff --git a/src/na/na_ofi.c b/src/na/na_ofi.c
index 5c13067a..c52168ee 100644
--- a/src/na/na_ofi.c
+++ b/src/na/na_ofi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ * Copyright (C) 2013-2020 Argonne National Laboratory, Department of Energy,
  *                    UChicago Argonne, LLC and The HDF Group.
  * All rights reserved.
  *
@@ -232,6 +232,7 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 #define NA_OFI_CONTEXT(na_context)  \
     ((struct na_ofi_context *)((na_context)->plugin_context))
 
+#define NA_NOMEM_ERROR      NA_NOMEM
 /************************************/
 /* Local Type and Struct Definition */
 /************************************/
@@ -349,6 +350,8 @@ struct na_ofi_context {
 /* Endpoint */
 struct na_ofi_endpoint {
     struct na_ofi_addr *src_addr;           /* Endpoint address         */
+    char *src_node;                         /* Fabric address           */
+    char *src_service;                      /* Service name             */
     struct fi_info *fi_prov;                /* Provider info            */
     struct fid_ep *fi_ep;                   /* Endpoint handle          */
     struct fid_wait *fi_wait;               /* Wait set handle          */
@@ -561,8 +564,9 @@ na_ofi_domain_close(struct na_ofi_domain *na_ofi_domain);
  */
 static na_return_t
 na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
-    const char *node, void *src_addr, na_size_t src_addrlen, na_bool_t no_wait,
-    na_uint8_t max_contexts, struct na_ofi_endpoint **na_ofi_endpoint_p);
+    const char *node, const char *service, void *src_addr,
+    na_size_t src_addrlen, na_bool_t no_wait, na_uint8_t max_contexts,
+    struct na_ofi_endpoint **na_ofi_endpoint_p);
 
 /**
  * Open basic endpoint.
@@ -688,7 +692,7 @@ na_ofi_msg_unexpected_op_remove(na_context_t *context,
  * Read from CQ.
  */
 static na_return_t
-na_ofi_cq_read(na_context_t *context, size_t max_count,
+na_ofi_cq_read(na_class_t *na_class, na_context_t *context, size_t max_count,
     struct fi_cq_tagged_entry cq_events[], fi_addr_t src_addrs[],
     void **src_err_addr, size_t *src_err_addrlen, size_t *actual_count);
 
@@ -1074,7 +1078,7 @@ na_ofi_str_to_addr(const char *str, na_uint32_t addr_format, void **addr,
         case FI_SOCKADDR_IN:
             return na_ofi_str_to_sin(str, addr, len);
         case FI_ADDR_PSMX2:
-            return na_ofi_str_to_psm2(str, addr, len);
+            return na_ofi_str_to_sin(str, addr, len);
         case FI_ADDR_GNI:
             return na_ofi_str_to_gni(str, addr, len);
         default:
@@ -1200,8 +1204,8 @@ na_ofi_addr_to_key(na_uint32_t addr_format, const void *addr, na_size_t len)
             assert(len == sizeof(struct na_ofi_sin_addr));
             return na_ofi_sin_to_key((const struct na_ofi_sin_addr *) addr);
         case FI_ADDR_PSMX2:
-            assert(len == sizeof(struct na_ofi_psm2_addr));
-            return na_ofi_psm2_to_key((const struct na_ofi_psm2_addr *) addr);
+            assert(len == sizeof(struct na_ofi_sin_addr));
+            return na_ofi_sin_to_key((const struct na_ofi_sin_addr *) addr);
         case FI_ADDR_GNI:
             assert(len == sizeof(struct na_ofi_gni_addr));
             return na_ofi_gni_to_key((const struct na_ofi_gni_addr *) addr);
@@ -1255,6 +1259,73 @@ na_ofi_addr_ht_key_equal(hg_hash_table_key_t vlocation1,
     return *((na_uint64_t *) vlocation1) == *((na_uint64_t *) vlocation2);
 }
 
+static na_return_t
+na_ofi_av_insert(struct na_ofi_domain *domain, const void *addr,
+    na_size_t addrlen, fi_addr_t *fi_addr)
+{
+    char *node_str, service_str[16];
+    struct fi_info *tmp_info = NULL;
+    int rc = 0;
+    int ret = 0;
+
+    if (na_ofi_prov_addr_format[domain->prov_type] == FI_ADDR_PSMX2) {
+        struct na_ofi_sin_addr *sin_addr = addr;
+        node_str = inet_ntoa(sin_addr->sin.sin_addr);
+        sprintf (service_str, "%d", ntohs(sin_addr->sin.sin_port));
+
+        /* Resolve node / service (always pass a numeric host) */
+        rc = fi_getinfo(NA_OFI_VERSION, node_str,
+            service_str /* service */,
+            0 /* flags */,
+            domain->fi_prov /* hints */, &tmp_info);
+        if (rc != 0) {
+            NA_LOG_ERROR("fi_getinfo (%s:%s) failed, rc: %d(%s).",
+                         node_str, service_str, rc, fi_strerror(-rc));
+            ret = NA_PROTOCOL_ERROR;
+            goto out;
+        }
+        addr = tmp_info->dest_addr;
+    }
+
+    na_ofi_domain_lock(domain);
+    rc = fi_av_insert(domain->fi_av, tmp_info->dest_addr, 1, fi_addr,
+            0 /* flags */, NULL /* context */);
+    na_ofi_domain_unlock(domain);
+
+    if (rc < 0) {
+        NA_LOG_ERROR("fi_av_insert/svc failed(node %s, service %s), rc: %d(%s).",
+                     node_str, service_str, rc, fi_strerror(-rc));
+        ret = NA_PROTOCOL_ERROR;
+        goto out;
+    }
+
+    /* The below just to verify the AV address resolution */
+    /*
+    void *peer_addr;
+    char peer_addr_str[NA_OFI_MAX_URI_LEN] = {'\0'};
+
+    peer_addr = malloc(addrlen);
+    if (peer_addr == NULL) {
+        NA_LOG_ERROR("Could not allocate peer_addr.");
+        ret = NA_NOMEM_ERROR;
+        goto out;
+    }
+    rc = fi_av_lookup(domain->fi_av, *fi_addr, peer_addr, &addrlen);
+    if (rc != 0) {
+        NA_LOG_ERROR("fi_av_lookup failed, rc: %d(%s).", rc, fi_strerror(-rc));
+        ret = NA_PROTOCOL_ERROR;
+        goto out;
+    }
+    addrlen = NA_OFI_MAX_URI_LEN;
+    fi_av_straddr(domain->fi_av, peer_addr, peer_addr_str, &addrlen);
+    NA_LOG_DEBUG("node %s, service %s, peer address %s.",
+                 node_str, service_str, peer_addr_str);
+    free(peer_addr);
+    */
+out:
+    return ret;
+}
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
@@ -1282,10 +1353,8 @@ na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
     }
 
     /* Insert addr into AV if key not found */
-    na_ofi_domain_lock(domain);
-    rc = fi_av_insert(domain->fi_av, addr, 1, fi_addr, 0 /* flags */, NULL);
-    na_ofi_domain_unlock(domain);
-    NA_CHECK_ERROR(rc < 1, out, ret, NA_PROTOCOL_ERROR,
+    rc = na_ofi_av_insert(domain, addr, addrlen, fi_addr);
+    NA_CHECK_ERROR(rc != NA_SUCCESS, out, ret, NA_PROTOCOL_ERROR,
         "fi_av_insert() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
     hg_thread_rwlock_wrlock(&domain->rwlock);
@@ -1922,8 +1991,9 @@ na_ofi_domain_close(struct na_ofi_domain *na_ofi_domain)
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
-    const char *node, void *src_addr, na_size_t src_addrlen, na_bool_t no_wait,
-    na_uint8_t max_contexts, struct na_ofi_endpoint **na_ofi_endpoint_p)
+    const char *node, const char *service, void *src_addr,
+    na_size_t src_addrlen, na_bool_t no_wait, na_uint8_t max_contexts,
+    struct na_ofi_endpoint **na_ofi_endpoint_p)
 {
     struct na_ofi_endpoint *na_ofi_endpoint;
     struct fi_info *hints = NULL;
@@ -1938,6 +2008,22 @@ na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
         "Could not allocate na_ofi_endpoint");
     memset(na_ofi_endpoint, 0, sizeof(struct na_ofi_endpoint));
 
+    /* Dup node string */
+    if (node && strcmp("\0", node)
+        && !(na_ofi_endpoint->src_node = strdup(node))) {
+        NA_LOG_ERROR("Could not duplicate node name");
+        ret = NA_NOMEM_ERROR;
+        goto out;
+    }
+
+    /* Dup service string */
+    if (service && strcmp("\0", service)
+            && !(na_ofi_endpoint->src_service = strdup(service))) {
+        NA_LOG_ERROR("Could not duplicate service name");
+        ret = NA_NOMEM_ERROR;
+        goto out;
+    }
+
     /* Dup fi_info */
     hints = fi_dupinfo(na_ofi_domain->fi_prov);
     NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM,
@@ -1955,7 +2041,7 @@ na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
     hints->ep_attr->tx_ctx_cnt = max_contexts;
     hints->ep_attr->rx_ctx_cnt = max_contexts;
 
-    rc = fi_getinfo(NA_OFI_VERSION, node, NULL, flags, hints,
+    rc = fi_getinfo(NA_OFI_VERSION, node, service, flags, hints,
         &na_ofi_endpoint->fi_prov);
     NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
         "fi_getinfo(%s) failed, rc: %d(%s)", node, rc, fi_strerror(-rc));
@@ -2174,9 +2260,16 @@ na_ofi_get_ep_addr(na_class_t *na_class, struct na_ofi_addr **na_ofi_addr_ptr)
         free(addr);
         goto retry;
     }
-    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
-        "fi_getname() failed, rc: %d(%s), addrlen: %zu", rc, fi_strerror(-rc),
-        addrlen);
+
+    /**
+     * addr now contains the ip:service string internal to psm2. overwrite it
+     * the external ip:port string
+     */
+    if (na_ofi_domain->prov_type == NA_OFI_PROV_PSM2) {
+        struct sockaddr_in *my_sin_addr = addr;
+        my_sin_addr->sin_addr.s_addr = inet_addr(priv->endpoint->src_node);
+        my_sin_addr->sin_port = htons(atoi(priv->endpoint->src_service));
+    }
 
     na_ofi_addr->addr = addr;
     na_ofi_addr->addrlen = addrlen;
@@ -2202,6 +2295,7 @@ na_ofi_get_ep_addr(na_class_t *na_class, struct na_ofi_addr **na_ofi_addr_ptr)
 static na_return_t
 na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
 {
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_domain *na_ofi_domain = NA_OFI_CLASS(na_class)->domain;
     char addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         fi_addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
@@ -2210,21 +2304,28 @@ na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    /* Convert FI address to a printable string */
-    fi_av_straddr(na_ofi_domain->fi_av, addr, fi_addr_str, &fi_addr_strlen);
-    NA_CHECK_ERROR(fi_addr_strlen > NA_OFI_MAX_URI_LEN, out, ret,
-        NA_PROTOCOL_ERROR, "fi_av_straddr() address truncated, addrlen: %zu",
-        fi_addr_strlen);
-
-    /* Remove unnecessary "://" prefix from string if present */
-    if (strstr(fi_addr_str, "://")) {
-        strtok_r(fi_addr_str, ":", &fi_addr_str_ptr);
-        rc = strncmp(fi_addr_str_ptr, "//", 2);
-        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTONOSUPPORT,
-            "Bad address string format");
-        fi_addr_str_ptr += 2;
-    } else
+    if (na_ofi_domain->prov_type == NA_OFI_PROV_PSM2) {
+        /* do not use fi_av_straddr(), as it returns the psm2 native URI */
+        snprintf(fi_addr_str, fi_addr_strlen, "%s:%s",
+            priv->endpoint->src_node, priv->endpoint->src_service);
         fi_addr_str_ptr = fi_addr_str;
+    } else {
+        /* Convert FI address to a printable string */
+        fi_av_straddr(na_ofi_domain->fi_av, addr, fi_addr_str, &fi_addr_strlen);
+        NA_CHECK_ERROR(fi_addr_strlen > NA_OFI_MAX_URI_LEN, out, ret,
+            NA_PROTOCOL_ERROR, "fi_av_straddr() address truncated, addrlen: %zu",
+            fi_addr_strlen);
+
+        /* Remove unnecessary "://" prefix from string if present */
+        if (strstr(fi_addr_str, "://")) {
+            strtok_r(fi_addr_str, ":", &fi_addr_str_ptr);
+            rc = strncmp(fi_addr_str_ptr, "//", 2);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTONOSUPPORT,
+                "Bad address string format");
+            fi_addr_str_ptr += 2;
+        } else
+            fi_addr_str_ptr = fi_addr_str;
+    }
 
     /* Generate URI */
     rc = snprintf(addr_str, NA_OFI_MAX_URI_LEN, "%s://%s",
@@ -2523,7 +2624,7 @@ na_ofi_msg_unexpected_op_remove(na_context_t *context,
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_cq_read(na_context_t *context, size_t max_count,
+na_ofi_cq_read(na_class_t *na_class, na_context_t *context, size_t max_count,
     struct fi_cq_tagged_entry cq_events[], fi_addr_t src_addrs[],
     void **src_err_addr, size_t *src_err_addrlen, size_t *actual_count)
 {
@@ -2584,14 +2685,43 @@ na_ofi_cq_read(na_context_t *context, size_t max_count,
          }
             break;
 
-        case FI_EADDRNOTAVAIL:
+        case FI_EADDRNOTAVAIL: {
+            struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
+            struct fid_av *av_hdl = priv->domain->fi_av;
+            void *err_addr = NULL;
+            size_t err_addrlen;
+
+            /* Copy addr information */
+            err_addr = malloc(cq_err.err_data_size);
+            NA_CHECK_ERROR(err_addr == NULL, out, ret, NA_NOMEM_ERROR,
+                "Could not allocate err_addr");
+            err_addrlen = cq_err.err_data_size;
+            memcpy(err_addr, cq_err.err_data, err_addrlen);
+
+            na_ofi_domain_lock(priv->domain);
+            /* Insert new source addr into AV if address was not found */
+            rc = fi_av_insert(av_hdl, err_addr, 1, &src_addrs[0],
+                0 /* flags */, NULL /* context */);
+            na_ofi_domain_unlock(priv->domain);
+            if (unlikely(rc < 1)) {
+                free(err_addr);
+                NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
+                    "fi_av_insert() failed, rc: %d(%s)",
+                    rc, fi_strerror((int) -rc));
+            }
             /* Only one error event processed in that case */
             memcpy(&cq_events[0], &cq_err, sizeof(cq_events[0]));
             *src_err_addr = cq_err.err_data;
             *src_err_addrlen = cq_err.err_data_size;
             *actual_count = 1;
             break;
-
+        }
+        case FI_EIO:
+            NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
+                "fi_cq_readerr() got err: %d(%s), prov_errno: %d(%s)",
+                cq_err.err, fi_strerror(cq_err.err), cq_err.prov_errno,
+                fi_strerror(-cq_err.prov_errno));
+            break;
         default:
             /* Ignore errors from OFI that we cannot handle */
             NA_LOG_WARNING(
@@ -2904,6 +3034,7 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     char *host_name = NULL;
     unsigned int port = 0;
     const char *node_ptr = NULL;
+    char *service_str = NULL;
     char node[NA_OFI_MAX_URI_LEN] = {'\0'};
     char *domain_name_ptr = NULL;
     char domain_name[NA_OFI_MAX_URI_LEN] = {'\0'};
@@ -2942,9 +3073,8 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
 
         /* Extract hostname */
         if (strstr(host_name, ":")) {
-            char *port_str = NULL;
-            strtok_r(host_name, ":", &port_str);
-            port = (unsigned int) strtoul(port_str, NULL, 10);
+            strtok_r(host_name, ":", &service_str);
+            port = (unsigned int) strtoul(service_str, NULL, 10);
         }
 
         /* Extract domain (if specified) */
@@ -2982,7 +3112,8 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
                 strncpy(domain_name, resolve_name, NA_OFI_MAX_URI_LEN - 1);
                 domain_name_ptr = domain_name;
             }
-        } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI) {
+        } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI ||
+                   na_ofi_prov_addr_format[prov_type] == FI_ADDR_PSMX2) {
             struct na_ofi_sin_addr *na_ofi_sin_addr = NULL;
             const char *ptr;
 
@@ -3041,10 +3172,12 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
         na_ofi_prov_name[prov_type], domain_name_ptr);
 
     /* Create endpoint */
-    ret = na_ofi_endpoint_open(priv->domain, node_ptr, src_addr, src_addrlen,
-        priv->no_wait, priv->max_contexts, &priv->endpoint);
-    NA_CHECK_NA_ERROR(out, ret, "Could not create endpoint for %s",
-        resolve_name);
+    ret = na_ofi_endpoint_open(priv->domain, node_ptr, service_str, src_addr,
+        src_addrlen, priv->no_wait, priv->max_contexts, &priv->endpoint);
+    if (ret != NA_SUCCESS) {
+        NA_LOG_ERROR("Could not create endpoint for %s", resolve_name);
+        goto out;
+    }
 
     /* Get address from endpoint */
     ret = na_ofi_get_ep_addr(na_class, &priv->endpoint->src_addr);
@@ -4346,8 +4479,8 @@ na_ofi_progress(na_class_t *na_class, na_context_t *context,
         }
 
         /* Read from CQ */
-        ret = na_ofi_cq_read(context, NA_OFI_CQ_EVENT_NUM, cq_events, src_addrs,
-            &src_err_addr_ptr, &src_err_addrlen, &actual_count);
+        ret = na_ofi_cq_read(na_class, context, NA_OFI_CQ_EVENT_NUM, cq_events,
+            src_addrs, &src_err_addr_ptr, &src_err_addrlen, &actual_count);
         NA_CHECK_NA_ERROR(out, ret,
             "Could not read events from context CQ");
 
