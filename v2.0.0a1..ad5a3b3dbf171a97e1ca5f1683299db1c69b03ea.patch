diff --git a/.travis.yml b/.travis.yml
index df5607e..aa36dda 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -7,9 +7,7 @@ compiler:
     - gcc
     - clang
 
-sudo: true
-dist: trusty
-group: beta
+dist: xenial
 
 cache:
   directories:
@@ -18,12 +16,12 @@ cache:
 env:
   global:
     - MERCURY_NO_LOOP="true"
-  matrix:
+  jobs:
     - MERCURY_BUILD_CONFIGURATION="Debug"
     - MERCURY_BUILD_CONFIGURATION="RelWithDebInfo"
     - MERCURY_BUILD_CONFIGURATION="Release"
 
-matrix:
+jobs:
   include:
    - os: linux
      compiler: gcc
@@ -32,8 +30,8 @@ matrix:
          sources:
          - ubuntu-toolchain-r-test
          packages:
-         - gcc-8
-         - g++-8
+         - gcc-9
+         - g++-9
          - libtsan0
          - libasan5
          - liblsan0
@@ -45,8 +43,8 @@ matrix:
          sources:
          - ubuntu-toolchain-r-test
          packages:
-         - gcc-8
-         - g++-8
+         - gcc-9
+         - g++-9
          - libtsan0
          - libasan5
          - liblsan0
@@ -58,8 +56,8 @@ matrix:
          sources:
          - ubuntu-toolchain-r-test
          packages:
-         - gcc-8
-         - g++-8
+         - gcc-9
+         - g++-9
      env: MERCURY_DO_COVERAGE="true"
 
 branches:
@@ -81,7 +79,7 @@ before_script:
     - export PATH=$HOME/install/bin:$PATH
     - export LD_LIBRARY_PATH=$HOME/install/lib:$HOME/install/lib64:$LD_LIBRARY_PATH
     - export PKG_CONFIG_PATH=$HOME/install/lib/pkgconfig:$PKG_CONFIG_PATH
-    - if [[ "$CC" == "gcc" && `command -v gcc-8` ]]; then export CC=gcc-8; export CXX=g++-8; export AR=gcc-ar-8; export NM=gcc-nm-8; export RANLIB=gcc-ranlib-8; which gcov-8; fi
+    - if [[ "$CC" == "gcc" && `command -v gcc-9` ]]; then export CC=gcc-9; export CXX=g++-9; export AR=gcc-ar-9; export NM=gcc-nm-9; export RANLIB=gcc-ranlib-9; export COV=gcov-9; fi
     - $CC --version
     - if [[ "$TRAVIS_EVENT_TYPE" == "cron" ]]; then export MERCURY_DASHBOARD_MODEL="Nightly"; elif [[ "$TRAVIS_EVENT_TYPE" == "pull_request" ]]; then export MERCURY_DASHBOARD_MODEL="Experimental"; else export MERCURY_DASHBOARD_MODEL="Continuous"; fi
     - ctest --version
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8b33e98..1f6fa8e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -172,6 +172,12 @@ endif()
 option(MERCURY_ENABLE_VERBOSE_ERROR "Print error messages to stderr." ON)
 if(MERCURY_ENABLE_VERBOSE_ERROR)
   set(HG_HAS_VERBOSE_ERROR 1)
+  option(MERCURY_ENABLE_DEBUG "Enable debug statements." OFF)
+  if(MERCURY_ENABLE_DEBUG)
+    set(HG_HAS_DEBUG 1)
+  else()
+    set(HG_HAS_DEBUG 0)
+  endif()
 else()
   set(HG_HAS_VERBOSE_ERROR 0)
 endif()
diff --git a/CTestConfig.cmake b/CTestConfig.cmake
index bbd9a46..138d468 100644
--- a/CTestConfig.cmake
+++ b/CTestConfig.cmake
@@ -9,7 +9,7 @@ set(CTEST_PROJECT_NAME "MERCURY")
 set(CTEST_NIGHTLY_START_TIME "00:00:00 CST")
 
 set(CTEST_DROP_METHOD "http")
-set(CTEST_DROP_SITE "cdash.hdfgroup.org")
-set(CTEST_DROP_LOCATION "/submit.php?project=MERCURY")
+set(CTEST_DROP_SITE "149.28.123.102/CDash")
+set(CTEST_DROP_LOCATION "/submit.php?project=Mercury")
 set(CTEST_DROP_SITE_CDASH TRUE)
 
diff --git a/Testing/CMakeLists.txt b/Testing/CMakeLists.txt
index b551008..b401427 100644
--- a/Testing/CMakeLists.txt
+++ b/Testing/CMakeLists.txt
@@ -3,44 +3,56 @@
 #------------------------------------------------------------------------------
 set(MERCURY_TESTING_BUFFER_SIZE "16" CACHE STRING
   "Total buffer size (in MB) used for testing.")
+set(HG_TEST_BUFFER_SIZE ${MERCURY_TESTING_BUFFER_SIZE})
 mark_as_advanced(MERCURY_TESTING_BUFFER_SIZE)
 
+set(MERCURY_TESTING_MAX_HANDLES "16" CACHE STRING
+  "Max number of concurrent handles used for testing.")
+set(HG_TEST_MAX_HANDLES ${MERCURY_TESTING_MAX_HANDLES})
+mark_as_advanced(MERCURY_TESTING_MAX_HANDLES)
+
 option(MERCURY_TESTING_USE_THREAD_POOL "Run tests using thread pool." ON)
 if(MERCURY_TESTING_USE_THREAD_POOL)
-  set(MERCURY_TESTING_HAS_THREAD_POOL ON)
+  set(HG_TEST_HAS_THREAD_POOL 1)
 endif()
 mark_as_advanced(MERCURY_TESTING_USE_THREAD_POOL)
 
 option(MERCURY_TESTING_VERIFY_DATA
   "Verify data when running tests (disable when measuring bandwidth)." ON)
 if(MERCURY_TESTING_VERIFY_DATA)
-  set(MERCURY_TESTING_HAS_VERIFY_DATA ON)
+  set(HG_TEST_HAS_VERIFY_DATA 1)
 endif()
 mark_as_advanced(MERCURY_TESTING_VERIFY_DATA)
 
 option(MERCURY_TESTING_PRINT_PARTIAL
   "Print partial results between loops (disable when measuring)." OFF)
+if(MERCURY_TESTING_PRINT_PARTIAL)
+  set(HG_TEST_PRINT_PARTIAL 1)
+endif()
 mark_as_advanced(MERCURY_TESTING_PRINT_PARTIAL)
 
-option(MERCURY_ENABLE_PARALLEL_TESTING
+option(MERCURY_TESTING_ENABLE_PARALLEL
   "Enable testing in parallel (requires MPI)." OFF)
-if(MERCURY_ENABLE_PARALLEL_TESTING OR NA_USE_MPI)
-  set(MERCURY_HAS_PARALLEL_TESTING 1)
-  if(NA_USE_MPI AND NOT MERCURY_ENABLE_PARALLEL_TESTING)
+if(MERCURY_TESTING_ENABLE_PARALLEL OR NA_USE_MPI)
+  set(HG_TEST_HAS_PARALLEL 1)
+  if(NA_USE_MPI AND NOT MERCURY_TESTING_ENABLE_PARALLEL)
     # Always force parallel testing if NA_USE_MPI is turned ON
-    set(MERCURY_ENABLE_PARALLEL_TESTING "ON" CACHE BOOL
+    set(MERCURY_TESTING_ENABLE_PARALLEL "ON" CACHE BOOL
       "Enable testing in parallel (requires MPI)." FORCE)
   endif()
 else()
-  set(MERCURY_HAS_PARALLEL_TESTING 0)
+  set(HG_TEST_HAS_PARALLEL 0)
 endif()
+mark_as_advanced(MERCURY_TESTING_ENABLE_PARALLEL)
 
-set(MERCURY_TEST_INIT_COMMAND "" CACHE STRING
+set(MERCURY_TESTING_INIT_COMMAND "" CACHE STRING
   "Command to run before a client/server test begins. Multiple commands are separated by ';'.")
-mark_as_advanced(MERCURY_TEST_INIT_COMMAND)
+set(HG_TEST_INIT_COMMAND ${MERCURY_TESTING_INIT_COMMAND})
+mark_as_advanced(MERCURY_TESTING_INIT_COMMAND)
 
 set(MERCURY_TESTING_TEMP_DIRECTORY "." CACHE PATH
   "Location to use for temp data (default is current directory).")
+set(HG_TEST_TEMP_DIRECTORY ${MERCURY_TESTING_TEMP_DIRECTORY})
 mark_as_advanced(MERCURY_TESTING_TEMP_DIRECTORY)
 
 if(MERCURY_USE_SELF_FORWARD)
@@ -51,6 +63,8 @@ else()
 endif()
 mark_as_advanced(MERCURY_TESTING_CORESIDENT)
 
+set(HG_TEST_FAIL_REGULAR_EXPRESSION "[^a-z]Error;ERROR;Failed")
+
 #------------------------------------------------------------------------------
 # NA protocols used for testing
 # (case where the NA plugin defines multiple protocols)
@@ -81,7 +95,7 @@ if(NA_USE_OFI)
   if(NA_OFI_TESTING_USE_CRAY_DRC)
     find_package(DRC REQUIRED)
     if(DRC_FOUND)
-      set(HG_TESTING_HAS_CRAY_DRC 1)
+      set(HG_TEST_HAS_CRAY_DRC 1)
       include_directories(${DRC_INCLUDE_DIRS})
       set(MERCURY_TEST_EXT_LIB_DEPENDENCIES
         ${MERCURY_TEST_EXT_LIB_DEPENDENCIES}
@@ -99,7 +113,7 @@ if(NA_USE_SM)
 endif()
 
 # Detect <sys/prctl.h>
-check_include_files("sys/prctl.h" HG_TESTING_HAS_SYSPRCTL_H)
+check_include_files("sys/prctl.h" HG_TEST_HAS_SYSPRCTL_H)
 
 #------------------------------------------------------------------------------
 # Compile kwsys library and setup TestDriver
@@ -114,7 +128,7 @@ include_directories(
   ${CMAKE_CURRENT_BINARY_DIR}
 )
 
-if(MERCURY_ENABLE_PARALLEL_TESTING)
+if(MERCURY_TESTING_ENABLE_PARALLEL)
   find_package(MPI REQUIRED)
   if(MPI_FOUND)
     include_directories(${MPI_INCLUDE_PATH})
@@ -143,7 +157,7 @@ function(build_mercury_test test_name)
   endif()
 endfunction()
 
-macro(add_mercury_test_comm test_name comm protocol busy)
+macro(add_mercury_test_comm test_name comm protocol busy serial)
   # Set full test name
   set(full_test_name ${test_name})
   set(opt_names ${comm} ${protocol})
@@ -159,6 +173,11 @@ macro(add_mercury_test_comm test_name comm protocol busy)
   if(${busy})
     set(test_args ${test_args} --busy)
   endif()
+  if(${serial})
+    set(numprocs 1)
+  else()
+    set(numprocs ${MPIEXEC_MAX_NUMPROCS})
+  endif()
 
   # Static client/server test
   if(${comm} STREQUAL "mpi" AND ${protocol} STREQUAL "static")
@@ -166,55 +185,72 @@ macro(add_mercury_test_comm test_name comm protocol busy)
     add_test(NAME "mercury_${full_test_name}"
       COMMAND ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} 1
       ${MPIEXEC_PREFLAGS} $<TARGET_FILE:hg_test_server> ${MPIEXEC_POSTFLAGS}
-      ${static_test_args} : ${MPIEXEC_NUMPROC_FLAG} ${MPIEXEC_MAX_NUMPROCS}
+      ${static_test_args} : ${MPIEXEC_NUMPROC_FLAG} ${numprocs}
       ${MPIEXEC_PREFLAGS} $<TARGET_FILE:hg_test_${test_name}> ${static_test_args}
     )
+    set_tests_properties("mercury_${full_test_name}" PROPERTIES
+      FAIL_REGULAR_EXPRESSION ${HG_TEST_FAIL_REGULAR_EXPRESSION}
+    )
   else()
+    set(driver_args --server $<TARGET_FILE:hg_test_server>       ${test_args}
+                    --client $<TARGET_FILE:hg_test_${test_name}> ${test_args})
+    if(${serial})
+      set(driver_args ${driver_args} --serial)
+    endif()
     # Dynamic client/server test
     add_test(NAME "mercury_${full_test_name}"
       COMMAND $<TARGET_FILE:mercury_test_driver>
-      --server $<TARGET_FILE:hg_test_server>
-      --client $<TARGET_FILE:hg_test_${test_name}> ${test_args}
+      ${driver_args}
     )
   endif()
 
   # Coresident test (disable for BMI and MPI)
   if(MERCURY_TESTING_CORESIDENT AND
     (NOT ((${comm} STREQUAL "bmi") OR (${comm} STREQUAL "mpi") OR (${test_name} STREQUAL "cancel"))))
-    set(cores_test_name ${full_test_name}_self)
-    set(cores_test_args ${test_args} --self_send)
-    if (MERCURY_ENABLE_PARALLEL_TESTING)
-      add_test(NAME "mercury_${cores_test_name}"
-        COMMAND ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} ${MPIEXEC_MAX_NUMPROCS}
+    set(self_test_name ${full_test_name}_self)
+    set(self_test_args ${test_args} --self_send)
+    if(MERCURY_TESTING_ENABLE_PARALLEL)
+      add_test(NAME "mercury_${self_test_name}"
+        COMMAND ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} ${numprocs}
         ${MPIEXEC_PREFLAGS} $<TARGET_FILE:hg_test_${test_name}> ${MPIEXEC_POSTFLAGS}
-        ${cores_test_args}
+        ${self_test_args}
+      )
+      set_tests_properties("mercury_${self_test_name}" PROPERTIES
+        FAIL_REGULAR_EXPRESSION ${HG_TEST_FAIL_REGULAR_EXPRESSION}
       )
     else()
       add_test(NAME "mercury_${cores_test_name}"
-        COMMAND $<TARGET_FILE:hg_test_${test_name}> ${cores_test_args}
+        COMMAND $<TARGET_FILE:hg_test_${test_name}> ${self_test_args}
+      )
+      set_tests_properties("mercury_${cores_test_name}" PROPERTIES
+        FAIL_REGULAR_EXPRESSION ${HG_TEST_FAIL_REGULAR_EXPRESSION}
       )
     endif()
   endif()
 
   # Scalable endpoint test
-  if(MERCURY_TESTING_HAS_THREAD_POOL AND ${comm} STREQUAL "ofi" AND
+  if(MERCURY_TESTING_USE_THREAD_POOL AND ${comm} STREQUAL "ofi" AND
     (NOT ((${protocol} STREQUAL "tcp") OR (${protocol} STREQUAL "verbs"))))
-    set(cores_test_name ${full_test_name}_scalable)
-    set(cores_test_args ${test_args} -C 2)
-    add_test(NAME "mercury_${cores_test_name}"
+    set(scalable_test_name ${full_test_name}_scalable)
+    set(scalable_test_args ${test_args} -C 2)
+    set(driver_args --server $<TARGET_FILE:hg_test_server>       ${scalable_test_args}
+                    --client $<TARGET_FILE:hg_test_${test_name}> ${scalable_test_args})
+    if(${serial})
+      set(driver_args ${driver_args} --serial)
+    endif()
+    add_test(NAME "mercury_${scalable_test_name}"
       COMMAND $<TARGET_FILE:mercury_test_driver>
-      --server $<TARGET_FILE:hg_test_server>
-      --client $<TARGET_FILE:hg_test_${test_name}> ${cores_test_args}
+      ${driver_args}
     )
   endif()
 endmacro()
 
-function(add_mercury_test test_name)
+function(add_mercury_test test_name serial)
   foreach(comm ${NA_PLUGINS})
     string(TOUPPER ${comm} upper_comm)
     foreach(protocol ${NA_${upper_comm}_TESTING_PROTOCOL})
-      add_mercury_test_comm(${test_name} ${comm} ${protocol} false)
-      add_mercury_test_comm(${test_name} ${comm} ${protocol} true)
+      add_mercury_test_comm(${test_name} ${comm} ${protocol} false ${serial})
+      add_mercury_test_comm(${test_name} ${comm} ${protocol} true ${serial})
     endforeach()
   endforeach()
 endfunction()
@@ -250,7 +286,7 @@ endif()
 #----------------------------------------------------------------------------
 
 add_library(mercury_test STATIC ${MERCURY_TEST_SRCS})
-target_link_libraries(mercury_test mercury_hl na_test
+target_link_libraries(mercury_test mercury na_test
   ${MERCURY_TEST_EXT_LIB_DEPENDENCIES}
 )
 if(MERCURY_ENABLE_COVERAGE)
@@ -264,27 +300,31 @@ endif()
 # Server used for testing
 build_mercury_test(server)
 
-set(MERCURY_tests
+# List of tests
+set(MERCURY_TESTS
   rpc
   bulk
-  overflow
 )
-if(NOT WIN32)
-  set(MERCURY_tests ${MERCURY_tests} posix)
-endif()
-#build_mercury_test(nested)
-build_mercury_test(cancel)
-build_mercury_test(perf)
-build_mercury_test(rpc_lat)
-build_mercury_test(write_bw)
-build_mercury_test(read_bw)
-#build_mercury_test(init)
-if(HG_TESTING_HAS_CRAY_DRC)
+
+# List of serial tests
+set(MERCURY_SERIAL_TESTS
+  rpc_lat
+  write_bw
+  read_bw
+)
+
+# Cray DRC test
+if(NA_OFI_TESTING_USE_CRAY_DRC)
   build_mercury_test(drc_auth)
 endif()
 
 # Build tests and add them to ctest
-foreach(MERCURY_test ${MERCURY_tests})
-  build_mercury_test(${MERCURY_test})
-  add_mercury_test(${MERCURY_test})
+foreach(test ${MERCURY_TESTS})
+  build_mercury_test(${test})
+  add_mercury_test(${test} false)
+endforeach()
+
+foreach(test ${MERCURY_SERIAL_TESTS})
+  build_mercury_test(${test})
+#  add_mercury_test(${test} true)
 endforeach()
diff --git a/Testing/driver/CMakeLists.txt b/Testing/driver/CMakeLists.txt
index fa46fd6..3055e12 100644
--- a/Testing/driver/CMakeLists.txt
+++ b/Testing/driver/CMakeLists.txt
@@ -1,4 +1,4 @@
-cmake_minimum_required(VERSION 2.8.5 FATAL_ERROR)
+cmake_minimum_required(VERSION 2.8.12.2 FATAL_ERROR)
 project(MERCURY_TEST_DRIVER CXX)
 
 set(KWSYS_NAMESPACE mercury_sys)
diff --git a/Testing/driver/mercury_test_driver.cxx b/Testing/driver/mercury_test_driver.cxx
index e6d8fb7..4b94597 100644
--- a/Testing/driver/mercury_test_driver.cxx
+++ b/Testing/driver/mercury_test_driver.cxx
@@ -1,7 +1,8 @@
-#include "mercury_test_driver.h"
+#include "mercury_test_driver.hxx"
 #include "mercury_test_config.h"
 
 #include <cstdio>
+#include <sstream>
 #include <iostream>
 #include <cstring>
 #include <cstdlib>
@@ -18,696 +19,686 @@ using std::string;
 using std::cerr;
 
 // The main function as this class should only be used by this program
-int main(int argc, char* argv[])
+int
+main(int argc, char *argv[])
 {
-  HGTestDriver d;
-  return d.Main(argc, argv);
+    HGTestDriver d;
+    return d.Main(argc, argv);
 }
+
 //----------------------------------------------------------------------------
 HGTestDriver::HGTestDriver()
 {
-  this->AllowErrorInOutput = 0;
-  this->TimeOut = 300;
-  this->ServerExitTimeOut = 60;
-  this->TestServer = 0;
+    this->ClientArgStart = 0;
+    this->ClientArgCount = 0;
+    this->ServerArgStart = 0;
+    this->ServerArgCount = 0;
+    this->AllowErrorInOutput = false;
+    // try to make sure that this times out before dart so it can kill all the processes
+    this->TimeOut = DART_TESTING_TIMEOUT - 10.0;
+    this->ServerExitTimeOut = 2; /* 2 seconds timeout for server to exit */
+    this->TestServer = false;
+    this->TestSerial = false;
 }
+
 //----------------------------------------------------------------------------
 HGTestDriver::~HGTestDriver()
 {
 }
+
 //----------------------------------------------------------------------------
-void HGTestDriver::SeparateArguments(const char* str,
-                                     vector<string>& flags)
+void
+HGTestDriver::SeparateArguments(const char *str, vector<string> &flags)
 {
-  string arg = str;
-  string::size_type pos1 = 0;
-  string::size_type pos2 = arg.find_first_of(" ;");
-  if(pos2 == arg.npos)
-    {
-    flags.push_back(str);
-    return;
-    }
-  while(pos2 != arg.npos)
-    {
-    flags.push_back(arg.substr(pos1, pos2-pos1));
-    pos1 = pos2+1;
-    pos2 = arg.find_first_of(" ;", pos1+1);
-    }
-  flags.push_back(arg.substr(pos1, pos2-pos1));
+    string arg = str;
+    string::size_type pos1 = 0;
+    string::size_type pos2 = arg.find_first_of(" ;");
+    if (pos2 == arg.npos) {
+        flags.push_back(str);
+        return;
+    }
+    while (pos2 != arg.npos) {
+        flags.push_back(arg.substr(pos1, pos2 - pos1));
+        pos1 = pos2 + 1;
+        pos2 = arg.find_first_of(" ;", pos1 + 1);
+    }
+    flags.push_back(arg.substr(pos1, pos2 - pos1));
 }
+
 //----------------------------------------------------------------------------
-void HGTestDriver::CollectConfiguredOptions()
+void
+HGTestDriver::CollectConfiguredOptions()
 {
-  // try to make sure that this timesout before dart so it can kill all the processes
-  this->TimeOut = DART_TESTING_TIMEOUT - 10.0;
-  if(this->TimeOut < 0)
-    {
-    this->TimeOut = 1500;
-    }
+    if (this->TimeOut < 0)
+        this->TimeOut = 1500;
+
+#ifdef HG_TEST_ENV_VARS
+    this->SeparateArguments(HG_TEST_ENV_VARS, this->ClientEnvVars);
+#endif
 
-  // now find all the mpi information if mpi run is set
+    // now find all the mpi information if mpi run is set
 #ifdef MPIEXEC_EXECUTABLE
-  this->MPIRun = MPIEXEC_EXECUTABLE;
+    this->MPIRun = MPIEXEC_EXECUTABLE;
 #else
-  return;
+    return;
 #endif
-  int maxNumProc = 1;
+    int maxNumProc = 1;
 
 # ifdef MPIEXEC_MAX_NUMPROCS
-  maxNumProc = MPIEXEC_MAX_NUMPROCS;
+    if (!this->TestSerial)
+        maxNumProc = MPIEXEC_MAX_NUMPROCS;
 # endif
 # ifdef MPIEXEC_NUMPROC_FLAG
-  this->MPINumProcessFlag = MPIEXEC_NUMPROC_FLAG;
+    this->MPINumProcessFlag = MPIEXEC_NUMPROC_FLAG;
 # endif
 # ifdef MPIEXEC_PREFLAGS
-  this->SeparateArguments(MPIEXEC_PREFLAGS, this->MPIPreFlags);
+    this->SeparateArguments(MPIEXEC_PREFLAGS, this->MPIClientPreFlags);
 # endif
 # ifdef MPIEXEC_POSTFLAGS
-  this->SeparateArguments(MPIEXEC_POSTFLAGS, this->MPIPostFlags);
+    this->SeparateArguments(MPIEXEC_POSTFLAGS, this->MPIClientPostFlags);
+# endif
+# ifdef MPIEXEC_SERVER_PREFLAGS
+    this->SeparateArguments(MPIEXEC_SERVER_PREFLAGS, this->MPIServerPreFlags);
+#else
+    this->MPIServerPreFlags = this->MPIClientPreFlags;
 # endif
-  char buf[32];
-  sprintf(buf, "%d", maxNumProc);
-  this->MPIServerNumProcessFlag = "1";
-  this->MPIClientNumProcessFlag = buf;
+# ifdef MPIEXEC_SERVER_POSTFLAGS
+    this->SeparateArguments(MPIEXEC_SERVER_POSTFLAGS, this->MPIServerPostFlags);
+#else
+    this->MPIServerPostFlags = this->MPIClientPostFlags;
+# endif
+    std::stringstream ss;
+    ss << maxNumProc;
+    this->MPIServerNumProcessFlag = "1";
+    this->MPIClientNumProcessFlag = ss.str();
 }
+
 //----------------------------------------------------------------------------
 /// This adds the debug/build configuration crap for the executable on windows.
-static string FixExecutablePath(const string& path)
+static string
+FixExecutablePath(const string &path)
 {
 #ifdef  CMAKE_INTDIR
-  string parent_dir =
+    string parent_dir =
     mercury_sys::SystemTools::GetFilenamePath(path.c_str());
 
-  string filename =
+    string filename =
     mercury_sys::SystemTools::GetFilenameName(path);
 
-  if (!mercury_sys::SystemTools::StringEndsWith(parent_dir.c_str(), CMAKE_INTDIR)) {
-    parent_dir += "/" CMAKE_INTDIR;
-  }
-  return parent_dir + "/" + filename;
+    if (!mercury_sys::SystemTools::StringEndsWith(parent_dir.c_str(), CMAKE_INTDIR)) {
+        parent_dir += "/" CMAKE_INTDIR;
+    }
+    return parent_dir + "/" + filename;
 #endif
 
-  return path;
+    return path;
 }
+
 //----------------------------------------------------------------------------
-int HGTestDriver::ProcessCommandLine(int argc, char* argv[])
+int
+HGTestDriver::ProcessCommandLine(int argc, char *argv[])
 {
-  this->ArgStart = 1;
-  int i;
-  for(i =1; i < argc - 1; ++i)
-    {
-    if(strcmp(argv[i], "--client") == 0)
-      {
-      this->ArgStart = i+2;
-      this->ClientExecutable = ::FixExecutablePath(argv[i+1]);
-      }
-    if(strcmp(argv[i], "--server") == 0)
-      {
-      this->ArgStart = i+2;
-      this->TestServer = 1;
-      this->ServerExecutable = ::FixExecutablePath(argv[i+1]);
-      fprintf(stderr, "Test Server.\n");
-      }
-    if(strcmp(argv[i], "--timeout") == 0)
-      {
-      this->ArgStart = i+2;
-      this->TimeOut = atoi(argv[i+1]);
-      fprintf(stderr, "The timeout was set to %f.\n", this->TimeOut);
-      }
-    if (strncmp(argv[i], "--allow-errors", strlen("--allow-errors"))==0)
-      {
-      this->ArgStart =i+1;
-      this->AllowErrorInOutput = 1;
-      fprintf(stderr, "The allow erros in output flag was set to %d.\n", 
-        this->AllowErrorInOutput);
-      }
+    int *ArgCountP = NULL;
+    int i;
+    for (i = 1; i < argc; ++i) {
+        if (strcmp(argv[i], "--client") == 0) {
+            this->ClientExecutable = ::FixExecutablePath(argv[i + 1]);
+            ++i; /* Skip executable */
+            this->ClientArgStart = i + 1;
+            this->ClientArgCount = this->ClientArgStart;
+            ArgCountP = &this->ClientArgCount;
+            continue;
+        }
+        if (strcmp(argv[i], "--server") == 0) {
+            std::cerr << "Test Server" << std::endl;
+            this->TestServer = true;
+            this->ServerExecutable = ::FixExecutablePath(argv[i + 1]);
+            ++i; /* Skip executable */
+            this->ServerArgStart = i + 1;
+            this->ServerArgCount = this->ServerArgStart;
+            ArgCountP = &this->ServerArgCount;
+            continue;
+        }
+        if (strcmp(argv[i], "--timeout") == 0) {
+            this->TimeOut = atoi(argv[i + 1]);
+            std::cerr << "The timeout was set to " << this->TimeOut << std::endl;
+            ArgCountP = NULL;
+            continue;
+        }
+        if (strncmp(argv[i], "--allow-errors", strlen("--allow-errors")) == 0) {
+            this->AllowErrorInOutput = true;
+            std::cerr << "The allow errors in output flag was set to " <<
+                this->AllowErrorInOutput << std::endl;
+            ArgCountP = NULL;
+            continue;
+        }
+        if (strcmp(argv[i], "--serial") == 0) {
+            this->TestSerial = true;
+            std::cerr << "This is a serial test" << std::endl;
+            ArgCountP = NULL;
+            continue;
+        }
+        if (ArgCountP)
+            (*ArgCountP)++;
     }
 
-  return 1;
+    return 1;
 }
+
 //----------------------------------------------------------------------------
 void
-HGTestDriver::CreateCommandLine(vector<const char*>& commandLine,
-                                const char* cmd,
-                                const char* numProc,
-                                int argStart,
-                                int argCount,
-                                char* argv[])
+HGTestDriver::CreateCommandLine(vector<const char*> &commandLine,
+    const char *cmd, int isServer, int isHelper, const char *numProc, int argStart,
+    int argCount, char *argv[])
 {
-  if(this->MPIRun.size())
-    {
-    commandLine.push_back(this->MPIRun.c_str());
-    commandLine.push_back(this->MPINumProcessFlag.c_str());
-    commandLine.push_back(numProc);
-
-    for(unsigned int i = 0; i < this->MPIPreFlags.size(); ++i)
-      {
-      commandLine.push_back(this->MPIPreFlags[i].c_str());
-      }
+    if (!isServer && this->ClientEnvVars.size()) {
+        for (unsigned int i = 0; i < this->ClientEnvVars.size(); ++i)
+            commandLine.push_back(this->ClientEnvVars[i].c_str());
     }
 
-  commandLine.push_back(cmd);
+    if (!isHelper && this->MPIRun.size()) {
+        commandLine.push_back(this->MPIRun.c_str());
+        commandLine.push_back(this->MPINumProcessFlag.c_str());
+        commandLine.push_back(numProc);
 
-  for(unsigned int i = 0; i < this->MPIPostFlags.size(); ++i)
-    {
-    commandLine.push_back(MPIPostFlags[i].c_str());
+        if (isServer)
+            for (unsigned int i = 0; i < this->MPIServerPreFlags.size(); ++i)
+                commandLine.push_back(this->MPIServerPreFlags[i].c_str());
+        else
+            for (unsigned int i = 0; i < this->MPIClientPreFlags.size(); ++i)
+                commandLine.push_back(this->MPIClientPreFlags[i].c_str());
     }
 
-  // remaining flags for the test
-  for(int ii = argStart; ii < argCount; ++ii)
-    {
-    commandLine.push_back(argv[ii]);
+    commandLine.push_back(cmd);
+
+    if (isServer)
+        for (unsigned int i = 0; i < this->MPIServerPostFlags.size(); ++i)
+            commandLine.push_back(MPIServerPostFlags[i].c_str());
+    else
+        for (unsigned int i = 0; i < this->MPIClientPostFlags.size(); ++i)
+            commandLine.push_back(MPIClientPostFlags[i].c_str());
+
+    // remaining flags for the test
+//    cerr << "Arg start is " << argStart << "\n";
+//    cerr << "Arg count is " << argCount << "\n";
+    for (int ii = argStart; ii < argCount; ++ii) {
+        commandLine.push_back(argv[ii]);
     }
 
-  commandLine.push_back(0);
+    commandLine.push_back(0);
 }
+
 //----------------------------------------------------------------------------
-int HGTestDriver::StartServer(mercury_sysProcess* server, const char* name,
-                              vector<char>& out,
-                              vector<char>& err)
+int
+HGTestDriver::StartServer(mercury_sysProcess *server, const char *name,
+    vector<char> &out, vector<char> &err)
 {
-  if(!server)
-    {
-    return 1;
-    }
-  cerr << "HGTestDriver: starting process " << name << "\n";
-  mercury_sysProcess_SetTimeout(server, this->TimeOut);
-  mercury_sysProcess_Execute(server);
-  int foundWaiting = 0;
-  string output;
-  while(!foundWaiting)
-    {
-    int pipe = this->WaitForAndPrintLine(name, server, output, 100.0, out, err,
-                                         &foundWaiting);
-    if(pipe == mercury_sysProcess_Pipe_None ||
-       pipe == mercury_sysProcess_Pipe_Timeout)
-      {
-      break;
-      }
+    if (!server)
+        return 1;
+
+    cerr << "HGTestDriver: starting process " << name << "\n";
+    mercury_sysProcess_SetTimeout(server, this->TimeOut);
+    mercury_sysProcess_Execute(server);
+    int foundWaiting = 0;
+    string output;
+    while (!foundWaiting) {
+        int pipe = this->WaitForAndPrintLine(name, server, output, 100.0, out,
+            err, &foundWaiting);
+        if (pipe == mercury_sysProcess_Pipe_None
+            || pipe == mercury_sysProcess_Pipe_Timeout) {
+            break;
+        }
     }
-  if(foundWaiting)
-    {
-    cerr << "HGTestDriver: " << name << " sucessfully started.\n";
-    return 1;
-    }
-  else
-    {
-    cerr << "HGTestDriver: " << name << " never started.\n";
-    mercury_sysProcess_Kill(server);
-    return 0;
+    if (foundWaiting) {
+        cerr << "HGTestDriver: " << name << " sucessfully started.\n";
+        return 1;
+    } else {
+        cerr << "HGTestDriver: " << name << " never started.\n";
+        mercury_sysProcess_Kill(server);
+        return 0;
     }
 }
+
 //----------------------------------------------------------------------------
-int HGTestDriver::StartClient(mercury_sysProcess* client, const char* name)
+int
+HGTestDriver::StartClient(mercury_sysProcess *client, const char *name)
 {
-  if(!client)
-    {
-    return 1;
-    }
-  cerr << "HGTestDriver: starting process " << name << "\n";
-  mercury_sysProcess_SetTimeout(client, this->TimeOut);
-  mercury_sysProcess_Execute(client);
-  if(mercury_sysProcess_GetState(client) == mercury_sysProcess_State_Executing)
-    {
-    cerr << "HGTestDriver: " << name << " sucessfully started.\n";
-    return 1;
-    }
-  else
-    {
-    this->ReportStatus(client, name);
-    mercury_sysProcess_Kill(client);
-    return 0;
+    if (!client)
+        return 1;
+
+    cerr << "HGTestDriver: starting process " << name << "\n";
+    mercury_sysProcess_SetTimeout(client, this->TimeOut);
+    mercury_sysProcess_Execute(client);
+    if (mercury_sysProcess_GetState(client)
+        == mercury_sysProcess_State_Executing) {
+        cerr << "HGTestDriver: " << name << " sucessfully started.\n";
+        return 1;
+    } else {
+        this->ReportStatus(client, name);
+        mercury_sysProcess_Kill(client);
+        return 0;
     }
 }
+
 //----------------------------------------------------------------------------
-void HGTestDriver::Stop(mercury_sysProcess* p, const char* name)
+void
+HGTestDriver::Stop(mercury_sysProcess *p, const char *name)
 {
-  if(p)
-    {
-    cerr << "HGTestDriver: killing process " << name << "\n";
-    mercury_sysProcess_Kill(p);
-    mercury_sysProcess_WaitForExit(p, 0);
+    if (p) {
+        cerr << "HGTestDriver: killing process " << name << "\n";
+        mercury_sysProcess_Kill(p);
+        mercury_sysProcess_WaitForExit(p, 0);
     }
 }
+
 //----------------------------------------------------------------------------
-int HGTestDriver::OutputStringHasError(const char* pname, string& output)
+int
+HGTestDriver::OutputStringHasError(const char *pname, string &output)
 {
-  const char* possibleMPIErrors[] = {
-    "error",
-    "Error",
-    "Missing:",
-    "core dumped",
-    "process in local group is dead",
-    "Segmentation fault",
-    "erroneous",
-    "ERROR:",
-    "Error:",
-    "mpirun can *only* be used with MPI programs",
-    "due to signal",
-    "failure",
-    "abnormal termination",
-    "failed",
-    "FAILED",
-    "Failed",
-    0
-  };
-
-  const char* nonErrors[] = {
-    "Memcheck, a memory error detector",  //valgrind
-    "error in locking authority file",  //Ice-T
-    "WARNING: Far depth failed sanity check, resetting.", //Ice-T
-    // these are all caused (we think) by the dodgy SMPD shutdown bug in mpich2 on windows mpich2 1.4.1p1
-    "Error posting writev,",     
-    "sock error: Error = 10058", 
-    "state machine failed.", 
-    0
-  };
-
-  if(this->AllowErrorInOutput)
-    {
-    return 0;
-    }
-
-  vector<string> lines;
-  vector<string>::iterator it;
-  mercury_sys::SystemTools::Split(output.c_str(), lines);
-
-  int i, j;
-
-  for ( it = lines.begin(); it != lines.end(); ++ it )
-    {
-    for(i = 0; possibleMPIErrors[i]; ++i)
-      {
-      if(it->find(possibleMPIErrors[i]) != it->npos)
-        {
-        int found = 1;
-        for (j = 0; nonErrors[j]; ++ j)
-          {
-          if ( it->find(nonErrors[j]) != it->npos )
-            {
-            found = 0;
-            cerr << "Non error \"" << it->c_str() << "\" suppressed " << std::endl;
-            }      
-          }
-        if ( found )
-          {
-          cerr << "HGTestDriver: ***** Test will fail, because the string: \""
-            << possibleMPIErrors[i]
-            << "\"\nHGTestDriver: ***** was found in the following output from the "
-            << pname << ":\n\""
-            << it->c_str() << "\"\n";
-          return 1;
-          }
+    const char* possibleMPIErrors[] = {"error", "Error", "Missing:",
+        "core dumped", "process in local group is dead", "Segmentation fault",
+        "erroneous", "ERROR:", "Error:",
+        "mpirun can *only* be used with MPI programs", "due to signal",
+        "failure", "abnormal termination", "failed", "FAILED", "Failed", 0};
+
+    const char* nonErrors[] = {
+        "Memcheck, a memory error detector",  //valgrind
+        0};
+
+    if (this->AllowErrorInOutput)
+        return 0;
+
+    vector<string> lines;
+    vector<string>::iterator it;
+    mercury_sys::SystemTools::Split(output.c_str(), lines);
+
+    int i, j;
+
+    for (it = lines.begin(); it != lines.end(); ++it) {
+        for (i = 0; possibleMPIErrors[i]; ++i) {
+            if (it->find(possibleMPIErrors[i]) != it->npos) {
+                int found = 1;
+                for (j = 0; nonErrors[j]; ++j) {
+                    if (it->find(nonErrors[j]) != it->npos) {
+                        found = 0;
+                        cerr << "Non error \"" << it->c_str()
+                            << "\" suppressed " << std::endl;
+                    }
+                }
+                if (found) {
+                    cerr
+                        << "HGTestDriver: ***** Test will fail, because the string: \""
+                        << possibleMPIErrors[i]
+                        << "\"\nHGTestDriver: ***** was found in the following output from the "
+                        << pname << ":\n\"" << it->c_str() << "\"\n";
+                    return 1;
+                }
+            }
         }
-      }
     }
-  return 0;
+    return 0;
 }
+
 //----------------------------------------------------------------------------
-#define HG_CLEAN_PROCESSES \
-  mercury_sysProcess_Delete(client); \
-  mercury_sysProcess_Delete(server);
+#define HG_CLEAN_PROCESSES do {         \
+  mercury_sysProcess_Delete(client);    \
+  mercury_sysProcess_Delete(server);    \
+} while (0)
+
 //----------------------------------------------------------------------------
-int HGTestDriver::Main(int argc, char* argv[])
+int
+HGTestDriver::Main(int argc, char* argv[])
 {
-#ifdef MERCURY_TEST_INIT_COMMAND
-  // run user-specified commands before initialization.
-  // For example: "killall -9 rsh test;"
-  if(strlen(MERCURY_TEST_INIT_COMMAND) > 0)
-    {
-    std::vector<mercury_sys::String> commands = mercury_sys::SystemTools::SplitString(
-      MERCURY_TEST_INIT_COMMAND, ';');
-    for (unsigned int cc=0; cc < commands.size(); cc++)
-      {
-      std::string command = commands[cc];
-      if (command.size() > 0)
-        {
-        system(command.c_str());
+#ifdef HG_TEST_INIT_COMMAND
+    // run user-specified commands before initialization.
+    // For example: "killall -9 rsh test;"
+    if (strlen(HG_TEST_INIT_COMMAND) > 0) {
+//        std::vector<std::string> commands =
+        std::vector<mercury_sys::String> commands =
+            mercury_sys::SystemTools::SplitString(HG_TEST_INIT_COMMAND, ';');
+        for (unsigned int cc = 0; cc < commands.size(); cc++) {
+            std::string command = commands[cc];
+            if (command.size() > 0)
+                system(command.c_str());
         }
-      }
     }
 #endif
 
-  this->CollectConfiguredOptions();
-  if(!this->ProcessCommandLine(argc, argv))
-    {
-    return 1;
+    if (!this->ProcessCommandLine(argc, argv))
+        return 1;
+    this->CollectConfiguredOptions();
+
+    // mpi code
+    // Allocate process managers.
+    mercury_sysProcess *server = 0;
+    mercury_sysProcess *client = 0;
+    if (this->TestServer) {
+        server = mercury_sysProcess_New();
+        if (!server) {
+            HG_CLEAN_PROCESSES;
+            cerr << "HGTestDriver: Cannot allocate mercury_sysProcess to "
+                "run the server.\n";
+            return 1;
+        }
     }
 
-  // mpi code
-  // Allocate process managers.
-  mercury_sysProcess* server = 0;
-  mercury_sysProcess* client = 0;
-  if(this->TestServer)
-    {
-    server = mercury_sysProcess_New();
-    if(!server)
-      {
-      HG_CLEAN_PROCESSES;
-      cerr << "HGTestDriver: Cannot allocate mercury_sysProcess to run the server.\n";
-      return 1;
-      }
+    client = mercury_sysProcess_New();
+    if (!client) {
+        HG_CLEAN_PROCESSES;
+        cerr << "HGTestDriver: Cannot allocate mercury_sysProcess to "
+            "run the client.\n";
+        return 1;
+    }
+
+    vector<char> ClientStdOut;
+    vector<char> ClientStdErr;
+    vector<char> ServerStdOut;
+    vector<char> ServerStdErr;
+
+    vector<const char *> serverCommand;
+    if (server) {
+        const char* serverExe = this->ServerExecutable.c_str();
+
+        this->CreateCommandLine(serverCommand, serverExe, 1, 0,
+            this->MPIServerNumProcessFlag.c_str(), this->ServerArgStart,
+            this->ServerArgCount, argv);
+        this->ReportCommand(&serverCommand[0], "server");
+        mercury_sysProcess_SetCommand(server, &serverCommand[0]);
+        mercury_sysProcess_SetWorkingDirectory(server,
+            this->GetDirectory(serverExe).c_str());
+    }
+
+    // Construct the client process command line.
+    vector<const char *> clientCommand;
+    const char *clientExe = this->ClientExecutable.c_str();
+    this->CreateCommandLine(clientCommand, clientExe, 0, 0,
+        this->MPIClientNumProcessFlag.c_str(), this->ClientArgStart,
+        this->ClientArgCount, argv);
+    this->ReportCommand(&clientCommand[0], "client");
+    mercury_sysProcess_SetCommand(client, &clientCommand[0]);
+    mercury_sysProcess_SetWorkingDirectory(client,
+        this->GetDirectory(clientExe).c_str());
+
+    // Start the server if there is one
+    if (!this->StartServer(server, "server", ServerStdOut, ServerStdErr)) {
+        cerr << "HGTestDriver: Server never started.\n";
+        HG_CLEAN_PROCESSES;
+        return -1;
+    }
+
+    // Now run the client
+    if (!this->StartClient(client, "client")) {
+        this->Stop(server, "server");
+        HG_CLEAN_PROCESSES;
+        return -1;
+    }
+
+    // Report the output of the processes.
+    int clientPipe = 1;
+
+    string output;
+    int mpiError = 0;
+    while (clientPipe) {
+        clientPipe = this->WaitForAndPrintLine("client", client, output, 0.1,
+            ClientStdOut, ClientStdErr, 0);
+        if (!mpiError && this->OutputStringHasError("client", output)) {
+            mpiError = 1;
+        }
+        // If client has died, we wait for output from the server processess
+        // for this->ServerExitTimeOut, then we'll kill the servers, if needed.
+        double timeout = (clientPipe) ? 0 : this->ServerExitTimeOut;
+        output = "";
+        this->WaitForAndPrintLine("server", server, output, timeout,
+            ServerStdOut, ServerStdErr, 0);
+        if (!mpiError && this->OutputStringHasError("server", output)) {
+            mpiError = 1;
+        }
+        output = "";
+    }
+
+    // Wait for the client and server to exit.
+    mercury_sysProcess_WaitForExit(client, 0);
+
+    // Once client is finished, the servers
+    // must finish quickly. If not, it usually is a sign that
+    // the client crashed/exited before it attempted to connect to
+    // the server.
+    if (server) {
+#ifdef HG_TEST_SERVER_EXIT_COMMAND
+    // run user-specified commands before initialization.
+    // For example: "killall -9 rsh test;"
+    if (strlen(HG_TEST_SERVER_EXIT_COMMAND) > 0) {
+//        std::vector<std::string> commands =
+        std::vector<mercury_sys::String> commands =
+            mercury_sys::SystemTools::SplitString(HG_TEST_SERVER_EXIT_COMMAND,
+                ';');
+        for (unsigned int cc = 0; cc < commands.size(); cc++) {
+            std::string command = commands[cc];
+            if (command.size() > 0) {
+                std::cout << command.c_str() << std::endl;
+                system(command.c_str());
+            }
+        }
     }
-  client = mercury_sysProcess_New();
-  if(!client)
-    {
-    HG_CLEAN_PROCESSES;
-    cerr << "HGTestDriver: Cannot allocate mercury_sysProcess to run the client.\n";
-    return 1;
+#endif
+        mercury_sysProcess_WaitForExit(server, &this->ServerExitTimeOut);
     }
 
-  vector<char> ClientStdOut;
-  vector<char> ClientStdErr;
-  vector<char> ServerStdOut;
-  vector<char> ServerStdErr;
-
-  vector<const char*> serverCommand;
-  if(server)
-    {
-    const char* serverExe = this->ServerExecutable.c_str();
-
-    this->CreateCommandLine(serverCommand,
-                            serverExe,
-                            this->MPIServerNumProcessFlag.c_str(),
-                            this->ArgStart, argc, argv);
-    this->ReportCommand(&serverCommand[0], "server");
-    mercury_sysProcess_SetCommand(server, &serverCommand[0]);
-    mercury_sysProcess_SetWorkingDirectory(server, this->GetDirectory(serverExe).c_str());
+    // Get the results.
+    int clientResult = this->ReportStatus(client, "client");
+    int serverResult = 0;
+    if (server) {
+        serverResult = this->ReportStatus(server, "server");
+        mercury_sysProcess_Kill(server);
     }
 
-  // Construct the client process command line.
-  vector<const char*> clientCommand;
-  
-  const char* clientExe = this->ClientExecutable.c_str();
-  this->CreateCommandLine(clientCommand,
-                          clientExe,
-                          this->MPIClientNumProcessFlag.c_str(),
-                          this->ArgStart, argc, argv);
-  this->ReportCommand(&clientCommand[0], "client");
-  mercury_sysProcess_SetCommand(client, &clientCommand[0]);
-  mercury_sysProcess_SetWorkingDirectory(client, this->GetDirectory(clientExe).c_str());
-
-  // Start the server if there is one
-  if(!this->StartServer(server, "server",
-      ServerStdOut, ServerStdErr))
-    {
-    cerr << "HGTestDriver: Server never started.\n";
-    HG_CLEAN_PROCESSES;
-    return -1;
-    }
-  // Now run the client
-  if(!this->StartClient(client, "client"))
-    {
-    this->Stop(server, "server");
+    // Free process managers.
     HG_CLEAN_PROCESSES;
-    return -1;
-    }
-
-  // Report the output of the processes.
-  int clientPipe = 1;
-
-  string output;
-  int mpiError = 0;
-  while(clientPipe)
-    {
-    clientPipe = this->WaitForAndPrintLine("client", client, output, 0.1,
-                                           ClientStdOut, ClientStdErr, 0);
-    if(!mpiError && this->OutputStringHasError("client", output))
-      {
-      mpiError = 1;
-      }
-    // If client has died, we wait for output from the server processess
-    // for this->ServerExitTimeOut, then we'll kill the servers, if needed.
-    double timeout = (clientPipe)? 0.1 : this->ServerExitTimeOut;
-    output = "";
-    this->WaitForAndPrintLine("server", server, output, timeout,
-                              ServerStdOut, ServerStdErr, 0);
-    if(!mpiError && this->OutputStringHasError("server", output))
-      {
-      mpiError = 1;
-      }
-    output = "";
-    }
-
-  // Wait for the client and server to exit.
-  mercury_sysProcess_WaitForExit(client, 0);
-
-  // Once client is finished, the servers
-  // must finish quickly. If not, is usually is a sign that
-  // the client crashed/exited before it attempted to connect to 
-  // the server.
-  if(server)
-    {
-    mercury_sysProcess_WaitForExit(server, &this->ServerExitTimeOut);
-    }
-
-  // Get the results.
-  int clientResult = this->ReportStatus(client, "client");
-  int serverResult = 0;
-  if(server)
-    {
-    serverResult = this->ReportStatus(server, "server");
-    mercury_sysProcess_Kill(server);
-    }
 
-  // Free process managers.
-  HG_CLEAN_PROCESSES;
+    // Report the server return code if it is nonzero.  Otherwise report
+    // the client return code.
+    if (serverResult)
+        return serverResult;
 
-  // Report the server return code if it is nonzero.  Otherwise report
-  // the client return code.
-  if(serverResult)
-    {
-    return serverResult;
+    if (mpiError) {
+        cerr
+            << "HGTestDriver: Error string found in ouput, HGTestDriver returning "
+            << mpiError << "\n";
+        return mpiError;
     }
 
-  if(mpiError)
-    {
-    cerr << "HGTestDriver: Error string found in ouput, HGTestDriver returning "
-         << mpiError << "\n";
-    return mpiError;
-    }
-  // if server is fine return the client result
-  return clientResult;
+    // if server is fine return the client result
+    return clientResult;
 }
 
 //----------------------------------------------------------------------------
-void HGTestDriver::ReportCommand(const char* const* command, const char* name)
+void
+HGTestDriver::ReportCommand(const char * const *command, const char *name)
 {
-  cerr << "HGTestDriver: " << name << " command is:\n";
-  for(const char* const * c = command; *c; ++c)
-    {
-    cerr << " \"" << *c << "\"";
-    }
-  cerr << "\n";
+    cerr << "HGTestDriver: " << name << " command is:\n";
+    for (const char * const *c = command; *c; ++c)
+        cerr << " \"" << *c << "\"";
+    cerr << "\n";
 }
 
 //----------------------------------------------------------------------------
-int HGTestDriver::ReportStatus(mercury_sysProcess* process, const char* name)
-{
-  int result = 1;
-  switch(mercury_sysProcess_GetState(process))
-    {
-    case mercury_sysProcess_State_Starting:
-      {
-      cerr << "HGTestDriver: Never started " << name << " process.\n";
-      } break;
-    case mercury_sysProcess_State_Error:
-      {
-      cerr << "HGTestDriver: Error executing " << name << " process: "
-           << mercury_sysProcess_GetErrorString(process)
-           << "\n";
-      } break;
-    case mercury_sysProcess_State_Exception:
-      {
-      cerr << "HGTestDriver: " << name
-                      << " process exited with an exception: ";
-      switch(mercury_sysProcess_GetExitException(process))
-        {
-        case mercury_sysProcess_Exception_None:
-          {
-          cerr << "None";
-          } break;
-        case mercury_sysProcess_Exception_Fault:
-          {
-          cerr << "Segmentation fault";
-          } break;
-        case mercury_sysProcess_Exception_Illegal:
-          {
-          cerr << "Illegal instruction";
-          } break;
-        case mercury_sysProcess_Exception_Interrupt:
-          {
-          cerr << "Interrupted by user";
-          } break;
-        case mercury_sysProcess_Exception_Numerical:
-          {
-          cerr << "Numerical exception";
-          } break;
-        case mercury_sysProcess_Exception_Other:
-          {
-          cerr << "Unknown";
-          } break;
-        }
-      cerr << "\n";
-      } break;
-    case mercury_sysProcess_State_Executing:
-      {
-      cerr << "HGTestDriver: Never terminated " << name << " process.\n";
-      } break;
-    case mercury_sysProcess_State_Exited:
-      {
-      result = mercury_sysProcess_GetExitValue(process);
-      cerr << "HGTestDriver: " << name << " process exited with code "
-                      << result << "\n";
-      } break;
-    case mercury_sysProcess_State_Expired:
-      {
-      cerr << "HGTestDriver: killed " << name << " process due to timeout.\n";
-      } break;
-    case mercury_sysProcess_State_Killed:
-      {
-      cerr << "HGTestDriver: killed " << name << " process.\n";
-      } break;
-    }
-  return result;
-}
-//----------------------------------------------------------------------------
-
-int HGTestDriver::WaitForLine(mercury_sysProcess* process, string& line,
-                              double timeout,
-                              vector<char>& out,
-                              vector<char>& err)
+int
+HGTestDriver::ReportStatus(mercury_sysProcess *process, const char *name)
 {
-  line = "";
-  vector<char>::iterator outiter = out.begin();
-  vector<char>::iterator erriter = err.begin();
-  while(1)
-    {
-    // Check for a newline in stdout.
-    for(;outiter != out.end(); ++outiter)
-      {
-      if((*outiter == '\r') && ((outiter+1) == out.end()))
-        {
-        break;
+    int result = 1;
+    switch (mercury_sysProcess_GetState(process)) {
+        case mercury_sysProcess_State_Starting: {
+            cerr << "HGTestDriver: Never started " << name << " process.\n";
         }
-      else if(*outiter == '\n' || *outiter == '\0')
-        {
-        int length = outiter-out.begin();
-        if(length > 1 && *(outiter-1) == '\r')
-          {
-          --length;
-          }
-        if(length > 0)
-          {
-          line.append(&out[0], length);
-          }
-        out.erase(out.begin(), outiter+1);
-        return mercury_sysProcess_Pipe_STDOUT;
+            break;
+        case mercury_sysProcess_State_Error: {
+            cerr << "HGTestDriver: Error executing " << name << " process: "
+                << mercury_sysProcess_GetErrorString(process) << "\n";
         }
-      }
-
-    // Check for a newline in stderr.
-    for(;erriter != err.end(); ++erriter)
-      {
-      if((*erriter == '\r') && ((erriter+1) == err.end()))
-        {
-        break;
+            break;
+        case mercury_sysProcess_State_Exception: {
+            cerr << "HGTestDriver: " << name
+                << " process exited with an exception: ";
+            switch (mercury_sysProcess_GetExitException(process)) {
+                case mercury_sysProcess_Exception_None: {
+                    cerr << "None";
+                }
+                    break;
+                case mercury_sysProcess_Exception_Fault: {
+                    cerr << "Segmentation fault";
+                }
+                    break;
+                case mercury_sysProcess_Exception_Illegal: {
+                    cerr << "Illegal instruction";
+                }
+                    break;
+                case mercury_sysProcess_Exception_Interrupt: {
+                    cerr << "Interrupted by user";
+                }
+                    break;
+                case mercury_sysProcess_Exception_Numerical: {
+                    cerr << "Numerical exception";
+                }
+                    break;
+                case mercury_sysProcess_Exception_Other: {
+                    cerr << "Unknown";
+                }
+                    break;
+            }
+            cerr << "\n";
         }
-      else if(*erriter == '\n' || *erriter == '\0')
-        {
-        int length = erriter-err.begin();
-        if(length > 1 && *(erriter-1) == '\r')
-          {
-          --length;
-          }
-        if(length > 0)
-          {
-          line.append(&err[0], length);
-          }
-        err.erase(err.begin(), erriter+1);
-        return mercury_sysProcess_Pipe_STDERR;
+            break;
+        case mercury_sysProcess_State_Executing: {
+            cerr << "HGTestDriver: Never terminated " << name
+                << " process.\n";
         }
-      }
-
-    // No newlines found.  Wait for more data from the process.
-    int length;
-    char* data;
-    int pipe = mercury_sysProcess_WaitForData(process, &data, &length, &timeout);
-    if(pipe == mercury_sysProcess_Pipe_Timeout)
-      {
-      // Timeout has been exceeded.
-      return pipe;
-      }
-    else if(pipe == mercury_sysProcess_Pipe_STDOUT)
-      {
-      // Append to the stdout buffer.
-      vector<char>::size_type size = out.size();
-      out.insert(out.end(), data, data+length);
-      outiter = out.begin()+size;
-      }
-    else if(pipe == mercury_sysProcess_Pipe_STDERR)
-      {
-      // Append to the stderr buffer.
-      vector<char>::size_type size = err.size();
-      err.insert(err.end(), data, data+length);
-      erriter = err.begin()+size;
-      }
-    else if(pipe == mercury_sysProcess_Pipe_None)
-      {
-      // Both stdout and stderr pipes have broken.  Return leftover data.
-      if(!out.empty())
-        {
-        line.append(&out[0], outiter-out.begin());
-        out.erase(out.begin(), out.end());
-        return mercury_sysProcess_Pipe_STDOUT;
+            break;
+        case mercury_sysProcess_State_Exited: {
+            result = mercury_sysProcess_GetExitValue(process);
+            cerr << "HGTestDriver: " << name << " process exited with code "
+                << result << "\n";
         }
-      else if(!err.empty())
-        {
-        line.append(&err[0], erriter-err.begin());
-        err.erase(err.begin(), err.end());
-        return mercury_sysProcess_Pipe_STDERR;
+            break;
+        case mercury_sysProcess_State_Expired: {
+            cerr << "HGTestDriver: killed " << name
+                << " process due to timeout.\n";
         }
-      else
-        {
-        return mercury_sysProcess_Pipe_None;
+            break;
+        case mercury_sysProcess_State_Killed: {
+            cerr << "HGTestDriver: killed " << name << " process.\n";
         }
-      }
+            break;
     }
+    return result;
 }
+
 //----------------------------------------------------------------------------
-void HGTestDriver::PrintLine(const char* pname, const char* line)
+int
+HGTestDriver::WaitForLine(mercury_sysProcess *process, string &line,
+    double timeout, vector<char> &out, vector<char> &err)
 {
-  // if the name changed then the line is output from a different process
-  if(this->CurrentPrintLineName != pname)
-    {
-    cerr << "-------------- " << pname
-         << " output --------------\n";
-    // save the current pname
-    this->CurrentPrintLineName = pname;
+    line = "";
+    vector<char>::iterator outiter = out.begin();
+    vector<char>::iterator erriter = err.begin();
+    while (1) {
+        // Check for a newline in stdout.
+        for (; outiter != out.end(); ++outiter) {
+            if ((*outiter == '\r') && ((outiter + 1) == out.end())) {
+                break;
+            } else if (*outiter == '\n' || *outiter == '\0') {
+                int length = outiter - out.begin();
+                if (length > 1 && *(outiter - 1) == '\r')
+                    --length;
+                if (length > 0)
+                    line.append(&out[0], length);
+                out.erase(out.begin(), outiter + 1);
+                return mercury_sysProcess_Pipe_STDOUT;
+            }
+        }
+
+        // Check for a newline in stderr.
+        for (; erriter != err.end(); ++erriter) {
+            if ((*erriter == '\r') && ((erriter + 1) == err.end())) {
+                break;
+            } else if (*erriter == '\n' || *erriter == '\0') {
+                int length = erriter - err.begin();
+                if (length > 1 && *(erriter - 1) == '\r')
+                    --length;
+                if (length > 0)
+                    line.append(&err[0], length);
+                err.erase(err.begin(), erriter + 1);
+                return mercury_sysProcess_Pipe_STDERR;
+            }
+        }
+
+        // No newlines found.  Wait for more data from the process.
+        int length;
+        char *data;
+        int pipe = mercury_sysProcess_WaitForData(process, &data, &length,
+            &timeout);
+        if (pipe == mercury_sysProcess_Pipe_Timeout) {
+            // Timeout has been exceeded.
+            return pipe;
+        } else if (pipe == mercury_sysProcess_Pipe_STDOUT) {
+            // Append to the stdout buffer.
+            vector<char>::size_type size = out.size();
+            out.insert(out.end(), data, data + length);
+            outiter = out.begin() + size;
+        } else if (pipe == mercury_sysProcess_Pipe_STDERR) {
+            // Append to the stderr buffer.
+            vector<char>::size_type size = err.size();
+            err.insert(err.end(), data, data + length);
+            erriter = err.begin() + size;
+        } else if (pipe == mercury_sysProcess_Pipe_None) {
+            // Both stdout and stderr pipes have broken.  Return leftover data.
+            if (!out.empty()) {
+                line.append(&out[0], outiter - out.begin());
+                out.erase(out.begin(), out.end());
+                return mercury_sysProcess_Pipe_STDOUT;
+            } else if (!err.empty()) {
+                line.append(&err[0], erriter - err.begin());
+                err.erase(err.begin(), err.end());
+                return mercury_sysProcess_Pipe_STDERR;
+            } else {
+                return mercury_sysProcess_Pipe_None;
+            }
+        }
     }
-  cerr << line << "\n";
-  cerr.flush();
 }
+
 //----------------------------------------------------------------------------
-int HGTestDriver::WaitForAndPrintLine(const char* pname, mercury_sysProcess* process,
-                                      string& line, double timeout,
-                                      vector<char>& out,
-                                      vector<char>& err,
-                                      int* foundWaiting)
+void
+HGTestDriver::PrintLine(const char *pname, const char *line)
 {
-  int pipe = this->WaitForLine(process, line, timeout, out, err);
-  if(pipe == mercury_sysProcess_Pipe_STDOUT || pipe == mercury_sysProcess_Pipe_STDERR)
-    {
-    this->PrintLine(pname, line.c_str());
-    if(foundWaiting && (line.find("Waiting") != line.npos))
-      {
-      *foundWaiting = 1;
-      }
-    }
-  return pipe;
+    // if the name changed then the line is output from a different process
+    if (this->CurrentPrintLineName != pname) {
+        cerr << "-------------- " << pname << " output --------------\n";
+        // save the current pname
+        this->CurrentPrintLineName = pname;
+    }
+    cerr << line << "\n";
+    cerr.flush();
 }
+
+//----------------------------------------------------------------------------
+int
+HGTestDriver::WaitForAndPrintLine(const char *pname,
+    mercury_sysProcess *process, string &line, double timeout,
+    vector<char> &out, vector<char> &err, int *foundWaiting)
+{
+    int pipe = this->WaitForLine(process, line, timeout, out, err);
+    if (pipe == mercury_sysProcess_Pipe_STDOUT
+        || pipe == mercury_sysProcess_Pipe_STDERR) {
+        this->PrintLine(pname, line.c_str());
+        if (foundWaiting && (line.find(HG_TEST_SERVER_START_MSG) != line.npos))
+            *foundWaiting = 1;
+    }
+    return pipe;
+}
+
 //----------------------------------------------------------------------------
-string HGTestDriver::GetDirectory(string location)
+string
+HGTestDriver::GetDirectory(string location)
 {
-  return mercury_sys::SystemTools::GetParentDirectory(location.c_str());
+    return mercury_sys::SystemTools::GetParentDirectory(location.c_str());
 }
diff --git a/Testing/driver/mercury_test_driver.h b/Testing/driver/mercury_test_driver.h
deleted file mode 100644
index 137cc2c..0000000
--- a/Testing/driver/mercury_test_driver.h
+++ /dev/null
@@ -1,76 +0,0 @@
-#ifndef SHIPPER_TEST_DRIVER_H
-#define SHIPPER_TEST_DRIVER_H
-
-#include <string>
-#include <vector>
-
-#include <mercury_sys/Process.h>
-
-class HGTestDriver
-{
-public:
-  int Main(int argc, char* argv[]);
-  HGTestDriver();
-  ~HGTestDriver();
-
-protected:
-  void SeparateArguments(const char* str, 
-                         std::vector<std::string>& flags);
-  
-  void ReportCommand(const char* const* command, const char* name);
-  int ReportStatus(mercury_sysProcess* process, const char* name);
-  int ProcessCommandLine(int argc, char* argv[]);
-  void CollectConfiguredOptions();
-  void CreateCommandLine(std::vector<const char*>& commandLine,
-                         const char* paraView,
-                         const char* numProc,
-                         int argStart=0,
-                         int argCount=0,
-                         char* argv[]=0);
-  
-  int StartServer(mercury_sysProcess* server, const char* name,
-                  std::vector<char>& out, std::vector<char>& err);
-  int StartClient(mercury_sysProcess* client, const char* name);
-  void Stop(mercury_sysProcess* p, const char* name);
-  int OutputStringHasError(const char* pname, std::string& output);
-
-  int WaitForLine(mercury_sysProcess* process, std::string& line, double timeout,
-                  std::vector<char>& out, std::vector<char>& err);
-  void PrintLine(const char* pname, const char* line);
-  int WaitForAndPrintLine(const char* pname, mercury_sysProcess* process,
-                          std::string& line, double timeout,
-                          std::vector<char>& out, std::vector<char>& err,
-                          int* foundWaiting);
-
-  std::string GetDirectory(std::string location);
-
-private:
-  std::string ClientExecutable;  // fullpath to paraview executable
-  std::string ServerExecutable;  // fullpath to paraview server executable
-  std::string MPIRun;  // fullpath to mpirun executable
-
-  // This specify the preflags and post flags that can be set using:
-  // VTK_MPI_PRENUMPROC_FLAGS VTK_MPI_PREFLAGS / VTK_MPI_POSTFLAGS at config time
-  std::vector<std::string> MPIPreNumProcFlags;
-  std::vector<std::string> MPIPreFlags;
-  std::vector<std::string> MPIPostFlags;
-  
-  // Specify the number of process flag, this can be set using: VTK_MPI_NUMPROC_FLAG. 
-  // This is then split into : 
-  // MPIServerNumProcessFlag & MPIRenderServerNumProcessFlag
-  std::string MPINumProcessFlag;
-  std::string MPIServerNumProcessFlag;
-  std::string MPIClientNumProcessFlag;
-
-  std::string CurrentPrintLineName;
-
-  double TimeOut;
-  double ServerExitTimeOut; // time to wait for servers to finish.
-  int TestServer;
-
-  int ArgStart;
-  int AllowErrorInOutput;
-};
-
-#endif //SHIPPER_TEST_DRIVER_H
-
diff --git a/Testing/driver/mercury_test_driver.hxx b/Testing/driver/mercury_test_driver.hxx
new file mode 100644
index 0000000..245d2f1
--- /dev/null
+++ b/Testing/driver/mercury_test_driver.hxx
@@ -0,0 +1,75 @@
+#ifndef MERCURY_TEST_DRIVER_H
+#define MERCURY_TEST_DRIVER_H
+
+#include <mercury_sys/Process.h>
+#include <string>
+#include <vector>
+
+class HGTestDriver {
+public:
+    int Main(int argc, char *argv[]);
+    HGTestDriver();
+    ~HGTestDriver();
+
+protected:
+    void SeparateArguments(const char* str, std::vector<std::string> &flags);
+
+    void ReportCommand(const char * const *command, const char *name);
+    int  ReportStatus(mercury_sysProcess *process, const char *name);
+    int  ProcessCommandLine(int argc, char *argv[]);
+    void CollectConfiguredOptions();
+    void CreateCommandLine(std::vector<const char *> &commandLine,
+        const char *cmd, int isServer, int isHelper, const char *numProc,
+        int argStart = 0, int argCount = 0, char *argv[] = 0);
+
+    int StartServer(mercury_sysProcess *server, const char *name,
+        std::vector<char> &out, std::vector<char> &err);
+    int StartClient(mercury_sysProcess *client, const char *name);
+    void Stop(mercury_sysProcess *p, const char *name);
+    int OutputStringHasError(const char *pname, std::string &output);
+
+    int WaitForLine(mercury_sysProcess *process, std::string &line,
+        double timeout, std::vector<char> &out, std::vector<char> &err);
+    void PrintLine(const char *pname, const char *line);
+    int WaitForAndPrintLine(const char *pname, mercury_sysProcess *process,
+        std::string &line, double timeout, std::vector<char> &out,
+        std::vector<char> &err, int *foundWaiting);
+
+    std::string GetDirectory(std::string location);
+
+private:
+    std::string ClientExecutable;       // fullpath to client executable
+    std::string ServerExecutable;       // fullpath to server executable
+    std::string MPIRun;                 // fullpath to mpirun executable
+
+    // This specify the preflags and post flags that can be set using:
+    // VTK_MPI_PRENUMPROC_FLAGS VTK_MPI_PREFLAGS / VTK_MPI_POSTFLAGS at config time
+    // std::vector<std::string> MPIPreNumProcFlags;
+    std::vector<std::string> ClientEnvVars;
+    std::vector<std::string> MPIClientPreFlags;
+    std::vector<std::string> MPIClientPostFlags;
+    std::vector<std::string> MPIServerPreFlags;
+    std::vector<std::string> MPIServerPostFlags;
+
+    // Specify the number of process flag, this can be set using: VTK_MPI_NUMPROC_FLAG.
+    // This is then split into :
+    // MPIServerNumProcessFlag & MPIRenderServerNumProcessFlag
+    std::string MPINumProcessFlag;
+    std::string MPIServerNumProcessFlag;
+    std::string MPIClientNumProcessFlag;
+
+    std::string CurrentPrintLineName;
+
+    double TimeOut;
+    double ServerExitTimeOut;   // time to wait for servers to finish.
+    bool TestServer;
+
+    int ClientArgStart;
+    int ClientArgCount;
+    int ServerArgStart;
+    int ServerArgCount;
+    bool AllowErrorInOutput;
+    bool TestSerial;
+};
+
+#endif //MERCURY_TEST_DRIVER_H
diff --git a/Testing/mercury_rpc_cb.c b/Testing/mercury_rpc_cb.c
index 5279c7f..3fa3fac 100644
--- a/Testing/mercury_rpc_cb.c
+++ b/Testing/mercury_rpc_cb.c
@@ -11,7 +11,7 @@
 #include "mercury_test.h"
 
 #include "mercury_time.h"
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
 #include "mercury_thread_pool.h"
 #endif
 #include "mercury_atomic.h"
@@ -21,24 +21,14 @@
 /****************/
 /* Local Macros */
 /****************/
-#define PIPELINE_SIZE 4
-#define MIN_BUFFER_SIZE (2 << 15) /* 11 Stop at 4KB buffer size */
 
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
-
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
 #define HG_TEST_ALLOC(size) calloc(size, sizeof(char))
 #else
 #define HG_TEST_ALLOC(size) malloc(size)
 #endif
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
 #define HG_TEST_RPC_CB(func_name, handle) \
     static hg_return_t \
     func_name ## _thread_cb(hg_handle_t handle)
@@ -47,40 +37,40 @@
  * will define func_name_thread and func_name_thread_cb that can be used
  * to execute RPC callback from a thread
  */
-#define HG_TEST_THREAD_CB(func_name) \
-        static HG_INLINE HG_THREAD_RETURN_TYPE \
-        func_name ## _thread \
-        (void *arg) \
-        { \
-            hg_handle_t handle = (hg_handle_t) arg; \
-            hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0; \
-            \
-            func_name ## _thread_cb(handle); \
-            \
-            return thread_ret; \
-        } \
-        hg_return_t \
-        func_name ## _cb(hg_handle_t handle) \
-        { \
-            struct hg_test_info *hg_test_info = \
-                (struct hg_test_info *) HG_Class_get_data( \
-                    HG_Get_info(handle)->hg_class); \
-            hg_return_t ret = HG_SUCCESS; \
-            \
-            if (!hg_test_info->secondary_contexts) { \
-                struct hg_thread_work *work = HG_Get_data(handle); \
-                work->func = func_name ## _thread; \
-                work->args = handle; \
-                hg_thread_pool_post(hg_test_info->thread_pool, work); \
-            } else { \
-                func_name ## _thread(handle); \
-            } \
-            \
-            return ret; \
+#define HG_TEST_THREAD_CB(func_name)                                    \
+        static HG_INLINE HG_THREAD_RETURN_TYPE                          \
+        func_name ## _thread                                            \
+        (void *arg)                                                     \
+        {                                                               \
+            hg_handle_t handle = (hg_handle_t) arg;                     \
+            hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;           \
+                                                                        \
+            func_name ## _thread_cb(handle);                            \
+                                                                        \
+            return thread_ret;                                          \
+        }                                                               \
+        hg_return_t                                                     \
+        func_name ## _cb(hg_handle_t handle)                            \
+        {                                                               \
+            struct hg_test_info *hg_test_info =                         \
+                (struct hg_test_info *) HG_Class_get_data(              \
+                    HG_Get_info(handle)->hg_class);                     \
+            hg_return_t ret = HG_SUCCESS;                               \
+                                                                        \
+            if (hg_test_info->na_test_info.max_contexts > 1) {          \
+                func_name ## _thread(handle);                           \
+            } else {                                                    \
+                struct hg_thread_work *work = HG_Get_data(handle);      \
+                work->func = func_name ## _thread;                      \
+                work->args = handle;                                    \
+                hg_thread_pool_post(hg_test_info->thread_pool, work);   \
+            }                                                           \
+                                                                        \
+            return ret;                                                 \
         }
 #else
-#define HG_TEST_RPC_CB(func_name, handle) \
-    hg_return_t \
+#define HG_TEST_RPC_CB(func_name, handle)                               \
+    hg_return_t                                                         \
     func_name ## _cb(hg_handle_t handle)
 #define HG_TEST_THREAD_CB(func_name)
 #endif
@@ -88,6 +78,7 @@
 /************************************/
 /* Local Type and Struct Definition */
 /************************************/
+
 #ifdef _WIN32
 #  ifndef _SSIZE_T_DEFINED
     typedef SSIZE_T ssize_t;
@@ -107,6 +98,7 @@ struct hg_test_bulk_args {
 /********************/
 /* Local Prototypes */
 /********************/
+
 static hg_return_t
 hg_test_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info);
 
@@ -114,12 +106,6 @@ static hg_return_t
 hg_test_bulk_bind_transfer_cb(const struct hg_cb_info *hg_cb_info);
 
 static hg_return_t
-hg_test_posix_write_transfer_cb(const struct hg_cb_info *hg_cb_info);
-
-static hg_return_t
-hg_test_posix_read_transfer_cb(const struct hg_cb_info *hg_cb_info);
-
-static hg_return_t
 hg_test_perf_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info);
 
 /*******************/
@@ -135,9 +121,10 @@ hg_test_perf_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info);
 static HG_INLINE int
 rpc_open(const char *path, rpc_handle_t handle, int *event_id)
 {
-    printf("Called rpc_open of %s with cookie %lu\n", path,
+    HG_TEST_LOG_DEBUG("Called rpc_open of %s with cookie %lu\n", path,
         (unsigned long) handle.cookie);
     *event_id = (int) handle.cookie;
+
     return HG_SUCCESS;
 }
 
@@ -146,7 +133,7 @@ static HG_INLINE size_t
 bulk_write(int fildes, const void *buf, size_t offset, size_t start_value,
     size_t nbyte, int verbose)
 {
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
     size_t i;
     int error = 0;
     const char *buf_ptr = (const char *) buf;
@@ -191,22 +178,18 @@ bulk_write(int fildes, const void *buf, size_t offset, size_t start_value,
 /*---------------------------------------------------------------------------*/
 HG_TEST_RPC_CB(hg_test_rpc_open, handle)
 {
-    hg_return_t ret = HG_SUCCESS;
-
     rpc_open_in_t  in_struct;
     rpc_open_out_t out_struct;
-
     hg_const_string_t path;
     rpc_handle_t rpc_handle;
     int event_id;
     int open_ret;
+    hg_return_t ret = HG_SUCCESS;
 
     /* Get input buffer */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get parameters */
     path = in_struct.path;
@@ -216,7 +199,9 @@ HG_TEST_RPC_CB(hg_test_rpc_open, handle)
     open_ret = rpc_open(path, rpc_handle, &event_id);
 
     /* Free input */
-    HG_Free_input(handle, &in_struct);
+    ret = HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill output structure */
     out_struct.event_id = event_id;
@@ -224,12 +209,13 @@ HG_TEST_RPC_CB(hg_test_rpc_open, handle)
 
     /* Send response back */
     ret = HG_Respond(handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Destroy(handle);
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
@@ -237,18 +223,16 @@ HG_TEST_RPC_CB(hg_test_rpc_open, handle)
 /*---------------------------------------------------------------------------*/
 HG_TEST_RPC_CB(hg_test_rpc_open_no_resp, handle)
 {
-    hg_return_t ret = HG_SUCCESS;
     rpc_open_in_t  in_struct;
     hg_const_string_t path;
     rpc_handle_t rpc_handle;
     int event_id;
+    hg_return_t ret = HG_SUCCESS;
 
     /* Get input buffer */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get parameters */
     path = in_struct.path;
@@ -257,8 +241,67 @@ HG_TEST_RPC_CB(hg_test_rpc_open_no_resp, handle)
     /* Call rpc_open */
     rpc_open(path, rpc_handle, &event_id);
 
-    HG_Free_input(handle, &in_struct);
-    HG_Destroy(handle);
+    ret = HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
+
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+HG_TEST_RPC_CB(hg_test_overflow, handle)
+{
+    size_t max_size =
+        HG_Class_get_output_eager_size(HG_Get_info(handle)->hg_class);
+    overflow_out_t out_struct;
+    hg_string_t string;
+    size_t string_len = max_size * 2;
+    hg_return_t ret = HG_SUCCESS;
+
+    string = (hg_string_t) malloc(string_len + 1);
+    HG_TEST_CHECK_ERROR(string == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate string");
+
+    memset(string, 'h', string_len);
+    string[string_len] = '\0';
+
+    /* Fill output structure */
+    out_struct.string = string;
+    out_struct.string_len = string_len;
+
+    /* Send response back */
+    ret = HG_Respond(handle, NULL, NULL, &out_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
+
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    free(string);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+HG_TEST_RPC_CB(hg_test_cancel_rpc, handle)
+{
+    hg_return_t ret = HG_SUCCESS;
+
+    /* Destroy twice and do not send expected response back */
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
@@ -277,6 +320,8 @@ HG_TEST_RPC_CB(hg_test_bulk_write, handle)
 
     bulk_args = (struct hg_test_bulk_args *) malloc(
             sizeof(struct hg_test_bulk_args));
+    HG_TEST_CHECK_ERROR(bulk_args == NULL, error, ret, HG_NOMEM_ERROR,
+        "Could not allocate bulk_args");
 
     /* Keep handle to pass to callback */
     bulk_args->handle = handle;
@@ -286,10 +331,8 @@ HG_TEST_RPC_CB(hg_test_bulk_write, handle)
 
     /* Get input parameters and data */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get parameters */
     fildes = in_struct.fildes;
@@ -301,13 +344,21 @@ HG_TEST_RPC_CB(hg_test_bulk_write, handle)
     bulk_args->target_offset = in_struct.target_offset;
     bulk_args->fildes = fildes;
 
+    ret = HG_Bulk_ref_incr(origin_bulk_handle);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_ref_incr() failed (%s)",
+        HG_Error_to_string(ret));
+
     /* Free input */
-    HG_Bulk_ref_incr(origin_bulk_handle);
-    HG_Free_input(handle, &in_struct);
+    ret = HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Create a new block handle to read the data */
-    HG_Bulk_create(hg_info->hg_class, 1, NULL, (hg_size_t *) &bulk_args->nbytes,
+    ret = HG_Bulk_create(hg_info->hg_class, 1, NULL,
+        (hg_size_t *) &bulk_args->nbytes,
         HG_BULK_READWRITE, &local_bulk_handle);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Pull bulk data */
     HG_TEST_LOG_DEBUG("Requesting transfer_size=%zu, origin_offset=%zu, "
@@ -317,21 +368,24 @@ HG_TEST_RPC_CB(hg_test_bulk_write, handle)
         bulk_args, HG_BULK_PULL, hg_info->addr, hg_info->context_id,
         origin_bulk_handle, bulk_args->origin_offset, local_bulk_handle,
         bulk_args->target_offset, bulk_args->transfer_size, &hg_bulk_op_id);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_transfer_id() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Test HG_Bulk_Cancel() */
     if (fildes < 0) {
         ret = HG_Bulk_cancel(hg_bulk_op_id);
-        if (ret != HG_SUCCESS){
-            fprintf(stderr, "Could not cancel bulk data\n");
-            return ret;
-        }
+        HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_cancel() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     return ret;
+
+error:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -347,6 +401,8 @@ HG_TEST_RPC_CB(hg_test_bulk_bind_write, handle)
 
     bulk_args = (struct hg_test_bulk_args *) malloc(
             sizeof(struct hg_test_bulk_args));
+    HG_TEST_CHECK_ERROR(bulk_args == NULL, error, ret, HG_NOMEM_ERROR,
+        "Could not allocate bulk_args");
 
     /* Keep handle to pass to callback */
     bulk_args->handle = handle;
@@ -356,10 +412,8 @@ HG_TEST_RPC_CB(hg_test_bulk_bind_write, handle)
 
     /* Get input parameters and data */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get parameters */
     fildes = in_struct.fildes;
@@ -372,8 +426,11 @@ HG_TEST_RPC_CB(hg_test_bulk_bind_write, handle)
     bulk_args->fildes = fildes;
 
     /* Create a new block handle to read the data */
-    HG_Bulk_create(hg_info->hg_class, 1, NULL, (hg_size_t *) &bulk_args->nbytes,
+    ret = HG_Bulk_create(hg_info->hg_class, 1, NULL,
+        (hg_size_t *) &bulk_args->nbytes,
         HG_BULK_READWRITE, &local_bulk_handle);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Pull bulk data */
     HG_TEST_LOG_DEBUG("Requesting transfer_size=%zu, origin_offset=%zu, "
@@ -383,10 +440,15 @@ HG_TEST_RPC_CB(hg_test_bulk_bind_write, handle)
         bulk_args, HG_BULK_PULL,
         origin_bulk_handle, bulk_args->origin_offset, local_bulk_handle,
         bulk_args->target_offset, bulk_args->transfer_size, HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_bind_transfer() failed (%s)",
+        HG_Error_to_string(ret));
+
+    return ret;
+
+error:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
@@ -405,50 +467,46 @@ hg_test_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info)
     size_t write_ret;
 
     if (hg_cb_info->ret == HG_CANCELED) {
-        printf("HG_Bulk_transfer() was successfully canceled\n");
-
+        HG_TEST_LOG_DEBUG("HG_Bulk_transfer() was canceled\n");
         /* Fill output structure */
         out_struct.ret = 0;
-    } else if (hg_cb_info->ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in callback");
-        ret = HG_PROTOCOL_ERROR;
         goto done;
-    }
+    } else
+        HG_TEST_CHECK_ERROR_NORET(hg_cb_info->ret != HG_SUCCESS, done,
+            "Error in HG callback (%s)", HG_Error_to_string(hg_cb_info->ret));
 
-    if (hg_cb_info->ret == HG_SUCCESS) {
-        /* Call bulk_write */
-        HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes,
-            HG_BULK_READ_ONLY, 1, &buf, NULL, NULL);
+    ret = HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes,
+        HG_BULK_READ_ONLY, 1, &buf, NULL, NULL);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_access() failed (%s)",
+        HG_Error_to_string(ret));
 
-        write_ret = bulk_write(bulk_args->fildes, buf, bulk_args->target_offset,
-            bulk_args->origin_offset - bulk_args->target_offset,
-            bulk_args->transfer_size, 1);
+    /* Call bulk_write */
+    write_ret = bulk_write(bulk_args->fildes, buf, bulk_args->target_offset,
+        bulk_args->origin_offset - bulk_args->target_offset,
+        bulk_args->transfer_size, 1);
 
-        /* Fill output structure */
-        out_struct.ret = write_ret;
-    }
+    /* Fill output structure */
+    out_struct.ret = write_ret;
 
+done:
     /* Free block handle */
     ret = HG_Bulk_free(local_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
+
     ret = HG_Bulk_free(origin_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Send response back */
     ret = HG_Respond(bulk_args->handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
+
+    ret = HG_Destroy(bulk_args->handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
-done:
-    HG_Destroy(bulk_args->handle);
     free(bulk_args);
 
     return ret;
@@ -475,386 +533,54 @@ hg_test_bulk_bind_transfer_cb(const struct hg_cb_info *hg_cb_info)
     size_t write_ret;
 
     if (hg_cb_info->ret == HG_CANCELED) {
-        printf("HG_Bulk_transfer() was successfully canceled\n");
-
+        HG_TEST_LOG_DEBUG("HG_Bulk_transfer() was successfully canceled\n");
         /* Fill output structure */
         out_struct.ret = 0;
-    } else if (hg_cb_info->ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in callback");
-        ret = HG_PROTOCOL_ERROR;
         goto done;
-    }
+    } else
+        HG_TEST_CHECK_ERROR_NORET(hg_cb_info->ret != HG_SUCCESS, done,
+            "Error in HG callback (%s)", HG_Error_to_string(hg_cb_info->ret));
 
-    if (hg_cb_info->ret == HG_SUCCESS) {
-        /* Call bulk_write */
-        HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes,
-            HG_BULK_READ_ONLY, 1, &buf, NULL, NULL);
-
-        write_ret = bulk_write(bulk_args->fildes, buf, bulk_args->target_offset,
-            bulk_args->origin_offset - bulk_args->target_offset,
-            bulk_args->transfer_size, 1);
-
-        /* Fill output structure */
-        out_struct.ret = write_ret;
-    }
-
-    /* Try to send the bulk handle back */
-    out_struct.bulk_handle = origin_bulk_handle;
-
-    /* Free block handle */
-    ret = HG_Bulk_free(local_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
-
-    /* Send response back */
-    ret = HG_Respond(bulk_args->handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
-
-    /* Free input */
-    HG_Free_input(bulk_args->handle, &in_struct);
-
-done:
-    HG_Destroy(bulk_args->handle);
-    free(bulk_args);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-#ifndef _WIN32
-HG_TEST_RPC_CB(hg_test_posix_open, handle)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    open_in_t in_struct;
-    open_out_t out_struct;
-
-    const char *path;
-    int flags;
-    mode_t mode;
-    int open_ret;
-
-    /* Get input struct */
-    ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
-
-    path = in_struct.path;
-    flags = in_struct.flags;
-    mode = in_struct.mode;
-
-    /* Call open */
-    printf("Calling open with path: %s\n", path);
-    open_ret = open(path, flags, mode);
-
-    /* Free input */
-    HG_Free_input(handle, &in_struct);
-
-    /* Fill output structure */
-    out_struct.ret = open_ret;
-
-    /* Send response back */
-    ret = HG_Respond(handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
-
-    HG_Destroy(handle);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_posix_close, handle)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    close_in_t in_struct;
-    close_out_t out_struct;
-
-    int fd;
-    int close_ret;
-
-    /* Get input struct */
-    ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
-
-    fd = in_struct.fd;
-
-    /* Free input */
-    HG_Free_input(handle, &in_struct);
-
-    /* Call close */
-    printf("Calling close with fd: %d\n", fd);
-    close_ret = close(fd);
-
-    /* Fill output structure */
-    out_struct.ret = close_ret;
-
-    /* Send response back */
-    ret = HG_Respond(handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
-
-    HG_Destroy(handle);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_posix_write, handle)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    const struct hg_info *hg_info = NULL;
-    hg_bulk_t origin_bulk_handle = HG_BULK_NULL;
-    hg_bulk_t local_bulk_handle = HG_BULK_NULL;
-    struct hg_test_bulk_args *bulk_args = NULL;
-    write_in_t in_struct;
-
-    bulk_args = (struct hg_test_bulk_args *) malloc(
-            sizeof(struct hg_test_bulk_args));
-
-    /* Keep handle to pass to callback */
-    bulk_args->handle = handle;
-
-    /* Get info from handle */
-    hg_info = HG_Get_info(handle);
-
-    /* Get input struct */
-    ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
-
-    origin_bulk_handle = in_struct.bulk_handle;
-
-    /* Create a new block handle to read the data */
-    bulk_args->nbytes = HG_Bulk_get_size(origin_bulk_handle);
-    bulk_args->fildes = in_struct.fd;
-
-    /* Free input */
-    HG_Bulk_ref_incr(origin_bulk_handle);
-    HG_Free_input(handle, &in_struct);
-
-    /* Create a new bulk handle to read the data */
-    HG_Bulk_create(hg_info->hg_class, 1, NULL, &bulk_args->nbytes,
-            HG_BULK_READWRITE, &local_bulk_handle);
-
-    /* Pull bulk data */
-    ret = HG_Bulk_transfer_id(hg_info->context, hg_test_posix_write_transfer_cb,
-            bulk_args, HG_BULK_PULL, hg_info->addr, hg_info->context_id,
-            origin_bulk_handle, 0, local_bulk_handle, 0, bulk_args->nbytes,
-            HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_posix_write_transfer_cb(const struct hg_cb_info *hg_cb_info)
-{
-    struct hg_test_bulk_args *bulk_args = (struct hg_test_bulk_args *)
-            hg_cb_info->arg;
-    hg_bulk_t local_bulk_handle = hg_cb_info->info.bulk.local_handle;
-    hg_bulk_t origin_bulk_handle = hg_cb_info->info.bulk.origin_handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    write_out_t out_struct;
-
-    void *buf;
-    ssize_t write_ret;
-
-    /* for debug */
-    int i;
-    const int *buf_ptr;
+    ret = HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes,
+        HG_BULK_READ_ONLY, 1, &buf, NULL, NULL);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_access() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Call bulk_write */
-    HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes, HG_BULK_READWRITE,
-            1, &buf, NULL, NULL);
-
-    /* Check bulk buf */
-    buf_ptr = (const int*) buf;
-    for (i = 0; i < (int)(bulk_args->nbytes / sizeof(int)); i++) {
-        if (buf_ptr[i] != i) {
-            printf("Error detected in bulk transfer, buf[%d] = %d, was expecting %d!\n", i, buf_ptr[i], i);
-            break;
-        }
-    }
-
-    printf("Calling write with fd: %d\n", bulk_args->fildes);
-    write_ret = write(bulk_args->fildes, buf, bulk_args->nbytes);
+    write_ret = bulk_write(bulk_args->fildes, buf, bulk_args->target_offset,
+        bulk_args->origin_offset - bulk_args->target_offset,
+        bulk_args->transfer_size, 1);
 
     /* Fill output structure */
     out_struct.ret = write_ret;
 
+done:
+    /* Try to send the bulk handle back */
+    out_struct.bulk_handle = origin_bulk_handle;
+
     /* Free block handle */
     ret = HG_Bulk_free(local_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
-
-    /* Free origin handle */
-    ret = HG_Bulk_free(origin_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Send response back */
     ret = HG_Respond(bulk_args->handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
-
-    HG_Destroy(bulk_args->handle);
-    free(bulk_args);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_posix_read, handle)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    const struct hg_info *hg_info = NULL;
-    hg_bulk_t origin_bulk_handle = HG_BULK_NULL;
-    hg_bulk_t local_bulk_handle = HG_BULK_NULL;
-    struct hg_test_bulk_args *bulk_args = NULL;
-    read_in_t in_struct;
-
-    void *buf;
-    ssize_t read_ret;
-
-    /* for debug */
-    int i;
-    const int *buf_ptr;
-
-    bulk_args = (struct hg_test_bulk_args *) malloc(
-            sizeof(struct hg_test_bulk_args));
-
-    /* Keep handle to pass to callback */
-    bulk_args->handle = handle;
-
-    /* Get info from handle */
-    hg_info = HG_Get_info(handle);
-
-    /* Get input struct */
-    ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
-
-    origin_bulk_handle = in_struct.bulk_handle;
-
-    /* Create a new block handle to read the data */
-    bulk_args->nbytes = HG_Bulk_get_size(origin_bulk_handle);
-    bulk_args->fildes = in_struct.fd;
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Free input */
-    HG_Bulk_ref_incr(origin_bulk_handle);
-    HG_Free_input(handle, &in_struct);
-
-    /* Create a new bulk handle to read the data */
-    HG_Bulk_create(hg_info->hg_class, 1, NULL, (hg_size_t *) &bulk_args->nbytes,
-            HG_BULK_READ_ONLY, &local_bulk_handle);
-
-    /* Call bulk_write */
-    HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes, HG_BULK_READWRITE,
-            1, &buf, NULL, NULL);
-
-    printf("Calling read with fd: %d\n", in_struct.fd);
-    read_ret = read(in_struct.fd, buf, bulk_args->nbytes);
-
-    /* Check bulk buf */
-    buf_ptr = (const int*) buf;
-    for (i = 0; i < (int)(bulk_args->nbytes / sizeof(int)); i++) {
-        if (buf_ptr[i] != i) {
-            printf("Error detected after read, buf[%d] = %d, was expecting %d!\n", i, buf_ptr[i], i);
-            break;
-        }
-    }
-
-    /* Fill output structure */
-    bulk_args->ret = read_ret;
-
-    /* Push bulk data */
-    ret = HG_Bulk_transfer_id(hg_info->context, hg_test_posix_read_transfer_cb,
-            bulk_args, HG_BULK_PUSH, hg_info->addr, hg_info->context_id,
-            origin_bulk_handle, 0, local_bulk_handle, 0, bulk_args->nbytes,
-            HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_posix_read_transfer_cb(const struct hg_cb_info *hg_cb_info)
-{
-    struct hg_test_bulk_args *bulk_args = (struct hg_test_bulk_args *)
-            hg_cb_info->arg;
-    hg_bulk_t local_bulk_handle = hg_cb_info->info.bulk.local_handle;
-    hg_bulk_t origin_bulk_handle = hg_cb_info->info.bulk.origin_handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    write_out_t out_struct;
-
-    /* Fill output structure */
-    out_struct.ret = bulk_args->ret;
-
-    /* Free block handle */
-    ret = HG_Bulk_free(local_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
-
-    /* Free origin handle */
-    ret = HG_Bulk_free(origin_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
+    ret = HG_Free_input(bulk_args->handle, &in_struct);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 
-    /* Send response back */
-    ret = HG_Respond(bulk_args->handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
+    ret = HG_Destroy(bulk_args->handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Destroy(bulk_args->handle);
     free(bulk_args);
 
     return ret;
 }
-#endif /* _WIN32 */
 
 /*---------------------------------------------------------------------------*/
 HG_TEST_RPC_CB(hg_test_perf_rpc, handle)
@@ -863,12 +589,13 @@ HG_TEST_RPC_CB(hg_test_perf_rpc, handle)
 
     /* Send response back */
     ret = HG_Respond(handle, NULL, NULL, NULL);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Destroy(handle);
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
@@ -877,28 +604,28 @@ HG_TEST_RPC_CB(hg_test_perf_rpc, handle)
 HG_TEST_RPC_CB(hg_test_perf_rpc_lat, handle)
 {
     hg_return_t ret = HG_SUCCESS;
-
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
     perf_rpc_lat_in_t in_struct;
 
     /* Get input struct */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Free_input(handle, &in_struct);
+    ret= HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 #endif
 
     /* Send response back */
     ret = HG_Respond(handle, NULL, NULL, NULL);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Destroy(handle);
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
@@ -906,51 +633,65 @@ HG_TEST_RPC_CB(hg_test_perf_rpc_lat, handle)
 /*---------------------------------------------------------------------------*/
 HG_TEST_RPC_CB(hg_test_perf_bulk, handle)
 {
-    hg_return_t ret = HG_SUCCESS;
     const struct hg_info *hg_info = NULL;
     struct hg_test_info *hg_test_info = NULL;
     hg_bulk_t origin_bulk_handle = HG_BULK_NULL;
     hg_bulk_t local_bulk_handle = HG_BULK_NULL;
     bulk_write_in_t in_struct;
+    hg_return_t ret = HG_SUCCESS;
 
     /* Get info from handle */
     hg_info = HG_Get_info(handle);
 
     /* Get test info */
     hg_test_info = (struct hg_test_info *) HG_Class_get_data(hg_info->hg_class);
+    HG_TEST_CHECK_ERROR(hg_test_info == NULL, error, ret, HG_INVALID_ARG,
+        "NULL hg_test_info");
 
     /* Get input struct */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     origin_bulk_handle = in_struct.bulk_handle;
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
     hg_thread_mutex_lock(&hg_test_info->bulk_handle_mutex);
 #endif
     local_bulk_handle = hg_test_info->bulk_handle;
 
+    ret = HG_Bulk_ref_incr(origin_bulk_handle);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_ref_incr() failed (%s)",
+        HG_Error_to_string(ret));
+
     /* Free input */
-    HG_Bulk_ref_incr(origin_bulk_handle);
     HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Pull bulk data */
     ret = HG_Bulk_transfer_id(hg_info->context, hg_test_perf_bulk_transfer_cb,
             handle, HG_BULK_PULL, hg_info->addr, hg_info->context_id,
             origin_bulk_handle, 0, local_bulk_handle, 0,
             HG_Bulk_get_size(origin_bulk_handle), HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_transfer_id() failed (%s)",
+        HG_Error_to_string(ret));
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+    hg_thread_mutex_unlock(&hg_test_info->bulk_handle_mutex);
+#endif
+
+    return ret;
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+error:
+#ifdef HG_TEST_HAS_THREAD_POOL
     hg_thread_mutex_unlock(&hg_test_info->bulk_handle_mutex);
 #endif
 
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
     return ret;
 }
 
@@ -969,24 +710,29 @@ HG_TEST_RPC_CB(hg_test_perf_bulk_read, handle)
 
     /* Get test info */
     hg_test_info = (struct hg_test_info *) HG_Class_get_data(hg_info->hg_class);
+    HG_TEST_CHECK_ERROR(hg_test_info == NULL, error, ret, HG_INVALID_ARG,
+        "NULL hg_test_info");
 
     /* Get input struct */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     origin_bulk_handle = in_struct.bulk_handle;
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
     hg_thread_mutex_lock(&hg_test_info->bulk_handle_mutex);
 #endif
     local_bulk_handle = hg_test_info->bulk_handle;
 
+    ret = HG_Bulk_ref_incr(origin_bulk_handle);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_ref_incr() failed (%s)",
+        HG_Error_to_string(ret));
+
     /* Free input */
-    HG_Bulk_ref_incr(origin_bulk_handle);
-    HG_Free_input(handle, &in_struct);
+    ret = HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Pull bulk data */
     ret = HG_Bulk_transfer_id(hg_info->context, hg_test_perf_bulk_transfer_cb,
@@ -994,15 +740,24 @@ HG_TEST_RPC_CB(hg_test_perf_bulk_read, handle)
         origin_bulk_handle, 0, local_bulk_handle, 0,
         HG_Bulk_get_size(origin_bulk_handle),
         HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_transfer_id() failed (%s)",
+        HG_Error_to_string(ret));
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+    hg_thread_mutex_unlock(&hg_test_info->bulk_handle_mutex);
+#endif
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+    return ret;
+
+error:
+#ifdef HG_TEST_HAS_THREAD_POOL
     hg_thread_mutex_unlock(&hg_test_info->bulk_handle_mutex);
 #endif
 
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
     return ret;
 }
 
@@ -1012,7 +767,7 @@ hg_test_perf_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info)
 {
     hg_handle_t handle = (hg_handle_t) hg_cb_info->arg;
     hg_bulk_t origin_bulk_handle = hg_cb_info->info.bulk.origin_handle;
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
     size_t size = HG_Bulk_get_size(hg_cb_info->info.bulk.origin_handle);
     void *buf;
     const char *buf_ptr;
@@ -1020,84 +775,43 @@ hg_test_perf_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info)
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
-    HG_Bulk_access(hg_cb_info->info.bulk.local_handle, 0,
+    HG_TEST_CHECK_ERROR_NORET(hg_cb_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(hg_cb_info->ret));
+
+#ifdef HG_TEST_HAS_VERIFY_DATA
+    ret = HG_Bulk_access(hg_cb_info->info.bulk.local_handle, 0,
         size, HG_BULK_READWRITE, 1, &buf, NULL, NULL);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_access() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Check bulk buf */
     buf_ptr = (const char*) buf;
     for (i = 0; i < size; i++) {
-        if (buf_ptr[i] != (char) i) {
-            printf("Error detected in bulk transfer, buf[%d] = %d, "
-                "was expecting %d!\n", (int) i, (char) buf_ptr[i], (char) i);
-            break;
-        }
+        HG_TEST_CHECK_ERROR(buf_ptr[i] != (char) i, done, ret, HG_SUCCESS,
+            "Error detected in bulk transfer, buf[%d] = %d, "
+            "was expecting %d!\n", (int) i, (char) buf_ptr[i], (char) i);
     }
 #endif
 
+done:
     /* Free origin handle */
     ret = HG_Bulk_free(origin_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Send response back */
     ret = HG_Respond(handle, NULL, NULL, NULL);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        goto done;
-    }
-
-done:
-    HG_Destroy(handle);
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_overflow, handle)
-{
-    size_t max_size =
-        HG_Class_get_output_eager_size(HG_Get_info(handle)->hg_class);
-    hg_return_t ret = HG_SUCCESS;
-
-    overflow_out_t out_struct;
-
-    hg_string_t string;
-    size_t string_len = max_size * 2;
-
-    string = (hg_string_t) malloc(string_len + 1);
-    memset(string, 'h', string_len);
-    string[string_len] = '\0';
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
-    /* Fill output structure */
-    out_struct.string = string;
-    out_struct.string_len = string_len;
-
-    /* Send response back */
-    ret = HG_Respond(handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
-
-    HG_Destroy(handle);
-    free(string);
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_cancel_rpc, handle)
-{
-    /* Destroy twice and do not send expected response back */
-    HG_Destroy(handle);
-    HG_Destroy(handle);
-
-    return HG_SUCCESS;
-}
-
-/*---------------------------------------------------------------------------*/
 //static hg_return_t
 //hg_test_nested1_forward_cb(const struct hg_cb_info *callback_info)
 //{
@@ -1173,21 +887,16 @@ HG_TEST_RPC_CB(hg_test_cancel_rpc, handle)
 /*---------------------------------------------------------------------------*/
 HG_TEST_THREAD_CB(hg_test_rpc_open)
 HG_TEST_THREAD_CB(hg_test_rpc_open_no_resp)
+HG_TEST_THREAD_CB(hg_test_overflow)
+HG_TEST_THREAD_CB(hg_test_cancel_rpc)
+
 HG_TEST_THREAD_CB(hg_test_bulk_write)
 HG_TEST_THREAD_CB(hg_test_bulk_bind_write)
-//HG_TEST_THREAD_CB(hg_test_pipeline_write)
-#ifndef _WIN32
-HG_TEST_THREAD_CB(hg_test_posix_open)
-HG_TEST_THREAD_CB(hg_test_posix_close)
-HG_TEST_THREAD_CB(hg_test_posix_write)
-HG_TEST_THREAD_CB(hg_test_posix_read)
-#endif
+
 HG_TEST_THREAD_CB(hg_test_perf_rpc)
 HG_TEST_THREAD_CB(hg_test_perf_rpc_lat)
 HG_TEST_THREAD_CB(hg_test_perf_bulk)
 HG_TEST_THREAD_CB(hg_test_perf_bulk_read)
-HG_TEST_THREAD_CB(hg_test_overflow)
-HG_TEST_THREAD_CB(hg_test_cancel_rpc)
 //HG_TEST_THREAD_CB(hg_test_nested1)
 //HG_TEST_THREAD_CB(hg_test_nested2)
 
diff --git a/Testing/mercury_rpc_cb.h b/Testing/mercury_rpc_cb.h
index 11c77bb..772f542 100644
--- a/Testing/mercury_rpc_cb.h
+++ b/Testing/mercury_rpc_cb.h
@@ -16,12 +16,12 @@
  */
 hg_return_t
 hg_test_rpc_open_cb(hg_handle_t handle);
-
-/**
- * test_rpc (no response)
- */
 hg_return_t
 hg_test_rpc_open_no_resp_cb(hg_handle_t handle);
+hg_return_t
+hg_test_overflow_cb(hg_handle_t handle);
+hg_return_t
+hg_test_cancel_rpc_cb(hg_handle_t handle);
 
 /**
  * test_bulk
@@ -31,24 +31,6 @@ hg_test_bulk_write_cb(hg_handle_t handle);
 hg_return_t
 hg_test_bulk_bind_write_cb(hg_handle_t handle);
 
-///**
-// * test_pipeline
-// */
-//hg_return_t
-//hg_test_pipeline_write_cb(hg_handle_t handle);
-
-/**
- * test_posix
- */
-hg_return_t
-hg_test_posix_open_cb(hg_handle_t handle);
-hg_return_t
-hg_test_posix_write_cb(hg_handle_t handle);
-hg_return_t
-hg_test_posix_read_cb(hg_handle_t handle);
-hg_return_t
-hg_test_posix_close_cb(hg_handle_t handle);
-
 /**
  * test_perf
  */
@@ -62,18 +44,6 @@ hg_return_t
 hg_test_perf_bulk_read_cb(hg_handle_t handle);
 
 /**
- * test_overflow
- */
-hg_return_t
-hg_test_overflow_cb(hg_handle_t handle);
-
-/**
- * test_cancel
- */
-hg_return_t
-hg_test_cancel_rpc_cb(hg_handle_t handle);
-
-/**
  * test_nested
  */
 hg_return_t
diff --git a/Testing/mercury_test.c b/Testing/mercury_test.c
index 0cd4be3..7cfadb2 100644
--- a/Testing/mercury_test.c
+++ b/Testing/mercury_test.c
@@ -11,12 +11,10 @@
 #include "mercury_test.h"
 #include "na_test_getopt.h"
 #include "mercury_rpc_cb.h"
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
 # include <mercury_test_drc.h>
 #endif
 
-#include "mercury_hl.h"
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -29,6 +27,11 @@
 /* Local Type and Struct Definition */
 /************************************/
 
+struct hg_test_lookup_arg {
+    hg_addr_t *addr_ptr;
+    hg_request_t *request;
+};
+
 /********************/
 /* Local Prototypes */
 /********************/
@@ -40,12 +43,21 @@ void
 hg_test_parse_options(int argc, char *argv[],
     struct hg_test_info *hg_test_info);
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+static int
+hg_test_request_progress(unsigned int timeout, void *arg);
+
+static int
+hg_test_request_trigger(unsigned int timeout, unsigned int *flag, void *arg);
+
+#ifdef HG_TEST_HAS_THREAD_POOL
 static hg_return_t
 hg_test_handle_create_cb(hg_handle_t handle, void *arg);
 #endif
 
 static hg_return_t
+hg_test_addr_lookup_cb(const struct hg_cb_info *callback_info);
+
+static hg_return_t
 hg_test_finalize_rpc(struct hg_test_info *hg_test_info, hg_uint8_t target_id);
 
 static hg_return_t
@@ -61,6 +73,11 @@ hg_test_register(hg_class_t *hg_class);
 /* Local Variables */
 /*******************/
 
+/* Default error log mask */
+#ifdef HG_HAS_VERBOSE_ERROR
+unsigned int HG_TEST_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
+#endif
+
 extern int na_test_opt_ind_g; /* token pointer */
 extern const char *na_test_opt_arg_g; /* flag argument (or value) */
 extern const char *na_test_short_opt_g;
@@ -69,20 +86,13 @@ extern const struct na_test_opt na_test_opt_g[];
 /* test_rpc */
 hg_id_t hg_test_rpc_open_id_g = 0;
 hg_id_t hg_test_rpc_open_id_no_resp_g = 0;
+hg_id_t hg_test_overflow_id_g = 0;
+hg_id_t hg_test_cancel_rpc_id_g = 0;
 
 /* test_bulk */
 hg_id_t hg_test_bulk_write_id_g = 0;
 hg_id_t hg_test_bulk_bind_write_id_g = 0;
 
-/* test_pipeline */
-hg_id_t hg_test_pipeline_write_id_g = 0;
-
-/* test_posix */
-hg_id_t hg_test_posix_open_id_g = 0;
-hg_id_t hg_test_posix_write_id_g = 0;
-hg_id_t hg_test_posix_read_id_g = 0;
-hg_id_t hg_test_posix_close_id_g = 0;
-
 /* test_perf */
 hg_id_t hg_test_perf_rpc_id_g = 0;
 hg_id_t hg_test_perf_rpc_lat_id_g = 0;
@@ -90,12 +100,6 @@ hg_id_t hg_test_perf_bulk_id_g = 0;
 hg_id_t hg_test_perf_bulk_write_id_g = 0;
 hg_id_t hg_test_perf_bulk_read_id_g = 0;
 
-/* test_overflow */
-hg_id_t hg_test_overflow_id_g = 0;
-
-/* test_cancel */
-hg_id_t hg_test_cancel_rpc_id_g = 0;
-
 /* test_nested */
 hg_id_t hg_test_nested1_id_g = 0;
 hg_id_t hg_test_nested2_id_g = 0;
@@ -131,7 +135,7 @@ hg_test_parse_options(int argc, char *argv[], struct hg_test_info *hg_test_info)
             case 'a': /* auth service */
                 hg_test_info->auth = HG_TRUE;
                 break;
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
             case 'k': /* auth key */
                 hg_test_info->credential = (uint32_t) atoi(na_test_opt_arg_g);
 #endif
@@ -150,23 +154,48 @@ hg_test_parse_options(int argc, char *argv[], struct hg_test_info *hg_test_info)
     na_test_opt_ind_g = 1;
 
     if (!hg_test_info->thread_count)
-        hg_test_info->thread_count = MERCURY_TESTING_NUM_THREADS_DEFAULT;
+        hg_test_info->thread_count = HG_TEST_NUM_THREADS_DEFAULT;
+}
+
+/*---------------------------------------------------------------------------*/
+static int
+hg_test_request_progress(unsigned int timeout, void *arg)
+{
+    hg_context_t *context = (hg_context_t *) arg;
+    int ret = HG_UTIL_SUCCESS;
+
+    if (HG_Progress(context, timeout) != HG_SUCCESS)
+        ret = HG_UTIL_FAIL;
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static int
+hg_test_request_trigger(unsigned int timeout, unsigned int *flag, void *arg)
+{
+    hg_context_t *context = (hg_context_t *) arg;
+    unsigned int actual_count = 0;
+    int ret = HG_UTIL_SUCCESS;
+
+    if (HG_Trigger(context, timeout, 1, &actual_count)
+            != HG_SUCCESS) ret = HG_UTIL_FAIL;
+    *flag = (actual_count) ? HG_UTIL_TRUE : HG_UTIL_FALSE;
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
 static hg_return_t
 hg_test_handle_create_cb(hg_handle_t handle, void *arg)
 {
-    struct hg_thread_work *hg_thread_work =
-        malloc(sizeof(struct hg_thread_work));
+    struct hg_thread_work *hg_thread_work;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_thread_work) {
-        HG_LOG_ERROR("Could not allocate hg_thread_work");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    hg_thread_work = malloc(sizeof(struct hg_thread_work));
+    HG_TEST_CHECK_ERROR(hg_thread_work == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate hg_thread_work");
 
     (void) arg;
     HG_Set_data(handle, hg_thread_work, free);
@@ -178,45 +207,50 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
+hg_test_addr_lookup_cb(const struct hg_cb_info *callback_info)
+{
+    struct hg_test_lookup_arg *request_args =
+            (struct hg_test_lookup_arg *) callback_info->arg;
+
+    *request_args->addr_ptr = callback_info->info.lookup.addr;
+
+    hg_request_complete(request_args->request);
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
 hg_test_finalize_rpc(struct hg_test_info *hg_test_info, hg_uint8_t target_id)
 {
     hg_request_t *request_object = NULL;
-    hg_handle_t handle;
-    hg_return_t ret = HG_SUCCESS;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS, cleanup_ret;
 
     request_object = hg_request_create(hg_test_info->request_class);
 
     ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
         hg_test_finalize_id_g, &handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not create HG handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Set target ID */
     ret = HG_Set_target_id(handle, target_id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set HG handle target ID");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Forward call to target addr */
     ret = HG_Forward(handle, hg_test_finalize_rpc_cb, request_object, NULL);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not forward finalize call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request_object, HG_MAX_IDLE_TIME, NULL);
 
-    /* Complete */
-    ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
-
 done:
+    cleanup_ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(cleanup_ret != HG_SUCCESS,
+        "HG_Destroy() failed (%s)", HG_Error_to_string(cleanup_ret));
+
     hg_request_destroy(request_object);
 
     return ret;
@@ -248,18 +282,14 @@ hg_test_finalize_cb(hg_handle_t handle)
 
     /* Free handle and send response back */
     ret = HG_Respond(handle, NULL, NULL, NULL);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not respond");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
+done:
     ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
-done:
     return ret;
 }
 
@@ -270,14 +300,20 @@ hg_test_register(hg_class_t *hg_class)
     /* test_rpc */
     hg_test_rpc_open_id_g = MERCURY_REGISTER(hg_class, "hg_test_rpc_open",
             rpc_open_in_t, rpc_open_out_t, hg_test_rpc_open_cb);
-
-    /* Disable response */
     hg_test_rpc_open_id_no_resp_g = MERCURY_REGISTER(hg_class,
         "hg_test_rpc_open_no_resp", rpc_open_in_t, rpc_open_out_t,
         hg_test_rpc_open_no_resp_cb);
+
+    /* Disable response */
     HG_Registered_disable_response(hg_class, hg_test_rpc_open_id_no_resp_g,
         HG_TRUE);
 
+    hg_test_overflow_id_g = MERCURY_REGISTER(hg_class, "hg_test_overflow",
+            void, overflow_out_t, hg_test_overflow_cb);
+    hg_test_cancel_rpc_id_g = MERCURY_REGISTER(hg_class, "hg_test_cancel_rpc",
+            void, void, hg_test_cancel_rpc_cb);
+
+
     /* test_bulk */
     hg_test_bulk_write_id_g = MERCURY_REGISTER(hg_class, "hg_test_bulk_write",
             bulk_write_in_t, bulk_write_out_t, hg_test_bulk_write_cb);
@@ -285,18 +321,6 @@ hg_test_register(hg_class_t *hg_class)
         "hg_test_bulk_bind_write", bulk_write_in_t, bulk_bind_write_out_t,
         hg_test_bulk_bind_write_cb);
 
-#ifndef _WIN32
-    /* test_posix */
-    hg_test_posix_open_id_g = MERCURY_REGISTER(hg_class, "hg_test_posix_open",
-            open_in_t, open_out_t, hg_test_posix_open_cb);
-    hg_test_posix_write_id_g = MERCURY_REGISTER(hg_class, "hg_test_posix_write",
-            write_in_t, write_out_t, hg_test_posix_write_cb);
-    hg_test_posix_read_id_g = MERCURY_REGISTER(hg_class, "hg_test_posix_read",
-            read_in_t, read_out_t, hg_test_posix_read_cb);
-    hg_test_posix_close_id_g = MERCURY_REGISTER(hg_class, "hg_test_posix_close",
-            close_in_t, close_out_t, hg_test_posix_close_cb);
-#endif
-
     /* test_perf */
     hg_test_perf_rpc_id_g = MERCURY_REGISTER(hg_class, "hg_test_perf_rpc",
             void, void, hg_test_perf_rpc_cb);
@@ -310,14 +334,6 @@ hg_test_register(hg_class_t *hg_class)
             "hg_test_perf_bulk_read", bulk_write_in_t, void,
             hg_test_perf_bulk_read_cb);
 
-    /* test_overflow */
-    hg_test_overflow_id_g = MERCURY_REGISTER(hg_class, "hg_test_overflow",
-            void, overflow_out_t, hg_test_overflow_cb);
-
-    /* test_cancel */
-    hg_test_cancel_rpc_id_g = MERCURY_REGISTER(hg_class, "hg_test_cancel_rpc",
-            void, void, hg_test_cancel_rpc_cb);
-
     /* test_nested */
 //    hg_test_nested1_id_g = MERCURY_REGISTER(hg_class, "hg_test_nested",
 //            void, void, hg_test_nested1_cb);
@@ -333,22 +349,30 @@ hg_test_register(hg_class_t *hg_class)
 hg_return_t
 HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
 {
-    struct hg_init_info hg_init_info;
+    struct hg_init_info hg_init_info = HG_INIT_INFO_INITIALIZER;
     struct hg_test_context_info *hg_test_context_info;
     hg_return_t ret = HG_SUCCESS;
+    na_return_t na_ret;
+#ifdef HG_HAS_VERBOSE_ERROR
+    const char *log_level = NULL;
+
+    /* Set log level */
+    log_level = getenv("HG_TEST_LOG_LEVEL");
+    if (log_level && (strcmp(log_level, "debug") == 0))
+        HG_TEST_LOG_MASK |= HG_LOG_TYPE_DEBUG;
+#endif
 
     /* Get HG test options */
     hg_test_parse_options(argc, argv, hg_test_info);
 
     if (hg_test_info->auth) {
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
         char hg_test_drc_key[NA_TEST_MAX_ADDR_NAME] = { '\0' };
 
         ret = hg_test_drc_acquire(argc, argv, hg_test_info);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not acquire DRC auth key");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "hg_test_drc_acquire() failed (%s)",
+            HG_Error_to_string(ret));
+
         sprintf(hg_test_drc_key, "%u", hg_test_info->cookie);
         hg_test_info->na_test_info.key = strdup(hg_test_drc_key);
 #endif
@@ -356,19 +380,13 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
     /* Initialize NA test layer */
     hg_test_info->na_test_info.extern_init = NA_TRUE;
-    if (NA_Test_init(argc, argv, &hg_test_info->na_test_info) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not initialize NA test layer");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
-
-    memset(&hg_init_info, 0, sizeof(struct hg_init_info));
+    na_ret = NA_Test_init(argc, argv, &hg_test_info->na_test_info);
+    HG_TEST_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "NA_Test_init() failed (%s)",  NA_Error_to_string(na_ret));
 
     /* Set progress mode */
     if (hg_test_info->na_test_info.busy_wait)
         hg_init_info.na_init_info.progress_mode = NA_NO_BLOCK;
-    else
-        hg_init_info.na_init_info.progress_mode = NA_DEFAULT;
 
     /* Set stats */
 #ifdef HG_HAS_COLLECT_STATS
@@ -390,28 +408,21 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     /* Init HG with init options */
     hg_test_info->hg_class = HG_Init_opt(NULL,
         hg_test_info->na_test_info.listen, &hg_init_info);
-    if (!hg_test_info->hg_class) {
-        HG_LOG_ERROR("Could not initialize HG");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
-    HG_CLASS_DEFAULT = hg_test_info->hg_class;
+    HG_TEST_CHECK_ERROR(hg_test_info->hg_class == NULL, done, ret, HG_FAULT,
+        "HG_Init_opt() failed (%s)");
 
     /* Attach test info to class */
     ret = HG_Class_set_data(hg_test_info->hg_class, hg_test_info, NULL);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set HG class data");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Class_set_data() failed (%s)",
+        HG_Error_to_string(ret));
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
     /* Attach handle created */
     ret = HG_Class_set_handle_create_callback(hg_test_info->hg_class,
         hg_test_handle_create_cb, hg_test_info->hg_class);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set HG handle create callback");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret,
+        "HG_Class_set_handle_create_callback() failed (%s)",
+        HG_Error_to_string(ret));
 #endif
 
     /* Set header */
@@ -420,40 +431,68 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     HG_Class_set_output_offset(hg_test_info->hg_class, sizeof(hg_uint64_t));
     */
 
-    /* For convenience */
-    ret = HG_Hl_init_opt(NULL, hg_test_info->na_test_info.listen,
-        &hg_init_info);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not initialize HG HL");
-        goto done;
+    /* Create primary context */
+    hg_test_info->context = HG_Context_create(hg_test_info->hg_class);
+    HG_TEST_CHECK_ERROR(hg_test_info->context == NULL, done, ret, HG_FAULT,
+        "Could not create HG context");
+
+    /* Create additional contexts (do not exceed total max contexts) */
+    if (hg_test_info->na_test_info.max_contexts > 1) {
+        hg_uint8_t secondary_contexts_count = (hg_uint8_t)
+                        (hg_test_info->na_test_info.max_contexts - 1);
+        hg_uint8_t i;
+
+        hg_test_info->secondary_contexts = malloc(
+            secondary_contexts_count * sizeof(hg_context_t *));
+        HG_TEST_CHECK_ERROR(hg_test_info->secondary_contexts == NULL, done,
+            ret, HG_NOMEM_ERROR, "Could not allocate secondary contexts");
+        for (i = 0; i < secondary_contexts_count; i++) {
+            hg_uint8_t context_id = (hg_uint8_t) (i + 1);
+            hg_test_info->secondary_contexts[i] =
+                HG_Context_create_id(hg_test_info->hg_class, context_id);
+            HG_TEST_CHECK_ERROR(hg_test_info->secondary_contexts[i] == NULL,
+                done, ret, HG_FAULT, "HG_Context_create_id() failed");
+
+            /* Attach context info to context */
+            hg_test_context_info = malloc(
+                sizeof(struct hg_test_context_info));
+            HG_TEST_CHECK_ERROR(hg_test_context_info == NULL, done, ret,
+                HG_NOMEM_ERROR, "Could not allocate HG test context info");
+
+            hg_atomic_init32(&hg_test_context_info->finalizing, 0);
+            ret = HG_Context_set_data(hg_test_info->secondary_contexts[i],
+                hg_test_context_info, free);
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_set_data() failed"
+                " (%s)", HG_Error_to_string(ret));
+        }
     }
-    hg_test_info->context = HG_CONTEXT_DEFAULT;
-    hg_test_info->request_class = HG_REQUEST_CLASS_DEFAULT;
+
+    /* Create request class */
+    hg_test_info->request_class = hg_request_init(hg_test_request_progress,
+        hg_test_request_trigger, hg_test_info->context);
+    HG_TEST_CHECK_ERROR(hg_test_info->request_class == NULL, done, ret,
+        HG_FAULT, "Could not create request class");
 
     /* Attach context info to context */
     hg_test_context_info = malloc(sizeof(struct hg_test_context_info));
-    if (!hg_test_context_info) {
-        HG_LOG_ERROR("Could not allocate HG test context info");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    hg_atomic_set32(&hg_test_context_info->finalizing, 0);
+    HG_TEST_CHECK_ERROR(hg_test_context_info == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate HG test context info");
+
+    hg_atomic_init32(&hg_test_context_info->finalizing, 0);
     ret = HG_Context_set_data(hg_test_info->context, hg_test_context_info, free);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set context data");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_set_data() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Register routines */
     hg_test_register(hg_test_info->hg_class);
 
     if (hg_test_info->na_test_info.listen
         || hg_test_info->na_test_info.self_send) {
-        size_t bulk_size = 1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE;
+        size_t bulk_size = 1024 * 1024 * HG_TEST_BUFFER_SIZE;
         char *buf_ptr;
         size_t i;
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
         /* Make sure that thread count is at least max_contexts */
         if (hg_test_info->thread_count <
             hg_test_info->na_test_info.max_contexts)
@@ -469,21 +508,17 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         /* Create bulk handle mutex */
         hg_thread_mutex_init(&hg_test_info->bulk_handle_mutex);
 #endif
-
         /* Create bulk buffer that can be used for receiving data */
         ret = HG_Bulk_create(hg_test_info->hg_class, 1, NULL,
             (hg_size_t *) &bulk_size, HG_BULK_READWRITE,
             &hg_test_info->bulk_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not create bulk handle");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+            HG_Error_to_string(ret));
+
         ret = HG_Bulk_access(hg_test_info->bulk_handle, 0, bulk_size,
             HG_BULK_READWRITE, 1, (void **) &buf_ptr, NULL, NULL);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not access bulk handle");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_access() failed (%s)",
+            HG_Error_to_string(ret));
         for (i = 0; i < bulk_size; i++)
             buf_ptr[i] = (char) i;
     }
@@ -493,113 +528,79 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         na_size_t addr_string_len = NA_TEST_MAX_ADDR_NAME;
         hg_addr_t self_addr;
 
-        /* Create additional contexts (do not exceed total max contexts) */
-        if (hg_test_info->na_test_info.max_contexts > 1) {
-            hg_uint8_t secondary_contexts_count = (hg_uint8_t)
-                (hg_test_info->na_test_info.max_contexts - 1);
-            hg_uint8_t i;
-
-            hg_test_info->secondary_contexts = malloc(
-                secondary_contexts_count * sizeof(hg_context_t *));
-            if (!hg_test_info->secondary_contexts) {
-                HG_LOG_ERROR("Could not allocate secondary contexts");
-                ret = HG_NOMEM_ERROR;
-                goto done;
-            }
-            for (i = 0; i < secondary_contexts_count; i++) {
-                hg_uint8_t context_id = (hg_uint8_t) (i + 1);
-                hg_test_info->secondary_contexts[i] =
-                    HG_Context_create_id(hg_test_info->hg_class, context_id);
-                if (!hg_test_info->secondary_contexts[i]) {
-                    HG_LOG_ERROR("Could not create HG context for id: %u", i);
-                    ret = HG_NOMEM_ERROR;
-                    goto done;
-                }
-
-                /* Attach context info to context */
-                hg_test_context_info = malloc(sizeof(struct hg_test_context_info));
-                if (!hg_test_context_info) {
-                    HG_LOG_ERROR("Could not allocate context info");
-                    ret = HG_NOMEM_ERROR;
-                    goto done;
-                }
-                hg_atomic_set32(&hg_test_context_info->finalizing, 0);
-                ret = HG_Context_set_data(hg_test_info->secondary_contexts[i],
-                    hg_test_context_info, free);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not set HG context data");
-                    goto done;
-                }
-            }
-        }
-
         /* TODO only rank 0 */
         ret = HG_Addr_self(hg_test_info->hg_class, &self_addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get HG self addr");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_self() failed (%s)",
+            HG_Error_to_string(ret));
 
         ret = HG_Addr_to_string(hg_test_info->hg_class, addr_string,
             &addr_string_len, self_addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not convert addr to string");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_to_string() failed (%s)",
+            HG_Error_to_string(ret));
 
         ret = HG_Addr_free(hg_test_info->hg_class, self_addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not free addr");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_free() failed (%s)",
+            HG_Error_to_string(ret));
 
         na_test_set_config(addr_string);
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
         /* If static client, must wait for server to write config file */
         if (hg_test_info->na_test_info.mpi_static)
             MPI_Barrier(MPI_COMM_WORLD);
 #endif
 
         /* Used by CTest Test Driver to know when to launch clients */
-        MERCURY_TESTING_READY_MSG();
+        HG_TEST_READY_MSG();
     } else if (hg_test_info->na_test_info.self_send) {
         /* Self addr is target */
         ret = HG_Addr_self(hg_test_info->hg_class, &hg_test_info->target_addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get HG self addr");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_self() failed (%s)",
+            HG_Error_to_string(ret));
     } else {
         char test_addr_name[NA_TEST_MAX_ADDR_NAME] = { '\0' };
+        hg_request_t *request = NULL;
+        unsigned int flag = 0;
+        struct hg_test_lookup_arg lookup_args;
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
         /* If static client must wait for server to write config file */
         if (hg_test_info->na_test_info.mpi_static)
             MPI_Barrier(MPI_COMM_WORLD);
 #endif
 
-        if (hg_test_info->na_test_info.mpi_comm_rank == 0) {
+        if (hg_test_info->na_test_info.mpi_comm_rank == 0)
             na_test_get_config(test_addr_name, NA_TEST_MAX_ADDR_NAME);
-        }
 
         /* Broadcast addr name */
         NA_Test_bcast(test_addr_name, NA_TEST_MAX_ADDR_NAME, 0,
             &hg_test_info->na_test_info);
 
         hg_test_info->na_test_info.target_name = strdup(test_addr_name);
+        HG_TEST_CHECK_ERROR(hg_test_info->na_test_info.target_name == NULL,
+            done, ret, HG_NOMEM_ERROR, "Could not dup test_addr_name");
         printf("# Target name read: %s\n",
             hg_test_info->na_test_info.target_name);
 
         /* Look up target addr using target name info */
-        ret = HG_Hl_addr_lookup_wait(hg_test_info->context,
-            hg_test_info->request_class, hg_test_info->na_test_info.target_name,
-            &hg_test_info->target_addr, HG_MAX_IDLE_TIME);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not lookup addr for target %s",
-                hg_test_info->na_test_info.target_name);
-            goto done;
-        }
+        request = hg_request_create(hg_test_info->request_class);
+        lookup_args.addr_ptr = &hg_test_info->target_addr;
+        lookup_args.request = request;
+
+        /* Forward call to remote addr and get a new request */
+        ret = HG_Addr_lookup(hg_test_info->context, hg_test_addr_lookup_cb,
+            &lookup_args, hg_test_info->na_test_info.target_name,
+            HG_OP_ID_IGNORE);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_lookup() failed (%s)",
+            HG_Error_to_string(ret));
+
+        /* Wait for request to be marked completed */
+        hg_request_wait(request, HG_MAX_IDLE_TIME, &flag);
+        HG_TEST_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
+            "Operation did not complete");
+
+        /* Free request */
+        hg_request_destroy(request);
     }
 
 done:
@@ -615,8 +616,8 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
 
     NA_Test_barrier(&hg_test_info->na_test_info);
 
+    /* Client sends request to terminate server */
     if (!hg_test_info->na_test_info.listen) {
-        /* Send request to terminate server */
         if (hg_test_info->na_test_info.mpi_comm_rank == 0) {
             hg_uint8_t i, context_count =
                 hg_test_info->na_test_info.max_contexts ?
@@ -624,61 +625,96 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
             for (i = 0; i < context_count; i++)
                 hg_test_finalize_rpc(hg_test_info, i);
         }
+    }
+
+    NA_Test_barrier(&hg_test_info->na_test_info);
 
-        /* Free addr id */
+    /* Free target addr */
+    if (hg_test_info->target_addr != HG_ADDR_NULL) {
         ret = HG_Addr_free(hg_test_info->hg_class, hg_test_info->target_addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not free addr");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_free() failed (%s)",
+            HG_Error_to_string(ret));
+        hg_test_info->target_addr = HG_ADDR_NULL;
     }
 
-    NA_Test_barrier(&hg_test_info->na_test_info);
+    /* Finalize request class */
+    if (hg_test_info->request_class) {
+        hg_request_finalize(hg_test_info->request_class, NULL);
+        hg_test_info->request_class = NULL;
+    }
 
-    if (hg_test_info->na_test_info.listen
-        || hg_test_info->na_test_info.self_send) {
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+    /* Make sure we triggered everything */
+    do {
+        unsigned int actual_count;
+
+        do {
+            ret = HG_Trigger(hg_test_info->context, 0, 1, &actual_count);
+        } while ((ret == HG_SUCCESS) && actual_count);
+        HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done, ret,
+            ret, "Could not trigger callback (%s)", HG_Error_to_string(ret));
+
+        ret = HG_Progress(hg_test_info->context, 100);
+    } while (ret == HG_SUCCESS);
+    HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done, ret,
+        ret, "HG_Progress failed (%s)", HG_Error_to_string(ret));
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+    if (hg_test_info->thread_pool) {
         hg_thread_pool_destroy(hg_test_info->thread_pool);
+        hg_test_info->thread_pool = NULL;
         hg_thread_mutex_destroy(&hg_test_info->bulk_handle_mutex);
+    }
 #endif
-        /* Destroy bulk handle */
-        HG_Bulk_free(hg_test_info->bulk_handle);
-
-        /* Destroy secondary contexts */
-        if (hg_test_info->secondary_contexts) {
-            hg_uint8_t secondary_contexts_count = (hg_uint8_t)
-                (hg_test_info->na_test_info.max_contexts - 1);
-            hg_uint8_t i;
-
-            for (i = 0; i < secondary_contexts_count; i++) {
-                ret = HG_Context_destroy(hg_test_info->secondary_contexts[i]);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not destroy HG context for id: %u", i);
-                    goto done;
-                }
-            }
-            free(hg_test_info->secondary_contexts);
+
+    /* Destroy secondary contexts */
+    if (hg_test_info->secondary_contexts) {
+        hg_uint8_t secondary_contexts_count =
+            (hg_uint8_t) (hg_test_info->na_test_info.max_contexts - 1);
+        hg_uint8_t i;
+
+        for (i = 0; i < secondary_contexts_count; i++) {
+            ret = HG_Context_destroy(hg_test_info->secondary_contexts[i]);
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_destroy() failed"
+                " (%s)", HG_Error_to_string(ret));
         }
+        free(hg_test_info->secondary_contexts);
+        hg_test_info->secondary_contexts = NULL;
+    }
+
+    /* Destroy context */
+    if (hg_test_info->context) {
+        ret = HG_Context_destroy(hg_test_info->context);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_destroy() failed"
+            " (%s)", HG_Error_to_string(ret));
+        hg_test_info->context = NULL;
+    }
+
+    if (hg_test_info->bulk_handle != HG_BULK_NULL) {
+        /* Destroy bulk handle */
+        ret = HG_Bulk_free(hg_test_info->bulk_handle);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+            HG_Error_to_string(ret));
+        hg_test_info->bulk_handle = HG_BULK_NULL;
     }
 
     /* Finalize interface */
-    ret = HG_Hl_finalize();
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize HG Hl");
-        goto done;
+    if (hg_test_info->hg_class) {
+        ret = HG_Finalize(hg_test_info->hg_class);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Finalize() failed (%s)",
+            HG_Error_to_string(ret));
+        hg_test_info->hg_class = NULL;
     }
 
     /* Finalize NA test interface */
     na_ret = NA_Test_finalize(&hg_test_info->na_test_info);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize NA test interface");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "NA_Test_finalize() failed (%s)", NA_Error_to_string(na_ret));
 
     if (hg_test_info->auth) {
-#ifdef HG_TESTING_HAS_CRAY_DRC
-        hg_test_drc_release(hg_test_info);
+#ifdef HG_TEST_HAS_CRAY_DRC
+        ret = hg_test_drc_release(hg_test_info);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "hg_test_drc_release() failed (%s)",
+            HG_Error_to_string(ret));
 #endif
     }
 
diff --git a/Testing/mercury_test.h b/Testing/mercury_test.h
index e74fffe..230f4a9 100644
--- a/Testing/mercury_test.h
+++ b/Testing/mercury_test.h
@@ -12,9 +12,10 @@
 #define MERCURY_TEST_H
 
 #include "na_test.h"
+
 #include "mercury.h"
 #include "mercury_request.h"
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
 # include "mercury_thread_pool.h"
 # include "mercury_thread_mutex.h"
 #endif
@@ -22,12 +23,9 @@
 
 #include "test_rpc.h"
 #include "test_bulk.h"
-#ifndef _WIN32
-# include "test_posix.h"
-#endif
 #include "test_overflow.h"
 
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
 # include <rdmacred.h>
 #endif
 
@@ -36,26 +34,26 @@
 /*************************************/
 
 struct hg_test_info {
+    struct na_test_info na_test_info;
+#ifdef HG_TEST_HAS_THREAD_POOL
+    hg_thread_mutex_t bulk_handle_mutex;
+    hg_thread_pool_t *thread_pool;
+#endif
     hg_class_t *hg_class;
     hg_context_t *context;
     hg_context_t **secondary_contexts;
     hg_request_class_t *request_class;
     hg_addr_t target_addr;
+    hg_bulk_t bulk_handle;
     hg_bool_t auth;
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
     uint32_t credential;
     uint32_t wlm_id;
     drc_info_handle_t credential_info;
     uint32_t cookie;
 #endif
-    hg_bool_t auto_sm;
-    struct na_test_info na_test_info;
     unsigned int thread_count;
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
-    hg_thread_pool_t *thread_pool;
-    hg_thread_mutex_t bulk_handle_mutex;
-#endif
-    hg_bulk_t bulk_handle;
+    hg_bool_t auto_sm;
 };
 
 struct hg_test_context_info {
@@ -68,33 +66,105 @@ struct hg_test_context_info {
 
 /* Default error macro */
 #ifdef HG_HAS_VERBOSE_ERROR
-  #include <mercury_log.h>
-  #define HG_TEST_LOG_MODULE_NAME "HG Test"
-  #define HG_TEST_LOG_ERROR(...)                                \
-      HG_LOG_WRITE_ERROR(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-  #define HG_TEST_LOG_WARNING(...)                              \
-      HG_LOG_WRITE_WARNING(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
+# include <mercury_log.h>
+# define HG_TEST_LOG_MASK hg_test_log_mask
+/* Log mask will be initialized in init routine */
+extern unsigned int HG_TEST_LOG_MASK;
+# define HG_TEST_LOG_MODULE_NAME "HG Test"
+# define HG_TEST_LOG_ERROR(...) do {                                \
+    if (HG_TEST_LOG_MASK & HG_LOG_TYPE_ERROR)                       \
+        HG_LOG_WRITE_ERROR(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__);   \
+} while (0)
+# ifdef HG_HAS_DEBUG
+#  define HG_TEST_LOG_DEBUG(...) do {                               \
+    if (HG_TEST_LOG_MASK & HG_LOG_TYPE_DEBUG)                       \
+        HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__);   \
+} while (0)
+# else
+#  define HG_TEST_LOG_DEBUG(...)    (void)0
+# endif
+# define HG_TEST_LOG_WARNING(...) do {                              \
+    if (HG_TEST_LOG_MASK & HG_LOG_TYPE_WARNING)                     \
+        HG_LOG_WRITE_WARNING(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__); \
+} while (0)
 #else
-  #define HG_TEST_LOG_ERROR(...) (void)0
-  #define HG_TEST_LOG_WARNING(...) (void)0
+# define HG_TEST_LOG_ERROR(...)     (void)0
+# define HG_TEST_LOG_DEBUG(...)     (void)0
+# define HG_TEST_LOG_WARNING(...)   (void)0
 #endif
 
-#define HG_TEST(x) do {         \
-    printf("Testing %-62s", x); \
-    fflush(stdout);             \
+/* Branch predictor hints */
+#ifndef _WIN32
+# define likely(x)       __builtin_expect(!!(x), 1)
+# define unlikely(x)     __builtin_expect(!!(x), 0)
+#else
+# define likely(x)       (x)
+# define unlikely(x)     (x)
+#endif
+
+/* Error macros */
+#define HG_TEST_GOTO_DONE(label, ret, ret_val) do {             \
+    ret = ret_val;                                              \
+    goto label;                                                 \
 } while (0)
 
-#define HG_PASSED() do {        \
-    puts(" PASSED");            \
-    fflush(stdout);             \
+#define HG_TEST_GOTO_ERROR(label, ret, err_val, ...) do {       \
+    HG_LOG_ERROR(__VA_ARGS__);                                  \
+    ret = err_val;                                              \
+    goto label;                                                 \
 } while (0)
 
-#define HG_FAILED() do {        \
-    puts("*FAILED*");           \
-    fflush(stdout);             \
+/* Check for hg_ret value and goto label */
+#define HG_TEST_CHECK_HG_ERROR(label, hg_ret, ...) do {         \
+    if (unlikely(hg_ret != HG_SUCCESS)) {                       \
+        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
+        goto label;                                             \
+    }                                                           \
 } while (0)
 
-#define MERCURY_TESTING_NUM_THREADS_DEFAULT 8
+/* Check for cond, set ret to err_val and goto label */
+#define HG_TEST_CHECK_ERROR(cond, label, ret, err_val, ...) do {\
+    if (unlikely(cond)) {                                       \
+        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
+        ret = err_val;                                          \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define HG_TEST_CHECK_ERROR_NORET(cond, label, ...) do {        \
+    if (unlikely(cond)) {                                       \
+        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define HG_TEST_CHECK_ERROR_DONE(cond, ...) do {                \
+    if (unlikely(cond)) {                                       \
+        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
+    }                                                           \
+} while (0)
+
+/* Check for cond and print warning */
+#define HG_TEST_CHECK_WARNING(cond, ...) do {                   \
+    if (unlikely(cond)) {                                       \
+        HG_TEST_LOG_WARNING(__VA_ARGS__);                       \
+    }                                                           \
+} while (0)
+
+#define HG_TEST(x) do {                                         \
+    printf("Testing %-62s", x);                                 \
+    fflush(stdout);                                             \
+} while (0)
+
+#define HG_PASSED() do {                                        \
+    puts(" PASSED");                                            \
+    fflush(stdout);                                             \
+} while (0)
+
+#define HG_FAILED() do {                                        \
+    puts("*FAILED*");                                           \
+    fflush(stdout);                                             \
+} while (0)
 
 /*********************/
 /* Public Prototypes */
diff --git a/Testing/mercury_test_config.h.in b/Testing/mercury_test_config.h.in
index c1b44f1..18d3712 100644
--- a/Testing/mercury_test_config.h.in
+++ b/Testing/mercury_test_config.h.in
@@ -8,46 +8,74 @@
  * found at the root of the source code distribution tree.
  */
 
+/* Generated file. Only edit mercury_test_config.h.in. */
+
 #ifndef MERCURY_TEST_CONFIG_H
 #define MERCURY_TEST_CONFIG_H
 
-#include <stdio.h>
-#define MERCURY_TESTING_READY_MSG() do {    \
-    /* Used by CTest Test Driver */         \
-    printf("# Waiting for client...\n");    \
-    fflush(stdout);                         \
-} while (0)
+/*************************************/
+/* Public Type and Struct Definition */
+/*************************************/
 
-#cmakedefine MERCURY_HAS_PARALLEL_TESTING
-#ifdef MERCURY_HAS_PARALLEL_TESTING
-#cmakedefine MPIEXEC_EXECUTABLE "@MPIEXEC_EXECUTABLE@"
-#cmakedefine MPIEXEC "@MPIEXEC@" /* For compatibility */
-#ifndef MPIEXEC_EXECUTABLE
-# define MPIEXEC_EXECUTABLE MPIEXEC
-#endif
-#cmakedefine MPIEXEC_NUMPROC_FLAG "@MPIEXEC_NUMPROC_FLAG@"
-#cmakedefine MPIEXEC_PREFLAGS "@MPIEXEC_PREFLAGS@"
-#cmakedefine MPIEXEC_POSTFLAGS "@MPIEXEC_POSTFLAGS@"
-#cmakedefine MPIEXEC_MAX_NUMPROCS @MPIEXEC_MAX_NUMPROCS@
-#endif
 
-#cmakedefine DART_TESTING_TIMEOUT @DART_TESTING_TIMEOUT@
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* MPI flags */
+#cmakedefine HG_TEST_HAS_PARALLEL
+#ifdef HG_TEST_HAS_PARALLEL
+# cmakedefine MPIEXEC_EXECUTABLE        "@MPIEXEC_EXECUTABLE@"
+# cmakedefine MPIEXEC                   "@MPIEXEC@" /* For compatibility */
+# ifndef MPIEXEC_EXECUTABLE
+#  define MPIEXEC_EXECUTABLE MPIEXEC
+# endif
+# cmakedefine MPIEXEC_NUMPROC_FLAG      "@MPIEXEC_NUMPROC_FLAG@"
+# cmakedefine MPIEXEC_PREFLAGS          "@MPIEXEC_PREFLAGS@"
+# cmakedefine MPIEXEC_POSTFLAGS         "@MPIEXEC_POSTFLAGS@"
+/* Server-specific flags if different */
+# cmakedefine MPIEXEC_SERVER_PREFLAGS   "@MPIEXEC_SERVER_PREFLAGS@"
+# cmakedefine MPIEXEC_SERVER_POSTFLAGS  "@MPIEXEC_SERVER_POSTFLAGS@"
+# cmakedefine MPIEXEC_MAX_NUMPROCS      (@MPIEXEC_MAX_NUMPROCS@)
+#endif /* HG_TEST_HAS_PARALLEL */
+
+/* Timeout */
+#cmakedefine DART_TESTING_TIMEOUT   @DART_TESTING_TIMEOUT@
 #ifndef DART_TESTING_TIMEOUT
-# define DART_TESTING_TIMEOUT 1500
+# define DART_TESTING_TIMEOUT   1500
+#endif
+
+/* Init/kill commands */
+#cmakedefine HG_TEST_INIT_COMMAND           "@HG_TEST_INIT_COMMAND@"
+#cmakedefine HG_TEST_SERVER_EXIT_COMMAND    "@HG_TEST_SERVER_EXIT_COMMAND@"
+
+/* Start msg */
+#cmakedefine HG_TEST_SERVER_START_MSG   "@HG_TEST_SERVER_START_MSG@"
+#ifndef HG_TEST_SERVER_START_MSG
+# define HG_TEST_SERVER_START_MSG   "# Waiting for client"
 #endif
+#include <stdio.h>
+#define HG_TEST_READY_MSG() do {            \
+    /* Used by CTest Test Driver */         \
+    printf(HG_TEST_SERVER_START_MSG "\n");  \
+    fflush(stdout);                         \
+} while (0)
 
-#cmakedefine MERCURY_TEST_INIT_COMMAND "@MERCURY_TEST_INIT_COMMAND@"
+/* Test options */
+#cmakedefine HG_TEST_BUFFER_SIZE        (@HG_TEST_BUFFER_SIZE@)
+#cmakedefine HG_TEST_MAX_HANDLES        (@HG_TEST_MAX_HANDLES@)
+#cmakedefine HG_TEST_HAS_THREAD_POOL
+#cmakedefine HG_TEST_HAS_VERIFY_DATA
+#cmakedefine HG_TEST_PRINT_PARTIAL
+#cmakedefine HG_TEST_TEMP_DIRECTORY     "@HG_TEST_TEMP_DIRECTORY@"
 
-#cmakedefine MERCURY_TESTING_BUFFER_SIZE @MERCURY_TESTING_BUFFER_SIZE@
-#cmakedefine MERCURY_TESTING_HAS_THREAD_POOL
-#cmakedefine MERCURY_TESTING_HAS_VERIFY_DATA
-#cmakedefine MERCURY_TESTING_PRINT_PARTIAL
-#cmakedefine MERCURY_TESTING_TEMP_DIRECTORY "@MERCURY_TESTING_TEMP_DIRECTORY@"
+/* Number of threads */
+#define HG_TEST_NUM_THREADS_DEFAULT     (8)
 
 /* Define if has <sys/prctl.h> */
-#cmakedefine HG_TESTING_HAS_SYSPRCTL_H
+#cmakedefine HG_TEST_HAS_SYSPRCTL_H
 
 /* Define if has <rdmacred.h> */
-#cmakedefine HG_TESTING_HAS_CRAY_DRC
+#cmakedefine HG_TEST_HAS_CRAY_DRC
 
 #endif /* MERCURY_TEST_CONFIG_H */
diff --git a/Testing/mercury_test_drc.c b/Testing/mercury_test_drc.c
index b383c1d..c31d194 100644
--- a/Testing/mercury_test_drc.c
+++ b/Testing/mercury_test_drc.c
@@ -125,7 +125,7 @@ hg_proc_hg_test_drc_grant_in_t(hg_proc_t proc, void *data)
 
     ret = hg_proc_hg_uint32_t(proc, &struct_data->wlm_id);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+        HG_TEST_LOG_ERROR("Proc error");
         goto done;
     }
 
@@ -143,13 +143,13 @@ hg_proc_hg_test_drc_grant_out_t(hg_proc_t proc, void *data)
 #ifdef HG_TEST_DRC_USE_TOKEN
     ret = hg_proc_hg_string_t(proc, &struct_data->token);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+        HG_TEST_LOG_ERROR("Proc error");
         goto done;
     }
 #else
     ret = hg_proc_hg_uint32_t(proc, &struct_data->credential);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+        HG_TEST_LOG_ERROR("Proc error");
         goto done;
     }
 #endif
@@ -183,7 +183,7 @@ hg_test_drc_grant_cb(hg_handle_t handle)
     /* Get input buffer */
     ret = HG_Get_input(handle, &in_struct);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get input");
+        HG_TEST_LOG_ERROR("Could not get input");
         goto done;
     }
 
@@ -202,7 +202,7 @@ drc_grant_again:
             sleep(1);
             goto drc_grant_again;
         }
-        HG_LOG_ERROR("drc_grant() to %d failed (%d, %s)", hg_test_info->wlm_id,
+        HG_TEST_LOG_ERROR("drc_grant() to %d failed (%d, %s)", hg_test_info->wlm_id,
             rc, drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -214,7 +214,7 @@ drc_grant_again:
 #ifndef HG_TEST_DRC_IGNORE
     rc = drc_get_credential_token(hg_test_info->credential, &token);
     if (rc != DRC_SUCCESS) {
-        HG_LOG_ERROR("drc_get_credential_token() failed (%d, %s)", rc,
+        HG_TEST_LOG_ERROR("drc_get_credential_token() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -234,7 +234,7 @@ drc_grant_again:
     /* Free handle and send response back */
     ret = HG_Respond(handle, NULL, NULL, &out_struct);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not respond");
+        HG_TEST_LOG_ERROR("Could not respond");
         goto done;
     }
 
@@ -264,7 +264,7 @@ drc_acquire_again:
                 sleep(1);
                 goto drc_acquire_again;
             }
-            HG_LOG_ERROR("drc_acquire() failed (%d, %s)", rc, drc_strerror(-rc));
+            HG_TEST_LOG_ERROR("drc_acquire() failed (%d, %s)", rc, drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
         }
@@ -284,7 +284,7 @@ drc_access_again:
             sleep(1);
             goto drc_access_again;
         }
-        HG_LOG_ERROR("drc_access() failed (%d, %s)", rc,
+        HG_TEST_LOG_ERROR("drc_access() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -329,7 +329,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
         hg_test_info->request_class, hg_test_info->na_test_info.target_name,
         &hg_test_info->target_addr, HG_MAX_IDLE_TIME);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not find addr for target %s",
+        HG_TEST_LOG_ERROR("Could not find addr for target %s",
             hg_test_info->na_test_info.target_name);
         goto done;
     }
@@ -341,7 +341,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
     ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
         hg_test_drc_grant_id_g, &handle);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not create handle");
+        HG_TEST_LOG_ERROR("Could not create handle");
         goto done;
     }
 
@@ -357,7 +357,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
     fflush(stdout);
     ret = HG_Forward(handle, hg_test_drc_token_request_cb, request, &in_struct);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not forward call with id=%d",
+        HG_TEST_LOG_ERROR("Could not forward call with id=%d",
             hg_test_drc_grant_id_g);
         goto done;
     }
@@ -368,7 +368,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
     /* Get output */
     ret = HG_Get_output(handle, &out_struct);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get output");
+        HG_TEST_LOG_ERROR("Could not get output");
         goto done;
     }
 
@@ -382,7 +382,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
 #ifndef HG_TEST_DRC_IGNORE
     rc = drc_access_with_token(token, 0, &hg_test_info->credential_info);
     if (rc != DRC_SUCCESS) {/* failed to grant access to the credential */
-        HG_LOG_ERROR("drc_access_with_token() failed (%d, %s)", rc,
+        HG_TEST_LOG_ERROR("drc_access_with_token() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -403,7 +403,7 @@ drc_access_again:
             sleep(1);
             goto drc_access_again;
         }
-        HG_LOG_ERROR("drc_access() failed (%d, %s)", rc,
+        HG_TEST_LOG_ERROR("drc_access() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -423,13 +423,13 @@ drc_access_again:
     /* Clean up resources */
     ret = HG_Free_output(handle, &out_struct);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free output");
+        HG_TEST_LOG_ERROR("Could not free output");
         goto done;
     }
 
     ret = HG_Destroy(handle);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy handle");
+        HG_TEST_LOG_ERROR("Could not destroy handle");
         goto done;
     }
 
@@ -438,7 +438,7 @@ drc_access_again:
     /* Free target addr */
     ret = HG_Addr_free(hg_test_info->hg_class, hg_test_info->target_addr);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free addr");
+        HG_TEST_LOG_ERROR("Could not free addr");
         goto done;
     }
 
@@ -454,7 +454,7 @@ hg_test_drc_token_request_cb(const struct hg_cb_info *callback_info)
     hg_return_t ret = HG_SUCCESS;
 
     if (callback_info->ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Return from callback info is not HG_SUCCESS");
+        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
         goto done;
     }
 
@@ -468,7 +468,7 @@ hg_return_t
 hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
 {
     struct hg_test_info hg_test_drc_info = { 0 };
-    struct hg_init_info hg_test_drc_init_info = { 0 };
+    struct hg_init_info hg_test_drc_init_info = HG_INIT_INFO_INITIALIZER;
     hg_return_t ret = HG_SUCCESS;
 
     if (!hg_test_info->credential) {
@@ -477,7 +477,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     hg_test_drc_info.na_test_info.protocol = strdup("tcp");
     hg_test_drc_info.na_test_info.listen = hg_test_info->na_test_info.listen;
     if (NA_Test_init(argc, argv, &hg_test_drc_info.na_test_info) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not initialize NA test layer");
+        HG_TEST_LOG_ERROR("Could not initialize NA test layer");
         ret = HG_NA_ERROR;
         goto done;
     }
@@ -489,7 +489,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     ret = HG_Hl_init_opt(NULL, hg_test_drc_info.na_test_info.listen,
         &hg_test_drc_init_info);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not initialize HG HL");
+        HG_TEST_LOG_ERROR("Could not initialize HG HL");
         goto done;
     }
     hg_test_drc_info.hg_class = HG_CLASS_DEFAULT;
@@ -510,21 +510,21 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
         ret = hg_test_drc_token_acquire(&hg_test_drc_info);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not acquire DRC token");
+            HG_TEST_LOG_ERROR("Could not acquire DRC token");
             goto done;
         }
 
         /* TODO only rank 0 */
         ret = HG_Addr_self(hg_test_drc_info.hg_class, &self_addr);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get self addr");
+            HG_TEST_LOG_ERROR("Could not get self addr");
             goto done;
         }
 
         ret = HG_Addr_to_string(hg_test_drc_info.hg_class, addr_string,
             &addr_string_len, self_addr);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not convert addr to string");
+            HG_TEST_LOG_ERROR("Could not convert addr to string");
             goto done;
         }
         HG_Addr_free(hg_test_drc_info.hg_class, self_addr);
@@ -532,7 +532,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
         na_test_set_config(addr_string);
 
         /* Used by CTest Test Driver to know when to launch clients */
-        MERCURY_TESTING_READY_MSG();
+        HG_TEST_READY_MSG();
 
         /* Progress */
         do {
@@ -566,28 +566,28 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
         ret = hg_test_drc_token_request(&hg_test_drc_info);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not request DRC token");
+            HG_TEST_LOG_ERROR("Could not request DRC token");
             goto done;
         }
     }
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     /* TODO bcast cookie when parallel mode */
 #endif
 
     /* Finalize HG HL interface */
     ret = HG_Hl_finalize();
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize HG HL");
+        HG_TEST_LOG_ERROR("Could not finalize HG HL");
         goto done;
     }
 
     /* Finalize NA test class interface */
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     hg_test_drc_info.na_test_info.mpi_no_finalize = NA_TRUE;
 #endif
     if (NA_Test_finalize(&hg_test_drc_info.na_test_info) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize NA test interface");
+        HG_TEST_LOG_ERROR("Could not finalize NA test interface");
         ret = HG_NA_ERROR;
         goto done;
     }
@@ -596,7 +596,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
         hg_test_drc_info.credential = hg_test_info->credential;
         ret = hg_test_drc_token_acquire(&hg_test_drc_info);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not acquire DRC token");
+            HG_TEST_LOG_ERROR("Could not acquire DRC token");
             goto done;
         }
     }
@@ -633,7 +633,7 @@ hg_test_drc_release(struct hg_test_info *hg_test_info)
     if (hg_test_info->credential_info) {
         rc = drc_release_local(&hg_test_info->credential_info);
         if (rc != DRC_SUCCESS) { /* failed to release credential info */
-            HG_LOG_ERROR("Could not release credential info (%d, %s)", rc,
+            HG_TEST_LOG_ERROR("Could not release credential info (%d, %s)", rc,
                 drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
@@ -645,7 +645,7 @@ hg_test_drc_release(struct hg_test_info *hg_test_info)
         rc = drc_revoke(hg_test_info->credential, hg_test_info->wlm_id,
             DRC_FLAGS_TARGET_WLM);
         if (rc != DRC_SUCCESS) { /* failed to release credential info */
-            HG_LOG_ERROR("Could not revoke access for %d (%d, %s)",
+            HG_TEST_LOG_ERROR("Could not revoke access for %d (%d, %s)",
                 hg_test_info->wlm_id, rc, drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
@@ -656,7 +656,7 @@ hg_test_drc_release(struct hg_test_info *hg_test_info)
         printf("# Releasing credential %u\n", hg_test_info->credential);
         rc = drc_release(hg_test_info->credential, 0);
         if (rc != DRC_SUCCESS) { /* failed to release credential */
-            HG_LOG_ERROR("Could not release credential (%d, %s)", rc,
+            HG_TEST_LOG_ERROR("Could not release credential (%d, %s)", rc,
                 drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
diff --git a/Testing/na/na_test.c b/Testing/na/na_test.c
index 0a48600..b72cae1 100644
--- a/Testing/na/na_test.c
+++ b/Testing/na/na_test.c
@@ -29,7 +29,7 @@
 #include <arpa/inet.h>
 #include <netdb.h>
 #include <unistd.h>
-#if defined(HG_TESTING_HAS_SYSPRCTL_H)
+#if defined(HG_TEST_HAS_SYSPRCTL_H)
 #include <sys/prctl.h>
 #endif
 #endif
@@ -51,7 +51,7 @@ static void
 na_test_parse_options(int argc, char *argv[],
     struct na_test_info *na_test_info);
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
 static void
 na_test_mpi_init(struct na_test_info *na_test_info);
 
@@ -71,6 +71,11 @@ extern const char *na_test_opt_arg_g; /* flag argument (or value) */
 extern const char *na_test_short_opt_g;
 extern const struct na_test_opt na_test_opt_g[];
 
+/* Default error log mask */
+#ifdef NA_HAS_VERBOSE_ERROR
+unsigned int NA_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
+#endif
+
 /*---------------------------------------------------------------------------*/
 void
 na_test_usage(const char *execname)
@@ -80,6 +85,7 @@ na_test_usage(const char *execname)
     printf("    -h, --help          Print a usage message and exit\n");
     printf("    -c, --comm          Select NA plugin\n"
            "                        NA plugins: bmi, mpi, cci, etc\n");
+    printf("    -d, --domain        Select NA OFI domain\n");
     printf("    -p, --protocol      Select plugin protocol\n"
            "                        Available protocols: tcp, ib, etc\n");
     printf("    -H, --hostname      Select hostname / IP address to use\n"
@@ -116,6 +122,9 @@ na_test_parse_options(int argc, char *argv[],
                 if (!na_test_info->comm)
                     na_test_info->comm = strdup(na_test_opt_arg_g);
                 break;
+            case 'd': /* Domain */
+                na_test_info->domain = strdup(na_test_opt_arg_g);
+                break;
             case 'p': /* Protocol */
                 /* Prevent from overriding protocol */
                 if (!na_test_info->protocol)
@@ -161,7 +170,7 @@ na_test_parse_options(int argc, char *argv[],
     }
     na_test_opt_ind_g = 1;
 
-    if (!na_test_info->comm || ! na_test_info->protocol) {
+    if (!na_test_info->protocol) {
         na_test_usage(argv[0]);
         exit(1);
     }
@@ -170,7 +179,7 @@ na_test_parse_options(int argc, char *argv[],
 }
 
 /*---------------------------------------------------------------------------*/
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
 static void
 na_test_mpi_init(struct na_test_info *na_test_info)
 {
@@ -262,13 +271,16 @@ na_test_gen_config(struct na_test_info *na_test_info)
     info_string = (char *) malloc(sizeof(char) * NA_TEST_MAX_ADDR_NAME);
     if (!info_string) {
         NA_LOG_ERROR("Could not allocate info string");
-        ret = NA_NOMEM_ERROR;
+        ret = NA_NOMEM;
         goto done;
     }
     memset(info_string, '\0', NA_TEST_MAX_ADDR_NAME);
     info_string_ptr = info_string;
-    info_string_ptr += sprintf(info_string_ptr, "%s+%s", na_test_info->comm,
-        na_test_info->protocol);
+    if (na_test_info->comm)
+        info_string_ptr += sprintf(info_string_ptr, "%s+", na_test_info->comm);
+    info_string_ptr += sprintf(info_string_ptr, "%s://", na_test_info->protocol);
+    if (na_test_info->domain)
+        info_string_ptr += sprintf(info_string_ptr, "%s/", na_test_info->domain);
 
     if (strcmp("sm", na_test_info->protocol) == 0) {
 #if defined(PR_SET_PTRACER) && defined(PR_SET_PTRACER_ANY)
@@ -291,7 +303,7 @@ na_test_gen_config(struct na_test_info *na_test_info)
 #endif
         if (na_test_info->listen) {
             /* special-case SM (pid:id) */
-            sprintf(info_string_ptr, "://%d/%d", (int) getpid(), port_incr);
+            sprintf(info_string_ptr, "%d/%d", (int) getpid(), port_incr);
         }
     } else if ((strcmp("tcp", na_test_info->protocol) == 0)
         || (strcmp("verbs;ofi_rxm", na_test_info->protocol) == 0)
@@ -302,21 +314,21 @@ na_test_gen_config(struct na_test_info *na_test_info)
             /* Nothing */
         } else if (na_test_info->listen) {
             base_port += (unsigned int) na_test_info->mpi_comm_rank;
-            sprintf(info_string_ptr, "://%s:%d", na_test_info->hostname,
+            sprintf(info_string_ptr, "%s:%d", na_test_info->hostname,
                 base_port + port_incr);
         } else
-            sprintf(info_string_ptr, "://%s", na_test_info->hostname);
+            sprintf(info_string_ptr, "%s", na_test_info->hostname);
     } else if (strcmp("static", na_test_info->protocol) == 0) {
         /* Nothing */
     } else if (strcmp("dynamic", na_test_info->protocol) == 0) {
         /* Nothing */
     } else if (strcmp("gni", na_test_info->protocol) == 0) {
         base_port += (unsigned int) na_test_info->mpi_comm_rank;
-        sprintf(info_string_ptr, "://%s:%d", na_test_info->hostname,
+        sprintf(info_string_ptr, "%s:%d", na_test_info->hostname,
             base_port + port_incr);
     } else {
         NA_LOG_ERROR("Unknown protocol: %s", na_test_info->protocol);
-        ret = NA_INVALID_PARAM;
+        ret = NA_INVALID_ARG;
         goto done;
     }
 
@@ -336,10 +348,10 @@ na_test_set_config(const char *addr_name)
 {
     FILE *config = NULL;
 
-    config = fopen(MERCURY_TESTING_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME, "w+");
+    config = fopen(HG_TEST_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME, "w+");
     if (!config) {
         NA_LOG_ERROR("Could not open config file from: %s",
-            MERCURY_TESTING_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME);
+            HG_TEST_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME);
         exit(1);
     }
     fprintf(config, "%s\n", addr_name);
@@ -352,10 +364,10 @@ na_test_get_config(char *addr_name, na_size_t len)
 {
     FILE *config = NULL;
 
-    config = fopen(MERCURY_TESTING_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME, "r");
+    config = fopen(HG_TEST_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME, "r");
     if (!config) {
         NA_LOG_ERROR("Could not open config file from: %s",
-            MERCURY_TESTING_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME);
+            HG_TEST_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME);
         exit(1);
     }
     if (fgets(addr_name, (int) len, config) == NULL) {
@@ -373,12 +385,12 @@ na_return_t
 NA_Test_init(int argc, char *argv[], struct na_test_info *na_test_info)
 {
     char *info_string = NULL;
-    struct na_init_info na_init_info;
+    struct na_init_info na_init_info = NA_INIT_INFO_INITIALIZER;
     na_return_t ret = NA_SUCCESS;
 
     na_test_parse_options(argc, argv, na_test_info);
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     /* Test run in parallel using mpirun so must intialize MPI to get
      * basic setup info etc */
     na_test_mpi_init(na_test_info);
@@ -401,12 +413,10 @@ NA_Test_init(int argc, char *argv[], struct na_test_info *na_test_info)
     if (na_test_info->listen && na_test_info->mpi_comm_rank == 0)
         NA_Cleanup();
 
-    memset(&na_init_info, 0, sizeof(struct na_init_info));
     if (na_test_info->busy_wait) {
         na_init_info.progress_mode = NA_NO_BLOCK;
         printf("# Initializing NA in busy wait mode\n");
-    } else
-        na_init_info.progress_mode = NA_DEFAULT;
+    }
     na_init_info.auth_key = na_test_info->key;
     na_init_info.max_contexts = na_test_info->max_contexts;
 
@@ -441,20 +451,20 @@ NA_Test_init(int argc, char *argv[], struct na_test_info *na_test_info)
 
             na_test_set_config(addr_string);
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
             /* If static client must wait for server to write config file */
             if (na_test_info->mpi_static)
                 MPI_Barrier(MPI_COMM_WORLD);
 #endif
 
             /* Used by CTest Test Driver to know when to launch clients */
-            MERCURY_TESTING_READY_MSG();
+            HG_TEST_READY_MSG();
         }
         /* Get config from file if self option is not passed */
         else if (!na_test_info->self_send) {
             char test_addr_name[NA_TEST_MAX_ADDR_NAME] = { '\0' };
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
             /* If static client must wait for server to write config file */
             if (na_test_info->mpi_static)
                 MPI_Barrier(MPI_COMM_WORLD);
@@ -463,7 +473,7 @@ NA_Test_init(int argc, char *argv[], struct na_test_info *na_test_info)
                 na_test_get_config(test_addr_name, NA_TEST_MAX_ADDR_NAME);
             }
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
             /* Broadcast addr name */
             MPI_Bcast(test_addr_name, NA_TEST_MAX_ADDR_NAME, MPI_BYTE, 0,
                 na_test_info->mpi_comm);
@@ -498,7 +508,7 @@ NA_Test_finalize(struct na_test_info *na_test_info)
     free(na_test_info->hostname);
     free(na_test_info->key);
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     na_test_mpi_finalize(na_test_info);
 #endif
 
@@ -510,7 +520,7 @@ done:
 void
 NA_Test_barrier(struct na_test_info *na_test_info)
 {
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     MPI_Barrier(na_test_info->mpi_comm);
 #else
     (void) na_test_info;
@@ -521,7 +531,7 @@ NA_Test_barrier(struct na_test_info *na_test_info)
 void
 NA_Test_bcast(char *buf, int count, int root, struct na_test_info *na_test_info)
 {
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     MPI_Bcast(buf, count, MPI_BYTE, root, na_test_info->mpi_comm);
 #else
     (void) na_test_info;
diff --git a/Testing/na/na_test.h b/Testing/na/na_test.h
index 62c1b61..67023f7 100644
--- a/Testing/na/na_test.h
+++ b/Testing/na/na_test.h
@@ -15,7 +15,7 @@
 #include "na.h"
 #include "na_error.h"
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
 # include <mpi.h>
 #endif
 
@@ -27,6 +27,7 @@ struct na_test_info {
     na_class_t *na_class;       /* NA class */
     char *target_name;          /* Target name */
     char *comm;                 /* Comm/Plugin name */
+    char *domain;               /* Domain name */
     char *protocol;             /* Protocol name */
     char *hostname;             /* Hostname */
     na_bool_t listen;           /* Listen */
@@ -39,7 +40,7 @@ struct na_test_info {
     na_uint8_t max_contexts;    /* Max contexts */
     na_bool_t verbose;          /* Verbose mode */
     int max_number_of_peers;    /* Max number of peers */
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     MPI_Comm mpi_comm;          /* MPI comm */
     na_bool_t mpi_no_finalize;  /* Prevent from finalizing MPI */
 #endif
diff --git a/Testing/na/na_test_getopt.c b/Testing/na/na_test_getopt.c
index 3f2005d..54f9c8d 100644
--- a/Testing/na/na_test_getopt.c
+++ b/Testing/na/na_test_getopt.c
@@ -17,10 +17,11 @@
 
 int na_test_opt_ind_g = 1; /* token pointer */
 const char *na_test_opt_arg_g = NULL; /* flag argument (or value) */
-const char *na_test_short_opt_g = "hc:p:H:LsSak:l:t:bmC:V";
+const char *na_test_short_opt_g = "hc:d:p:H:LsSak:l:t:bmC:V";
 const struct na_test_opt na_test_opt_g[] = {
     { "help", no_arg, 'h'},
     { "comm", require_arg, 'c' },
+    { "domain", require_arg, 'd' },
     { "protocol", require_arg, 'p' },
     { "hostname", require_arg, 'H' },
     { "listen", no_arg, 'L' },
diff --git a/Testing/na/test_lat_client.c b/Testing/na/test_lat_client.c
index e0d2c16..cd03c5e 100644
--- a/Testing/na/test_lat_client.c
+++ b/Testing/na/test_lat_client.c
@@ -120,18 +120,21 @@ na_test_target_lookup(struct na_test_lat_info *na_test_lat_info)
 {
     struct na_test_target_lookup_arg request_args = { 0 };
     hg_request_t *request = NULL;
+    na_op_id_t op_id = NA_OP_ID_NULL;
     na_return_t ret = NA_SUCCESS;
 
     request = hg_request_create(na_test_lat_info->request_class);
     request_args.addr_ptr = &na_test_lat_info->target_addr;
     request_args.request = request;
 
+    op_id = NA_Op_create(na_test_lat_info->na_class);
+
     /* Forward call to remote addr and get a new request */
     ret = NA_Addr_lookup(na_test_lat_info->na_class, na_test_lat_info->context,
         na_test_target_lookup_cb, &request_args,
-        na_test_lat_info->na_test_info.target_name, NA_OP_ID_IGNORE);
+        na_test_lat_info->na_test_info.target_name, &op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not lookup address");
+        NA_LOG_ERROR("Could not lookup address (%s)", NA_Error_to_string(ret));
         goto done;
     }
 
@@ -139,6 +142,7 @@ na_test_target_lookup(struct na_test_lat_info *na_test_lat_info)
     hg_request_wait(request, NA_MAX_IDLE_TIME, NULL);
 
 done:
+    NA_Op_destroy(na_test_lat_info->na_class, op_id);
     hg_request_destroy(request);
     return ret;
 }
@@ -217,16 +221,21 @@ na_test_measure_latency(struct na_test_lat_info *na_test_lat_info,
             recv_buf, buf_size, recv_buf_data, na_test_lat_info->target_addr, 0,
             0, &recv_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_recv_expected() failed");
+            NA_LOG_ERROR("NA_Msg_recv_expected() failed (%s)", NA_Error_to_string(ret));
             goto done;
         }
 
+again:
         /* Post send */
         ret = NA_Msg_send_unexpected(na_test_lat_info->na_class,
             na_test_lat_info->context, NULL, NULL, send_buf, buf_size,
             send_buf_data, na_test_lat_info->target_addr, 0, 0, &send_op_id);
+        if (ret == NA_AGAIN) {
+            hg_request_wait(recv_request, 0, NULL);
+            goto again;
+        }
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_send_unexpected() failed");
+            NA_LOG_ERROR("NA_Msg_send_unexpected() failed (%s)", NA_Error_to_string(ret));
             goto done;
         }
 
@@ -248,7 +257,7 @@ na_test_measure_latency(struct na_test_lat_info *na_test_lat_info,
             recv_buf, buf_size, recv_buf_data, na_test_lat_info->target_addr, 0,
             1, &recv_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_recv_expected() failed");
+            NA_LOG_ERROR("NA_Msg_recv_expected() failed (%s)", NA_Error_to_string(ret));
             goto done;
         }
 
@@ -258,7 +267,7 @@ na_test_measure_latency(struct na_test_lat_info *na_test_lat_info,
             send_buf_data, na_test_lat_info->target_addr, 0, 1,
             &send_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_send_unexpected() failed");
+            NA_LOG_ERROR("NA_Msg_send_unexpected() failed (%s)", NA_Error_to_string(ret));
             goto done;
         }
 
@@ -269,7 +278,7 @@ na_test_measure_latency(struct na_test_lat_info *na_test_lat_info,
 
         hg_request_reset(recv_request);
 
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
     /* Check recv buf */
     const char *recv_buf_ptr = (const char*) recv_buf;
 
@@ -285,7 +294,7 @@ na_test_measure_latency(struct na_test_lat_info *na_test_lat_info,
 #endif
 
     /* At this point we have received everything so work out the bandwidth */
-#ifdef MERCURY_TESTING_PRINT_PARTIAL
+#ifdef HG_TEST_PRINT_PARTIAL
         read_lat = time_read * 1.0e6
             / (double) ((avg_iter + 1) * 2 *
                 (unsigned int) na_test_lat_info->na_test_info.mpi_comm_size);
@@ -294,7 +303,7 @@ na_test_measure_latency(struct na_test_lat_info *na_test_lat_info,
                 NDIGITS, read_lat);
 #endif
     }
-#ifndef MERCURY_TESTING_PRINT_PARTIAL
+#ifndef HG_TEST_PRINT_PARTIAL
     read_lat = time_read * 1.0e6
         / (double) (loop * 2 *
             (unsigned int) na_test_lat_info->na_test_info.mpi_comm_size);
@@ -326,6 +335,8 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
         NA_Msg_get_unexpected_header_size(na_test_lat_info->na_class);
     na_size_t buf_size =
         (unexpected_header_size) ? unexpected_header_size + 1 : 1;
+    na_op_id_t send_op_id;
+    na_op_id_t recv_op_id;
     na_return_t ret = NA_SUCCESS;
 
     /* Prepare send_buf */
@@ -338,15 +349,18 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
         &recv_buf_data);
     memset(recv_buf, 0, buf_size);
 
+    send_op_id = NA_Op_create(na_test_lat_info->na_class);
+    recv_op_id = NA_Op_create(na_test_lat_info->na_class);
+
     recv_request = hg_request_create(na_test_lat_info->request_class);
 
     /* Post recv */
     ret = NA_Msg_recv_expected(na_test_lat_info->na_class,
         na_test_lat_info->context, na_test_recv_expected_cb, recv_request,
         recv_buf, buf_size, recv_buf_data, na_test_lat_info->target_addr, 0,
-        NA_TEST_TAG_DONE, NA_OP_ID_IGNORE);
+        NA_TEST_TAG_DONE, &recv_op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("NA_Msg_recv_expected() failed");
+        NA_LOG_ERROR("NA_Msg_recv_expected() failed (%s)", NA_Error_to_string(ret));
         goto done;
     }
 
@@ -354,9 +368,9 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
     ret = NA_Msg_send_unexpected(na_test_lat_info->na_class,
         na_test_lat_info->context, NULL, NULL, send_buf, buf_size,
         send_buf_data, na_test_lat_info->target_addr, 0, NA_TEST_TAG_DONE,
-        NA_OP_ID_IGNORE);
+        &send_op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("NA_Msg_send_unexpected() failed");
+        NA_LOG_ERROR("NA_Msg_send_unexpected() failed (%s)", NA_Error_to_string(ret));
         goto done;
     }
 
@@ -365,6 +379,8 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
 done:
     /* Clean up resources */
     hg_request_destroy(recv_request);
+    NA_Op_destroy(na_test_lat_info->na_class, send_op_id);
+    NA_Op_destroy(na_test_lat_info->na_class, recv_op_id);
     NA_Msg_buf_free(na_test_lat_info->na_class, send_buf, send_buf_data);
     NA_Msg_buf_free(na_test_lat_info->na_class, recv_buf, recv_buf_data);
     return ret;
@@ -395,7 +411,7 @@ main(int argc, char *argv[])
         fprintf(stdout, "# %s v%s\n", BENCHMARK_NAME, VERSION_NAME);
         fprintf(stdout, "# Loop %d times from size %d to %zu byte(s)\n",
             na_test_lat_info.na_test_info.loop, 1, max_size);
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
         fprintf(stdout, "# WARNING verifying data, output will be slower\n");
 #endif
         fprintf(stdout, "%-*s%*s\n", 10, "# Size", NWIDTH,
diff --git a/Testing/na/test_lat_server.c b/Testing/na/test_lat_server.c
index ea48512..c54f3bb 100644
--- a/Testing/na/test_lat_server.c
+++ b/Testing/na/test_lat_server.c
@@ -112,7 +112,7 @@ na_test_recv_unexpected_cb(const struct na_cb_info *na_cb_info)
     na_return_t ret;
 
     na_test_source_recv_arg->tag = na_cb_info->info.recv_unexpected.tag;
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
     if (na_test_source_recv_arg->tag != NA_TEST_TAG_DONE) {
         /* Check recv buf */
         const char *recv_buf_ptr = (const char*) na_test_source_recv_arg->recv_buf;
@@ -142,7 +142,7 @@ na_test_recv_unexpected_cb(const struct na_cb_info *na_cb_info)
         na_cb_info->info.recv_unexpected.tag,
         &na_test_source_recv_arg->send_op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("NA_Msg_send_expected() failed");
+        NA_LOG_ERROR("NA_Msg_send_expected() failed (%s)", NA_Error_to_string(ret));
     }
 
     NA_Addr_free(na_test_lat_info->na_class,
@@ -210,7 +210,7 @@ na_test_loop_latency(struct na_test_lat_info *na_test_lat_info)
             &na_test_source_recv_arg, recv_buf, unexpected_size,
             recv_buf_data, &recv_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_recv_unexpected() failed");
+            NA_LOG_ERROR("NA_Msg_recv_unexpected() failed (%s)", NA_Error_to_string(ret));
             goto done;
         }
 
diff --git a/Testing/script/travis_build.sh b/Testing/script/travis_build.sh
index 32cc97f..69997f2 100755
--- a/Testing/script/travis_build.sh
+++ b/Testing/script/travis_build.sh
@@ -1,11 +1,10 @@
 #!/bin/bash
 
 BMI_VERSION=master
-CMAKE_VERSION_MAJOR=3.15
-CMAKE_VERSION_MINOR=1
-MPI_VERSION=3.3.1
-CCI_VERSION=2.1
-OFI_VERSION=1.8.0
+CMAKE_VERSION_MAJOR=3.16
+CMAKE_VERSION_MINOR=5
+MPI_VERSION=3.3.2
+OFI_VERSION=1.9.1
 PREFIX=$HOME/install
 
 set -e
@@ -52,16 +51,6 @@ if [[ $TRAVIS_OS_NAME == 'linux' ]]; then
     echo "Using cached directory for MPI";
   fi
 
-  # CCI
-  if [ ! -f "$PREFIX/bin/cci_info" ]; then
-    cd $HOME && wget http://cci-forum.com/wp-content/uploads/2017/05/cci-${CCI_VERSION}.tar.gz
-    tar -xzf cci-${CCI_VERSION}.tar.gz && cd cci-${CCI_VERSION};
-    patch -p1 < ${TRAVIS_BUILD_DIR}/Testing/script/cci_20170918.patch
-    ./configure --disable-silent-rules --disable-static --prefix=$PREFIX && make -j2 -s && make install;
-  else
-    echo "Using cached directory for CCI";
-  fi
-
   # OFI
   if [ -f "$PREFIX/ofi_version.txt" ]; then
     OFI_INSTALLED_VERSION=`cat $PREFIX/ofi_version.txt`;
diff --git a/Testing/script/travis_script.cmake b/Testing/script/travis_script.cmake
index 4a9d46f..391f21a 100644
--- a/Testing/script/travis_script.cmake
+++ b/Testing/script/travis_script.cmake
@@ -54,7 +54,7 @@ set(CTEST_TEST_TIMEOUT 180) # 180s timeout
 set(MERCURY_DO_COVERAGE $ENV{MERCURY_DO_COVERAGE})
 if(MERCURY_DO_COVERAGE)
   message("Enabling Coverage")
-  set(CTEST_COVERAGE_COMMAND "/usr/bin/gcov-8")
+  set(CTEST_COVERAGE_COMMAND "/usr/bin/$ENV{COV}")
   # don't run parallel coverage tests, no matter what.
   set(CTEST_TEST_ARGS PARALLEL_LEVEL 1)
 
@@ -118,14 +118,12 @@ if(APPLE)
   set(PROC_NAME_OPT -c)
   set(USE_BMI OFF)
   set(USE_MPI OFF)
-  set(USE_CCI OFF)
   set(USE_SM OFF)
 else()
   set(SOEXT so)
   set(PROC_NAME_OPT -r)
   set(USE_BMI ON)
   set(USE_MPI ON)
-  set(USE_CCI ON)
   set(USE_SM ON)
   set(CMAKE_FIND_ROOT_PATH $ENV{HOME}/install ${CMAKE_FIND_ROOT_PATH})
 endif()
@@ -147,7 +145,6 @@ MEMORYCHECK_SUPPRESSIONS_FILE:FILEPATH=${CTEST_MEMORYCHECK_SUPPRESSIONS_FILE}
 COVERAGE_COMMAND:FILEPATH=${CTEST_COVERAGE_COMMAND}
 
 MERCURY_ENABLE_COVERAGE:BOOL=${dashboard_do_coverage}
-MERCURY_ENABLE_PARALLEL_TESTING:BOOL=${USE_MPI}
 MERCURY_USE_BOOST_PP:BOOL=OFF
 MERCURY_USE_SELF_FORWARD:BOOL=ON
 MERCURY_USE_XDR:BOOL=OFF
@@ -155,14 +152,16 @@ NA_USE_BMI:BOOL=${USE_BMI}
 BMI_INCLUDE_DIR:PATH=$ENV{HOME}/install/include
 BMI_LIBRARY:FILEPATH=$ENV{HOME}/install/lib/libbmi.${SOEXT}
 NA_USE_MPI:BOOL=${USE_MPI}
-NA_USE_CCI:BOOL=${USE_CCI}
-NA_CCI_TESTING_PROTOCOL:STRING=
+NA_USE_CCI:BOOL=OFF
 NA_USE_SM:BOOL=${USE_SM}
 NA_USE_OFI:BOOL=ON
 NA_OFI_TESTING_PROTOCOL:STRING=sockets;tcp
 MPIEXEC_MAX_NUMPROCS:STRING=4
 
-MERCURY_TEST_INIT_COMMAND:STRING=killall -9 ${PROC_NAME_OPT} hg_test_client;killall -9 ${PROC_NAME_OPT} hg_test_server;
+MERCURY_TESTING_ENABLE_PARALLEL:BOOL=${USE_MPI}
+MERCURY_TESTING_INIT_COMMAND:STRING=killall -9 ${PROC_NAME_OPT} hg_test_server;
+MERCURY_TESTING_BUFFER_SIZE:STRING=1
+MERCURY_TESTING_MAX_HANDLES:STRING=1
 MERCURY_TESTING_CORESIDENT:BOOL=ON
 ")
 
diff --git a/Testing/test_bulk.c b/Testing/test_bulk.c
index cfb31f2..cbbb630 100644
--- a/Testing/test_bulk.c
+++ b/Testing/test_bulk.c
@@ -13,10 +13,15 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-extern hg_id_t hg_test_bulk_write_id_g;
-extern hg_id_t hg_test_bulk_bind_write_id_g;
+/****************/
+/* Local Macros */
+/****************/
 
-#define BUFSIZE (MERCURY_TESTING_BUFFER_SIZE * 1024 * 1024)
+#define BUFSIZE (HG_TEST_BUFFER_SIZE * 1024 * 1024)
+
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
 
 struct forward_cb_args {
     hg_request_t *request;
@@ -24,18 +29,21 @@ struct forward_cb_args {
     hg_return_t ret;
 };
 
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
+/********************/
+/* Local Prototypes */
+/********************/
+
+static hg_return_t
+hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info);
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+extern hg_id_t hg_test_bulk_write_id_g;
+extern hg_id_t hg_test_bulk_bind_write_id_g;
 
 /*---------------------------------------------------------------------------*/
-/**
- * HG_Forward callback
- */
 static hg_return_t
 hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -45,32 +53,24 @@ hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info)
     bulk_write_out_t bulk_write_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
 
     /* Get output */
     ret = HG_Get_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not get output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get output parameters */
     bulk_write_ret = bulk_write_out_struct.ret;
-    if (bulk_write_ret != args->expected_bytes) {
-        HG_TEST_LOG_ERROR("Returned: %zu bytes, was expecting %zu",
-            bulk_write_ret, args->expected_bytes);
-        args->ret = HG_SIZE_ERROR;
-    }
+    HG_TEST_CHECK_ERROR(bulk_write_ret != args->expected_bytes, done,
+        args->ret, HG_MSGSIZE, "Returned: %zu bytes, was expecting %zu",
+        bulk_write_ret, args->expected_bytes);
 
     /* Free request */
     ret = HG_Free_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not free output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     hg_request_complete(args->request);
@@ -87,32 +87,24 @@ hg_test_bulk_bind_forward_cb(const struct hg_cb_info *callback_info)
     bulk_bind_write_out_t bulk_write_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
 
     /* Get output */
     ret = HG_Get_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not get output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get output parameters */
     bulk_write_ret = bulk_write_out_struct.ret;
-    if (bulk_write_ret != args->expected_bytes) {
-        HG_TEST_LOG_ERROR("Returned: %zu bytes, was expecting %zu",
-            bulk_write_ret, args->expected_bytes);
-        args->ret = HG_SIZE_ERROR;
-    }
+    HG_TEST_CHECK_ERROR(bulk_write_ret != args->expected_bytes, done,
+        args->ret, HG_MSGSIZE, "Returned: %zu bytes, was expecting %zu",
+        bulk_write_ret, args->expected_bytes);
 
     /* Free request */
     ret = HG_Free_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not free output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     hg_request_complete(args->request);
@@ -140,14 +132,14 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
     hg_cb_t forward_cb = hg_test_bulk_forward_cb;
     size_t i;
 
-    if (origin_offset + transfer_size > bulk_size) {
-        HG_LOG_ERROR("Exceeding bulk size");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(origin_offset + transfer_size > bulk_size, done, ret,
+        HG_OVERFLOW, "Exceeding bulk size");
 
     /* Prepare bulk_buf */
     bulk_buf = malloc(bulk_size);
+    HG_TEST_CHECK_ERROR(bulk_buf == NULL, done, ret, HG_NOMEM_ERROR,
+         "Could not allocate bulk_buf");
+
     for (i = 0; i < bulk_size; i++)
         bulk_buf[i] = (char) i;
     buf_ptrs[0] = bulk_buf;
@@ -160,10 +152,8 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
     /* Register memory */
     ret = HG_Bulk_create(hg_class, 2, buf_ptrs, buf_sizes, HG_BULK_READ_ONLY,
         &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     if (bind_addr) {
         /* Bind local context to bulk, it is only necessary if this bulk handle
@@ -171,19 +161,16 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
          * should also work for normal case. Add here just to test the
          * functionality. */
         ret = HG_Bulk_bind(bulk_handle, context);
-        if (ret != HG_SUCCESS) {
-            HG_TEST_LOG_ERROR("Could not bind context to bulk handle");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_bind() failed (%s)",
+            HG_Error_to_string(ret));
+
         rpc_id = hg_test_bulk_bind_write_id_g;
         forward_cb = hg_test_bulk_bind_forward_cb;
     }
 
     ret = HG_Create(context, target_addr, rpc_id, &handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     bulk_write_in_struct.fildes = 0;
@@ -202,26 +189,20 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
     forward_cb_args.ret = HG_SUCCESS;
     ret = HG_Forward(handle, forward_cb, &forward_cb_args,
         &bulk_write_in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Complete */
     ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_destroy(request);
 
@@ -253,20 +234,26 @@ hg_test_bulk_seg(hg_class_t *hg_class, hg_context_t *context,
     hg_size_t bulk_size = BUFSIZE;
     size_t i;
 
-    if (origin_offset + transfer_size > bulk_size) {
-        HG_LOG_ERROR("Exceeding bulk size");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(origin_offset + transfer_size > bulk_size, done, ret,
+        HG_OVERFLOW, "Exceeding bulk size");
 
     /* Prepare bulk_buf */
     buf_ptrs = (void **) malloc(origin_segment_count * sizeof(void *));
+    HG_TEST_CHECK_ERROR(buf_ptrs == NULL, done, ret, HG_NOMEM_ERROR,
+         "Could not allocate buf_ptrs");
+
     buf_sizes = (hg_size_t *) malloc(origin_segment_count * sizeof(hg_size_t));
+    HG_TEST_CHECK_ERROR(buf_sizes == NULL, done, ret, HG_NOMEM_ERROR,
+         "Could not allocate buf_sizes");
+
     for (i = 0; i < origin_segment_count; i++) {
         hg_size_t j;
 
         buf_sizes[i] = bulk_size / origin_segment_count;
         buf_ptrs[i] = malloc(buf_sizes[i]);
+        HG_TEST_CHECK_ERROR(buf_ptrs == NULL, done, ret, HG_NOMEM_ERROR,
+             "Could not allocate bulk_buf");
+
         for (j = 0; j < buf_sizes[i]; j++) {
             ((char **) buf_ptrs)[i][j] = (char) (i * buf_sizes[i] + j);
         }
@@ -275,18 +262,14 @@ hg_test_bulk_seg(hg_class_t *hg_class, hg_context_t *context,
     request = hg_request_create(request_class);
 
     ret = HG_Create(context, target_addr, hg_test_bulk_write_id_g, &handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Register memory */
     ret = HG_Bulk_create(hg_class, origin_segment_count, buf_ptrs,
         buf_sizes, HG_BULK_READ_ONLY, &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     bulk_write_in_struct.fildes = 0;
@@ -306,26 +289,20 @@ hg_test_bulk_seg(hg_class_t *hg_class, hg_context_t *context,
     forward_cb_args.ret = HG_SUCCESS;
     ret = HG_Forward(handle, hg_test_bulk_forward_cb, &forward_cb_args,
             &bulk_write_in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Complete */
     ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_destroy(request);
 
@@ -360,11 +337,8 @@ hg_test_bulk_small(hg_class_t *hg_class, hg_context_t *context,
     hg_size_t bulk_size = 12;
     size_t i;
 
-    if (origin_offset + transfer_size > bulk_size) {
-        HG_LOG_ERROR("Exceeding bulk size");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(origin_offset + transfer_size > bulk_size, done, ret,
+        HG_OVERFLOW, "Exceeding bulk size");
 
     /* Prepare bulk buf */
     for (i = 0; i < bulk_size; i++)
@@ -373,18 +347,14 @@ hg_test_bulk_small(hg_class_t *hg_class, hg_context_t *context,
     request = hg_request_create(request_class);
 
     ret = HG_Create(context, target_addr, hg_test_bulk_write_id_g, &handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Register memory */
     ret = HG_Bulk_create(hg_class, 2, buf_ptrs, buf_sizes, HG_BULK_READ_ONLY,
         &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     bulk_write_in_struct.fildes = 1;
@@ -404,26 +374,20 @@ hg_test_bulk_small(hg_class_t *hg_class, hg_context_t *context,
     forward_cb_args.ret = HG_SUCCESS;
     ret = HG_Forward(handle, hg_test_bulk_forward_cb, &forward_cb_args,
             &bulk_write_in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Complete */
     ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_destroy(request);
 
@@ -435,146 +399,126 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-int main(int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
     struct hg_test_info hg_test_info = { 0 };
     hg_return_t hg_ret;
     int ret = EXIT_SUCCESS;
 
     /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
+    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
     /* Simple RPC bulk test */
     HG_TEST("contiguous RPC bulk (size BUFSIZE, offsets 0, 0)");
     hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, 0, hg_test_info.target_addr, BUFSIZE, 0, 0);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "contiguous RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("contiguous RPC bulk (size BUFSIZE/4, offsets BUFSIZE/2 + 1, 0)");
     hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, 0, hg_test_info.target_addr, BUFSIZE/4,
         BUFSIZE/2 + 1, 0);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "contiguous RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("contiguous RPC bulk (size BUFSIZE/8, offsets BUFSIZE/2 + 1, BUFSIZE/4)");
     hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, 0, hg_test_info.target_addr, BUFSIZE/8,
         BUFSIZE/2 + 1, BUFSIZE/4);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "contiguous RPC bulk failed");
     HG_PASSED();
 
     /* small bulk test */
     HG_TEST("small segmented RPC bulk (size 8, offsets 0, 0)");
     hg_ret = hg_test_bulk_small(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 8, 0, 0);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "small segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("small segmented RPC bulk (size 4, offsets 8, 0)");
     hg_ret = hg_test_bulk_small(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 4, 8, 0);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "small segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("small segmented RPC bulk (size 8, offsets 4, 2)");
     hg_ret = hg_test_bulk_small(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 8, 4, 2);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "small segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("segmented RPC bulk (size BUFSIZE, offsets 0, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE, 0, 0, 16);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("segmented RPC bulk (size BUFSIZE/4, offsets BUFSIZE/2 + 1, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/4,
         BUFSIZE/2 + 1, 0, 16);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("segmented RPC bulk (size BUFSIZE/8, offsets BUFSIZE/2 + 1, BUFSIZE/4)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/8,
         BUFSIZE/2 + 1, BUFSIZE/4, 16);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("over-segmented RPC bulk (size BUFSIZE, offsets 0, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE, 0, 0,
         1024);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "over-segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("over-segmented RPC bulk (size BUFSIZE/4, offsets BUFSIZE/2 + 1, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/4,
         BUFSIZE/2 + 1, 0, 1024);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "over-segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("over-segmented RPC bulk (size BUFSIZE/8, offsets BUFSIZE/2 + 1, BUFSIZE/4)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/8,
         BUFSIZE/2 + 1, BUFSIZE/4, 1024);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "over-segmented RPC bulk failed");
     HG_PASSED();
 
     if (strcmp(HG_Class_get_name(hg_test_info.hg_class), "ofi") == 0) {
         HG_TEST("bind contiguous RPC bulk (size BUFSIZE, offsets 0, 0)");
         hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
             hg_test_info.request_class, 1, hg_test_info.target_addr, BUFSIZE, 0, 0);
-        if (hg_ret != HG_SUCCESS) {
-            ret = EXIT_FAILURE;
-            goto done;
-        }
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "bind contiguous RPC bulk failed");
         HG_PASSED();
     }
 
 done:
     if (ret != EXIT_SUCCESS)
         HG_FAILED();
-    HG_Test_finalize(&hg_test_info);
+
+    hg_ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
+
     return ret;
 }
diff --git a/Testing/test_bulk.h b/Testing/test_bulk.h
index 02eecaf..ecafb96 100644
--- a/Testing/test_bulk.h
+++ b/Testing/test_bulk.h
@@ -45,34 +45,24 @@ hg_proc_bulk_write_in_t(hg_proc_t proc, void *data)
     bulk_write_in_t *struct_data = (bulk_write_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fildes);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_size_t(proc, &struct_data->transfer_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_size_t(proc, &struct_data->origin_offset);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_size_t(proc, &struct_data->target_offset);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -90,10 +80,8 @@ hg_proc_bulk_write_out_t(hg_proc_t proc, void *data)
     bulk_write_out_t *struct_data = (bulk_write_out_t *) data;
 
     ret = hg_proc_hg_size_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -112,16 +100,12 @@ hg_proc_bulk_bind_write_out_t(hg_proc_t proc, void *data)
     bulk_bind_write_out_t *struct_data = (bulk_bind_write_out_t *) data;
 
     ret = hg_proc_hg_size_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
diff --git a/Testing/test_bulk_seg.c b/Testing/test_bulk_seg.c
deleted file mode 100644
index c025d3f..0000000
--- a/Testing/test_bulk_seg.c
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#include "mercury_test.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-extern hg_id_t hg_test_bulk_seg_write_id_g;
-
-static hg_return_t
-hg_test_bulk_seg_forward_cb(const struct hg_cb_info *callback_info)
-{
-    hg_handle_t handle = callback_info->info.forward.handle;
-    hg_request_t *request = (hg_request_t *) callback_info->arg;
-    size_t bulk_write_ret = 0;
-    bulk_write_out_t bulk_write_out_struct;
-    hg_return_t ret = HG_SUCCESS;
-
-    /* Get output */
-    ret = HG_Get_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get output\n");
-        goto done;
-    }
-
-    /* Get output parameters */
-    bulk_write_ret = bulk_write_out_struct.ret;
-    printf("bulk_write returned: %zu\n", bulk_write_ret);
-
-    /* Free request */
-    ret = HG_Free_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free output\n");
-        goto done;
-    }
-
-    hg_request_complete(request);
-
-done:
-    return ret;
-}
-
-/*****************************************************************************/
-int main(int argc, char *argv[])
-{
-    struct hg_test_info hg_test_info = { 0 };
-    hg_request_t *request = NULL;
-    hg_handle_t handle;
-
-    bulk_write_in_t bulk_write_in_struct;
-
-    int fildes = 12345;
-    void **bulk_buf;
-    size_t *bulk_sizes;
-    size_t bulk_size = 1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE / sizeof(int);
-    size_t bulk_size_x = 16;
-    size_t bulk_size_y = 0;
-    size_t *bulk_size_y_var = NULL;
-    hg_bulk_t bulk_handle = HG_BULK_NULL;
-
-    hg_return_t hg_ret;
-    size_t i, j;
-
-    /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
-
-    request = hg_request_create(hg_test_info.request_class);
-
-    hg_ret = HG_Create(hg_test_info.context, hg_test_info.target_addr,
-        hg_test_bulk_seg_write_id_g, &handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not start call\n");
-        return EXIT_FAILURE;
-    }
-
-    /* This will create a list of variable size segments */
-//    if (hg_test_info.variable) {
-//        printf("Using variable size segments!\n");
-//        /* bulk_size_x >= 2 */
-//        /* 524288 + 262144 + 131072 + 65536 + 32768 + 16384 + 8192 + 8192 */
-//        bulk_size_x = 8;
-//        bulk_size_y_var = (size_t*) malloc(bulk_size_x * sizeof(size_t));
-//        bulk_size_y_var[0] = bulk_size / 2;
-//        for (i = 1; i < bulk_size_x - 1; i++) {
-//            bulk_size_y_var[i] = bulk_size_y_var[i-1] / 2;
-//        }
-//        bulk_size_y_var[bulk_size_x - 1] = bulk_size_y_var[bulk_size_x - 2];
-//    }
-//    /* This will use an extra encoding buffer */
-//    else if (hg_test_info.extra) {
-//        printf("Using large number of segments!\n");
-//        bulk_size_x = 1024;
-//        bulk_size_y = bulk_size / bulk_size_x;
-//    }
-//    else {
-        /* This will create a list of fixed size segments */
-        bulk_size_y = bulk_size / bulk_size_x;
-//    }
-
-    /* Prepare bulk_buf */
-    bulk_buf = (void **) malloc(bulk_size_x * sizeof(void *));
-    bulk_sizes = (size_t *) malloc(bulk_size_x * sizeof(size_t));
-    if (bulk_size_y_var) {
-        int val = 0;
-        for (i = 0; i < bulk_size_x; i++) {
-            bulk_sizes[i] = bulk_size_y_var[i] * sizeof(int);
-            bulk_buf[i] = malloc(bulk_sizes[i]);
-            for (j = 0; j < bulk_size_y_var[i]; j++) {
-                ((int **) (bulk_buf))[i][j] = val;
-                val++;
-            }
-        }
-    } else {
-        for (i = 0; i < bulk_size_x; i++) {
-            bulk_sizes[i] = bulk_size_y * sizeof(int);
-            bulk_buf[i] = malloc(bulk_sizes[i]);
-            for (j = 0; j < bulk_size_y; j++) {
-                ((int **) (bulk_buf))[i][j] = (int) (i * bulk_size_y + j);
-            }
-        }
-    }
-
-    /* Register memory */
-    hg_ret = HG_Bulk_create(hg_test_info.hg_class, (hg_uint32_t) bulk_size_x,
-        bulk_buf, (hg_size_t *) bulk_sizes, HG_BULK_READ_ONLY, &bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    free(bulk_sizes);
-    bulk_sizes = NULL;
-    if (bulk_size_y_var) free(bulk_size_y_var);
-    bulk_size_y_var = NULL;
-
-    /* Fill input structure */
-    bulk_write_in_struct.fildes = fildes;
-    bulk_write_in_struct.bulk_handle = bulk_handle;
-
-    /* Forward call to remote addr and get a new request */
-    printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_seg_write_id_g);
-    hg_ret = HG_Forward(handle, hg_test_bulk_seg_forward_cb, request,
-            &bulk_write_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not forward call\n");
-        return EXIT_FAILURE;
-    }
-
-    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
-
-    /* Free memory handle */
-    hg_ret = HG_Bulk_free(bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Complete */
-    hg_ret = HG_Destroy(handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not complete\n");
-        return EXIT_FAILURE;
-    }
-
-    hg_request_destroy(request);
-
-    HG_Test_finalize(&hg_test_info);
-
-    /* Free bulk_buf */
-    for (i = 0; i < bulk_size_x; i++) {
-        free(bulk_buf[i]);
-        bulk_buf[i] = NULL;
-    }
-    free(bulk_buf);
-    bulk_buf = NULL;
-
-    return EXIT_SUCCESS;
-}
diff --git a/Testing/test_cancel.c b/Testing/test_cancel.c
deleted file mode 100644
index 5e1b834..0000000
--- a/Testing/test_cancel.c
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#include "mercury_test.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-extern hg_id_t hg_test_cancel_rpc_id_g;
-
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
-
-/*---------------------------------------------------------------------------*/
-/**
- * HG_Forward callback
- */
-static hg_return_t
-hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
-{
-    hg_request_t *request = (hg_request_t *) callback_info->arg;
-    hg_return_t ret = HG_SUCCESS;
-
-    if (callback_info->ret != HG_CANCELED) {
-        HG_TEST_LOG_DEBUG("Error: HG_Forward() was not canceled: %d",
-            callback_info->ret);
-    } else {
-        HG_TEST_LOG_DEBUG("HG_Forward() was successfully canceled");
-    }
-
-    hg_request_complete(request);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
-{
-    hg_request_t *request = NULL;
-    hg_handle_t handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    request = hg_request_create(request_class);
-
-    /* Create RPC request */
-    ret = HG_Create(context, addr, rpc_id, &handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
-
-    /* Forward call to remote addr and get a new request */
-    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
-    ret = HG_Forward(handle, callback, request, NULL);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
-
-    /* Cancel request */
-    ret = HG_Cancel(handle);
-    if (ret != HG_SUCCESS && ret != HG_CANCEL_ERROR) {
-        HG_TEST_LOG_ERROR("Could not cancel call");
-        goto done;
-    }
-
-    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
-
-    /* Complete */
-    ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
-
-done:
-    hg_request_destroy(request);
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-int
-main(int argc, char *argv[])
-{
-    struct hg_test_info hg_test_info = { 0 };
-    hg_return_t hg_ret;
-    int ret = EXIT_SUCCESS;
-
-    /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
-
-    /* Skip for OFI/tcp for now (cancelation of unexpected send is not
-     * guaranteed by underlying provider) */
-    if (!(strcmp(HG_Class_get_name(hg_test_info.hg_class), "ofi"))
-        && !strcmp(hg_test_info.na_test_info.protocol, "tcp"))
-        goto done;
-
-    /* Cancel RPC test */
-    HG_TEST("cancel RPC");
-    hg_ret = hg_test_cancel_rpc(hg_test_info.context,
-        hg_test_info.request_class, hg_test_info.target_addr,
-        hg_test_cancel_rpc_id_g, hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
-    HG_PASSED();
-
-done:
-    if (ret != EXIT_SUCCESS)
-        HG_FAILED();
-    HG_Test_finalize(&hg_test_info);
-    return ret;
-}
diff --git a/Testing/test_multiple.c b/Testing/test_multiple.c
deleted file mode 100644
index 6c80d21..0000000
--- a/Testing/test_multiple.c
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#include "mercury_test.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-extern hg_id_t hg_test_rpc_open_id_g;
-extern hg_id_t hg_test_bulk_write_id_g;
-
-/******************************************************************************/
-int main(int argc, char *argv[])
-{
-    hg_addr_t addr;
-
-    rpc_open_in_t  rpc_open_in_struct;
-    rpc_open_out_t rpc_open_out_struct;
-    hg_request_t rpc_open_request;
-
-    bulk_write_in_t bulk_write_in_struct;
-    bulk_write_out_t bulk_write_out_struct;
-    hg_request_t bulk_write_request;
-
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
-    rpc_handle_t rpc_open_handle;
-    int rpc_open_ret = 0;
-    int rpc_open_event_id = 0;
-
-    int fildes = 12345;
-    int *bulk_buf = NULL;
-    size_t bulk_size = 1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE / sizeof(int);
-    hg_bulk_t bulk_handle = HG_BULK_NULL;
-    size_t bulk_write_ret = 0;
-
-    hg_status_t rpc_open_status;
-    hg_status_t bulk_write_status;
-    hg_return_t hg_ret;
-    size_t i;
-
-    /* Prepare bulk_buf */
-    bulk_buf = (int*) malloc(sizeof(int) * bulk_size);
-    for (i = 0; i < bulk_size; i++) {
-        bulk_buf[i] = i;
-    }
-
-    /* Initialize the interface (for convenience, shipper_test_client_init
-     * initializes the network interface with the selected plugin)
-     */
-    HG_Test_client_init(argc, argv, &addr, NULL);
-
-    /* Register memory */
-    hg_ret = HG_Bulk_handle_create(bulk_buf, sizeof(int) * bulk_size, HG_BULK_READ_ONLY,
-            &bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Fill input structure */
-    rpc_open_handle.cookie = 12345;
-    rpc_open_in_struct.path = rpc_open_path;
-    rpc_open_in_struct.handle = rpc_open_handle;
-    bulk_write_in_struct.fildes = fildes;
-    bulk_write_in_struct.bulk_handle = bulk_handle;
-
-    /* Forward call to remote addr and get a new request */
-    printf("Forwarding rpc_open, op id: %u...\n", hg_test_rpc_open_id_g);
-    hg_ret = HG_Forward(addr, hg_test_rpc_open_id_g, &rpc_open_in_struct,
-            &rpc_open_out_struct, &rpc_open_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not forward call\n");
-        return EXIT_FAILURE;
-    }
-    printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_write_id_g);
-    hg_ret = HG_Forward(addr, hg_test_bulk_write_id_g,
-            &bulk_write_in_struct, &bulk_write_out_struct, &bulk_write_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not forward call\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Wait for call to be executed and return value to be sent back
-     * (Request is freed when the call completes)
-     */
-    hg_ret = HG_Wait(rpc_open_request, HG_MAX_IDLE_TIME, &rpc_open_status);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Error during wait\n");
-        return EXIT_FAILURE;
-    }
-    if (!rpc_open_status) {
-        fprintf(stderr, "Operation did not complete\n");
-        return EXIT_FAILURE;
-    } else {
-        printf("Call completed\n");
-    }
-    hg_ret = HG_Wait(bulk_write_request, HG_MAX_IDLE_TIME, &bulk_write_status);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Error during wait\n");
-        return EXIT_FAILURE;
-    }
-    if (!bulk_write_status) {
-        fprintf(stderr, "Operation did not complete\n");
-        return EXIT_FAILURE;
-    } else {
-        printf("Call completed\n");
-    }
-
-    /* Get output parameters */
-    rpc_open_ret = rpc_open_out_struct.ret;
-    rpc_open_event_id = rpc_open_out_struct.event_id;
-    printf("rpc_open returned: %d with event_id: %d\n", rpc_open_ret, rpc_open_event_id);
-    bulk_write_ret = bulk_write_out_struct.ret;
-    printf("bulk_write returned: %lu\n", bulk_write_ret);
-
-    /* Free request */
-    hg_ret = HG_Request_free(rpc_open_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free request\n");
-        return EXIT_FAILURE;
-    }
-    hg_ret = HG_Request_free(bulk_write_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free request\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Free memory handle */
-    hg_ret = HG_Bulk_handle_free(bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Free bulk data */
-    free(bulk_buf);
-
-    HG_Test_finalize();
-
-    return EXIT_SUCCESS;
-}
diff --git a/Testing/test_multiple.h b/Testing/test_multiple.h
deleted file mode 100644
index b497125..0000000
--- a/Testing/test_multiple.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#ifndef TEST_MULTIPLE_H
-#define TEST_MULTIPLE_H
-
-#include "test_rpc.h"
-#include "test_bulk.h"
-
-#endif /* TEST_MULTIPLE_H */
diff --git a/Testing/test_overflow.c b/Testing/test_overflow.c
deleted file mode 100644
index 49499a6..0000000
--- a/Testing/test_overflow.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#include "mercury_test.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-extern hg_id_t hg_test_overflow_id_g;
-
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
-{
-    hg_handle_t handle = callback_info->info.forward.handle;
-    hg_request_t *request = (hg_request_t *) callback_info->arg;
-    overflow_out_t out_struct;
-    hg_string_t string;
-    size_t string_len;
-    hg_return_t ret = HG_SUCCESS;
-
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_WARNING("Return from callback info is not HG_SUCCESS");
-        goto done;
-    }
-
-    /* Get output */
-    ret = HG_Get_output(handle, &out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not get output");
-        goto done;
-    }
-
-    /* Get output parameters */
-    string = out_struct.string;
-    string_len = out_struct.string_len;
-    HG_TEST_LOG_DEBUG("Returned string (length %zu): %s", string_len, string);
-    (void) string;
-    (void) string_len;
-
-    /* Free request */
-    ret = HG_Free_output(handle, &out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not free output");
-        goto done;
-    }
-
-done:
-    hg_request_complete(request);
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_overflow(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
-{
-    hg_request_t *request = NULL;
-    hg_handle_t handle;
-    hg_return_t hg_ret = HG_SUCCESS;
-
-    request = hg_request_create(request_class);
-
-    /* Create RPC request */
-    hg_ret = HG_Create(context, addr, rpc_id, &handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
-
-    /* Forward call to remote addr and get a new request */
-    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
-    hg_ret = HG_Forward(handle, callback, request, NULL);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
-
-    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
-
-    /* Complete */
-    hg_ret = HG_Destroy(handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
-
-done:
-    hg_request_destroy(request);
-    return hg_ret;
-}
-
-/*---------------------------------------------------------------------------*/
-int
-main(int argc, char *argv[])
-{
-    struct hg_test_info hg_test_info = { 0 };
-    hg_return_t hg_ret;
-    int ret = EXIT_SUCCESS;
-
-    /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
-
-    /* Overflow RPC test */
-    HG_TEST("overflow RPC");
-    hg_ret = hg_test_overflow(hg_test_info.context, hg_test_info.request_class,
-        hg_test_info.target_addr, hg_test_overflow_id_g,
-        hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
-    HG_PASSED();
-
-done:
-    if (ret != EXIT_SUCCESS)
-        HG_FAILED();
-    HG_Test_finalize(&hg_test_info);
-    return ret;
-}
diff --git a/Testing/test_overflow.h b/Testing/test_overflow.h
index 7fad03a..b85a72c 100644
--- a/Testing/test_overflow.h
+++ b/Testing/test_overflow.h
@@ -32,16 +32,12 @@ hg_proc_overflow_out_t(hg_proc_t proc, void *data)
     overflow_out_t *struct_data = (overflow_out_t *) data;
 
     ret = hg_proc_hg_string_t(proc, &struct_data->string);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_uint64_t(proc, &struct_data->string_len);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
diff --git a/Testing/test_perf.c b/Testing/test_perf.c
index 7da5abe..bc9e2db 100644
--- a/Testing/test_perf.c
+++ b/Testing/test_perf.c
@@ -171,7 +171,7 @@ measure_rpc2(struct hg_test_info *hg_test_info)
     hg_request_t *request;
     struct hg_test_perf_args args;
     double time_read = 0, min_time_read = -1, max_time_read = 0;
-    unsigned int nhandles = MERCURY_TESTING_NUM_THREADS_DEFAULT * 2;
+    unsigned int nhandles = HG_TEST_NUM_THREADS_DEFAULT * 2;
     hg_return_t ret = HG_SUCCESS;
     size_t i;
     unsigned int op_count = 0;
@@ -478,7 +478,7 @@ main(int argc, char *argv[])
 {
     struct hg_test_info hg_test_info = { 0 };
     size_t size_small = 1024; /* Use small values for eager message */
-    size_t size_big = (1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE);
+    size_t size_big = (1024 * 1024 * HG_TEST_BUFFER_SIZE);
 
     HG_Test_init(argc, argv, &hg_test_info);
 
diff --git a/Testing/test_pipeline.c b/Testing/test_pipeline.c
deleted file mode 100644
index 9f540a0..0000000
--- a/Testing/test_pipeline.c
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#include "mercury_test.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-extern hg_id_t hg_test_pipeline_write_id_g;
-
-/*****************************************************************************/
-int main(int argc, char *argv[])
-{
-    hg_addr_t addr;
-
-    bulk_write_in_t bulk_write_in_struct;
-    bulk_write_out_t bulk_write_out_struct;
-    hg_request_t bulk_write_request;
-
-    int fildes = 12345;
-    int *bulk_buf;
-    void *buf_ptr[1];
-    size_t count = (1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE) / sizeof(int);
-    size_t bulk_size = count * sizeof(int);
-    hg_bulk_t bulk_handle = HG_BULK_NULL;
-    size_t bulk_write_ret = 0;
-
-    hg_status_t bla_open_status;
-    hg_return_t hg_ret;
-    size_t i;
-
-    /* Initialize the interface (for convenience, shipper_test_client_init
-     * initializes the network interface with the selected plugin)
-     */
-    HG_Test_client_init(argc, argv, &addr, NULL);
-
-    /* Prepare bulk_buf */
-    bulk_buf = (int*) malloc(bulk_size);
-    for (i = 0; i < count; i++) {
-        bulk_buf[i] = (int) i;
-    }
-    *buf_ptr = bulk_buf;
-
-    /* Register memory */
-    hg_ret = HG_Bulk_handle_create(1, buf_ptr, &bulk_size,
-            HG_BULK_READ_ONLY, &bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Fill input structure */
-    bulk_write_in_struct.fildes = fildes;
-    bulk_write_in_struct.bulk_handle = bulk_handle;
-
-    /* Forward call to remote addr and get a new request */
-    /* printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_write_id_g); */
-    hg_ret = HG_Forward(addr, hg_test_pipeline_write_id_g,
-            &bulk_write_in_struct, &bulk_write_out_struct, &bulk_write_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not forward call\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Wait for call to be executed and return value to be sent back
-     * (Request is freed when the call completes)
-     */
-    hg_ret = HG_Wait(bulk_write_request, HG_MAX_IDLE_TIME, &bla_open_status);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Error during wait\n");
-        return EXIT_FAILURE;
-    }
-    if (!bla_open_status) {
-        fprintf(stderr, "Operation did not complete\n");
-        return EXIT_FAILURE;
-    } else {
-        /* printf("Call completed\n"); */
-    }
-
-    /* Get output parameters */
-    bulk_write_ret = bulk_write_out_struct.ret;
-    if (bulk_write_ret != bulk_size) {
-        fprintf(stderr, "Data not correctly processed\n");
-    }
-
-    /* Free request */
-    hg_ret = HG_Request_free(bulk_write_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free request\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Free memory handle */
-    hg_ret = HG_Bulk_handle_free(bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Free bulk_buf */
-    free(bulk_buf);
-    bulk_buf = NULL;
-
-    HG_Test_finalize();
-
-    return EXIT_SUCCESS;
-}
diff --git a/Testing/test_posix.c b/Testing/test_posix.c
index 267cefb..5d40abb 100644
--- a/Testing/test_posix.c
+++ b/Testing/test_posix.c
@@ -350,7 +350,7 @@ main(int argc, char *argv[])
     addr = hg_test_info.target_addr;
     rank = hg_test_info.na_test_info.mpi_comm_rank;
 #endif
-    sprintf(filename, MERCURY_TESTING_TEMP_DIRECTORY "/posix_test%d", rank);
+    sprintf(filename, HG_TEST_TEMP_DIRECTORY "/posix_test%d", rank);
 
     /* Prepare buffers */
     write_buf = (int*) malloc(sizeof(int) * n_ints);
diff --git a/Testing/test_posix.h b/Testing/test_posix.h
index 770f946..9e88136 100644
--- a/Testing/test_posix.h
+++ b/Testing/test_posix.h
@@ -66,22 +66,16 @@ hg_proc_open_in_t(hg_proc_t proc, void *data)
     open_in_t *struct_data = (open_in_t *) data;
 
     ret = hg_proc_hg_const_string_t(proc, &struct_data->path);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_int32_t(proc, &struct_data->flags);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_uint32_t(proc, &struct_data->mode);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -99,10 +93,8 @@ hg_proc_open_out_t(hg_proc_t proc, void *data)
     open_out_t *struct_data = (open_out_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -120,10 +112,8 @@ hg_proc_close_in_t(hg_proc_t proc, void *data)
     close_in_t *struct_data = (close_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fd);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -141,10 +131,8 @@ hg_proc_close_out_t(hg_proc_t proc, void *data)
     close_out_t *struct_data = (close_out_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -163,16 +151,12 @@ hg_proc_write_in_t(hg_proc_t proc, void *data)
     write_in_t *struct_data = (write_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fd);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -190,10 +174,8 @@ hg_proc_write_out_t(hg_proc_t proc, void *data)
     write_out_t *struct_data = (write_out_t *) data;
 
     ret = hg_proc_int64_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -212,16 +194,12 @@ hg_proc_read_in_t(hg_proc_t proc, void *data)
     read_in_t *struct_data = (read_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fd);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -239,10 +217,8 @@ hg_proc_read_out_t(hg_proc_t proc, void *data)
     read_out_t *struct_data = (read_out_t *) data;
 
     ret = hg_proc_int64_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
diff --git a/Testing/test_read_bw.c b/Testing/test_read_bw.c
index 37a5648..b2c7727 100644
--- a/Testing/test_read_bw.c
+++ b/Testing/test_read_bw.c
@@ -15,26 +15,32 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+/****************/
+/* Local Macros */
+/****************/
+
 #define BENCHMARK_NAME "Read BW (server bulk push)"
 #define STRING(s) #s
 #define XSTRING(s) STRING(s)
-#define VERSION_NAME \
-    XSTRING(HG_VERSION_MAJOR) \
-    "." \
-    XSTRING(HG_VERSION_MINOR) \
-    "." \
+#define VERSION_NAME            \
+    XSTRING(HG_VERSION_MAJOR)   \
+    "."                         \
+    XSTRING(HG_VERSION_MINOR)   \
+    "."                         \
     XSTRING(HG_VERSION_PATCH)
 
-#define SMALL_SKIP 20
-#define LARGE_SKIP 10
-#define LARGE_SIZE 8192
+#define SMALL_SKIP      20
+#define LARGE_SKIP      10
+#define LARGE_SIZE      8192
 
-#define NDIGITS 2
-#define NWIDTH 20
-#define MAX_MSG_SIZE (MERCURY_TESTING_BUFFER_SIZE * 1024 * 1024)
-#define MAX_HANDLES 16
+#define NDIGITS         2
+#define NWIDTH          20
+#define MAX_MSG_SIZE    (HG_TEST_BUFFER_SIZE * 1024 * 1024)
+#define MAX_HANDLES     (HG_TEST_MAX_HANDLES)
 
-extern hg_id_t hg_test_perf_bulk_read_id_g;
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
 
 struct hg_test_perf_args {
     hg_request_t *request;
@@ -42,6 +48,23 @@ struct hg_test_perf_args {
     hg_atomic_int32_t op_completed_count;
 };
 
+/********************/
+/* Local Prototypes */
+/********************/
+
+static hg_return_t
+hg_test_perf_forward_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
+    unsigned int nhandles);
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+extern hg_id_t hg_test_perf_bulk_read_id_g;
+
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -49,13 +72,13 @@ hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
         (struct hg_test_perf_args *) callback_info->arg;
 
     if ((unsigned int) hg_atomic_incr32(&args->op_completed_count)
-        == args->op_count) {
+        == args->op_count)
         hg_request_complete(args->request);
-    }
 
     return HG_SUCCESS;
 }
 
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
     unsigned int nhandles)
@@ -80,6 +103,8 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Prepare bulk_buf */
     bulk_buf = malloc(nbytes);
+    HG_TEST_CHECK_ERROR(bulk_buf == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate bulk buf");
     for (i = 0; i < nbytes; i++)
         bulk_buf[i] = 1;
     buf_ptrs = (void **) &bulk_buf;
@@ -87,13 +112,14 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Create handles */
     handles = malloc(nhandles * sizeof(hg_handle_t));
+    HG_TEST_CHECK_ERROR(handles == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate handles");
+
     for (i = 0; i < nhandles; i++) {
         ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
             hg_test_perf_bulk_read_id_g, &handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not start call\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     request = hg_request_create(hg_test_info->request_class);
@@ -104,10 +130,8 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
     /* Register memory */
     ret = HG_Bulk_create(hg_test_info->hg_class, 1, buf_ptrs,
         (hg_size_t *) buf_sizes, HG_BULK_READWRITE, &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     in_struct.fildes = 0;
@@ -118,11 +142,10 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         unsigned int j;
 
         for (j = 0; j < nhandles; j++) {
-            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args, &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
-            }
+            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
+                &in_struct);
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -140,11 +163,10 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         hg_time_get_current(&t1);
 
         for (j = 0; j < nhandles; j++) {
-            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args, &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
-            }
+            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
+                &in_struct);
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -155,7 +177,7 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         hg_request_reset(request);
         hg_atomic_set32(&args.op_completed_count, 0);
 
-#ifdef MERCURY_TESTING_PRINT_PARTIAL
+#ifdef HG_TEST_PRINT_PARTIAL
         read_bandwidth = nmbytes
             * (double) (nhandles * (avg_iter + 1) *
                 (unsigned int) hg_test_info->na_test_info.mpi_comm_size)
@@ -166,7 +188,7 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
             fprintf(stdout, "%-*d%*.*f\r", 10, (int) nbytes, NWIDTH,
                 NDIGITS, read_bandwidth);
 #endif
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
         for (i = 0; i < nbytes; i++) {
             if (bulk_buf[i] != (char) i) {
                 printf("Error detected in bulk transfer, buf[%d] = %d, "
@@ -177,7 +199,7 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         }
 #endif
     }
-#ifndef MERCURY_TESTING_PRINT_PARTIAL
+#ifndef HG_TEST_PRINT_PARTIAL
     read_bandwidth = nmbytes
         * (double) (nhandles * loop *
             (unsigned int) hg_test_info->na_test_info.mpi_comm_size)
@@ -192,19 +214,15 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Complete */
     hg_request_destroy(request);
     for (i = 0; i < nhandles; i++) {
         ret = HG_Destroy(handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not complete\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
 done:
@@ -220,8 +238,12 @@ main(int argc, char *argv[])
     struct hg_test_info hg_test_info = { 0 };
     unsigned int nhandles;
     size_t size;
+    hg_return_t hg_ret;
+    int ret = EXIT_SUCCESS;
 
-    HG_Test_init(argc, argv, &hg_test_info);
+    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
     for (nhandles = 1; nhandles <= MAX_HANDLES; nhandles *= 2) {
         if (hg_test_info.na_test_info.mpi_comm_rank == 0) {
@@ -229,7 +251,7 @@ main(int argc, char *argv[])
             fprintf(stdout, "# Loop %d times from size %d to %d byte(s) with "
                 "%u handle(s)\n",
                 hg_test_info.na_test_info.loop, 1, MAX_MSG_SIZE, nhandles);
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
             fprintf(stdout, "# WARNING verifying data, output will be slower\n");
 #endif
             fprintf(stdout, "%-*s%*s\n", 10, "# Size", NWIDTH,
@@ -237,13 +259,18 @@ main(int argc, char *argv[])
             fflush(stdout);
         }
 
-        for (size = 1; size <= MAX_MSG_SIZE; size *= 2)
-            measure_bulk_transfer(&hg_test_info, size, nhandles);
+        for (size = 1; size <= MAX_MSG_SIZE; size *= 2) {
+            hg_ret = measure_bulk_transfer(&hg_test_info, size, nhandles);
+            HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+                "measure_bulk_transfer() failed");
+        }
 
         fprintf(stdout, "\n");
     }
 
-    HG_Test_finalize(&hg_test_info);
+done:
+    hg_ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
 
-    return EXIT_SUCCESS;
+    return ret;
 }
diff --git a/Testing/test_rpc.c b/Testing/test_rpc.c
index 67834dd..77c8fa3 100644
--- a/Testing/test_rpc.c
+++ b/Testing/test_rpc.c
@@ -13,28 +13,73 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-extern hg_id_t hg_test_rpc_open_id_g;
-extern hg_id_t hg_test_rpc_open_id_no_resp_g;
+/****************/
+/* Local Macros */
+/****************/
 
-#define NINFLIGHT 32
+#define NINFLIGHT   (HG_TEST_MAX_HANDLES)
+
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
 
 struct forward_cb_args {
     hg_request_t *request;
     rpc_handle_t *rpc_handle;
 };
 
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
+struct lookup_cb_args {
+    hg_request_t *request;
+    hg_addr_t *addr_ptr;
+};
+
+/********************/
+/* Local Prototypes */
+/********************/
+
+static hg_return_t
+hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+hg_test_rpc_forward_no_resp_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+hg_test_rpc_lookup_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+hg_test_rpc_forward_reset_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+hg_test_rpc_forward_overflow_cb(const struct hg_cb_info *callback_info);
+
+static hg_return_t
+hg_test_rpc(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_rpc_lookup(hg_context_t *context, hg_request_class_t *request_class,
+    const char *target_name, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_uint8_t target_id, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_overflow(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+extern hg_id_t hg_test_rpc_open_id_g;
+extern hg_id_t hg_test_rpc_open_id_no_resp_g;
+extern hg_id_t hg_test_overflow_id_g;
+extern hg_id_t hg_test_cancel_rpc_id_g;
 
 /*---------------------------------------------------------------------------*/
-/**
- * HG_Forward callback
- */
 static hg_return_t
 hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -45,17 +90,16 @@ hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
     rpc_open_out_t rpc_open_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_DEBUG("Return from callback info is not HG_SUCCESS");
+    if (callback_info->ret == HG_NOENTRY)
         goto done;
-    }
+
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
 
     /* Get output */
     ret = HG_Get_output(handle, &rpc_open_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not get output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get output parameters */
     rpc_open_ret = rpc_open_out_struct.ret;
@@ -63,17 +107,13 @@ hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
     HG_TEST_LOG_DEBUG("rpc_open returned: %d with event_id: %d", rpc_open_ret,
         rpc_open_event_id);
     (void)rpc_open_ret;
-    if (rpc_open_event_id != (int) args->rpc_handle->cookie) {
-        HG_TEST_LOG_ERROR("Cookie did not match RPC response");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(rpc_open_event_id != (int) args->rpc_handle->cookie,
+        done, ret, HG_FAULT, "Cookie did not match RPC response");
 
     /* Free request */
     ret = HG_Free_output(handle, &rpc_open_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not free output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     hg_request_complete(args->request);
@@ -81,19 +121,14 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-/**
- * HG_Forward callback (no response)
- */
 static hg_return_t
 hg_test_rpc_forward_no_resp_cb(const struct hg_cb_info *callback_info)
 {
     struct forward_cb_args *args = (struct forward_cb_args *) callback_info->arg;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
 
 done:
     hg_request_complete(args->request);
@@ -102,21 +137,31 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
+hg_test_rpc_lookup_cb(const struct hg_cb_info *callback_info)
+{
+    struct lookup_cb_args *request_args =
+        (struct lookup_cb_args *) callback_info->arg;
+
+    *request_args->addr_ptr = callback_info->info.lookup.addr;
+
+    hg_request_complete(request_args->request);
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
 hg_test_rpc_forward_reset_cb(const struct hg_cb_info *callback_info)
 {
     struct forward_cb_args *args = (struct forward_cb_args *) callback_info->arg;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
 
     ret = HG_Reset(callback_info->info.forward.handle, HG_ADDR_NULL, 0);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not reset handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Reset() failed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     hg_request_complete(args->request);
@@ -125,26 +170,77 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
+hg_test_rpc_forward_overflow_cb(const struct hg_cb_info *callback_info)
+{
+    hg_handle_t handle = callback_info->info.forward.handle;
+    hg_request_t *request = (hg_request_t *) callback_info->arg;
+    overflow_out_t out_struct;
+    hg_string_t string;
+    size_t string_len;
+    hg_return_t ret = HG_SUCCESS;
+
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
+
+    /* Get output */
+    ret = HG_Get_output(handle, &out_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
+        HG_Error_to_string(ret));
+
+    /* Get output parameters */
+    string = out_struct.string;
+    string_len = out_struct.string_len;
+    HG_TEST_LOG_DEBUG("Returned string (length %zu): %s", string_len, string);
+
+    /* Free request */
+    ret = HG_Free_output(handle, &out_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
+        HG_Error_to_string(ret));
+
+done:
+    hg_request_complete(request);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_rpc_forward_cancel_cb(const struct hg_cb_info *callback_info)
+{
+    hg_request_t *request = (hg_request_t *) callback_info->arg;
+    hg_return_t ret = HG_SUCCESS;
+
+    if (callback_info->ret == HG_CANCELED)
+        HG_TEST_LOG_DEBUG("HG_Forward() was successfully canceled");
+    else
+        HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+            "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
+
+done:
+    hg_request_complete(request);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
 hg_test_rpc(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
-    hg_handle_t handle;
-    hg_return_t hg_ret = HG_SUCCESS;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS, cleanup_ret;
     struct forward_cb_args forward_cb_args;
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    hg_const_string_t rpc_open_path = HG_TEST_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
-    rpc_open_in_t  rpc_open_in_struct;
+    rpc_open_in_t rpc_open_in_struct;
 
     request = hg_request_create(request_class);
 
     /* Create RPC request */
-    hg_ret = HG_Create(context, addr, rpc_id, &handle);
-    if (hg_ret != HG_SUCCESS) {
-        if (hg_ret != HG_NO_MATCH)
-            HG_TEST_LOG_ERROR("Could not create handle");
+    ret = HG_Create(context, addr, rpc_id, &handle);
+    if (ret == HG_NOENTRY)
         goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     rpc_open_handle.cookie = 100;
@@ -155,25 +251,110 @@ hg_test_rpc(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args.request = request;
     forward_cb_args.rpc_handle = &rpc_open_handle;
-    hg_ret = HG_Forward(handle, callback, &forward_cb_args,
+again:
+    ret = HG_Forward(handle, callback, &forward_cb_args,
         &rpc_open_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
+    if (ret == HG_AGAIN) {
+        hg_request_wait(request, 0, NULL);
+        goto again;
     }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
-    /* Complete */
-    hg_ret = HG_Destroy(handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
+done:
+    cleanup_ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(cleanup_ret != HG_SUCCESS,
+        "HG_Destroy() failed (%s)", HG_Error_to_string(cleanup_ret));
+
+    hg_request_destroy(request);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_rpc_lookup(hg_context_t *context, hg_request_class_t *request_class,
+    const char *target_name, hg_id_t rpc_id, hg_cb_t callback)
+{
+    hg_request_t *request = NULL;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS;
+    struct forward_cb_args forward_cb_args;
+    hg_const_string_t rpc_open_path = HG_TEST_TEMP_DIRECTORY "/test.h5";
+    rpc_handle_t rpc_open_handle;
+    rpc_open_in_t rpc_open_in_struct;
+    hg_addr_t target_addr = HG_ADDR_NULL;
+    int i;
+
+    for (i = 0; i < 32; i++) {
+        struct lookup_cb_args lookup_args;
+        unsigned int flag = 0;
+
+        request = hg_request_create(request_class);
+
+        /* Look up target addr using target name info */
+        lookup_args.addr_ptr = &target_addr;
+        lookup_args.request = request;
+
+        /* Forward call to remote addr and get a new request */
+        ret = HG_Addr_lookup(context, hg_test_rpc_lookup_cb,
+            &lookup_args, target_name, HG_OP_ID_IGNORE);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_lookup() failed (%s)",
+            HG_Error_to_string(ret));
+
+        /* Wait for request to be marked completed */
+        hg_request_wait(request, HG_MAX_IDLE_TIME, &flag);
+        HG_TEST_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
+            "Operation did not complete");
+
+        /* Reset request */
+        hg_request_reset(request);
+
+        /* Create RPC request */
+        ret = HG_Create(context, target_addr, rpc_id, &handle);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+            HG_Error_to_string(ret));
+
+        /* Fill input structure */
+        rpc_open_handle.cookie = 100;
+        rpc_open_in_struct.path = rpc_open_path;
+        rpc_open_in_struct.handle = rpc_open_handle;
+
+        /* Forward call to remote addr and get a new request */
+        HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
+        forward_cb_args.request = request;
+        forward_cb_args.rpc_handle = &rpc_open_handle;
+        ret = HG_Forward(handle, callback, &forward_cb_args,
+            &rpc_open_in_struct);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+            HG_Error_to_string(ret));
+
+        hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+        /* Complete */
+        ret = HG_Destroy(handle);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+            HG_Error_to_string(ret));
+
+        ret = HG_Addr_set_remove(context->hg_class, target_addr);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_set_remove() failed (%s)",
+            HG_Error_to_string(ret));
+
+        ret = HG_Addr_free(context->hg_class, target_addr);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_free() failed (%s)",
+            HG_Error_to_string(ret));
+        target_addr = HG_ADDR_NULL;
+
+        hg_request_destroy(request);
+        request = NULL;
     }
 
 done:
     hg_request_destroy(request);
-    return hg_ret;
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -182,28 +363,24 @@ hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
-    hg_handle_t handle;
-    hg_return_t hg_ret = HG_SUCCESS;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS, cleanup_ret;
     struct forward_cb_args forward_cb_args;
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    hg_const_string_t rpc_open_path = HG_TEST_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
-    rpc_open_in_t  rpc_open_in_struct;
+    rpc_open_in_t rpc_open_in_struct;
 
     request = hg_request_create(request_class);
 
     /* Create request with invalid RPC id */
-    hg_ret = HG_Create(context, HG_ADDR_NULL, 0, &handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    ret = HG_Create(context, HG_ADDR_NULL, 0, &handle);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Reset with valid addr and ID */
-    hg_ret = HG_Reset(handle, addr, rpc_id);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not reset handle");
-        goto done;
-    }
+    ret = HG_Reset(handle, addr, rpc_id);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Reset() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     rpc_open_handle.cookie = 100;
@@ -214,26 +391,21 @@ hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args.request = request;
     forward_cb_args.rpc_handle = &rpc_open_handle;
-    hg_ret = HG_Forward(handle, callback, &forward_cb_args,
+    ret = HG_Forward(handle, callback, &forward_cb_args,
         &rpc_open_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
-    /* Complete */
-    hg_ret = HG_Destroy(handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+done:
+    cleanup_ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(cleanup_ret != HG_SUCCESS,
+        "HG_Destroy() failed (%s)", HG_Error_to_string(cleanup_ret));
 
     hg_request_destroy(request);
 
-done:
-    return hg_ret;
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -242,23 +414,23 @@ hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
-    hg_handle_t handle;
-    hg_return_t hg_ret = HG_SUCCESS;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS, cleanup_ret;
     struct forward_cb_args forward_cb_args;
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    hg_const_string_t rpc_open_path = HG_TEST_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
     rpc_open_in_t  rpc_open_in_struct;
 
     request = hg_request_create(request_class);
 
     /* Create request with invalid RPC id */
-    hg_ret = HG_Create(context, addr, rpc_id, &handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    ret = HG_Create(context, addr, rpc_id, &handle);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Set_target_id(handle, 0);
+    ret = HG_Set_target_id(handle, 0);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     rpc_open_handle.cookie = 100;
@@ -269,26 +441,21 @@ hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args.request = request;
     forward_cb_args.rpc_handle = &rpc_open_handle;
-    hg_ret = HG_Forward(handle, callback, &forward_cb_args,
+    ret = HG_Forward(handle, callback, &forward_cb_args,
         &rpc_open_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
-    /* Complete */
-    hg_ret = HG_Destroy(handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+done:
+    cleanup_ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(cleanup_ret != HG_SUCCESS,
+        "HG_Destroy() failed (%s)", HG_Error_to_string(cleanup_ret));
 
     hg_request_destroy(request);
 
-done:
-    return hg_ret;
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -299,9 +466,9 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     hg_request_t *request1 = NULL, *request2 = NULL;
     hg_handle_t handle1, handle2;
     struct forward_cb_args forward_cb_args1, forward_cb_args2;
-    hg_return_t hg_ret = HG_SUCCESS;
-    rpc_open_in_t  rpc_open_in_struct;
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    hg_return_t ret = HG_SUCCESS;
+    rpc_open_in_t rpc_open_in_struct;
+    hg_const_string_t rpc_open_path = HG_TEST_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle1, rpc_open_handle2;
     /* Used for multiple in-flight RPCs */
     hg_request_t *request_m[NINFLIGHT];
@@ -313,16 +480,13 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     /* Create request 1 */
     request1 = hg_request_create(request_class);
 
-    hg_ret = HG_Create(context, addr, rpc_id, &handle1);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
-    hg_ret = HG_Set_target_id(handle1, target_id);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not set target ID to handle");
-        goto done;
-    }
+    ret = HG_Create(context, addr, rpc_id, &handle1);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
+
+    ret = HG_Set_target_id(handle1, target_id);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     rpc_open_handle1.cookie = 1;
@@ -333,26 +497,20 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args1.request = request1;
     forward_cb_args1.rpc_handle = &rpc_open_handle1;
-    hg_ret = HG_Forward(handle1, callback, &forward_cb_args1,
-        &rpc_open_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    ret = HG_Forward(handle1, callback, &forward_cb_args1, &rpc_open_in_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Create request 2 */
     request2 = hg_request_create(request_class);
 
-    hg_ret = HG_Create(context, addr, rpc_id, &handle2);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
-    hg_ret = HG_Set_target_id(handle2, target_id);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not set target ID to handle");
-        goto done;
-    }
+    ret = HG_Create(context, addr, rpc_id, &handle2);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
+
+    ret = HG_Set_target_id(handle2, target_id);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     rpc_open_handle2.cookie = 2;
@@ -363,27 +521,21 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args2.request = request2;
     forward_cb_args2.rpc_handle = &rpc_open_handle2;
-    hg_ret = HG_Forward(handle2, callback, &forward_cb_args2,
-        &rpc_open_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    ret = HG_Forward(handle2, callback, &forward_cb_args2, &rpc_open_in_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request2, HG_MAX_IDLE_TIME, NULL);
     hg_request_wait(request1, HG_MAX_IDLE_TIME, NULL);
 
     /* Complete */
-    hg_ret = HG_Destroy(handle1);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
-    hg_ret = HG_Destroy(handle2);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    ret = HG_Destroy(handle1);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    ret = HG_Destroy(handle2);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_destroy(request1);
     hg_request_destroy(request2);
@@ -393,46 +545,120 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
      */
     HG_TEST_LOG_DEBUG("Creating %u requests...", NINFLIGHT);
     for (i = 0; i < NINFLIGHT; i++) {
-	    request_m[i] = hg_request_create(request_class);
-	    hg_ret = HG_Create(context, addr, rpc_id, handle_m + i );
-	    if (hg_ret != HG_SUCCESS) {
-	        HG_TEST_LOG_ERROR("Could not create handle");
-		    goto done;
-	    }
-	    hg_ret = HG_Set_target_id(handle_m[i], target_id);
-	    if (hg_ret != HG_SUCCESS) {
-	        HG_TEST_LOG_ERROR("Could not set target ID to handle");
-	        goto done;
-	    }
-	    rpc_open_handle_m[i].cookie = i;
-	    rpc_open_in_struct.path = rpc_open_path;
-	    rpc_open_in_struct.handle = rpc_open_handle_m[i];
-	    HG_TEST_LOG_DEBUG(" %d Forwarding rpc_open, op id: %u...", i, rpc_id);
-	    forward_cb_args_m[i].request = request_m[i];
-	    forward_cb_args_m[i].rpc_handle = &rpc_open_handle_m[i];
-	    hg_ret = HG_Forward(handle_m[i], callback, &forward_cb_args_m[i],
-	        &rpc_open_in_struct);
-	    if (hg_ret != HG_SUCCESS) {
-	        HG_TEST_LOG_ERROR("Could not forward call");
-		    goto done;
-	    }
+        request_m[i] = hg_request_create(request_class);
+        ret = HG_Create(context, addr, rpc_id, handle_m + i);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+            HG_Error_to_string(ret));
+
+        ret = HG_Set_target_id(handle_m[i], target_id);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+            HG_Error_to_string(ret));
+
+        rpc_open_handle_m[i].cookie = i;
+        rpc_open_in_struct.path = rpc_open_path;
+        rpc_open_in_struct.handle = rpc_open_handle_m[i];
+        HG_TEST_LOG_DEBUG(" %d Forwarding rpc_open, op id: %u...", i, rpc_id);
+        forward_cb_args_m[i].request = request_m[i];
+        forward_cb_args_m[i].rpc_handle = &rpc_open_handle_m[i];
+again:
+        ret = HG_Forward(handle_m[i], callback, &forward_cb_args_m[i],
+            &rpc_open_in_struct);
+        if (ret == HG_AGAIN) {
+            hg_request_wait(request_m[i], 0, NULL);
+            goto again;
+        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     /* Complete */
     for (i = 0; i < NINFLIGHT; i++) {
-	    hg_request_wait(request_m[i], HG_MAX_IDLE_TIME, NULL);
-
-	    hg_ret = HG_Destroy(handle_m[i]);
-	    if (hg_ret != HG_SUCCESS) {
-	        HG_TEST_LOG_ERROR("Could not destroy handle");
-		    goto done;
-	    }
-	    hg_request_destroy(request_m[i]);
+        hg_request_wait(request_m[i], HG_MAX_IDLE_TIME, NULL);
+
+        ret = HG_Destroy(handle_m[i]);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+            HG_Error_to_string(ret));
+
+        hg_request_destroy(request_m[i]);
     }
     HG_TEST_LOG_DEBUG("Done");
 
 done:
-    return hg_ret;
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_overflow(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
+{
+    hg_request_t *request = NULL;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS, cleanup_ret;
+
+    request = hg_request_create(request_class);
+
+    /* Create RPC request */
+    ret = HG_Create(context, addr, rpc_id, &handle);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
+
+    /* Forward call to remote addr and get a new request */
+    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
+    ret = HG_Forward(handle, callback, request, NULL);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
+
+    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+done:
+    cleanup_ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(cleanup_ret != HG_SUCCESS,
+        "HG_Destroy() failed (%s)", HG_Error_to_string(cleanup_ret));
+
+    hg_request_destroy(request);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
+{
+    hg_request_t *request = NULL;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS, cleanup_ret;
+
+    request = hg_request_create(request_class);
+
+    /* Create RPC request */
+    ret = HG_Create(context, addr, rpc_id, &handle);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
+
+    /* Forward call to remote addr and get a new request */
+    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
+    ret = HG_Forward(handle, callback, request, NULL);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
+
+    /* Cancel request before making progress, this ensures that the RPC has not
+     * completed yet. */
+    ret = HG_Cancel(handle);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Cancel() failed (%s)",
+        HG_Error_to_string(ret));
+
+    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+done:
+    cleanup_ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(cleanup_ret != HG_SUCCESS,
+        "HG_Destroy() failed (%s)", HG_Error_to_string(cleanup_ret));
+
+    hg_request_destroy(request);
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -445,28 +671,66 @@ main(int argc, char *argv[])
     int ret = EXIT_SUCCESS;
 
     /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
+    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
     /* Simple RPC test */
     HG_TEST("simple RPC");
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "simple RPC test failed");
     HG_PASSED();
 
+    /* RPC test with lookup/free */
+    if (!hg_test_info.na_test_info.self_send &&
+        strcmp(HG_Class_get_name(hg_test_info.hg_class), "mpi")) {
+        hg_request_t *request = NULL;
+        struct lookup_cb_args lookup_args;
+        unsigned int flag = 0;
+
+        HG_Addr_free(hg_test_info.hg_class, hg_test_info.target_addr);
+        hg_test_info.target_addr = HG_ADDR_NULL;
+
+        HG_TEST("lookup RPC");
+        hg_ret = hg_test_rpc_lookup(hg_test_info.context,
+            hg_test_info.request_class, hg_test_info.na_test_info.target_name,
+            hg_test_rpc_open_id_g, hg_test_rpc_forward_cb);
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "lookup test failed");
+        HG_PASSED();
+
+        request = hg_request_create(hg_test_info.request_class);
+
+        /* Look up target addr using target name info */
+        lookup_args.addr_ptr = &hg_test_info.target_addr;
+        lookup_args.request = request;
+
+        /* Forward call to remote addr and get a new request */
+        hg_ret = HG_Addr_lookup(hg_test_info.context, hg_test_rpc_lookup_cb,
+            &lookup_args, hg_test_info.na_test_info.target_name,
+            HG_OP_ID_IGNORE);
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "HG_Addr_lookup() failed (%s)", HG_Error_to_string(hg_ret));
+
+        /* Wait for request to be marked completed */
+        hg_request_wait(request, HG_MAX_IDLE_TIME, &flag);
+        HG_TEST_CHECK_ERROR(flag == 0, done, ret, EXIT_FAILURE,
+            "Operation did not complete");
+
+        /* Destroy request */
+        hg_request_destroy(request);
+    }
+
     /* RPC reset test */
     HG_TEST("RPC reset");
     hg_ret = hg_test_rpc_reset(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "reset RPC test failed");
     HG_PASSED();
 
     /* RPC test with tag mask */
@@ -474,10 +738,8 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc_mask(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "tagged RPC test failed");
     HG_PASSED();
 
     /* RPC test with no response */
@@ -485,48 +747,48 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_no_resp_g,
         hg_test_rpc_forward_no_resp_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "no response RPC test failed");
     HG_PASSED();
 
     /* RPC test with unregistered ID */
-    HG_TEST("unregistered RPC");
-    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "unreg_id", void, void, NULL);
+    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "unreg_id", void, void,
+        NULL);
+    HG_TEST_CHECK_ERROR(inv_id == 0, done, ret, EXIT_FAILURE,
+        "HG_Register() failed");
     hg_ret = HG_Deregister(hg_test_info.hg_class, inv_id);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Deregister() failed (%s)", HG_Error_to_string(hg_ret));
+
+    HG_TEST("unregistered RPC");
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, inv_id, hg_test_rpc_forward_cb);
-    if (hg_ret == HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_NOENTRY, done, ret, EXIT_FAILURE,
+        "unregistered RPC test failed");
     HG_PASSED();
 
-    /* RPC test with invalid ID (not registered on server) */
-    HG_TEST("invalid RPC");
-    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "inv_id", void, void, NULL);
-    hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
-        hg_test_info.target_addr, inv_id, hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
+    if (!hg_test_info.na_test_info.self_send) {
+        /* RPC test with invalid ID (not registered on server) */
+        inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "inv_id", void, void,
+            NULL);
+        HG_TEST_CHECK_ERROR(inv_id == 0, done, ret, EXIT_FAILURE,
+            "HG_Register() failed");
+
+        HG_TEST("invalid RPC");
+        hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
+            hg_test_info.target_addr, inv_id, hg_test_rpc_forward_cb);
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "invalid RPC test failed");
+        HG_PASSED();
     }
-    HG_PASSED();
 
     /* RPC test with reset */
     HG_TEST("reset RPC");
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_reset_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "reset RPC test failed");
     HG_PASSED();
 
     /* RPC test with multiple handle in flight */
@@ -534,10 +796,8 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc_multiple(hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 0,
         hg_test_rpc_open_id_g, hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "concurrent RPC test failed");
     HG_PASSED();
 
     /* RPC test with multiple handle to multiple target contexts */
@@ -545,22 +805,43 @@ main(int argc, char *argv[])
         hg_uint8_t i, context_count =
             hg_test_info.na_test_info.max_contexts;
 
-        HG_TEST("multi-target RPCs");
+        HG_TEST("multi context target RPCs");
         for (i = 0; i < context_count; i++) {
             hg_ret = hg_test_rpc_multiple(hg_test_info.context,
                 hg_test_info.request_class, hg_test_info.target_addr, i,
                 hg_test_rpc_open_id_g, hg_test_rpc_forward_cb);
-            if (hg_ret != HG_SUCCESS) {
-                ret = EXIT_FAILURE;
-                goto done;
-            }
+            HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+                "multi context target RPC test failed");
         }
         HG_PASSED();
     }
 
+    /* Overflow RPC test */
+    HG_TEST("overflow RPC");
+    hg_ret = hg_test_overflow(hg_test_info.context, hg_test_info.request_class,
+        hg_test_info.target_addr, hg_test_overflow_id_g,
+        hg_test_rpc_forward_overflow_cb);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "overflow RPC test failed");
+    HG_PASSED();
+
+    /* Cancel RPC test (self cancelation is not supported) */
+    if (!hg_test_info.na_test_info.self_send) {
+        HG_TEST("cancel RPC");
+        hg_ret = hg_test_cancel_rpc(hg_test_info.context,
+            hg_test_info.request_class, hg_test_info.target_addr,
+            hg_test_cancel_rpc_id_g, hg_test_rpc_forward_cancel_cb);
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "cancel RPC test failed");
+        HG_PASSED();
+    }
+
 done:
     if (ret != EXIT_SUCCESS)
         HG_FAILED();
-    HG_Test_finalize(&hg_test_info);
+
+    hg_ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
+
     return ret;
 }
diff --git a/Testing/test_rpc.h b/Testing/test_rpc.h
index fddc856..9f457b7 100644
--- a/Testing/test_rpc.h
+++ b/Testing/test_rpc.h
@@ -50,10 +50,8 @@ hg_proc_rpc_handle_t(hg_proc_t proc, void *data)
     rpc_handle_t *struct_data = (rpc_handle_t *) data;
 
     ret = hg_proc_uint64_t(proc, &struct_data->cookie);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -72,16 +70,12 @@ hg_proc_rpc_open_in_t(hg_proc_t proc, void *data)
     rpc_open_in_t *struct_data = (rpc_open_in_t *) data;
 
     ret = hg_proc_hg_const_string_t(proc, &struct_data->path);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_rpc_handle_t(proc, &struct_data->handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -100,16 +94,12 @@ hg_proc_rpc_open_out_t(hg_proc_t proc, void *data)
     rpc_open_out_t *struct_data = (rpc_open_out_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_int32_t(proc, &struct_data->event_id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -123,10 +113,8 @@ hg_proc_perf_rpc_lat_in_t(hg_proc_t proc, void *data)
     hg_return_t ret = HG_SUCCESS;
 
     ret = hg_proc_hg_uint32_t(proc, &struct_data->buf_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     if (struct_data->buf_size) {
         switch (hg_proc_get_op(proc)) {
@@ -135,21 +123,18 @@ hg_proc_perf_rpc_lat_in_t(hg_proc_t proc, void *data)
                 HG_FALLTHROUGH();
             case HG_ENCODE:
                 ret = hg_proc_raw(proc, struct_data->buf, struct_data->buf_size);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                if (ret != HG_SUCCESS)
                     return ret;
-                }
                 break;
             case HG_FREE:
                 free(struct_data->buf);
                 break;
             default:
-                HG_LOG_ERROR("Proc error");
-                ret = HG_PROTOCOL_ERROR;
+                ret = HG_INVALID_ARG;
                 return ret;
         }
 
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
         if (hg_proc_get_op(proc) == HG_DECODE) {
             hg_size_t i;
             char *buf_ptr = struct_data->buf;
diff --git a/Testing/test_rpc_lat.c b/Testing/test_rpc_lat.c
index a31c3c2..9e7a04f 100644
--- a/Testing/test_rpc_lat.c
+++ b/Testing/test_rpc_lat.c
@@ -15,27 +15,32 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+/****************/
+/* Local Macros */
+/****************/
+
 #define BENCHMARK_NAME "RPC latency"
 #define STRING(s) #s
 #define XSTRING(s) STRING(s)
-#define VERSION_NAME \
-    XSTRING(HG_VERSION_MAJOR) \
-    "." \
-    XSTRING(HG_VERSION_MINOR) \
-    "." \
+#define VERSION_NAME            \
+    XSTRING(HG_VERSION_MAJOR)   \
+    "."                         \
+    XSTRING(HG_VERSION_MINOR)   \
+    "."                         \
     XSTRING(HG_VERSION_PATCH)
 
-#define SMALL_SKIP 100
-#define LARGE_SKIP 10
-#define LARGE_SIZE 8192
+#define SMALL_SKIP      100
+#define LARGE_SKIP      10
+#define LARGE_SIZE      8192
 
-#define NDIGITS 2
-#define NWIDTH 20
-#define MAX_MSG_SIZE (MERCURY_TESTING_BUFFER_SIZE * 1024 * 1024)
-#define MAX_HANDLES 16
+#define NDIGITS         2
+#define NWIDTH          20
+#define MAX_MSG_SIZE    (HG_TEST_BUFFER_SIZE * 1024 * 1024)
+#define MAX_HANDLES     (HG_TEST_MAX_HANDLES)
 
-extern hg_id_t hg_test_perf_rpc_id_g;
-extern hg_id_t hg_test_perf_rpc_lat_id_g;
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
 
 struct hg_test_perf_args {
     hg_request_t *request;
@@ -43,6 +48,24 @@ struct hg_test_perf_args {
     hg_atomic_int32_t op_completed_count;
 };
 
+/********************/
+/* Local Prototypes */
+/********************/
+
+static hg_return_t
+hg_test_perf_forward_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
+    unsigned int nhandles);
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+extern hg_id_t hg_test_perf_rpc_id_g;
+extern hg_id_t hg_test_perf_rpc_lat_id_g;
+
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -50,13 +73,13 @@ hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
         (struct hg_test_perf_args *) callback_info->arg;
 
     if ((unsigned int) hg_atomic_incr32(&args->op_completed_count)
-        == args->op_count) {
+        == args->op_count)
         hg_request_complete(args->request);
-    }
 
     return HG_SUCCESS;
 }
 
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
     unsigned int nhandles)
@@ -79,12 +102,17 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
     /* Prepare bulk_buf */
     if (nbytes) {
         bulk_buf = malloc(nbytes);
+        HG_TEST_CHECK_ERROR(bulk_buf == NULL, done, ret, HG_NOMEM_ERROR,
+            "Could not allocate bulk buf");
         for (i = 0; i < nbytes; i++)
             bulk_buf[i] = (char) i;
     }
 
     /* Create handles */
     handles = malloc(nhandles * sizeof(hg_handle_t));
+    HG_TEST_CHECK_ERROR(handles == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate handles");
+
     for (i = 0; i < nhandles; i++) {
         /* Use NULL RPC ID to skip proc encoding if total_size = 0 */
         hg_id_t rpc_id = total_size ? hg_test_perf_rpc_lat_id_g :
@@ -92,10 +120,8 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
 
         ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
             rpc_id, &handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not start call\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     request = hg_request_create(hg_test_info->request_class);
@@ -112,12 +138,15 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
         unsigned int j;
 
         for (j = 0; j < nhandles; j++) {
+again:
             ret = HG_Forward(handles[j], hg_test_perf_forward_cb,
                 &args, &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
+            if (ret == HG_AGAIN) {
+                hg_request_wait(request, 0, NULL);
+                goto again;
             }
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -136,16 +165,17 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
 
         for (j = 0; j < nhandles; j++) {
             /* Assign handles to multiple targets */
-            if (hg_test_info->na_test_info.max_contexts > 1)
-                HG_Set_target_id(handles[j],
+            if (hg_test_info->na_test_info.max_contexts > 1) {
+                ret = HG_Set_target_id(handles[j],
                     (hg_uint8_t) (avg_iter % hg_test_info->na_test_info.max_contexts));
+                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+                    HG_Error_to_string(ret));
+            }
 
             ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
 			     &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
-            }
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -157,7 +187,7 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
         hg_atomic_set32(&args.op_completed_count, 0);
 
 	/* We have received everything so calculate the bandwidth */
-#ifdef MERCURY_TESTING_PRINT_PARTIAL
+#ifdef HG_TEST_PRINT_PARTIAL
         read_lat = time_read * 1.0e6 / (double) (nhandles * (avg_iter + 1) *
             (unsigned int) hg_test_info->na_test_info.mpi_comm_size);
         if (hg_test_info->na_test_info.mpi_comm_rank == 0)
@@ -165,7 +195,7 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
                 NDIGITS, (read_lat), NWIDTH, (int) (1.0e6 / read_lat));
 #endif
     }
-#ifndef MERCURY_TESTING_PRINT_PARTIAL
+#ifndef HG_TEST_PRINT_PARTIAL
     read_lat = time_read * 1.0e6 / (double) (nhandles * loop *
         (unsigned int) hg_test_info->na_test_info.mpi_comm_size);
     if (hg_test_info->na_test_info.mpi_comm_rank == 0)
@@ -178,10 +208,8 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
     hg_request_destroy(request);
     for (i = 0; i < nhandles; i++) {
         ret = HG_Destroy(handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not complete\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
 done:
@@ -190,15 +218,19 @@ done:
     return ret;
 }
 
-/*****************************************************************************/
+/*---------------------------------------------------------------------------*/
 int
 main(int argc, char *argv[])
 {
     struct hg_test_info hg_test_info = { 0 };
     unsigned int nhandles;
     size_t size;
+    hg_return_t hg_ret;
+    int ret = EXIT_SUCCESS;
 
-    HG_Test_init(argc, argv, &hg_test_info);
+    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
     for (nhandles = 1; nhandles <= MAX_HANDLES; nhandles *= 2) {
         if (hg_test_info.na_test_info.mpi_comm_rank == 0) {
@@ -206,7 +238,7 @@ main(int argc, char *argv[])
             fprintf(stdout, "# Loop %d times from size %d to %d byte(s) with "
                 "%u handle(s)\n",
                 hg_test_info.na_test_info.loop, 1, MAX_MSG_SIZE, nhandles);
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
             fprintf(stdout, "# WARNING verifying data, output will be slower\n");
 #endif
             fprintf(stdout, "%-*s%*s%*s\n", 10, "# Size", NWIDTH,
@@ -215,16 +247,23 @@ main(int argc, char *argv[])
         }
 
         /* NULL RPC */
-        measure_rpc_latency(&hg_test_info, 0, nhandles);
+        hg_ret = measure_rpc_latency(&hg_test_info, 0, nhandles);
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "measure_rpc_latency() failed");
 
         /* RPC with different sizes */
-        for (size = sizeof(hg_uint32_t); size <= MAX_MSG_SIZE; size *= 2)
-            measure_rpc_latency(&hg_test_info, size, nhandles);
+        for (size = sizeof(hg_uint32_t); size <= MAX_MSG_SIZE; size *= 2) {
+            hg_ret = measure_rpc_latency(&hg_test_info, size, nhandles);
+            HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+                "measure_rpc_latency() failed");
+        }
 
         fprintf(stdout, "\n");
     }
 
-    HG_Test_finalize(&hg_test_info);
+done:
+    hg_ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
 
-    return EXIT_SUCCESS;
+    return ret;
 }
diff --git a/Testing/test_server.c b/Testing/test_server.c
index bee0c8e..752a974 100644
--- a/Testing/test_server.c
+++ b/Testing/test_server.c
@@ -13,12 +13,45 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+/****************/
+/* Local Macros */
+/****************/
+
 #define HG_TEST_PROGRESS_TIMEOUT    100
 #define HG_TEST_TRIGGER_TIMEOUT     HG_MAX_IDLE_TIME
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+struct hg_test_worker {
+    struct hg_thread_work thread_work;
+    hg_class_t *hg_class;
+    hg_context_t *context;
+};
+#endif
+
+/********************/
+/* Local Prototypes */
+/********************/
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+static HG_INLINE HG_THREAD_RETURN_TYPE
+hg_test_progress_thread(void *arg);
+static HG_INLINE HG_THREAD_RETURN_TYPE
+hg_test_progress_work(void *arg);
+#endif
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+/*---------------------------------------------------------------------------*/
+#ifdef HG_TEST_HAS_THREAD_POOL
+
 static HG_INLINE HG_THREAD_RETURN_TYPE
-hg_progress_thread(void *arg)
+hg_test_progress_thread(void *arg)
 {
     hg_context_t *context = (hg_context_t *) arg;
     struct hg_test_context_info *hg_test_context_info =
@@ -32,16 +65,22 @@ hg_progress_thread(void *arg)
 
         ret = HG_Progress(context, HG_TEST_PROGRESS_TIMEOUT);
     } while (ret == HG_SUCCESS || ret == HG_TIMEOUT);
+    HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        tret, (HG_THREAD_RETURN_TYPE) 0, "HG_Progress() failed (%s)",
+        HG_Error_to_string(ret));
 
+done:
     printf("Exiting\n");
     hg_thread_exit(tret);
     return tret;
 }
 
+/*---------------------------------------------------------------------------*/
 static HG_INLINE HG_THREAD_RETURN_TYPE
-hg_progress_work(void *arg)
+hg_test_progress_work(void *arg)
 {
-    hg_context_t *context = (hg_context_t *) arg;
+    struct hg_test_worker *worker = (struct hg_test_worker *) arg;
+    hg_context_t *context = worker->context;
     struct hg_test_context_info *hg_test_context_info =
         (struct hg_test_context_info *) HG_Context_get_data(context);
     HG_THREAD_RETURN_TYPE tret = (HG_THREAD_RETURN_TYPE) 0;
@@ -53,6 +92,9 @@ hg_progress_work(void *arg)
         do {
             ret = HG_Trigger(context, 0, 1, &actual_count);
         } while ((ret == HG_SUCCESS) && actual_count);
+        HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+            tret, (HG_THREAD_RETURN_TYPE) 0, "HG_Trigger() failed (%s)",
+            HG_Error_to_string(ret));
 
         if (hg_atomic_get32(&hg_test_context_info->finalizing)) {
             /* Make sure everything was progressed/triggered */
@@ -66,20 +108,22 @@ hg_progress_work(void *arg)
         /* Use same value as HG_TEST_TRIGGER_TIMEOUT for convenience */
         ret = HG_Progress(context, HG_TEST_TRIGGER_TIMEOUT);
     } while (ret == HG_SUCCESS || ret == HG_TIMEOUT);
+    HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        tret, (HG_THREAD_RETURN_TYPE) 0, "HG_Progress() failed (%s)",
+        HG_Error_to_string(ret));
 
+done:
     return tret;
 }
 #endif
 
-/**
- *
- */
+/*---------------------------------------------------------------------------*/
 int
 main(int argc, char *argv[])
 {
     struct hg_test_info hg_test_info = { 0 };
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
-    struct hg_thread_work *progress_workers = NULL;
+#ifdef HG_TEST_HAS_THREAD_POOL
+    struct hg_test_worker *progress_workers = NULL;
 #endif
     struct hg_test_context_info *hg_test_context_info;
     hg_return_t ret = HG_SUCCESS;
@@ -88,53 +132,68 @@ main(int argc, char *argv[])
     /* Force to listen */
     hg_test_info.na_test_info.listen = NA_TRUE;
     ret = HG_Test_init(argc, argv, &hg_test_info);
-    if (ret != HG_SUCCESS) {
-        rc = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(ret != HG_SUCCESS, done, rc, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
-    hg_test_context_info =
-        (struct hg_test_context_info *) HG_Context_get_data(
-            hg_test_info.context);
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
-    if (!hg_test_info.secondary_contexts) {
+    hg_test_context_info = (struct hg_test_context_info *) HG_Context_get_data(
+        hg_test_info.context);
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+    if (hg_test_info.na_test_info.max_contexts > 1) {
+        hg_uint8_t context_count = (hg_uint8_t)
+            (hg_test_info.na_test_info.max_contexts);
+        hg_uint8_t i;
+
+        progress_workers = malloc(
+            sizeof(struct hg_test_worker) * context_count);
+        HG_TEST_CHECK_ERROR(progress_workers == NULL, error, rc, EXIT_FAILURE,
+            "Could not allocate progress_workers");
+
+        progress_workers[0].thread_work.func = hg_test_progress_work;
+        progress_workers[0].thread_work.args = &progress_workers[0];
+        progress_workers[0].hg_class = hg_test_info.hg_class;
+        progress_workers[0].context = hg_test_info.context;
+
+        for (i = 0; i < context_count - 1; i++) {
+            progress_workers[i + 1].thread_work.func = hg_test_progress_work;
+            progress_workers[i + 1].thread_work.args = &progress_workers[i + 1];
+            progress_workers[i + 1].hg_class = hg_test_info.hg_class;
+            progress_workers[i + 1].context = hg_test_info.secondary_contexts[i];
+
+            hg_thread_pool_post(hg_test_info.thread_pool,
+                &progress_workers[i + 1].thread_work);
+        }
+        /* Use main thread for progress on main context */
+        hg_test_progress_work(&progress_workers[0]);
+    } else {
         hg_thread_t progress_thread;
 
-        hg_thread_create(&progress_thread, hg_progress_thread, hg_test_info.context);
+        hg_thread_create(&progress_thread, hg_test_progress_thread,
+            hg_test_info.context);
 
         do {
             if (hg_atomic_get32(&hg_test_context_info->finalizing))
                 break;
 
-            ret = HG_Trigger(hg_test_info.context, HG_TEST_TRIGGER_TIMEOUT, 1, NULL);
+            ret = HG_Trigger(hg_test_info.context, HG_TEST_TRIGGER_TIMEOUT, 1,
+                NULL);
         } while (ret == HG_SUCCESS || ret == HG_TIMEOUT);
+        HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, error,
+            rc, EXIT_FAILURE, "HG_Trigger() failed (%s)",
+            HG_Error_to_string(ret));
 
         hg_thread_join(progress_thread);
-    } else {
-        hg_uint8_t context_count = (hg_uint8_t)
-            (hg_test_info.na_test_info.max_contexts);
-        hg_uint8_t i;
-
-        progress_workers = malloc(sizeof(struct hg_thread_work) * context_count);
-        progress_workers[0].func = hg_progress_work;
-        progress_workers[0].args = hg_test_info.context;
-        hg_thread_pool_post(hg_test_info.thread_pool, &progress_workers[0]);
-        for (i = 0; i < context_count - 1; i++) {
-            progress_workers[i + 1].func = hg_progress_work;
-            progress_workers[i + 1].args = hg_test_info.secondary_contexts[i];
-            hg_thread_pool_post(hg_test_info.thread_pool, &progress_workers[i + 1]);
-        }
     }
 #else
-    if (hg_test_info.secondary_contexts)
-        HG_LOG_WARNING("Secondary contexts only supported with thread pool");
-
     do {
         unsigned int actual_count = 0;
 
         do {
             ret = HG_Trigger(hg_test_info.context, 0, 1, &actual_count);
         } while ((ret == HG_SUCCESS) && actual_count);
+        HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, error,
+            rc, EXIT_FAILURE, "HG_Trigger() failed (%s)",
+            HG_Error_to_string(ret));
 
         if (hg_atomic_get32(&hg_test_context_info->finalizing))
             break;
@@ -142,13 +201,19 @@ main(int argc, char *argv[])
         /* Use same value as HG_TEST_TRIGGER_TIMEOUT for convenience */
         ret = HG_Progress(hg_test_info.context, HG_TEST_TRIGGER_TIMEOUT);
     } while (ret == HG_SUCCESS || ret == HG_TIMEOUT);
+    HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, error,
+        rc, EXIT_FAILURE, "HG_Progress() failed (%s)",
+        HG_Error_to_string(ret));
 #endif
 
-done:
-    HG_Test_finalize(&hg_test_info);
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+error:
+    ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Test_finalize() failed");
+
+#ifdef HG_TEST_HAS_THREAD_POOL
     free(progress_workers);
 #endif
 
+done:
     return rc;
 }
diff --git a/Testing/test_write_bw.c b/Testing/test_write_bw.c
index 7c38896..3b0ea6c 100644
--- a/Testing/test_write_bw.c
+++ b/Testing/test_write_bw.c
@@ -15,26 +15,32 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+/****************/
+/* Local Macros */
+/****************/
+
 #define BENCHMARK_NAME "Write BW (server bulk pull)"
 #define STRING(s) #s
 #define XSTRING(s) STRING(s)
-#define VERSION_NAME \
-    XSTRING(HG_VERSION_MAJOR) \
-    "." \
-    XSTRING(HG_VERSION_MINOR) \
-    "." \
+#define VERSION_NAME            \
+    XSTRING(HG_VERSION_MAJOR)   \
+    "."                         \
+    XSTRING(HG_VERSION_MINOR)   \
+    "."                         \
     XSTRING(HG_VERSION_PATCH)
 
-#define SMALL_SKIP 20
-#define LARGE_SKIP 10
-#define LARGE_SIZE 8192
+#define SMALL_SKIP      20
+#define LARGE_SKIP      10
+#define LARGE_SIZE      8192
 
-#define NDIGITS 2
-#define NWIDTH 20
-#define MAX_MSG_SIZE (MERCURY_TESTING_BUFFER_SIZE * 1024 * 1024)
-#define MAX_HANDLES 16
+#define NDIGITS         2
+#define NWIDTH          20
+#define MAX_MSG_SIZE    (HG_TEST_BUFFER_SIZE * 1024 * 1024)
+#define MAX_HANDLES     (HG_TEST_MAX_HANDLES)
 
-extern hg_id_t hg_test_perf_bulk_write_id_g;
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
 
 struct hg_test_perf_args {
     hg_request_t *request;
@@ -42,6 +48,20 @@ struct hg_test_perf_args {
     hg_atomic_int32_t op_completed_count;
 };
 
+/********************/
+/* Local Prototypes */
+/********************/
+
+static hg_return_t
+hg_test_perf_forward_cb(const struct hg_cb_info *callback_info);
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+extern hg_id_t hg_test_perf_bulk_write_id_g;
+
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -49,13 +69,13 @@ hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
         (struct hg_test_perf_args *) callback_info->arg;
 
     if ((unsigned int) hg_atomic_incr32(&args->op_completed_count)
-        == args->op_count) {
+        == args->op_count)
         hg_request_complete(args->request);
-    }
 
     return HG_SUCCESS;
 }
 
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
     unsigned int nhandles)
@@ -80,6 +100,8 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Prepare bulk_buf */
     bulk_buf = malloc(nbytes);
+    HG_TEST_CHECK_ERROR(bulk_buf == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate bulk buf");
     for (i = 0; i < nbytes; i++)
         bulk_buf[i] = (char) i;
     buf_ptrs = (void **) &bulk_buf;
@@ -87,13 +109,14 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Create handles */
     handles = malloc(nhandles * sizeof(hg_handle_t));
+    HG_TEST_CHECK_ERROR(handles == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate handles");
+
     for (i = 0; i < nhandles; i++) {
         ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
             hg_test_perf_bulk_write_id_g, &handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not start call\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     request = hg_request_create(hg_test_info->request_class);
@@ -104,10 +127,8 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
     /* Register memory */
     ret = HG_Bulk_create(hg_test_info->hg_class, 1, buf_ptrs,
         (hg_size_t *) buf_sizes, HG_BULK_READ_ONLY, &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     in_struct.fildes = 0;
@@ -118,11 +139,15 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         unsigned int j;
 
         for (j = 0; j < nhandles; j++) {
-            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args, &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
+again:
+            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
+                &in_struct);
+            if (ret == HG_AGAIN) {
+                hg_request_wait(request, 0, NULL);
+                goto again;
             }
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -140,11 +165,18 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         hg_time_get_current(&t1);
 
         for (j = 0; j < nhandles; j++) {
-            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args, &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
+            /* Assign handles to multiple targets */
+            if (hg_test_info->na_test_info.max_contexts > 1) {
+                ret = HG_Set_target_id(handles[j],
+                    (hg_uint8_t) (avg_iter % hg_test_info->na_test_info.max_contexts));
+                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+                    HG_Error_to_string(ret));
             }
+
+            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
+                &in_struct);
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -155,7 +187,7 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         hg_request_reset(request);
         hg_atomic_set32(&args.op_completed_count, 0);
 
-#ifdef MERCURY_TESTING_PRINT_PARTIAL
+#ifdef HG_TEST_PRINT_PARTIAL
         read_bandwidth = nmbytes
             * (double) (nhandles * (avg_iter + 1) *
                 (unsigned int) hg_test_info->na_test_info.mpi_comm_size)
@@ -167,7 +199,7 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
                 NDIGITS, read_bandwidth);
 #endif
     }
-#ifndef MERCURY_TESTING_PRINT_PARTIAL
+#ifndef HG_TEST_PRINT_PARTIAL
     read_bandwidth = nmbytes
         * (double) (nhandles * loop *
             (unsigned int) hg_test_info->na_test_info.mpi_comm_size)
@@ -182,19 +214,15 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Complete */
     hg_request_destroy(request);
     for (i = 0; i < nhandles; i++) {
         ret = HG_Destroy(handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not complete\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
 done:
@@ -203,15 +231,19 @@ done:
     return ret;
 }
 
-/*****************************************************************************/
+/*---------------------------------------------------------------------------*/
 int
 main(int argc, char *argv[])
 {
     struct hg_test_info hg_test_info = { 0 };
     unsigned int nhandles;
     size_t size;
+    hg_return_t hg_ret;
+    int ret = EXIT_SUCCESS;
 
-    HG_Test_init(argc, argv, &hg_test_info);
+    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
     for (nhandles = 1; nhandles <= MAX_HANDLES; nhandles *= 2) {
         if (hg_test_info.na_test_info.mpi_comm_rank == 0) {
@@ -219,7 +251,7 @@ main(int argc, char *argv[])
             fprintf(stdout, "# Loop %d times from size %d to %d byte(s) with "
                 "%u handle(s)\n",
                 hg_test_info.na_test_info.loop, 1, MAX_MSG_SIZE, nhandles);
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
             fprintf(stdout, "# WARNING verifying data, output will be slower\n");
 #endif
             fprintf(stdout, "%-*s%*s\n", 10, "# Size", NWIDTH,
@@ -227,13 +259,18 @@ main(int argc, char *argv[])
             fflush(stdout);
         }
 
-        for (size = 1; size <= MAX_MSG_SIZE; size *= 2)
-            measure_bulk_transfer(&hg_test_info, size, nhandles);
+        for (size = 1; size <= MAX_MSG_SIZE; size *= 2) {
+            hg_ret = measure_bulk_transfer(&hg_test_info, size, nhandles);
+            HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+                "measure_bulk_transfer() failed");
+        }
 
         fprintf(stdout, "\n");
     }
 
-    HG_Test_finalize(&hg_test_info);
+done:
+    hg_ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
 
-    return EXIT_SUCCESS;
+    return ret;
 }
diff --git a/Testing/util/test_atomic.c b/Testing/util/test_atomic.c
index 4a96ab5..b4b0f68 100644
--- a/Testing/util/test_atomic.c
+++ b/Testing/util/test_atomic.c
@@ -1,133 +1,245 @@
 #include "mercury_atomic.h"
-#include "mercury_thread.h"
 
 #include "mercury_test_config.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 
-static HG_THREAD_RETURN_TYPE
-thread_cb_incr32(void *arg)
-{
-    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
-    hg_atomic_int32_t *atomic_int32 = (hg_atomic_int32_t *) arg;
-    hg_util_int32_t incr;
-
-    incr = hg_atomic_incr32(atomic_int32);
-    if (!incr)
-        fprintf(stderr, "Error: incr is %d\n", incr);
-    incr = hg_atomic_decr32(atomic_int32);
-    if (incr)
-        fprintf(stderr, "Error: incr is %d\n", incr);
-
-    hg_thread_exit(thread_ret);
-    return thread_ret;
-}
-
-static HG_THREAD_RETURN_TYPE
-thread_cb_cas32(void *arg)
+int
+main(void)
 {
-    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
-    hg_atomic_int32_t *atomic_int32 = (hg_atomic_int32_t *) arg;
+    hg_atomic_int32_t atomic_int32;
+    hg_util_int32_t val32, init_val32;
+    hg_atomic_int64_t atomic_int64;
+    hg_util_int64_t val64, init_val64;
+    int ret = EXIT_SUCCESS;
 
-    hg_atomic_incr32(atomic_int32);
+    /* Init32 test */
+    hg_atomic_init32(&atomic_int32, 1);
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != 1) {
+        fprintf(stderr, "Error in hg_atomic_init32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    if (HG_UTIL_TRUE == hg_atomic_cas32(atomic_int32, 2, 99)) {
-        hg_atomic_incr32(atomic_int32);
+    /* Set32 test */
+    hg_atomic_set32(&atomic_int32, 2);
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != 2) {
+        fprintf(stderr, "Error in hg_atomic_set32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
     }
 
-    hg_thread_exit(thread_ret);
-    return thread_ret;
-}
+    /* Incr32 test */
+    val32 = hg_atomic_incr32(&atomic_int32);
+    if (val32 != 3) {
+        fprintf(stderr, "Error in hg_atomic_incr32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != 3) {
+        fprintf(stderr, "Error in hg_atomic_incr32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-#ifndef HG_UTIL_HAS_OPA_PRIMITIVES_H
-static HG_THREAD_RETURN_TYPE
-thread_cb_incr64(void *arg)
-{
-    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
-    hg_atomic_int64_t *atomic_int64 = (hg_atomic_int64_t *) arg;
-    hg_util_int64_t incr;
-
-    incr = hg_atomic_incr64(atomic_int64);
-    if (!incr)
-        fprintf(stderr, "Error: incr is %ld\n", (long) incr);
-    incr = hg_atomic_decr64(atomic_int64);
-    if (incr)
-        fprintf(stderr, "Error: incr is %ld\n", (long) incr);
-
-    hg_thread_exit(thread_ret);
-    return thread_ret;
-}
+    /* Decr32 test */
+    val32 = hg_atomic_decr32(&atomic_int32);
+    if (val32 != 2) {
+        fprintf(stderr, "Error in hg_atomic_decr32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != 2) {
+        fprintf(stderr, "Error in hg_atomic_decr32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-static HG_THREAD_RETURN_TYPE
-thread_cb_cas64(void *arg)
-{
-    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
-    hg_atomic_int64_t *atomic_int64 = (hg_atomic_int64_t *) arg;
+    /* Or32 test */
+    init_val32 = hg_atomic_get32(&atomic_int32);
+    val32 = hg_atomic_or32(&atomic_int32, 8);
+    if (val32 != init_val32) {
+        fprintf(stderr, "Error in hg_atomic_or32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != (init_val32 | 8)) {
+        fprintf(stderr, "Error in hg_atomic_or32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    hg_atomic_incr64(atomic_int64);
+    /* Xor32 test */
+    init_val32 = hg_atomic_get32(&atomic_int32);
+    val32 = hg_atomic_xor32(&atomic_int32, 17);
+    if (val32 != init_val32) {
+        fprintf(stderr, "Error in hg_atomic_xor32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != (init_val32 ^ 17)) {
+        fprintf(stderr, "Error in hg_atomic_xor32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    if (HG_UTIL_TRUE == hg_atomic_cas64(atomic_int64, 2, 99)) {
-        hg_atomic_incr64(atomic_int64);
+    /* And32 test */
+    init_val32 = hg_atomic_get32(&atomic_int32);
+    val32 = hg_atomic_and32(&atomic_int32, 33);
+    if (val32 != init_val32) {
+        fprintf(stderr, "Error in hg_atomic_and32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != (init_val32 & 33)) {
+        fprintf(stderr, "Error in hg_atomic_and32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
     }
 
-    hg_thread_exit(thread_ret);
-    return thread_ret;
-}
-#endif
+    /* Cas32 test */
+    init_val32 = hg_atomic_get32(&atomic_int32);
+    val32 = 128;
+    if (hg_atomic_cas32(&atomic_int32, init_val32, val32) == HG_UTIL_FALSE) {
+        fprintf(stderr, "Error in hg_atomic_cas32: could not swap values"
+            "with %d, is %d, expected %d\n", val32,
+            hg_atomic_get32(&atomic_int32), init_val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != 128) {
+        fprintf(stderr, "Error in hg_atomic_cas32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    if (hg_atomic_cas32(&atomic_int32, 1, 0) == HG_UTIL_TRUE) {
+        fprintf(stderr, "Error in hg_atomic_cas32: should not swap values\n");
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-int
-main(int argc, char *argv[])
-{
-    hg_thread_t thread, thread1;
-    hg_atomic_int32_t atomic_int32;
-    hg_util_int32_t value32 = 0;
-#ifndef HG_UTIL_HAS_OPA_PRIMITIVES_H
-    hg_atomic_int64_t atomic_int64;
-    hg_util_int64_t value64 = 0;
-#endif
-    int ret = EXIT_SUCCESS;
+    /* Init64 test */
+    hg_atomic_init64(&atomic_int64, 1);
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != 1) {
+        fprintf(stderr, "Error in hg_atomic_init64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    (void) argc;
-    (void) argv;
+    /* Set64 test */
+    hg_atomic_set64(&atomic_int64, 2);
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != 2) {
+        fprintf(stderr, "Error in hg_atomic_set64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    /* Atomic 32 test */
-    hg_thread_init(&thread);
-    hg_atomic_set32(&atomic_int32, value32);
-    hg_thread_create(&thread, thread_cb_incr32, &atomic_int32);
-    hg_thread_join(thread);
+    /* Incr64 test */
+    val64 = hg_atomic_incr64(&atomic_int64);
+    if (val64 != 3) {
+        fprintf(stderr, "Error in hg_atomic_incr64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != 3) {
+        fprintf(stderr, "Error in hg_atomic_incr64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    hg_thread_init(&thread1);
-    hg_thread_create(&thread1, thread_cb_cas32, &atomic_int32);
-    hg_thread_create(&thread, thread_cb_cas32, &atomic_int32);
-    hg_thread_join(thread);
-    hg_thread_join(thread1);
+    /* Decr64 test */
+    val64 = hg_atomic_decr64(&atomic_int64);
+    if (val64 != 2) {
+        fprintf(stderr, "Error in hg_atomic_decr64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != 2) {
+        fprintf(stderr, "Error in hg_atomic_decr64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    value32 = hg_atomic_get32(&atomic_int32);
-    if (value32 != 100) {
-        fprintf(stderr, "Error: atomic value is %d\n", value32);
+    /* Or64 test */
+    init_val64 = hg_atomic_get64(&atomic_int64);
+    val64 = hg_atomic_or64(&atomic_int64, 8);
+    if (val64 != init_val64) {
+        fprintf(stderr, "Error in hg_atomic_or64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != (init_val64 | 8)) {
+        fprintf(stderr, "Error in hg_atomic_or64: atomic value is %ld\n", val64);
         ret = EXIT_FAILURE;
+        goto done;
     }
 
-#ifndef HG_UTIL_HAS_OPA_PRIMITIVES_H
-    /* Atomic 64 test */
-    hg_thread_init(&thread);
-    hg_atomic_set64(&atomic_int64, value64);
-    hg_thread_create(&thread, thread_cb_incr64, &atomic_int64);
-    hg_thread_join(thread);
+    /* Xor64 test */
+    init_val64 = hg_atomic_get64(&atomic_int64);
+    val64 = hg_atomic_xor64(&atomic_int64, 17);
+    if (val64 != init_val64) {
+        fprintf(stderr, "Error in hg_atomic_xor64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != (init_val64 ^ 17)) {
+        fprintf(stderr, "Error in hg_atomic_xor64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    hg_thread_init(&thread1);
-    hg_thread_create(&thread1, thread_cb_cas64, &atomic_int64);
-    hg_thread_create(&thread, thread_cb_cas64, &atomic_int64);
-    hg_thread_join(thread);
-    hg_thread_join(thread1);
+    /* And64 test */
+    init_val64 = hg_atomic_get64(&atomic_int64);
+    val64 = hg_atomic_and64(&atomic_int64, 33);
+    if (val64 != init_val64) {
+        fprintf(stderr, "Error in hg_atomic_and64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != (init_val64 & 33)) {
+        fprintf(stderr, "Error in hg_atomic_and64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    value64 = hg_atomic_get64(&atomic_int64);
-    if (value64 != 100) {
-        fprintf(stderr, "Error: atomic value is %ld\n", (long) value64);
+    /* Cas64 test */
+    init_val64 = hg_atomic_get64(&atomic_int64);
+    val64 = 128;
+    if (hg_atomic_cas64(&atomic_int64, init_val64, val64) == HG_UTIL_FALSE) {
+        fprintf(stderr, "Error in hg_atomic_cas64: could not swap values"
+            "with %ld, is %ld, expected %ld\n", val64,
+            hg_atomic_get64(&atomic_int64), init_val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != 128) {
+        fprintf(stderr, "Error in hg_atomic_cas64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    if (hg_atomic_cas64(&atomic_int64, 1, 0) == HG_UTIL_TRUE) {
+        fprintf(stderr, "Error in hg_atomic_cas64: should not swap values\n");
         ret = EXIT_FAILURE;
+        goto done;
     }
-#endif
 
+done:
     return ret;
 }
diff --git a/Testing/util/test_thread.c b/Testing/util/test_thread.c
index 1888b33..0312b5d 100644
--- a/Testing/util/test_thread.c
+++ b/Testing/util/test_thread.c
@@ -56,6 +56,20 @@ done:
     return thread_ret;
 }
 
+static HG_THREAD_RETURN_TYPE
+thread_cb_equal(void *arg)
+{
+    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
+    hg_thread_t *t1_ptr = (hg_thread_t *) arg;
+    hg_thread_t t2 = hg_thread_self();
+
+    if (hg_thread_equal(*t1_ptr, t2) == 0)
+        fprintf(stderr, "Error: t1 is not equal to t2\n");
+
+    hg_thread_exit(thread_ret);
+    return thread_ret;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -86,6 +100,9 @@ main(int argc, char *argv[])
     hg_thread_join(thread);
     hg_thread_key_delete(thread_key);
 
+    hg_thread_create(&thread, thread_cb_equal, &thread);
+    hg_thread_join(thread);
+
 done:
     return ret;
 }
diff --git a/Testing/util/test_thread_condition.c b/Testing/util/test_thread_condition.c
index aed9052..a7ad671 100644
--- a/Testing/util/test_thread_condition.c
+++ b/Testing/util/test_thread_condition.c
@@ -6,8 +6,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#define MERCURY_TESTING_NUM_THREADS 8
-
 static hg_thread_cond_t thread_cond;
 static hg_thread_mutex_t thread_mutex;
 static int working = 0;
@@ -57,26 +55,26 @@ thread_cb_cond_all(void *arg)
 int
 main(int argc, char *argv[])
 {
-    hg_thread_t thread[MERCURY_TESTING_NUM_THREADS];
+    hg_thread_t thread[HG_TEST_NUM_THREADS_DEFAULT];
     int ret = EXIT_SUCCESS;
     int i;
 
     (void) argc;
     (void) argv;
 
-    for (i = 0; i < MERCURY_TESTING_NUM_THREADS; i++)
+    for (i = 0; i < HG_TEST_NUM_THREADS_DEFAULT; i++)
         hg_thread_init(&thread[i]);
     hg_thread_mutex_init(&thread_mutex);
     hg_thread_cond_init(&thread_cond);
 
-    for (i = 0; i < MERCURY_TESTING_NUM_THREADS; i++)
+    for (i = 0; i < HG_TEST_NUM_THREADS_DEFAULT; i++)
         hg_thread_create(&thread[i], thread_cb_cond, NULL);
-    for (i = 0; i < MERCURY_TESTING_NUM_THREADS; i++)
+    for (i = 0; i < HG_TEST_NUM_THREADS_DEFAULT; i++)
         hg_thread_join(thread[i]);
 
     working = 1;
 
-    for (i = 0; i < MERCURY_TESTING_NUM_THREADS; i++)
+    for (i = 0; i < HG_TEST_NUM_THREADS_DEFAULT; i++)
         hg_thread_create(&thread[i], thread_cb_cond_all, NULL);
 
     hg_thread_mutex_lock(&thread_mutex);
@@ -84,7 +82,7 @@ main(int argc, char *argv[])
     hg_thread_cond_broadcast(&thread_cond);
     hg_thread_mutex_unlock(&thread_mutex);
 
-    for (i = 0; i < MERCURY_TESTING_NUM_THREADS; i++)
+    for (i = 0; i < HG_TEST_NUM_THREADS_DEFAULT; i++)
         hg_thread_join(thread[i]);
 
     return ret;
diff --git a/Testing/util/test_threadpool.c b/Testing/util/test_threadpool.c
index 3318ae2..d174a5c 100644
--- a/Testing/util/test_threadpool.c
+++ b/Testing/util/test_threadpool.c
@@ -6,7 +6,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#define MERCURY_TESTING_NUM_THREADS 8
 #define POOL_NUM_POSTS 32
 
 /*
@@ -55,7 +54,7 @@ main(int argc, char *argv[])
     (void) argc;
     (void) argv;
     hg_thread_mutex_init(&mymutex);
-    hg_thread_pool_init(MERCURY_TESTING_NUM_THREADS, &thread_pool);
+    hg_thread_pool_init(HG_TEST_NUM_THREADS_DEFAULT, &thread_pool);
 
     for (i = 0; i < POOL_NUM_POSTS; i++) {
         work[i].func = myfunc;
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 55e1b8f..f258f24 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -243,7 +243,6 @@ set(MERCURY_HEADERS
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core_header.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core_types.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_error.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_header.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_macros.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_proc_bulk.h
diff --git a/src/mercury.c b/src/mercury.c
index af27515..4101ffe 100644
--- a/src/mercury.c
+++ b/src/mercury.c
@@ -12,6 +12,7 @@
 #include "mercury_bulk.h"
 #include "mercury_proc.h"
 #include "mercury_proc_bulk.h"
+#include "mercury_error.h"
 
 #include "mercury_hash_string.h"
 #include "mercury_mem.h"
@@ -19,6 +20,7 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include <assert.h>
 
 /****************/
 /* Local Macros */
@@ -26,10 +28,6 @@
 
 #define HG_POST_LIMIT_DEFAULT 256
 
-/* Convert value to string */
-#define HG_ERROR_STRING_MACRO(def, value, string) \
-  if (value == def) string = #def
-
 #define HG_CONTEXT_CLASS(context) \
     ((struct hg_private_class *)(context->hg_class))
 
@@ -40,11 +38,9 @@
 /* HG class */
 struct hg_private_class {
     struct hg_class hg_class;       /* Must remain as first field */
-    hg_thread_spin_t register_lock; /* Register lock */
-
-    /* Callbacks */
     hg_return_t (*handle_create)(hg_handle_t, void *);  /* handle_create */
     void *handle_create_arg;                            /* handle_create arg */
+    hg_thread_spin_t register_lock; /* Register lock */
 };
 
 /* Info for function map */
@@ -52,28 +48,28 @@ struct hg_proc_info {
     hg_rpc_cb_t rpc_cb;             /* RPC callback */
     hg_proc_cb_t in_proc_cb;        /* Input proc callback */
     hg_proc_cb_t out_proc_cb;       /* Output proc callback */
-    hg_bool_t no_response;          /* RPC response not expected */
     void *data;                     /* User data */
     void (*free_callback)(void *);  /* User data free callback */
+    hg_bool_t no_response;          /* RPC response not expected */
 };
 
 /* HG handle */
 struct hg_private_handle {
     struct hg_handle handle;        /* Must remain as first field */
+    struct hg_header hg_header;     /* Header for input/output */
     hg_cb_t forward_cb;             /* Forward callback */
-    void *forward_arg;              /* Forward callback args */
     hg_cb_t respond_cb;             /* Respond callback */
+    hg_return_t (*extra_bulk_transfer_cb)(hg_core_handle_t); /* Bulk transfer callback */
+    void *forward_arg;              /* Forward callback args */
     void *respond_arg;              /* Respond callback args */
-    struct hg_header hg_header;     /* Header for input/output */
+    void *in_extra_buf;             /* Extra input buffer */
+    void *out_extra_buf;            /* Extra output buffer */
     hg_proc_t in_proc;              /* Proc for input */
     hg_proc_t out_proc;             /* Proc for output */
-    void *in_extra_buf;             /* Extra input buffer */
-    hg_size_t in_extra_buf_size;    /* Extra input buffer size */
     hg_bulk_t in_extra_bulk;        /* Extra input bulk handle */
-    void *out_extra_buf;            /* Extra output buffer */
-    hg_size_t out_extra_buf_size;   /* Extra output buffer size */
     hg_bulk_t out_extra_bulk;       /* Extra output bulk handle */
-    hg_return_t (*extra_bulk_transfer_cb)(hg_core_handle_t); /* Bulk transfer callback */
+    hg_size_t in_extra_buf_size;    /* Extra input buffer size */
+    hg_size_t out_extra_buf_size;   /* Extra output buffer size */
 };
 
 /* HG op id */
@@ -83,13 +79,13 @@ struct hg_op_info_lookup {
 };
 
 struct hg_op_id {
-    struct hg_context *context;     /* Context */
-    hg_cb_type_t type;              /* Callback type */
-    hg_cb_t callback;               /* Callback */
-    void *arg;                      /* Callback arguments */
     union {
         struct hg_op_info_lookup lookup;
     } info;
+    struct hg_context *context;     /* Context */
+    hg_cb_t callback;               /* Callback */
+    void *arg;                      /* Callback arguments */
+    hg_cb_type_t type;              /* Callback type */
 };
 
 /********************/
@@ -244,6 +240,16 @@ hg_core_respond_cb(
 /* Local Variables */
 /*******************/
 
+/* Return code string table */
+#define X(a) #a,
+static const char *const hg_return_name[] = { HG_RETURN_VALUES };
+#undef X
+
+/* Default error log mask */
+#ifdef HG_HAS_VERBOSE_ERROR
+unsigned int HG_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
+#endif
+
 /*---------------------------------------------------------------------------*/
 /**
  * Free function for value in function map.
@@ -268,28 +274,27 @@ hg_handle_create(struct hg_private_class *hg_class)
     /* Create private data to wrap callbacks etc */
     hg_handle = (struct hg_private_handle *) malloc(
         sizeof(struct hg_private_handle));
-    if (!hg_handle) {
-        HG_LOG_ERROR("Could not allocate private data");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_handle == NULL, error,
+        "Could not allocate handle private data");
+
     memset(hg_handle, 0, sizeof(struct hg_private_handle));
     hg_handle->handle.info.hg_class = (hg_class_t *) hg_class;
     hg_header_init(&hg_handle->hg_header, HG_UNDEF);
 
     /* CRC32 is enough for small size buffers */
-    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32, &hg_handle->in_proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Cannot create HG proc");
-        goto done;
-    }
-    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32, &hg_handle->out_proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Cannot create HG proc");
-        goto done;
-    }
+    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32,
+        &hg_handle->in_proc);
+    HG_CHECK_HG_ERROR(error, ret, "Cannot create HG proc");
+
+    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32,
+        &hg_handle->out_proc);
+    HG_CHECK_HG_ERROR(error, ret, "Cannot create HG proc");
 
-done:
     return hg_handle;
+
+error:
+    hg_handle_free(hg_handle);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -298,6 +303,9 @@ hg_handle_free(void *arg)
 {
     struct hg_private_handle *hg_handle = (struct hg_private_handle *) arg;
 
+    if (!hg_handle)
+        return;
+
     if (hg_handle->handle.data_free_callback)
         hg_handle->handle.data_free_callback(hg_handle->handle.data);
     if (hg_handle->in_proc != HG_PROC_NULL)
@@ -317,11 +325,9 @@ hg_handle_create_cb(hg_core_handle_t core_handle, void *arg)
     hg_return_t ret = HG_SUCCESS;
 
     hg_handle = hg_handle_create(HG_CONTEXT_CLASS(hg_context));
-    if (!hg_handle) {
-        HG_LOG_ERROR("Could not create HG handle");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_handle == NULL, error, ret, HG_NOMEM,
+        "Could not create HG handle");
+
     hg_handle->handle.core_handle = core_handle;
     hg_handle->handle.info.context = hg_context;
 
@@ -332,13 +338,13 @@ hg_handle_create_cb(hg_core_handle_t core_handle, void *arg)
         ret = HG_CONTEXT_CLASS(hg_context)->handle_create(
             (hg_handle_t) hg_handle,
             HG_CONTEXT_CLASS(hg_context)->handle_create_arg);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Error in handle create callback");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Error in handle create callback");
     }
 
-done:
+    return ret;
+
+error:
+    hg_handle_free(hg_handle);
     return ret;
 }
 
@@ -353,11 +359,8 @@ hg_more_data_cb(hg_core_handle_t core_handle, hg_op_t op,
 
     /* Retrieve private data */
     hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
-    if (!hg_handle) {
-        HG_LOG_ERROR("Could not get private data");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_handle == NULL, done, ret, HG_FAULT,
+        "Could not get private data");
 
     switch (op) {
         case HG_INPUT:
@@ -367,25 +370,18 @@ hg_more_data_cb(hg_core_handle_t core_handle, hg_op_t op,
             extra_buf = hg_handle->out_extra_buf;
             break;
         default:
-            HG_LOG_ERROR("Invalid HG op");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
     }
 
     if (extra_buf) {
         /* We were forwarding to ourself and the extra buf is already set */
         ret = done_cb(core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not execute more data done callback");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret,
+            "Could not execute more data done callback");
     } else {
         /* We need to do a bulk transfer to get the extra data */
         ret = hg_get_extra_payload(hg_handle, op, done_cb);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get extra input");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not get extra payload");
     }
 
 done:
@@ -400,14 +396,10 @@ hg_more_data_free_cb(hg_core_handle_t core_handle)
 
     /* Retrieve private data */
     hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
-    if (!hg_handle) {
-        goto done;
-    }
+    if (!hg_handle)
+        return;
 
     hg_free_extra_payload(hg_handle);
-
-done:
-    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -425,16 +417,17 @@ hg_core_rpc_cb(hg_core_handle_t core_handle)
     hg_handle->handle.info.context_id = hg_core_info->context_id;
     hg_handle->handle.info.id = hg_core_info->id;
 
-    if (!hg_proc_info->rpc_cb) {
-        HG_LOG_ERROR("No RPC callback registered");
-        /* Need to decrement refcount on handle */
-        HG_Core_destroy(core_handle);
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info->rpc_cb == NULL, error, ret, HG_INVALID_ARG,
+        "No RPC callback registered");
+
     ret = hg_proc_info->rpc_cb((hg_handle_t) hg_handle);
 
-done:
+    return ret;
+
+error:
+    /* Need to decrement refcount on handle */
+    HG_Core_destroy(core_handle);
+
     return ret;
 }
 
@@ -454,6 +447,7 @@ hg_core_addr_lookup_cb(const struct hg_core_cb_info *callback_info)
         hg_op_id->callback(&hg_cb_info);
 
     free(hg_op_id);
+
     return ret;
 }
 
@@ -484,21 +478,19 @@ hg_get_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.input.hash;
 #endif
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get input buffer");
-                goto done;
-            }
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer");
+
             extra_buf = hg_handle->in_extra_buf;
             extra_buf_size = hg_handle->in_extra_buf_size;
             break;
         case HG_OUTPUT:
             /* Cannot respond if no_response flag set */
-            if (hg_proc_info->no_response) {
-                HG_LOG_ERROR("No output was produced on that RPC (no response)");
-                ret = HG_PROTOCOL_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(hg_proc_info->no_response, done, ret,
+                HG_OPNOTSUPPORTED,
+                "No output was produced on that RPC (no response)");
+
             /* Use custom header offset */
             header_offset += hg_handle->handle.info.hg_class->out_offset;
             /* Set output proc */
@@ -508,34 +500,25 @@ hg_get_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.output.hash;
 #endif
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get output buffer");
-                goto done;
-            }
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer");
+
             extra_buf = hg_handle->out_extra_buf;
             extra_buf_size = hg_handle->out_extra_buf_size;
             break;
         default:
-            HG_LOG_ERROR("Invalid HG op");
-            ret = HG_INVALID_PARAM;
-            goto done;
-    }
-    if (!proc_cb) {
-        HG_LOG_ERROR("No proc set, proc must be set in HG_Register()");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
     }
+    HG_CHECK_ERROR(proc_cb == NULL, done, ret, HG_FAULT,
+        "No proc set, proc must be set in HG_Register()");
 
     /* Reset header */
     hg_header_reset(hg_header, op);
 
     /* Get header */
     ret = hg_header_proc(HG_DECODE, buf, buf_size, hg_header);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process header");
 
     /* If the payload did not fit into the core buffer and we have an extra
      * buffer set, use that buffer directly */
@@ -550,33 +533,21 @@ hg_get_struct(struct hg_private_handle *hg_handle,
 
     /* Reset proc */
     ret = hg_proc_reset(proc, buf, buf_size, HG_DECODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
 
     /* Decode parameters */
     ret = proc_cb(proc, struct_ptr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode parameters");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not decode parameters");
 
     /* Flush proc */
     ret = hg_proc_flush(proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in proc flush");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
 
 #ifdef HG_HAS_CHECKSUMS
     /* Compare checksum with header hash */
     ret = hg_proc_checksum_verify(proc, &hg_header_hash->payload,
         sizeof(hg_header_hash->payload));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in proc checksum verify");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error in proc checksum verify");
 #endif
 
     /* Increment ref count on handle so that it remains valid until free_struct
@@ -616,22 +587,20 @@ hg_set_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.input.hash;
 #endif
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get input buffer");
-                goto done;
-            }
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer");
+
             extra_buf = &hg_handle->in_extra_buf;
             extra_buf_size = &hg_handle->in_extra_buf_size;
             extra_bulk = &hg_handle->in_extra_bulk;
             break;
         case HG_OUTPUT:
             /* Cannot respond if no_response flag set */
-            if (hg_proc_info->no_response) {
-                HG_LOG_ERROR("No output was produced on that RPC (no response)");
-                ret = HG_PROTOCOL_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(hg_proc_info->no_response, done, ret,
+                HG_OPNOTSUPPORTED,
+                "No output was produced on that RPC (no response)");
+
             /* Use custom header offset */
             header_offset += hg_handle->handle.info.hg_class->out_offset;
             /* Set output proc */
@@ -641,19 +610,16 @@ hg_set_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.output.hash;
 #endif
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get output buffer");
-                goto done;
-            }
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer");
+
             extra_buf = &hg_handle->out_extra_buf;
             extra_buf_size = &hg_handle->out_extra_buf_size;
             extra_bulk = &hg_handle->out_extra_bulk;
             break;
         default:
-            HG_LOG_ERROR("Invalid HG op");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
     }
     if (!proc_cb || !struct_ptr) {
         /* Silently skip */
@@ -670,33 +636,21 @@ hg_set_struct(struct hg_private_handle *hg_handle,
 
     /* Reset proc */
     ret = hg_proc_reset(proc, buf, buf_size, HG_ENCODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
 
     /* Encode parameters */
     ret = proc_cb(proc, struct_ptr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode parameters");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode parameters");
 
     /* Flush proc */
     ret = hg_proc_flush(proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in proc flush");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
 
 #ifdef HG_HAS_CHECKSUMS
     /* Set checksum in header */
     ret = hg_proc_checksum_get(proc, &hg_header_hash->payload,
         sizeof(hg_header_hash->payload));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in getting proc checksum");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error in getting proc checksum");
 #endif
 
     /* The proc object may have allocated an extra buffer at this point.
@@ -709,9 +663,8 @@ hg_set_struct(struct hg_private_handle *hg_handle,
         /* Potentially free previous payload if handle was not reset */
         hg_free_extra_payload(hg_handle);
 #ifdef HG_HAS_XDR
-        HG_LOG_ERROR("Extra encoding using XDR is not yet supported");
-        ret = HG_SIZE_ERROR;
-        goto done;
+        HG_GOTO_ERROR(done, HG_PROTOCOL_ERROR,
+            "Extra encoding using XDR is not yet supported");
 #endif
         /* Create a bulk descriptor only of the size that is used */
         *extra_buf = hg_proc_get_extra_buf(proc);
@@ -723,38 +676,23 @@ hg_set_struct(struct hg_private_handle *hg_handle,
         /* Create bulk descriptor */
         ret = HG_Bulk_create(hg_handle->handle.info.hg_class, 1, extra_buf,
             extra_buf_size, HG_BULK_READ_ONLY, extra_bulk);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not create bulk data handle");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not create bulk data handle");
 
         /* Reset proc */
         ret = hg_proc_reset(proc, buf, buf_size, HG_ENCODE);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not reset proc");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
 
         /* Encode extra_bulk_handle, we can do that safely here because
          * the user payload has been copied so we don't have to worry
          * about overwriting the user's data */
         ret = hg_proc_hg_bulk_t(proc, extra_bulk);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not process extra bulk handle");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not process extra bulk handle");
 
         ret = hg_proc_flush(proc);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Error in proc flush");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
 
-        if (hg_proc_get_extra_buf(proc)) {
-            HG_LOG_ERROR("Extra bulk handle could not fit into buffer");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_proc_get_extra_buf(proc), done, ret,
+            HG_OVERFLOW, "Extra bulk handle could not fit into buffer");
 
         *more_data = HG_TRUE;
     }
@@ -763,10 +701,7 @@ hg_set_struct(struct hg_private_handle *hg_handle,
     buf = (char *) buf - header_offset;
     buf_size += header_offset;
     ret = hg_header_proc(HG_ENCODE, buf, buf_size, hg_header);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process header");
 
     /* Only send the actual size of the data, not the entire buffer */
     *payload_size = hg_proc_get_size_used(proc) + header_offset;
@@ -796,36 +731,22 @@ hg_free_struct(struct hg_private_handle *hg_handle,
             proc_cb = hg_proc_info->out_proc_cb;
             break;
         default:
-            HG_LOG_ERROR("Invalid HG op");
-            ret = HG_INVALID_PARAM;
-            goto done;
-    }
-    if (!proc_cb) {
-        HG_LOG_ERROR("No proc set, proc must be set in HG_Register()");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
     }
+    HG_CHECK_ERROR(proc_cb == NULL, done, ret, HG_FAULT,
+        "No proc set, proc must be set in HG_Register()");
 
     /* Reset proc */
     ret = hg_proc_reset(proc, NULL, 0, HG_FREE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
 
     /* Free memory allocated during decode operation */
     ret = proc_cb(proc, struct_ptr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free allocated parameters");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free allocated parameters");
 
     /* Decrement ref count or free */
     ret = HG_Core_destroy(hg_handle->handle.core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decrement handle ref count");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not decrement handle ref count");
 
 done:
     return ret;
@@ -854,11 +775,10 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
             /* Set input proc */
             proc = hg_handle->in_proc;
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get input buffer");
-                goto done;
-            }
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer");
+
             extra_buf = &hg_handle->in_extra_buf;
             extra_buf_size = &hg_handle->in_extra_buf_size;
             extra_bulk = &hg_handle->in_extra_bulk;
@@ -869,19 +789,16 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
             /* Set output proc */
             proc = hg_handle->out_proc;
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get output buffer");
-                goto done;
-            }
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer");
+
             extra_buf = &hg_handle->out_extra_buf;
             extra_buf_size = &hg_handle->out_extra_buf_size;
             extra_bulk = &hg_handle->out_extra_bulk;
             break;
         default:
-            HG_LOG_ERROR("Invalid HG op");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
     }
 
     /* Include our own header offset */
@@ -889,39 +806,24 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
     buf_size -= header_offset;
 
     ret = hg_proc_reset(proc, buf, buf_size, HG_DECODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
 
     /* Decode extra bulk handle */
     ret = hg_proc_hg_bulk_t(proc, extra_bulk);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process extra bulk handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process extra bulk handle");
 
     ret = hg_proc_flush(proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in proc flush");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
 
     /* Create a new local handle to read the data */
     *extra_buf_size = HG_Bulk_get_size(*extra_bulk);
     *extra_buf = hg_mem_aligned_alloc(page_size, *extra_buf_size);
-    if (!*extra_buf) {
-        HG_LOG_ERROR("Could not allocate extra payload buffer");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(*extra_buf == NULL, done, ret, HG_NOMEM,
+        "Could not allocate extra payload buffer");
 
     ret = HG_Bulk_create(hg_handle->handle.info.hg_class, 1, extra_buf,
         extra_buf_size, HG_BULK_READWRITE, &local_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not create HG bulk handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not create HG bulk handle");
 
     /* Read bulk data here and wait for the data to be here  */
     hg_handle->extra_bulk_transfer_cb = done_cb;
@@ -930,10 +832,7 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
         (hg_addr_t) hg_core_info->addr, hg_core_info->context_id,
         *extra_bulk, 0, local_handle, 0, *extra_buf_size,
         HG_OP_ID_IGNORE /* TODO not used for now */);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not transfer bulk data");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not transfer bulk data");
 
 done:
     HG_Bulk_free(local_handle);
@@ -953,10 +852,7 @@ hg_get_extra_payload_cb(const struct hg_cb_info *callback_info)
     hg_return_t ret = HG_SUCCESS;
 
     ret = hg_handle->extra_bulk_transfer_cb(hg_handle->handle.core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not execute bulk transfer callback");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not execute bulk transfer callback");
 
 done:
     return ret;
@@ -1047,21 +943,7 @@ HG_Version_get(unsigned int *major, unsigned int *minor, unsigned int *patch)
 const char *
 HG_Error_to_string(hg_return_t errnum)
 {
-    const char *hg_error_string = "UNDEFINED/UNRECOGNIZED NA ERROR";
-
-    HG_ERROR_STRING_MACRO(HG_SUCCESS, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_NA_ERROR, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_TIMEOUT, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_INVALID_PARAM, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_SIZE_ERROR, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_NOMEM_ERROR, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_PROTOCOL_ERROR, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_NO_MATCH, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_CHECKSUM_ERROR, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_CANCELED, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_OTHER_ERROR, errnum, hg_error_string);
-
-    return hg_error_string;
+    return hg_return_name[errnum];
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1077,34 +959,42 @@ HG_Init_opt(const char *na_info_string, hg_bool_t na_listen,
     const struct hg_init_info *hg_init_info)
 {
     struct hg_private_class *hg_class = NULL;
-    hg_return_t ret = HG_SUCCESS;
+#ifdef HG_HAS_VERBOSE_ERROR
+    const char *log_level = NULL;
+
+    /* Set log level */
+    log_level = getenv("HG_LOG_LEVEL");
+    if (log_level && (strcmp(log_level, "debug") == 0))
+        HG_LOG_MASK |= HG_LOG_TYPE_DEBUG;
+#endif
+
+    /* Make sure error return codes match */
+    assert(HG_CANCELED == (hg_return_t) NA_CANCELED);
 
     hg_class = malloc(sizeof(struct hg_private_class));
-    if (!hg_class) {
-        HG_LOG_ERROR("Could not allocate HG class");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_class == NULL, error,
+        "Could not allocate HG class");
+
     memset(hg_class, 0, sizeof(struct hg_private_class));
     hg_thread_spin_init(&hg_class->register_lock);
 
     hg_class->hg_class.core_class = HG_Core_init_opt(na_info_string, na_listen,
         hg_init_info);
-    if (!hg_class->hg_class.core_class) {
-        HG_LOG_ERROR("Could not create HG core class");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_class->hg_class.core_class == NULL, error,
+        "Could not create HG core class");
 
     /* Set more data callback */
     HG_Core_set_more_data_callback(hg_class->hg_class.core_class,
         hg_more_data_cb, hg_more_data_free_cb);
 
-done:
-    if (ret != HG_SUCCESS) {
+    return (hg_class_t *) hg_class;
+
+error:
+    if (hg_class) {
+        hg_thread_spin_destroy(&hg_class->register_lock);
         free(hg_class);
-        hg_class = NULL;
     }
-    return (hg_class_t *) hg_class;
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1116,10 +1006,8 @@ HG_Finalize(hg_class_t *hg_class)
     hg_return_t ret = HG_SUCCESS;
 
     ret = HG_Core_finalize(private_class->hg_class.core_class);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize HG core class");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not finalize HG core class");
+
     hg_thread_spin_destroy(&private_class->register_lock);
     free(private_class);
 
@@ -1143,11 +1031,8 @@ HG_Class_set_handle_create_callback(hg_class_t *hg_class,
         (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     private_class->handle_create = callback;
     private_class->handle_create_arg = arg;
@@ -1174,26 +1059,19 @@ HG_Context_create_id(hg_class_t *hg_class, hg_uint8_t id)
 #else
     unsigned int request_count = HG_POST_LIMIT_DEFAULT;
 #endif
-    hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_class == NULL, error, "NULL HG class");
 
     hg_context = malloc(sizeof(struct hg_context));
-    if (!hg_context) {
-        HG_LOG_ERROR("Could not allocate HG context");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_context == NULL, error,
+        "Could not allocate HG context");
+
     memset(hg_context, 0, sizeof(struct hg_context));
     hg_context->hg_class = hg_class;
     hg_context->core_context = HG_Core_context_create_id(
         hg_class->core_class, id);
-    if (!hg_context->core_context) {
-        HG_LOG_ERROR("Could not create context for ID %u", id);
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_context->core_context == NULL, error,
+        "Could not create context for ID %u", id);
 
     /* Set handle create callback */
     HG_Core_context_set_handle_create_callback(hg_context->core_context,
@@ -1201,16 +1079,24 @@ HG_Context_create_id(hg_class_t *hg_class, hg_uint8_t id)
 
     /* If we are listening, start posting requests */
     if (HG_Core_class_is_listening(hg_class->core_class)) {
-        ret = HG_Core_context_post(hg_context->core_context, request_count,
-            HG_TRUE);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not post context requests");
-            goto done;
-        }
+        hg_return_t ret = HG_Core_context_post(hg_context->core_context,
+            request_count, HG_TRUE);
+        HG_CHECK_HG_ERROR(error, ret, "Could not post context requests (%s)",
+            HG_Error_to_string(ret));
     }
 
-done:
     return hg_context;
+
+error:
+    if (hg_context) {
+        if (hg_context->core_context) {
+            hg_return_t ret = HG_Core_context_destroy(hg_context->core_context);
+            HG_CHECK_ERROR_DONE(ret != HG_SUCCESS,
+                "Could not destroy HG core context");
+        }
+        free(hg_context);
+    }
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1219,17 +1105,13 @@ HG_Context_destroy(hg_context_t *context)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
 
     ret = HG_Core_context_destroy(context->core_context);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy HG core context");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not destroy HG core context (%s)",
+        HG_Error_to_string(ret));
+
     free(context);
 
 done:
@@ -1242,26 +1124,18 @@ HG_Register_name(hg_class_t *hg_class, const char *func_name,
     hg_proc_cb_t in_proc_cb, hg_proc_cb_t out_proc_cb, hg_rpc_cb_t rpc_cb)
 {
     hg_id_t id = 0;
-    hg_return_t ret = HG_SUCCESS;
+    hg_return_t ret;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
-    if (!func_name) {
-        HG_LOG_ERROR("NULL string");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_class == NULL, done, "NULL HG class");
+    HG_CHECK_ERROR_NORET(func_name == NULL, done, "NULL string");
 
     /* Generate an ID from the function name */
     id = hg_hash_string(func_name);
 
     /* Register RPC */
     ret = HG_Register(hg_class, id, in_proc_cb, out_proc_cb, rpc_cb);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not register RPC id");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not register RPC ID (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return id;
@@ -1277,31 +1151,23 @@ HG_Registered_name(hg_class_t *hg_class, const char *func_name, hg_id_t *id,
     hg_id_t rpc_id = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!func_name) {
-        HG_LOG_ERROR("NULL string");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    hg_thread_spin_lock(&private_class->register_lock);
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
+    HG_CHECK_ERROR(func_name == NULL, done, ret, HG_INVALID_ARG, "NULL string");
 
     /* Generate an ID from the function name */
     rpc_id = hg_hash_string(func_name);
 
+    hg_thread_spin_lock(&private_class->register_lock);
+
     ret = HG_Core_registered(private_class->hg_class.core_class, rpc_id, flag);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not check for registered RPC id");
-        hg_thread_spin_unlock(&private_class->register_lock);
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(unlock, ret, "Could not check for registered RPC ID (%s)",
+        HG_Error_to_string(ret));
 
-    if (id) *id = rpc_id;
+    if (id)
+        *id = rpc_id;
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1316,67 +1182,59 @@ HG_Register(hg_class_t *hg_class, hg_id_t id, hg_proc_cb_t in_proc_cb,
     struct hg_private_class *private_class =
         (struct hg_private_class *) hg_class;
     struct hg_proc_info *hg_proc_info = NULL;
-    hg_bool_t registered;
+    hg_bool_t registered = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Check if already registered */
     ret = HG_Core_registered(hg_class->core_class, id, &registered);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not check for registered RPC id");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not check for registered RPC ID (%s)",
+        HG_Error_to_string(ret));
 
     /* Register RPC (register only RPC callback if already registered) */
     ret = HG_Core_register(hg_class->core_class, id, hg_core_rpc_cb);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not register RPC id");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not register RPC ID (%s)",
+        HG_Error_to_string(ret));
 
     if (!registered) {
         hg_proc_info =
             (struct hg_proc_info *) malloc(sizeof(struct hg_proc_info));
-        if (!hg_proc_info) {
-            HG_LOG_ERROR("Could not allocate proc info");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_proc_info == NULL, error, ret, HG_NOMEM,
+            "Could not allocate proc info");
         memset(hg_proc_info, 0, sizeof(struct hg_proc_info));
 
         /* Attach proc info to RPC ID */
         ret = HG_Core_register_data(hg_class->core_class, id, hg_proc_info,
             hg_proc_info_free);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not set proc info");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not set proc info (%s)",
+            HG_Error_to_string(ret));
+        registered = HG_TRUE;
     } else {
         /* Retrieve proc function from function map */
         hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
             hg_class->core_class, id);
-        if (!hg_proc_info) {
-            HG_LOG_ERROR("Could not get registered data");
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_proc_info == NULL, error, ret, HG_FAULT,
+            "Could not get registered data");
     }
     hg_proc_info->rpc_cb = rpc_cb;
     hg_proc_info->in_proc_cb = in_proc_cb;
     hg_proc_info->out_proc_cb = out_proc_cb;
 
+    hg_thread_spin_unlock(&private_class->register_lock);
+
 done:
-    if (ret != HG_SUCCESS) {
+    return ret;
+
+error:
+    if (registered)
+        HG_Core_deregister(hg_class->core_class, id);
+    else
         free(hg_proc_info);
-    }
-    if (hg_class)
-        hg_thread_spin_unlock(&private_class->register_lock);
+    hg_thread_spin_unlock(&private_class->register_lock);
     return ret;
 }
 
@@ -1388,15 +1246,14 @@ HG_Deregister(hg_class_t *hg_class, hg_id_t id)
         (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
     ret = HG_Core_deregister(hg_class->core_class, id);
     hg_thread_spin_unlock(&private_class->register_lock);
+    HG_CHECK_HG_ERROR(done, ret, "Could not deregister RPC ID (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1410,15 +1267,14 @@ HG_Registered(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag)
         (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
     ret = HG_Core_registered(hg_class->core_class, id, flag);
     hg_thread_spin_unlock(&private_class->register_lock);
+    HG_CHECK_HG_ERROR(done, ret, "Could not check for registered RPC ID (s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1434,31 +1290,29 @@ HG_Registered_proc_cb(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     ret = HG_Core_registered(hg_class->core_class, id, flag);
-    if(ret == HG_SUCCESS && *flag) {
+    HG_CHECK_HG_ERROR(unlock, ret, "Could not check for registered RPC ID (%s)",
+        HG_Error_to_string(ret));
+
+    if(*flag) {
         /* if RPC is registered, retrieve pointers */
         hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
             hg_class->core_class, id);
-        if (!hg_proc_info) {
-            HG_LOG_ERROR("Could not get registered data");
-            ret = HG_NO_MATCH;
-            hg_thread_spin_unlock(&private_class->register_lock);
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_FAULT,
+            "Could not get registered data");
+
         if (in_proc_cb)
             *in_proc_cb = hg_proc_info->in_proc_cb;
         if (out_proc_cb)
             *out_proc_cb = hg_proc_info->out_proc_cb;
     }
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1475,27 +1329,21 @@ HG_Register_data(hg_class_t *hg_class, hg_id_t id, void *data,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get registered data");
-        ret = HG_NO_MATCH;
-        hg_thread_spin_unlock(&private_class->register_lock);
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_NOENTRY,
+        "Could not get registered data");
 
     hg_proc_info->data = data;
     hg_proc_info->free_callback = free_callback;
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1511,24 +1359,19 @@ HG_Registered_data(hg_class_t *hg_class, hg_id_t id)
     struct hg_proc_info *hg_proc_info = NULL;
     void *data = NULL;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_class == NULL, done, "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get registered data");
-        hg_thread_spin_unlock(&private_class->register_lock);
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_proc_info == NULL, unlock,
+        "Could not get registered data");
 
     data = hg_proc_info->data;
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1545,26 +1388,20 @@ HG_Registered_disable_response(hg_class_t *hg_class, hg_id_t id,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get registered data");
-        ret = HG_NO_MATCH;
-        hg_thread_spin_unlock(&private_class->register_lock);
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_NOENTRY,
+        "Could not get registered data");
 
     hg_proc_info->no_response = disable;
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1581,31 +1418,22 @@ HG_Registered_disabled_response(hg_class_t *hg_class, hg_id_t id,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!disabled) {
-        HG_LOG_ERROR("NULL pointer to disabled flag");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
+    HG_CHECK_ERROR(disabled == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to disabled flag");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get registered data");
-        ret = HG_NO_MATCH;
-        hg_thread_spin_unlock(&private_class->register_lock);
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_NOENTRY,
+        "Could not get registered data");
 
     *disabled = hg_proc_info->no_response;
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1620,33 +1448,34 @@ HG_Addr_lookup(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_op_id *hg_op_id = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, error, ret, HG_INVALID_ARG,
+        "NULL HG context");
 
     /* Allocate op_id */
     hg_op_id = (struct hg_op_id *) malloc(sizeof(struct hg_op_id));
-    if (!hg_op_id) {
-        HG_LOG_ERROR("Could not allocate HG operation ID");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_op_id == NULL, error, ret, HG_NOMEM,
+        "Could not allocate HG operation ID");
+
     hg_op_id->context = context;
     hg_op_id->type = HG_CB_LOOKUP;
     hg_op_id->callback = callback;
     hg_op_id->arg = arg;
     hg_op_id->info.lookup.hg_addr = HG_ADDR_NULL;
 
+    ret = HG_Core_addr_lookup(context->core_context, hg_core_addr_lookup_cb,
+        hg_op_id, name, &hg_op_id->info.lookup.core_op_id);
+    HG_CHECK_HG_ERROR(error, ret, "Could not lookup %s (%s)", name,
+        HG_Error_to_string(ret));
+
     /* Assign op_id */
     if (op_id && op_id != HG_OP_ID_IGNORE)
         *op_id = (hg_op_id_t) hg_op_id;
 
-    ret = HG_Core_addr_lookup(context->core_context, hg_core_addr_lookup_cb,
-        hg_op_id, name, &hg_op_id->info.lookup.core_op_id);
+    return ret;
+
+error:
+    free(hg_op_id);
 
-done:
     return ret;
 }
 
@@ -1656,13 +1485,29 @@ HG_Addr_free(hg_class_t *hg_class, hg_addr_t addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     ret = HG_Core_addr_free(hg_class->core_class, (hg_core_addr_t) addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not free addr (%s)",
+        HG_Error_to_string(ret));
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
+HG_Addr_set_remove(hg_class_t *hg_class, hg_addr_t addr)
+{
+    hg_return_t ret = HG_SUCCESS;
+
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
+
+    ret = HG_Core_addr_set_remove(hg_class->core_class, (hg_core_addr_t) addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not set addr to be removed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1674,13 +1519,12 @@ HG_Addr_self(hg_class_t *hg_class, hg_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     ret = HG_Core_addr_self(hg_class->core_class, (hg_core_addr_t *) addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not retrieve self addr (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1692,14 +1536,28 @@ HG_Addr_dup(hg_class_t *hg_class, hg_addr_t addr, hg_addr_t *new_addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     ret = HG_Core_addr_dup(hg_class->core_class, (hg_core_addr_t) addr,
         (hg_core_addr_t *) new_addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not dup addr (%s)",
+        HG_Error_to_string(ret));
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_bool_t
+HG_Addr_cmp(hg_class_t *hg_class, hg_addr_t addr1, hg_addr_t addr2)
+{
+    hg_bool_t ret = HG_FALSE;
+
+    HG_CHECK_ERROR_NORET(hg_class == NULL, done, "NULL HG class");
+
+    ret = HG_Core_addr_cmp(hg_class->core_class, (hg_core_addr_t) addr1,
+        (hg_core_addr_t) addr2);
 
 done:
     return ret;
@@ -1712,14 +1570,13 @@ HG_Addr_to_string(hg_class_t *hg_class, char *buf, hg_size_t *buf_size,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     ret = HG_Core_addr_to_string(hg_class->core_class, buf, buf_size,
         (hg_core_addr_t) addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not convert addr to string (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1734,20 +1591,16 @@ HG_Create(hg_context_t *context, hg_addr_t addr, hg_id_t id,
     hg_core_handle_t core_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
 
     /* Create HG core handle (calls handle_create_cb) */
     ret = HG_Core_create(context->core_context, (hg_core_addr_t) addr, id,
         &core_handle);
-    if (ret != HG_SUCCESS) {
-        if (ret != HG_NO_MATCH) /* silence error if invalid ID is used */
-            HG_LOG_ERROR("Cannot create HG handle with ID %lu", id);
-        goto done;
-    }
+    if (ret == HG_NOENTRY)
+        goto done; /* silence error if invalid ID is used */
+    HG_CHECK_HG_ERROR(done, ret, "Cannot create HG handle with ID %lu (%s)", id,
+        HG_Error_to_string(ret));
 
     /* Get data and HG info */
     hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
@@ -1766,13 +1619,12 @@ HG_Destroy(hg_handle_t handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
+    if (handle == HG_HANDLE_NULL)
         goto done;
-    }
 
     ret = HG_Core_destroy(handle->core_handle);
+    HG_CHECK_HG_ERROR(done, ret, "Could not set handle to be destroyed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1786,18 +1638,13 @@ HG_Reset(hg_handle_t handle, hg_addr_t addr, hg_id_t id)
         (struct hg_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
 
     /* Call core reset */
     ret = HG_Core_reset(handle->core_handle, (hg_core_addr_t) addr, id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset core HG handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not reset core HG handle (%s)",
+        HG_Error_to_string(ret));
 
     /* Set info */
     private_handle->handle.info.addr = addr;
@@ -1815,33 +1662,22 @@ HG_Get_input(hg_handle_t handle, void *in_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!in_struct) {
-        HG_LOG_ERROR("NULL pointer to input struct");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(in_struct == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to input struct");
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Get input struct */
     ret = hg_get_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_INPUT, in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get input");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get input (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1854,33 +1690,22 @@ HG_Free_input(hg_handle_t handle, void *in_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!in_struct) {
-        HG_LOG_ERROR("NULL pointer to input struct");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(in_struct == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to input struct");
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Free input struct */
     ret = hg_free_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_INPUT, in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free input");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free input (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1893,33 +1718,22 @@ HG_Get_output(hg_handle_t handle, void *out_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!out_struct) {
-        HG_LOG_ERROR("NULL pointer to output struct");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(out_struct == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to output struct");
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Get output struct */
     ret = hg_get_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_OUTPUT, out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get output");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get output (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1932,33 +1746,22 @@ HG_Free_output(hg_handle_t handle, void *out_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!out_struct) {
-        HG_LOG_ERROR("NULL pointer to output struct");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(out_struct == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to output struct");
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Free output struct */
     ret = hg_free_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_OUTPUT, out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free output");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free output (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1971,16 +1774,10 @@ HG_Get_input_buf(hg_handle_t handle, void **in_buf, hg_size_t *in_buf_size)
     hg_size_t buf_size, header_offset = hg_header_get_size(HG_INPUT);
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!in_buf) {
-        HG_LOG_ERROR("NULL pointer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(in_buf == NULL, done, ret, HG_INVALID_ARG,
+        "NULL input buffer pointer");
 
     /* Get core input buffer */
     /* Note: any extra header information will be transmitted with the
@@ -1988,10 +1785,8 @@ HG_Get_input_buf(hg_handle_t handle, void **in_buf, hg_size_t *in_buf_size)
      * limit.
      */
     ret = HG_Core_get_input(handle->core_handle, in_buf, &buf_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get input buffer");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer (%s)",
+        HG_Error_to_string(ret));
 
     *in_buf = (char *) *in_buf + header_offset;
     if (in_buf_size)
@@ -2008,16 +1803,10 @@ HG_Get_output_buf(hg_handle_t handle, void **out_buf, hg_size_t *out_buf_size)
     hg_size_t buf_size, header_offset = hg_header_get_size(HG_OUTPUT);
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!out_buf) {
-        HG_LOG_ERROR("NULL pointer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(out_buf == NULL, done, ret, HG_INVALID_ARG,
+        "NULL output buffer pointer");
 
     /* Get core output buffer */
     /* Note: any extra header information will be transmitted with the
@@ -2025,10 +1814,8 @@ HG_Get_output_buf(hg_handle_t handle, void **out_buf, hg_size_t *out_buf_size)
      * size limit.
      */
     ret = HG_Core_get_output(handle->core_handle, out_buf, &buf_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get output buffer");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer (%s)",
+        HG_Error_to_string(ret));
 
     *out_buf = (char *) *out_buf + header_offset;
     if (out_buf_size)
@@ -2040,21 +1827,64 @@ done:
 
 /*---------------------------------------------------------------------------*/
 hg_return_t
+HG_Get_input_extra_buf(hg_handle_t handle, void **in_buf,
+    hg_size_t *in_buf_size)
+{
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
+    hg_return_t ret = HG_SUCCESS;
+
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(in_buf == NULL, done, ret, HG_INVALID_ARG,
+        "NULL input buffer pointer");
+
+    /* No offset if extra buffer since only the user payload is copied */
+    *in_buf = private_handle->in_extra_buf;
+    if (in_buf_size)
+        *in_buf_size = private_handle->in_extra_buf_size;
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
+HG_Get_output_extra_buf(hg_handle_t handle, void **out_buf,
+    hg_size_t *out_buf_size)
+{
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
+    hg_return_t ret = HG_SUCCESS;
+
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(out_buf == NULL, done, ret, HG_INVALID_ARG,
+        "NULL output buffer pointer");
+
+    /* No offset if extra buffer since only the user payload is copied */
+    *out_buf = private_handle->out_extra_buf;
+    if (out_buf_size)
+        *out_buf_size = private_handle->out_extra_buf_size;
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
 HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
 {
     struct hg_private_handle *private_handle =
         (struct hg_private_handle *) handle;
-    const struct hg_proc_info *hg_proc_info;
-    hg_size_t payload_size;
+    const struct hg_proc_info *hg_proc_info = NULL;
+    hg_size_t payload_size = 0;
     hg_bool_t more_data = HG_FALSE;
     hg_uint8_t flags = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
 
     /* Set callback data */
     private_handle->forward_cb = callback;
@@ -2063,19 +1893,14 @@ HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Set input struct */
     ret = hg_set_struct(private_handle, hg_proc_info, HG_INPUT, in_struct,
         &payload_size, &more_data);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set input");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not set input (%s)",
+        HG_Error_to_string(ret));
 
     /* Set more data flag on handle so that handle_more_callback is triggered */
     if (more_data)
@@ -2088,10 +1913,10 @@ HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
     /* Send request */
     ret = HG_Core_forward(handle->core_handle, hg_core_forward_cb, handle,
         flags, payload_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not forward call");
+    if (ret == HG_AGAIN)
         goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not forward call (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -2109,11 +1934,8 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     hg_uint8_t flags = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
 
     /* Set callback data */
     private_handle->respond_cb = callback;
@@ -2122,19 +1944,14 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Set output struct */
     ret = hg_set_struct(private_handle, hg_proc_info, HG_OUTPUT, out_struct,
         &payload_size, &more_data);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set output");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not set output (%s)",
+        HG_Error_to_string(ret));
 
     /* Set more data flag on handle so that handle_more_callback is triggered */
     if (more_data)
@@ -2143,10 +1960,8 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     /* Send response back */
     ret = HG_Core_respond(handle->core_handle, hg_core_respond_cb, handle,
         flags, payload_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not respond");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not respond (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -2158,13 +1973,13 @@ HG_Progress(hg_context_t *context, unsigned int timeout)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
 
     ret = HG_Core_progress(context->core_context, timeout);
+    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        "Could not make progress on context (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -2177,14 +1992,14 @@ HG_Trigger(hg_context_t *context, unsigned int timeout, unsigned int max_count,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
 
     ret = HG_Core_trigger(context->core_context, timeout, max_count,
         actual_count);
+    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        "Could not trigger operations from context (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -2196,13 +2011,12 @@ HG_Cancel(hg_handle_t handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
 
     ret = HG_Core_cancel(handle->core_handle);
+    HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
diff --git a/src/mercury.h b/src/mercury.h
index a052735..d8d385d 100644
--- a/src/mercury.h
+++ b/src/mercury.h
@@ -13,7 +13,6 @@
 
 #include "mercury_types.h"
 #include "mercury_header.h"
-#include "mercury_error.h"
 
 #include "mercury_core.h"
 
@@ -46,7 +45,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Version_get(
         unsigned int *major,
         unsigned int *minor,
@@ -60,7 +59,7 @@ HG_Version_get(
  *
  * \return String
  */
-HG_EXPORT const char *
+HG_PUBLIC const char *
 HG_Error_to_string(
         hg_return_t errnum
         );
@@ -76,7 +75,7 @@ HG_Error_to_string(
  *
  * \return Pointer to HG class or NULL in case of failure
  */
-HG_EXPORT hg_class_t *
+HG_PUBLIC hg_class_t *
 HG_Init(
         const char *na_info_string,
         hg_bool_t na_listen
@@ -95,7 +94,7 @@ HG_Init(
  *
  * \return Pointer to HG class or NULL in case of failure
  */
-HG_EXPORT hg_class_t *
+HG_PUBLIC hg_class_t *
 HG_Init_opt(
         const char *na_info_string,
         hg_bool_t na_listen,
@@ -109,7 +108,7 @@ HG_Init_opt(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Finalize(
         hg_class_t *hg_class
         );
@@ -120,7 +119,7 @@ HG_Finalize(
  * to HG_Finalize(), this routine gives a chance to programs that terminate
  * abnormally to easily clean up those resources.
  */
-HG_EXPORT void
+HG_PUBLIC void
 HG_Cleanup(
         void
         );
@@ -264,7 +263,7 @@ HG_Class_get_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Class_set_handle_create_callback(
         hg_class_t *hg_class,
         hg_return_t (*callback)(hg_handle_t, void *),
@@ -283,7 +282,7 @@ HG_Class_set_handle_create_callback(
  *
  * \return Pointer to HG context or NULL in case of failure
  */
-HG_EXPORT hg_context_t *
+HG_PUBLIC hg_context_t *
 HG_Context_create(
         hg_class_t *hg_class
         );
@@ -304,7 +303,7 @@ HG_Context_create(
  *
  * \return Pointer to HG context or NULL in case of failure
  */
-HG_EXPORT hg_context_t *
+HG_PUBLIC hg_context_t *
 HG_Context_create_id(
         hg_class_t *hg_class,
         hg_uint8_t id
@@ -317,7 +316,7 @@ HG_Context_create_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Context_destroy(
         hg_context_t *context
         );
@@ -389,7 +388,7 @@ HG_Context_get_data(
  *
  * \return unique ID associated to the registered function
  */
-HG_EXPORT hg_id_t
+HG_PUBLIC hg_id_t
 HG_Register_name(
         hg_class_t *hg_class,
         const char *func_name,
@@ -409,7 +408,7 @@ HG_Register_name(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Registered_name(
         hg_class_t *hg_class,
         const char *func_name,
@@ -430,7 +429,7 @@ HG_Registered_name(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Register(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -449,7 +448,7 @@ HG_Register(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Deregister(
         hg_class_t *hg_class,
         hg_id_t id
@@ -464,7 +463,7 @@ HG_Deregister(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Registered(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -483,7 +482,7 @@ HG_Registered(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Registered_proc_cb(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -504,7 +503,7 @@ HG_Registered_proc_cb(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Register_data(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -521,7 +520,7 @@ HG_Register_data(
  *
  * \return Pointer to data or NULL
  */
-HG_EXPORT void *
+HG_PUBLIC void *
 HG_Registered_data(
         hg_class_t *hg_class,
         hg_id_t id
@@ -541,7 +540,7 @@ HG_Registered_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Registered_disable_response(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -559,7 +558,7 @@ HG_Registered_disable_response(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Registered_disabled_response(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -579,7 +578,7 @@ HG_Registered_disabled_response(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Addr_lookup(
         hg_context_t *context,
         hg_cb_t       callback,
@@ -589,20 +588,37 @@ HG_Addr_lookup(
         );
 
 /**
- * Free the addr from the list of peers.
+ * Free the addr.
  *
  * \param hg_class [IN]         pointer to HG class
  * \param addr [IN]             abstract address
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Addr_free(
         hg_class_t *hg_class,
         hg_addr_t   addr
         );
 
 /**
+ * Hint that the address is no longer valid. This may happen if the peer is
+ * no longer responding. This can be used to force removal of the
+ * peer address from the list of the peers, before freeing it and reclaim
+ * resources.
+ *
+ * \param hg_class [IN]         pointer to HG class
+ * \param addr [IN]             abstract address
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_PUBLIC hg_return_t
+HG_Addr_set_remove(
+        hg_class_t *hg_class,
+        hg_addr_t   addr
+        );
+
+/**
  * Access self address. Address must be freed with HG_Addr_free().
  *
  * \param hg_class [IN]         pointer to HG class
@@ -610,7 +626,7 @@ HG_Addr_free(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Addr_self(
         hg_class_t *hg_class,
         hg_addr_t  *addr
@@ -627,7 +643,7 @@ HG_Addr_self(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Addr_dup(
         hg_class_t *hg_class,
         hg_addr_t   addr,
@@ -635,6 +651,22 @@ HG_Addr_dup(
         );
 
 /**
+ * Compare two addresses.
+ *
+ * \param hg_class [IN]         pointer to HG class
+ * \param addr1 [IN]            abstract address
+ * \param addr2 [IN]            abstract address
+ *
+ * \return HG_TRUE if addresses are determined to be equal, HG_FALSE otherwise
+ */
+HG_PUBLIC hg_bool_t
+HG_Addr_cmp(
+        hg_class_t *hg_class,
+        hg_addr_t addr1,
+        hg_addr_t addr2
+        );
+
+/**
  * Convert an addr to a string (returned string includes the terminating
  * null byte '\0'). If buf is NULL, the address is not converted and only
  * the required size of the buffer is returned. If the input value passed
@@ -648,7 +680,7 @@ HG_Addr_dup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Addr_to_string(
         hg_class_t *hg_class,
         char       *buf,
@@ -669,7 +701,7 @@ HG_Addr_to_string(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Create(
         hg_context_t *context,
         hg_addr_t addr,
@@ -685,7 +717,7 @@ HG_Create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Destroy(
         hg_handle_t handle
         );
@@ -702,7 +734,7 @@ HG_Destroy(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Reset(
         hg_handle_t handle,
         hg_addr_t addr,
@@ -789,7 +821,7 @@ HG_Get_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Get_input(
         hg_handle_t handle,
         void *in_struct
@@ -805,7 +837,7 @@ HG_Get_input(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Free_input(
         hg_handle_t handle,
         void *in_struct
@@ -825,7 +857,7 @@ HG_Free_input(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Get_output(
         hg_handle_t handle,
         void *out_struct
@@ -841,7 +873,7 @@ HG_Get_output(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Free_output(
         hg_handle_t handle,
         void *out_struct
@@ -866,7 +898,7 @@ HG_Free_output(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Get_input_buf(
         hg_handle_t handle,
         void **in_buf,
@@ -892,7 +924,7 @@ HG_Get_input_buf(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Get_output_buf(
         hg_handle_t handle,
         void **out_buf,
@@ -900,6 +932,50 @@ HG_Get_output_buf(
         );
 
 /**
+ * Get raw extra input buffer from handle that can be used for encoding and
+ * decoding parameters. This buffer is only valid if the input payload is large
+ * enough that it cannot fit into an eager buffer.
+ *
+ * \remark NULL pointer will be returned if there is no associated buffer.
+ *
+ * \remark in_buf_size argument will be ignored if NULL.
+ *
+ * \param handle [IN]           HG handle
+ * \param in_buf [OUT]          pointer to input buffer
+ * \param in_buf_size [OUT]     pointer to input buffer size
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_PUBLIC hg_return_t
+HG_Get_input_extra_buf(
+        hg_handle_t handle,
+        void **in_buf,
+        hg_size_t *in_buf_size
+        );
+
+/**
+ * Get raw extra output buffer from handle that can be used for encoding and
+ * decoding parameters. This buffer is only valid if the output payload is large
+ * enough that it cannot fit into an eager buffer.
+ *
+ * \remark NULL pointer will be returned if there is no associated buffer.
+ *
+ * \remark out_buf_size argument will be ignored if NULL.
+ *
+ * \param handle [IN]           HG handle
+ * \param out_buf [OUT]         pointer to output buffer
+ * \param out_buf_size [OUT]    pointer to output buffer size
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_PUBLIC hg_return_t
+HG_Get_output_extra_buf(
+        hg_handle_t handle,
+        void **out_buf,
+        hg_size_t *out_buf_size
+        );
+
+/**
  * Set target context ID that will receive and process the RPC request
  * (ID is defined on target context creation, see HG_Context_create_id()).
  *
@@ -933,7 +1009,7 @@ HG_Set_target_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Forward(
         hg_handle_t handle,
         hg_cb_t callback,
@@ -959,7 +1035,7 @@ HG_Forward(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Respond(
         hg_handle_t handle,
         hg_cb_t callback,
@@ -979,7 +1055,7 @@ HG_Respond(
  *
  * \return HG_SUCCESS if any completion has occurred / HG error code otherwise
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Progress(
         hg_context_t *context,
         unsigned int timeout
@@ -997,7 +1073,7 @@ HG_Progress(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Trigger(
         hg_context_t *context,
         unsigned int timeout,
@@ -1012,7 +1088,7 @@ HG_Trigger(
  *
  * \return HG_SUCCESS or HG_CANCEL_ERROR or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Cancel(
         hg_handle_t handle
         );
@@ -1036,8 +1112,8 @@ struct hg_context {
 
 /* HG handle */
 struct hg_handle {
-    hg_core_handle_t core_handle;       /* Core handle */
     struct hg_info info;                /* HG info */
+    hg_core_handle_t core_handle;       /* Core handle */
     void *data;                         /* User data */
     void (*data_free_callback)(void *); /* User data free callback */
 };
@@ -1046,12 +1122,6 @@ struct hg_handle {
 static HG_INLINE const char *
 HG_Class_get_name(const hg_class_t *hg_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return NULL;
-    }
-#endif
     return HG_Core_class_get_name(hg_class->core_class);
 }
 
@@ -1059,12 +1129,6 @@ HG_Class_get_name(const hg_class_t *hg_class)
 static HG_INLINE const char *
 HG_Class_get_protocol(const hg_class_t *hg_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return NULL;
-    }
-#endif
     return HG_Core_class_get_protocol(hg_class->core_class);
 }
 
@@ -1072,12 +1136,6 @@ HG_Class_get_protocol(const hg_class_t *hg_class)
 static HG_INLINE hg_bool_t
 HG_Class_is_listening(const hg_class_t *hg_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return HG_FALSE;
-    }
-#endif
     return HG_Core_class_is_listening(hg_class->core_class);
 }
 
@@ -1085,15 +1143,8 @@ HG_Class_is_listening(const hg_class_t *hg_class)
 static HG_INLINE hg_size_t
 HG_Class_get_input_eager_size(const hg_class_t *hg_class)
 {
-    hg_size_t core, header;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return 0;
-    }
-#endif
-    core = HG_Core_class_get_input_eager_size(hg_class->core_class);
-    header = hg_header_get_size(HG_INPUT);
+    hg_size_t core = HG_Core_class_get_input_eager_size(hg_class->core_class),
+        header = hg_header_get_size(HG_INPUT);
 
     return (core > header) ? core - header : 0;
 }
@@ -1102,15 +1153,8 @@ HG_Class_get_input_eager_size(const hg_class_t *hg_class)
 static HG_INLINE hg_size_t
 HG_Class_get_output_eager_size(const hg_class_t *hg_class)
 {
-    hg_size_t core, header;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return 0;
-    }
-#endif
-    core = HG_Core_class_get_output_eager_size(hg_class->core_class);
-    header = hg_header_get_size(HG_OUTPUT);
+    hg_size_t core = HG_Core_class_get_output_eager_size(hg_class->core_class),
+        header = hg_header_get_size(HG_OUTPUT);
 
     return (core > header) ? core - header : 0;
 }
@@ -1119,15 +1163,9 @@ HG_Class_get_output_eager_size(const hg_class_t *hg_class)
 static HG_INLINE hg_return_t
 HG_Class_set_input_offset(hg_class_t *hg_class, hg_size_t offset)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return HG_INVALID_PARAM;
-    }
-#endif
     /* Extra input header must not be larger than eager size */
     if (offset > HG_Class_get_input_eager_size(hg_class))
-        return HG_INVALID_PARAM;
+        return HG_INVALID_ARG;
 
     hg_class->in_offset = offset;
 
@@ -1138,15 +1176,9 @@ HG_Class_set_input_offset(hg_class_t *hg_class, hg_size_t offset)
 static HG_INLINE hg_return_t
 HG_Class_set_output_offset(hg_class_t *hg_class, hg_size_t offset)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return HG_INVALID_PARAM;
-    }
-#endif
     /* Extra output header must not be larger than eager size */
     if (offset > HG_Class_get_output_eager_size(hg_class))
-        return HG_INVALID_PARAM;
+        return HG_INVALID_ARG;
 
     hg_class->out_offset = offset;
 
@@ -1158,12 +1190,6 @@ static HG_INLINE hg_return_t
 HG_Class_set_data(hg_class_t *hg_class, void *data,
     void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return HG_INVALID_PARAM;
-    }
-#endif
     return HG_Core_class_set_data(hg_class->core_class, data, free_callback);
 }
 
@@ -1171,12 +1197,6 @@ HG_Class_set_data(hg_class_t *hg_class, void *data,
 static HG_INLINE void *
 HG_Class_get_data(const hg_class_t *hg_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return NULL;
-    }
-#endif
     return HG_Core_class_get_data(hg_class->core_class);
 }
 
@@ -1184,12 +1204,6 @@ HG_Class_get_data(const hg_class_t *hg_class)
 static HG_INLINE hg_class_t *
 HG_Context_get_class(const hg_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        return NULL;
-    }
-#endif
     return context->hg_class;
 }
 
@@ -1197,12 +1211,6 @@ HG_Context_get_class(const hg_context_t *context)
 static HG_INLINE hg_uint8_t
 HG_Context_get_id(const hg_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        return 0;
-    }
-#endif
     return HG_Core_context_get_id(context->core_context);
 }
 
@@ -1211,12 +1219,6 @@ static HG_INLINE hg_return_t
 HG_Context_set_data(hg_context_t *context, void *data,
     void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        return HG_INVALID_PARAM;
-    }
-#endif
     return HG_Core_context_set_data(context->core_context, data, free_callback);
 }
 
@@ -1224,12 +1226,6 @@ HG_Context_set_data(hg_context_t *context, void *data,
 static HG_INLINE void *
 HG_Context_get_data(const hg_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        return NULL;
-    }
-#endif
     return HG_Core_context_get_data(context->core_context);
 }
 
@@ -1237,12 +1233,6 @@ HG_Context_get_data(const hg_context_t *context)
 static HG_INLINE hg_return_t
 HG_Ref_incr(hg_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
     return HG_Core_ref_incr(handle->core_handle);
 }
 
@@ -1250,12 +1240,6 @@ HG_Ref_incr(hg_handle_t handle)
 static HG_INLINE hg_int32_t
 HG_Ref_get(hg_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return -1;
-    }
-#endif
     return HG_Core_ref_get(handle->core_handle);
 }
 
@@ -1263,12 +1247,6 @@ HG_Ref_get(hg_handle_t handle)
 static HG_INLINE const struct hg_info *
 HG_Get_info(hg_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return NULL;
-    }
-#endif
     return &handle->info;
 }
 
@@ -1276,12 +1254,6 @@ HG_Get_info(hg_handle_t handle)
 static HG_INLINE hg_return_t
 HG_Set_data(hg_handle_t handle, void *data, void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
     handle->data = data;
     handle->data_free_callback = free_callback;
 
@@ -1292,12 +1264,6 @@ HG_Set_data(hg_handle_t handle, void *data, void (*free_callback)(void *))
 static HG_INLINE void *
 HG_Get_data(hg_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return NULL;
-    }
-#endif
     return handle->data;
 }
 
@@ -1305,12 +1271,6 @@ HG_Get_data(hg_handle_t handle)
 static HG_INLINE hg_return_t
 HG_Set_target_id(hg_handle_t handle, hg_uint8_t id)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
     handle->info.context_id = id;
 
     return HG_Core_set_target_id(handle->core_handle, id);
diff --git a/src/mercury_bulk.c b/src/mercury_bulk.c
index ba0040c..7223bef 100644
--- a/src/mercury_bulk.c
+++ b/src/mercury_bulk.c
@@ -13,8 +13,6 @@
 #include "mercury_private.h"
 #include "mercury_error.h"
 
-#include "na.h"
-
 #include "mercury_atomic.h"
 
 #include <stdlib.h>
@@ -23,16 +21,17 @@
 /****************/
 /* Local Macros */
 /****************/
+
 #define HG_BULK_MIN(a, b) \
     (a < b) ? a : b
 
 /* Remove warnings when plugin does not use callback arguments */
 #if defined(__cplusplus)
-    #define HG_BULK_UNUSED
+# define HG_BULK_UNUSED
 #elif defined(__GNUC__) && (__GNUC__ >= 4)
-    #define HG_BULK_UNUSED __attribute__((unused))
+# define HG_BULK_UNUSED __attribute__((unused))
 #else
-    #define HG_BULK_UNUSED
+# define HG_BULK_UNUSED
 #endif
 
 /************************************/
@@ -51,6 +50,10 @@ struct hg_context {
 
 /* HG Bulk op id */
 struct hg_bulk_op_id {
+    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
+    struct hg_bulk *hg_bulk_origin;       /* Origin handle */
+    struct hg_bulk *hg_bulk_local;        /* Local handle */
+    na_op_id_t *na_op_ids ;               /* NA operations IDs */
     hg_context_t *context;                /* Context */
     na_class_t *na_class;                 /* NA class */
     na_context_t *na_context;             /* NA context */
@@ -58,14 +61,10 @@ struct hg_bulk_op_id {
     void *arg;                            /* Callback arguments */
     hg_atomic_int32_t completed;          /* Operation completed TODO needed ? */
     hg_atomic_int32_t canceled;           /* Operation canceled */
-    unsigned int op_count;                /* Number of ongoing operations */
     hg_atomic_int32_t op_completed_count; /* Number of operations completed */
+    unsigned int op_count;                /* Number of ongoing operations */
     hg_bulk_op_t op;                      /* Operation type */
-    struct hg_bulk *hg_bulk_origin;       /* Origin handle */
-    struct hg_bulk *hg_bulk_local;        /* Local handle */
-    na_op_id_t *na_op_ids ;               /* NA operations IDs */
     hg_bool_t is_self;                    /* Is self operation */
-    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
 };
 
 /* Segment used to transfer data and map to NA layer */
@@ -99,23 +98,23 @@ struct hg_bulk {
 #ifdef HG_HAS_SM_ROUTING
     na_class_t *na_sm_class;             /* NA SM class */
 #endif
-    hg_uint8_t context_id;               /* Context ID (valid if bound to handle) */
     hg_core_addr_t addr;                 /* Addr (valid if bound to handle) */
-    hg_size_t total_size;                /* Total size of data abstracted */
-    hg_uint32_t segment_count;           /* Number of segments */
     struct hg_bulk_segment *segments;    /* Array of segments */
     na_mem_handle_t *na_mem_handles;     /* Array of NA memory handles */
 #ifdef HG_HAS_SM_ROUTING
     na_mem_handle_t *na_sm_mem_handles;  /* Array of NA SM memory handles */
 #endif
+    void *serialize_ptr;                 /* Cached serialization buffer */
+    hg_size_t total_size;                /* Total size of data abstracted */
+    hg_size_t serialize_size;            /* Cached serialization size */
+    hg_uint32_t segment_count;           /* Number of segments */
     hg_uint32_t na_mem_handle_count;     /* Number of handles */
+    hg_atomic_int32_t ref_count;         /* Reference count */
     hg_bool_t segment_published;         /* NA memory handles published */
     hg_bool_t segment_alloc;             /* Allocated memory to mirror data */
-    hg_uint8_t flags;                    /* Permission flags */
     hg_bool_t eager_mode;                /* Eager transfer */
-    void *serialize_ptr;                 /* Cached serialization buffer */
-    hg_size_t serialize_size;            /* Cached serialization size */
-    hg_atomic_int32_t ref_count;         /* Reference count */
+    hg_uint8_t flags;                    /* Permission flags */
+    hg_uint8_t context_id;               /* Context ID (valid if bound to handle) */
 };
 
 /********************/
@@ -255,8 +254,8 @@ hg_bulk_na_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_uint8_t remote_id, na_op_id_t *op_id)
 {
     return NA_Put(na_class, context, callback, arg, local_mem_handle,
-            local_offset, remote_mem_handle, remote_offset, data_size,
-            remote_addr, remote_id, op_id);
+        local_offset, remote_mem_handle, remote_offset, data_size, remote_addr,
+        remote_id, op_id);
 }
 
 /**
@@ -271,8 +270,8 @@ hg_bulk_na_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_uint8_t remote_id, na_op_id_t *op_id)
 {
     return NA_Get(na_class, context, callback, arg, local_mem_handle,
-            local_offset, remote_mem_handle, remote_offset, data_size,
-            remote_addr, remote_id, op_id);
+        local_offset, remote_mem_handle, remote_offset, data_size, remote_addr,
+        remote_id, op_id);
 }
 
 /**
@@ -328,11 +327,8 @@ hg_bulk_serialize_memcpy(char **dest, ssize_t *dest_left, const void *src,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if ((*dest_left -= (ssize_t) n) < 0) {
-        HG_LOG_ERROR("Buffer size too small");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR((*dest_left -= (ssize_t) n) < 0, done, ret, HG_OVERFLOW,
+        "Serialize buffer size too small");
     memcpy(*dest, src, n);
     *dest += n;
 
@@ -349,11 +345,8 @@ hg_bulk_deserialize_memcpy(const char **src, ssize_t *src_left, void *dest,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if ((*src_left -= (ssize_t) n) < 0) {
-        HG_LOG_ERROR("Buffer size too small");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR((*src_left -= (ssize_t) n) < 0, done, ret, HG_OVERFLOW,
+        "Deserialize buffer size too small");
     memcpy(dest, *src, n);
     *src += n;
 
@@ -383,11 +376,9 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
     unsigned int i;
 
     hg_bulk = (struct hg_bulk *) malloc(sizeof(struct hg_bulk));
-    if (!hg_bulk) {
-        HG_LOG_ERROR("Could not allocate handle");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, error, ret, HG_NOMEM,
+        "Could not allocate handle");
+
     memset(hg_bulk, 0, sizeof(struct hg_bulk));
     hg_bulk->hg_class = hg_class;
     hg_bulk->na_class = na_class;
@@ -403,11 +394,9 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
     /* Allocate segments */
     hg_bulk->segments = (struct hg_bulk_segment *) malloc(
         hg_bulk->segment_count * sizeof(struct hg_bulk_segment));
-    if (!hg_bulk->segments) {
-        HG_LOG_ERROR("Could not allocate segment array");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk->segments == NULL, error, ret, HG_NOMEM,
+        "Could not allocate segment array");
+
     memset(hg_bulk->segments, 0,
            hg_bulk->segment_count * sizeof(struct hg_bulk_segment));
 
@@ -422,31 +411,23 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
             /* Use calloc to avoid uninitialized memory used for transfer */
             hg_bulk->segments[i].address = (hg_ptr_t) calloc(
                 hg_bulk->segments[i].size, sizeof(char));
-            if (!hg_bulk->segments[i].address) {
-                HG_LOG_ERROR("Could not allocate segment");
-                ret = HG_NOMEM_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(hg_bulk->segments[i].address == (hg_ptr_t ) 0, error,
+                ret, HG_NOMEM, "Could not allocate segment");
         }
     }
 
     /* Allocate NA memory handles */
     hg_bulk->na_mem_handles = (na_mem_handle_t *) malloc(
         hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-    if (!hg_bulk->na_mem_handles) {
-        HG_LOG_ERROR("Could not allocate mem handle array");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk->na_mem_handles == NULL, error, ret, HG_NOMEM,
+        "Could not allocate mem handle array");
+
 #ifdef HG_HAS_SM_ROUTING
     if (na_sm_class) {
         hg_bulk->na_sm_mem_handles = (na_mem_handle_t *) malloc(
             hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-        if (!hg_bulk->na_sm_mem_handles) {
-            HG_LOG_ERROR("Could not allocate SM mem handle array");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_bulk->na_sm_mem_handles == NULL, error, ret,
+            HG_NOMEM, "Could not allocate SM mem handle array");
     }
 #endif
     for (i = 0; i < hg_bulk->na_mem_handle_count; i++) {
@@ -469,69 +450,67 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
             na_size_t na_segment_count = (na_size_t) hg_bulk->segment_count;
             na_ret = NA_Mem_handle_create_segments(na_class, na_segments,
                 na_segment_count, flags, &hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_handle_create_segments failed");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                (hg_return_t ) na_ret,
+                "NA_Mem_handle_create_segments() failed (%s)",
+                NA_Error_to_string(na_ret));
+
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles) {
                 na_ret = NA_Mem_handle_create_segments(na_sm_class, na_segments,
                     na_segment_count, flags, &hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_handle_create_segments for SM failed");
-                    ret = HG_NA_ERROR;
-                    goto done;
-                }
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                    (hg_return_t) na_ret,
+                    "NA_Mem_handle_create_segments() for SM failed (%s)",
+                    NA_Error_to_string(na_ret));
             }
 #endif
         } else {
             na_ret = NA_Mem_handle_create(na_class,
                 (void *) hg_bulk->segments[i].address,
                 hg_bulk->segments[i].size, flags, &hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_handle_create failed");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                (hg_return_t) na_ret,
+                "NA_Mem_handle_create() failed (%s)",
+                NA_Error_to_string(na_ret));
+
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles) {
                 na_ret = NA_Mem_handle_create(na_sm_class,
                     (void *) hg_bulk->segments[i].address,
-                    hg_bulk->segments[i].size, flags, &hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_handle_create for SM failed");
-                    ret = HG_NA_ERROR;
-                    goto done;
-                }
+                    hg_bulk->segments[i].size, flags,
+                    &hg_bulk->na_sm_mem_handles[i]);
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                    (hg_return_t) na_ret,
+                    "NA_Mem_handle_create() for SM failed (%s)",
+                    NA_Error_to_string(na_ret));
             }
 #endif
         }
+
         /* Register segment */
         na_ret = NA_Mem_register(na_class, hg_bulk->na_mem_handles[i]);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("NA_Mem_register failed");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+            "NA_Mem_register() failed (%s)", NA_Error_to_string(na_ret));
+
 #ifdef HG_HAS_SM_ROUTING
         if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-            na_ret = NA_Mem_register(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_register failed");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            na_ret = NA_Mem_register(na_sm_class,
+                hg_bulk->na_sm_mem_handles[i]);
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                (hg_return_t) na_ret,
+                "NA_Mem_register() failed (%s)", NA_Error_to_string(na_ret));
         }
 #endif
     }
 
     *hg_bulk_ptr = hg_bulk;
 
-done:
-    if (ret != HG_SUCCESS) {
-        hg_bulk_free(hg_bulk);
-    }
+    return ret;
+
+error:
+    hg_bulk_free(hg_bulk);
+
     return ret;
 }
 
@@ -542,12 +521,12 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
     hg_return_t ret = HG_SUCCESS;
     unsigned int i;
 
-    if (!hg_bulk) goto done;
+    if (!hg_bulk)
+        goto done;
 
-    if (hg_atomic_decr32(&hg_bulk->ref_count)) {
-        /* Cannot free yet */
+    /* Cannot free yet */
+    if (hg_atomic_decr32(&hg_bulk->ref_count))
         goto done;
-    }
 
     if (hg_bulk->na_mem_handles) {
         na_class_t *na_class = hg_bulk->na_class;
@@ -564,15 +543,18 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
                     continue;
 
                 na_ret = NA_Mem_unpublish(na_class, hg_bulk->na_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_unpublish failed");
-                }
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                    (hg_return_t) na_ret,
+                    "NA_Mem_unpublish() failed (%s)");
+
 #ifdef HG_HAS_SM_ROUTING
                 if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-                    na_ret = NA_Mem_unpublish(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-                    if (na_ret != NA_SUCCESS) {
-                        HG_LOG_ERROR("NA_Mem_unpublish for SM failed");
-                    }
+                    na_ret = NA_Mem_unpublish(na_sm_class,
+                        hg_bulk->na_sm_mem_handles[i]);
+                    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                        (hg_return_t) na_ret,
+                        "NA_Mem_unpublish() for SM failed (%s)",
+                        NA_Error_to_string(na_ret));
                 }
 #endif
             }
@@ -586,26 +568,33 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
                 continue;
 
             na_ret = NA_Mem_deregister(na_class, hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_deregister failed");
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t) na_ret,
+                "NA_Mem_deregister() failed (%s)", NA_Error_to_string(na_ret));
 
             na_ret = NA_Mem_handle_free(na_class, hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_handle_free failed");
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t) na_ret,
+                "NA_Mem_handle_free() failed (%s)", NA_Error_to_string(na_ret));
+
             hg_bulk->na_mem_handles[i] = NA_MEM_HANDLE_NULL;
 
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-                na_ret = NA_Mem_deregister(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_deregister for SM failed");
-                }
-                na_ret = NA_Mem_handle_free(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_handle_free for SM failed");
-                }
+                na_ret = NA_Mem_deregister(na_sm_class,
+                    hg_bulk->na_sm_mem_handles[i]);
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                    (hg_return_t) na_ret,
+                    "NA_Mem_deregister() for SM failed (%s)",
+                    NA_Error_to_string(na_ret));
+
+                na_ret = NA_Mem_handle_free(na_sm_class,
+                    hg_bulk->na_sm_mem_handles[i]);
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                    (hg_return_t) na_ret,
+                    "NA_Mem_handle_free() for SM failed (%s)",
+                    NA_Error_to_string(na_ret));
+
                 hg_bulk->na_sm_mem_handles[i] = NA_MEM_HANDLE_NULL;
             }
 #endif
@@ -626,7 +615,8 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
     free(hg_bulk->segments);
 
     /* Free addr if any was attached to handle */
-    HG_Core_addr_free(hg_bulk->hg_class->core_class, hg_bulk->addr);
+    ret = HG_Core_addr_free(hg_bulk->hg_class->core_class, hg_bulk->addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk addr");
 
     free(hg_bulk);
 
@@ -702,7 +692,8 @@ hg_bulk_access(struct hg_bulk *hg_bulk, hg_size_t offset, hg_size_t size,
         count++;
     }
 
-    if (actual_count) *actual_count = count;
+    if (actual_count)
+        *actual_count = count;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -711,18 +702,14 @@ hg_bulk_transfer_cb(const struct na_cb_info *callback_info)
 {
     struct hg_bulk_op_id *hg_bulk_op_id =
         (struct hg_bulk_op_id *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     int ret = 0;
 
-    if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
+    /* If canceled, mark handle as canceled */
+    if (callback_info->ret == NA_CANCELED)
         hg_atomic_cas32(&hg_bulk_op_id->canceled, 0, 1);
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback: %s",
-            NA_Error_to_string(callback_info->ret));
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* When all NA transfers that correspond to bulk operation complete
      * add HG user callback to completion queue
@@ -734,7 +721,6 @@ hg_bulk_transfer_cb(const struct na_cb_info *callback_info)
     }
 
 done:
-    (void) na_ret;
     return ret;
 }
 
@@ -800,11 +786,11 @@ hg_bulk_transfer_pieces(na_bulk_op_t na_bulk_op, na_addr_t origin_addr, na_uint8
                 hg_bulk_origin->segments[origin_segment_index].address,
                 origin_segment_offset, transfer_size, origin_addr, origin_id,
                 &hg_bulk_op_id->na_op_ids[count]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("Could not transfer data");
-                ret = HG_NA_ERROR;
-                break;
-            }
+            if (na_ret == NA_AGAIN)
+                HG_GOTO_DONE(done, ret, HG_AGAIN);
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t ) na_ret, "Could not transfer data (%s)",
+                NA_Error_to_string(na_ret));
         }
         count++;
 
@@ -835,6 +821,7 @@ hg_bulk_transfer_pieces(na_bulk_op_t na_bulk_op, na_addr_t origin_addr, na_uint8
         }
     }
 
+done:
     /* Set number of NA operations issued */
     if (na_op_count)
         *na_op_count = count;
@@ -885,19 +872,15 @@ hg_bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
                 scatter_gather = HG_FALSE;
             break;
         default:
-            HG_LOG_ERROR("Unknown bulk operation");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(error, ret, HG_INVALID_ARG, "Unknown bulk operation");
     }
 
     /* Allocate op_id */
     hg_bulk_op_id = (struct hg_bulk_op_id *) malloc(
         sizeof(struct hg_bulk_op_id));
-    if (!hg_bulk_op_id) {
-        HG_LOG_ERROR("Could not allocate HG Bulk operation ID");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk_op_id == NULL, error, ret, HG_NOMEM,
+        "Could not allocate HG Bulk operation ID");
+
     hg_bulk_op_id->context = context;
 #ifdef HG_HAS_SM_ROUTING
     if (na_sm_class == na_origin_addr_class) {
@@ -937,43 +920,45 @@ hg_bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
 
     /* Figure out number of NA operations required */
     if (!scatter_gather) {
-        hg_bulk_transfer_pieces(NULL, NA_ADDR_NULL, origin_id, use_sm, hg_bulk_origin,
-            origin_segment_start_index, origin_segment_start_offset,
-            hg_bulk_local, local_segment_start_index,
-            local_segment_start_offset, size, HG_FALSE, NULL,
-            &hg_bulk_op_id->op_count);
-        if (!hg_bulk_op_id->op_count) {
-            HG_LOG_ERROR("Could not get bulk op_count");
-            ret = HG_INVALID_PARAM;
-            goto done;
-        }
+        ret = hg_bulk_transfer_pieces(NULL, NA_ADDR_NULL, origin_id, use_sm,
+            hg_bulk_origin, origin_segment_start_index,
+            origin_segment_start_offset, hg_bulk_local,
+            local_segment_start_index, local_segment_start_offset, size,
+            HG_FALSE, NULL, &hg_bulk_op_id->op_count);
+        HG_CHECK_HG_ERROR(error, ret, "Could not get bulk op count");
+        HG_CHECK_ERROR(hg_bulk_op_id->op_count == 0, error, ret,
+            HG_INVALID_ARG, "Could not get bulk op_count");
     }
 
     /* Allocate memory for NA operation IDs */
-    hg_bulk_op_id->na_op_ids = malloc(sizeof(na_op_id_t) * hg_bulk_op_id->op_count);
-    if (!hg_bulk_op_id->na_op_ids) {
-        HG_LOG_ERROR("Could not allocate memory for op_ids");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    for (i = 0; i < hg_bulk_op_id->op_count; i++)
-        hg_bulk_op_id->na_op_ids[i] = NA_OP_ID_NULL;
+    hg_bulk_op_id->na_op_ids = malloc(
+        sizeof(na_op_id_t) * hg_bulk_op_id->op_count);
+    HG_CHECK_ERROR(hg_bulk_op_id->na_op_ids == NULL, error, ret, HG_NOMEM,
+        "Could not allocate memory for op_ids");
 
-    /* Assign op_id */
-    if (op_id && op_id != HG_OP_ID_IGNORE) *op_id = (hg_op_id_t) hg_bulk_op_id;
+    for (i = 0; i < hg_bulk_op_id->op_count; i++) {
+        hg_bulk_op_id->na_op_ids[i] = NA_Op_create(hg_bulk_op_id->na_class);
+        HG_CHECK_ERROR(hg_bulk_op_id->na_op_ids[i] == NA_OP_ID_NULL, error, ret,
+            HG_NA_ERROR, "Could not create NA op ID");
+    }
 
     /* Do actual transfer */
     ret = hg_bulk_transfer_pieces(na_bulk_op, na_origin_addr, origin_id, use_sm,
         hg_bulk_origin, origin_segment_start_index, origin_segment_start_offset,
         hg_bulk_local, local_segment_start_index, local_segment_start_offset,
         size, scatter_gather, hg_bulk_op_id, NULL);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not transfer data pieces");
-        goto done;
-    }
+    if (ret == HG_AGAIN)
+       goto error;
+    HG_CHECK_HG_ERROR(error, ret, "Could not transfer data pieces");
 
-done:
-    if (ret != HG_SUCCESS && hg_bulk_op_id) {
+    /* Assign op_id */
+    if (op_id && op_id != HG_OP_ID_IGNORE)
+        *op_id = (hg_op_id_t) hg_bulk_op_id;
+
+    return ret;
+
+error:
+    if (hg_bulk_op_id) {
         free(hg_bulk_op_id->na_op_ids);
         free(hg_bulk_op_id);
     }
@@ -994,10 +979,7 @@ hg_bulk_complete(struct hg_bulk_op_id *hg_bulk_op_id)
         /* In the case of eager bulk transfer, directly trigger the operation
          * to avoid potential deadlocks */
         ret = hg_bulk_trigger_entry(hg_bulk_op_id);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not trigger completion entry");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not trigger completion entry");
     } else {
         struct hg_completion_entry *hg_completion_entry =
             &hg_bulk_op_id->hg_completion_entry;
@@ -1007,10 +989,8 @@ hg_bulk_complete(struct hg_bulk_op_id *hg_bulk_op_id)
 
         ret = hg_core_completion_add(context->core_context, hg_completion_entry,
             hg_bulk_op_id->is_self);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not add HG completion entry to completion queue");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret,
+            "Could not add HG completion entry to completion queue");
     }
 
 done:
@@ -1022,6 +1002,7 @@ hg_return_t
 hg_bulk_trigger_entry(struct hg_bulk_op_id *hg_bulk_op_id)
 {
     hg_return_t ret = HG_SUCCESS;
+    unsigned int i;
 
     /* Execute callback */
     if (hg_bulk_op_id->callback) {
@@ -1043,17 +1024,18 @@ hg_bulk_trigger_entry(struct hg_bulk_op_id *hg_bulk_op_id)
 
     /* Decrement ref_count */
     ret = hg_bulk_free(hg_bulk_op_id->hg_bulk_origin);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free bulk handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk handle");
+
     ret = hg_bulk_free(hg_bulk_op_id->hg_bulk_local);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free bulk handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk handle");
 
     /* Free op */
+    for (i = 0; i < hg_bulk_op_id->op_count; i++) {
+        na_return_t na_ret = NA_Op_destroy(hg_bulk_op_id->na_class,
+            hg_bulk_op_id->na_op_ids[i]);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not destroy NA op ID (%s)", NA_Error_to_string(na_ret));
+    }
     free(hg_bulk_op_id->na_op_ids);
     free(hg_bulk_op_id);
 
@@ -1069,49 +1051,29 @@ HG_Bulk_create(hg_class_t *hg_class, hg_uint32_t count, void **buf_ptrs,
     struct hg_bulk *hg_bulk = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!count) {
-        HG_LOG_ERROR("Invalid number of segments");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!buf_sizes) {
-        HG_LOG_ERROR("NULL segment pointer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
+    HG_CHECK_ERROR(count == 0, done, ret, HG_INVALID_ARG,
+        "Invalid number of segments");
+    HG_CHECK_ERROR(buf_sizes == NULL, done, ret, HG_INVALID_ARG,
+        "NULL segment size pointer");
 
     switch (flags) {
         case HG_BULK_READWRITE:
-            break;
         case HG_BULK_READ_ONLY:
-            break;
         case HG_BULK_WRITE_ONLY:
             break;
         default:
-            HG_LOG_ERROR("Unrecognized handle flag");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG,
+                "Unrecognized handle flag");
     }
 
     ret = hg_bulk_create(hg_class, count, buf_ptrs, buf_sizes, flags, &hg_bulk);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not create bulk handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not create bulk handle");
 
     *handle = (hg_bulk_t) hg_bulk;
 
 done:
-    if (ret != HG_SUCCESS) {
-        hg_bulk_free(hg_bulk);
-    }
     return ret;
 }
 
@@ -1122,9 +1084,11 @@ HG_Bulk_free(hg_bulk_t handle)
     hg_return_t ret = HG_SUCCESS;
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    if (!hg_bulk) goto done;
+    if (!hg_bulk)
+        goto done;
 
     ret = hg_bulk_free(hg_bulk);
+    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk handle");
 
 done:
     return ret;
@@ -1137,11 +1101,8 @@ HG_Bulk_ref_incr(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
 
     /* Increment ref count */
     hg_atomic_incr32(&hg_bulk->ref_count);
@@ -1158,30 +1119,16 @@ HG_Bulk_bind(hg_bulk_t handle, hg_context_t *context)
     struct hg_context *hg_context = context;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG bulk context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hg_bulk->addr != HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("Handle is already bound to existing address");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
+    HG_CHECK_ERROR(hg_bulk->addr != HG_CORE_ADDR_NULL, done, ret,
+        HG_INVALID_ARG, "Handle is already bound to existing address");
 
     /* Retrieve self address */
     ret = HG_Core_addr_self(hg_bulk->hg_class->core_class, &hg_bulk->addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get self address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get self address");
 
     /* Add context ID */
     hg_bulk->context_id = HG_Core_context_get_id(hg_context->core_context);
@@ -1197,10 +1144,7 @@ HG_Bulk_get_addr(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_core_addr_t ret = HG_CORE_ADDR_NULL;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
 
     ret = hg_bulk->addr;
 
@@ -1215,10 +1159,7 @@ HG_Bulk_get_context_id(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_uint8_t ret = 0;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
 
     ret = hg_bulk->context_id;
 
@@ -1233,24 +1174,18 @@ HG_Bulk_access(hg_bulk_t handle, hg_size_t offset, hg_size_t size,
     hg_size_t *buf_sizes, hg_uint32_t *actual_count)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
-    hg_uint32_t count = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
 
-    if (!size || !max_count) goto done;
+    if (!size || !max_count)
+        goto done;
 
     hg_bulk_access(hg_bulk, offset, size, flags, max_count, buf_ptrs,
-        buf_sizes, &count);
+        buf_sizes, actual_count);
 
 done:
-    if (ret == HG_SUCCESS) {
-        if (actual_count) *actual_count = count;
-    }
     return ret;
 }
 
@@ -1261,10 +1196,7 @@ HG_Bulk_get_size(hg_bulk_t handle)
     hg_size_t ret = 0;
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
 
     ret = hg_bulk->total_size;
 
@@ -1279,10 +1211,7 @@ HG_Bulk_get_segment_count(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_uint32_t ret = 0;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL bulk handle passed");
 
     ret = hg_bulk->segment_count;
 
@@ -1298,10 +1227,7 @@ HG_Bulk_get_serialize_size(hg_bulk_t handle, hg_bool_t request_eager)
     hg_size_t ret = 0;
     hg_uint32_t i;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
 
     /* Permission flags */
     ret = sizeof(hg_bulk->flags);
@@ -1325,17 +1251,15 @@ HG_Bulk_get_serialize_size(hg_bulk_t handle, hg_bool_t request_eager)
     for (i = 0; i < hg_bulk->na_mem_handle_count; i++) {
         na_size_t serialize_size = 0;
 
-        if (hg_bulk->na_mem_handles[i]) {
+        if (hg_bulk->na_mem_handles[i])
             serialize_size = NA_Mem_handle_get_serialize_size(
                 hg_bulk->na_class, hg_bulk->na_mem_handles[i]);
-        }
         ret += sizeof(serialize_size) + serialize_size;
 #ifdef HG_HAS_SM_ROUTING
         if (hg_bulk->na_sm_mem_handles) {
-            if (hg_bulk->na_sm_mem_handles[i]) {
+            if (hg_bulk->na_sm_mem_handles[i])
                 serialize_size = NA_Mem_handle_get_serialize_size(
                     hg_bulk->na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-            }
             ret += sizeof(serialize_size) + serialize_size;
         }
 #endif
@@ -1368,11 +1292,8 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
 #endif
     hg_uint32_t i;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
 
     /* Get NA class */
     na_class = hg_bulk->na_class;
@@ -1387,19 +1308,18 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
                 continue;
 
             na_ret = NA_Mem_publish(na_class, hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_publish failed");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t ) na_ret, "NA_Mem_publish() failed (%s)",
+                NA_Error_to_string(na_ret));
+
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-                na_ret = NA_Mem_publish(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_publish for SM failed");
-                    ret = HG_NA_ERROR;
-                    goto done;
-                }
+                na_ret = NA_Mem_publish(na_sm_class,
+                    hg_bulk->na_sm_mem_handles[i]);
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                    (hg_return_t ) na_ret,
+                    "NA_Mem_publish() for SM failed (%s)",
+                    NA_Error_to_string(na_ret));
             }
 #endif
         }
@@ -1409,19 +1329,13 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
     /* Add the permission flags */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->flags, sizeof(hg_bulk->flags));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode permission flags");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode permission flags");
 
     /* Address information is bound */
     bind_addr = (hg_bool_t) (hg_bulk->addr != HG_CORE_ADDR_NULL);
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &bind_addr, sizeof(bind_addr));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode bind address boolean");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode bind address boolean");
 
     /* Add the address information and context ID */
     if (hg_bulk->addr != HG_CORE_ADDR_NULL) {
@@ -1430,85 +1344,62 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
 
         ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
             &serialize_size, sizeof(serialize_size));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not encode serialize size");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not encode serialize size");
 
         na_ret = NA_Addr_serialize(na_class, buf_ptr, (na_size_t) buf_size_left,
             HG_Core_addr_get_na(hg_bulk->addr));
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not serialize address");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not serialize address (%s)", NA_Error_to_string(na_ret));
+
         buf_ptr += serialize_size;
         buf_size_left -= (ssize_t) serialize_size;
 
         ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->context_id, sizeof(hg_bulk->context_id));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not encode context ID");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not encode context ID");
     }
 
     /* Add the total size of the segments */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->total_size, sizeof(hg_bulk->total_size));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode total size");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode total size");
 
     /* Add the number of segments */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->segment_count, sizeof(hg_bulk->segment_count));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode segment count");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode segment count");
 
     /* Add the array of segments */
     for (i = 0; i < hg_bulk->segment_count; i++) {
         ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->segments[i], sizeof(hg_bulk->segments[i]));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not encode segment");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not encode segment");
     }
 
     /* Add the number of NA memory handles */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->na_mem_handle_count, sizeof(hg_bulk->na_mem_handle_count));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode NA memory handle count");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode NA memory handle count");
 
     /* Add the NA memory handles */
     for (i = 0; i < hg_bulk->na_mem_handle_count; i++) {
         na_size_t serialize_size = 0;
 
-        if (hg_bulk->na_mem_handles[i]) {
+        if (hg_bulk->na_mem_handles[i])
             serialize_size = NA_Mem_handle_get_serialize_size(
                 na_class, hg_bulk->na_mem_handles[i]);
-        }
-        ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left, &serialize_size,
-            sizeof(serialize_size));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not encode serialize size");
-            goto done;
-        }
+
+        ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
+            &serialize_size, sizeof(serialize_size));
+        HG_CHECK_HG_ERROR(done, ret, "Could not encode serialize size");
+
         if (hg_bulk->na_mem_handles[i]) {
             na_ret = NA_Mem_handle_serialize(na_class, buf_ptr,
                 (na_size_t) buf_size_left, hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("Could not serialize memory handle");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t ) na_ret, "Could not serialize memory handle (%s)",
+                NA_Error_to_string(na_ret));
+
             buf_ptr += serialize_size;
             buf_size_left -= (ssize_t) serialize_size;
         }
@@ -1522,18 +1413,16 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
                 serialize_size = 0;
             ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
                 &serialize_size, sizeof(serialize_size));
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not encode serialize size");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(done, ret, "Could not encode serialize size");
+
             if (hg_bulk->na_sm_mem_handles[i]) {
                 na_ret = NA_Mem_handle_serialize(na_sm_class, buf_ptr,
                     (na_size_t) buf_size_left, hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("Could not serialize SM memory handle");
-                    ret = HG_NA_ERROR;
-                    goto done;
-                }
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                    (hg_return_t ) na_ret,
+                    "Could not serialize SM memory handle (%s)",
+                    NA_Error_to_string(na_ret));
+
                 buf_ptr += serialize_size;
                 buf_size_left -= (ssize_t) serialize_size;
             }
@@ -1545,10 +1434,7 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
     eager_mode = (request_eager && (hg_bulk->flags == HG_BULK_READ_ONLY));
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left, &eager_mode,
         sizeof(eager_mode));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode eager_mode bool");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode eager_mode bool");
 
     /* Add the serialized data */
     if (eager_mode) {
@@ -1559,15 +1445,12 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
             ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
                 (const void *) hg_bulk->segments[i].address,
                 hg_bulk->segments[i].size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not encode segment data");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(done, ret, "Could not encode segment data");
         }
     }
 
-    if (buf_size_left)
-        HG_LOG_WARNING("Buf size left greater than 0, %zd", buf_size_left);
+    HG_CHECK_WARNING(buf_size_left > 0, "Buf size left greater than 0, %zd",
+        buf_size_left);
 
 done:
     return ret;
@@ -1586,18 +1469,13 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
     hg_bool_t bind_addr;
     hg_uint32_t i;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == NULL, error, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
 
     hg_bulk = (struct hg_bulk *) malloc(sizeof(struct hg_bulk));
-    if (!hg_bulk) {
-        HG_LOG_ERROR("Could not allocate handle");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, error, ret, HG_NOMEM,
+        "Could not allocate handle");
+
     memset(hg_bulk, 0, sizeof(struct hg_bulk));
     hg_bulk->hg_class = hg_class;
     hg_bulk->na_class = HG_Core_class_get_na(hg_class->core_class);
@@ -1609,18 +1487,12 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
     /* Get the permission flags */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->flags, sizeof(hg_bulk->flags));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode permission flags");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode permission flags");
 
     /* Address information is bound */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &bind_addr, sizeof(bind_addr));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode bind address boolean");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode bind address boolean");
 
     /* Get the address information and context ID */
     if (bind_addr) {
@@ -1629,96 +1501,67 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
 
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &serialize_size, sizeof(serialize_size));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not decode serialize size");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not decode serialize size");
 
         na_ret = NA_Addr_deserialize(hg_bulk->na_class, &na_addr, buf_ptr,
             (na_size_t) buf_size_left);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not deserialize address");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+            "Could not deserialize address (%s)", NA_Error_to_string(na_ret));
+
         buf_ptr += serialize_size;
         buf_size_left -= (ssize_t) serialize_size;
 
-        ret = HG_Core_addr_create(hg_bulk->hg_class->core_class, &hg_bulk->addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not create core addr");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        ret = HG_Core_addr_create(hg_bulk->hg_class->core_class,
+            &hg_bulk->addr);
+        HG_CHECK_HG_ERROR(error, ret, "Could not create core addr");
+
         HG_Core_addr_set_na(hg_bulk->addr, na_addr);
 
         /* Decode context ID */
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->context_id, sizeof(hg_bulk->context_id));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not decode context ID");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not decode context ID");
     }
 
     /* Get the total size of the segments */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->total_size, sizeof(hg_bulk->total_size));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode total size");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode total size");
 
     /* Get the number of segments */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->segment_count, sizeof(hg_bulk->segment_count));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode segment count");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode segment count");
 
     /* Get the array of segments */
     hg_bulk->segments = (struct hg_bulk_segment *) malloc(
             hg_bulk->segment_count * sizeof(struct hg_bulk_segment));
-    if (!hg_bulk->segments) {
-        HG_LOG_ERROR("Could not allocate segment array");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk->segments == NULL, error, ret, HG_NOMEM,
+        "Could not allocate segment array");
+
     for (i = 0; i < hg_bulk->segment_count; i++) {
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->segments[i], sizeof(hg_bulk->segments[i]));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not decode segment");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not decode segment");
     }
 
     /* Get the number of NA memory handles */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->na_mem_handle_count, sizeof(hg_bulk->na_mem_handle_count));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode NA memory handle count");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode NA memory handle count");
 
     /* Get the NA memory handles */
     hg_bulk->na_mem_handles = (na_mem_handle_t *) malloc(
             hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-    if (!hg_bulk->na_mem_handles) {
-        HG_LOG_ERROR("Could not allocate NA memory handle array");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk->na_mem_handles == NULL, error, ret, HG_NOMEM,
+        "Could not allocate NA memory handle array");
+
 #ifdef HG_HAS_SM_ROUTING
     if (hg_bulk->na_sm_class) {
         hg_bulk->na_sm_mem_handles = (na_mem_handle_t *) malloc(
                 hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-        if (!hg_bulk->na_sm_mem_handles) {
-            HG_LOG_ERROR("Could not allocate NA SM memory handle array");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_bulk->na_sm_mem_handles == NULL, error, ret,
+            HG_NOMEM, "Could not allocate NA SM memory handle array");
     }
 #endif
 
@@ -1727,47 +1570,39 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
 
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &serialize_size, sizeof(serialize_size));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not decode serialize size");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not decode serialize size");
+
         if (serialize_size) {
             na_ret = NA_Mem_handle_deserialize(hg_bulk->na_class,
                 &hg_bulk->na_mem_handles[i], buf_ptr,
                 (na_size_t) buf_size_left);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("Could not deserialize memory handle");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                (hg_return_t ) na_ret, "Could not deserialize memory handle");
+
             buf_ptr += serialize_size;
             buf_size_left -= (ssize_t) serialize_size;
-        } else {
+        } else
             hg_bulk->na_mem_handles[i] = NA_MEM_HANDLE_NULL;
-        }
 
 #ifdef HG_HAS_SM_ROUTING
         if (hg_bulk->na_sm_mem_handles) {
             ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
                 &serialize_size, sizeof(serialize_size));
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not decode serialize size");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(error, ret, "Could not decode serialize size");
+
             if (serialize_size) {
                 na_ret = NA_Mem_handle_deserialize(hg_bulk->na_sm_class,
                     &hg_bulk->na_sm_mem_handles[i], buf_ptr,
                     (na_size_t) buf_size_left);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("Could not deserialize SM memory handle");
-                    ret = HG_NA_ERROR;
-                    goto done;
-                }
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                    (hg_return_t ) na_ret,
+                    "Could not deserialize SM memory handle (%s)",
+                    NA_Error_to_string(na_ret));
+
                 buf_ptr += serialize_size;
                 buf_size_left -= (ssize_t) serialize_size;
-            } else {
+            } else
                 hg_bulk->na_sm_mem_handles[i] = NA_MEM_HANDLE_NULL;
-            }
         }
 #endif
     }
@@ -1775,10 +1610,7 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
     /* Get whether data is serialized or not */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->eager_mode, sizeof(hg_bulk->eager_mode));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode eager_mode bool");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode eager_mode bool");
 
     /* Get the serialized data */
     if (hg_bulk->eager_mode) {
@@ -1790,30 +1622,26 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
             /* Use calloc to avoid uninitialized memory used for transfer */
             hg_bulk->segments[i].address = (hg_ptr_t) calloc(
                 hg_bulk->segments[i].size, sizeof(char));
-            if (!hg_bulk->segments[i].address) {
-                HG_LOG_ERROR("Could not allocate segment");
-                ret = HG_NOMEM_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(hg_bulk->segments[i].address == 0, error, ret,
+                HG_NOMEM, "Could not allocate segment");
+
             ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
                 (void *) hg_bulk->segments[i].address,
                 hg_bulk->segments[i].size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not decode segment data");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(error, ret, "Could not decode segment data");
         }
     }
 
-    if (buf_size_left)
-        HG_LOG_WARNING("Buf size left greater than 0, %zd", buf_size_left);
+    HG_CHECK_WARNING(buf_size_left > 0, "Buf size left greater than 0, %zd",
+        buf_size_left);
 
     *handle = (hg_bulk_t) hg_bulk;
 
-done:
-    if (ret != HG_SUCCESS) {
-        hg_bulk_free(hg_bulk);
-    }
+    return ret;
+
+error:
+    hg_bulk_free(hg_bulk);
+
     return ret;
 }
 
@@ -1823,12 +1651,12 @@ HG_Bulk_get_serialize_cached_ptr(hg_bulk_t handle)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        return NULL;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, error, "NULL memory handle passed");
 
     return hg_bulk->serialize_ptr;
+
+error:
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1837,12 +1665,12 @@ HG_Bulk_get_serialize_cached_size(hg_bulk_t handle)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        return 0;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, error, "NULL memory handle passed");
 
     return hg_bulk->serialize_size;
+
+error:
+    return 0;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1851,16 +1679,16 @@ HG_Bulk_set_serialize_cached_ptr(hg_bulk_t handle, void *buf,
     na_size_t buf_size)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
+    hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        return HG_INVALID_PARAM;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
 
     hg_bulk->serialize_ptr = buf;
     hg_bulk->serialize_size = buf_size;
 
-    return HG_SUCCESS;
+done:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1873,18 +1701,11 @@ HG_Bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_bulk *hg_bulk_origin = (struct hg_bulk *) origin_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk_origin) {
-        HG_LOG_ERROR("NULL origin handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hg_bulk_origin->addr != HG_CORE_ADDR_NULL
-        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr) {
-        HG_LOG_ERROR("Mismatched address information passed with origin handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk_origin == NULL, done, ret, HG_INVALID_ARG,
+        "NULL origin handle passed");
+    HG_CHECK_ERROR(hg_bulk_origin->addr != HG_CORE_ADDR_NULL
+        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr, done, ret,
+        HG_INVALID_ARG, "Mismatched address information from origin handle");
 
     ret = HG_Bulk_transfer_id(context, callback, arg, op, origin_addr, 0,
         origin_handle, origin_offset, local_handle, local_offset, size, op_id);
@@ -1903,18 +1724,11 @@ HG_Bulk_bind_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_bulk *hg_bulk_origin = (struct hg_bulk *) origin_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk_origin) {
-        HG_LOG_ERROR("NULL origin handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hg_bulk_origin->addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("No address information found on bulk handle, "
-            "HG_Bulk_bind() must be called on bulk handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk_origin == NULL, done, ret, HG_INVALID_ARG,
+        "NULL origin handle passed");
+    HG_CHECK_ERROR(hg_bulk_origin->addr == HG_CORE_ADDR_NULL, done, ret,
+        HG_INVALID_ARG, "No address information found on bulk handle, "
+        "HG_Bulk_bind() must be called on bulk handle");
 
     ret = HG_Bulk_transfer_id(context, callback, arg, op,
         (hg_addr_t) hg_bulk_origin->addr, hg_bulk_origin->context_id,
@@ -1935,84 +1749,48 @@ HG_Bulk_transfer_id(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_bulk *hg_bulk_local = (struct hg_bulk *) local_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG bulk context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!hg_bulk_origin || !hg_bulk_local) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hg_bulk_origin->addr != HG_CORE_ADDR_NULL
-        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr) {
-        HG_LOG_ERROR("Mismatched address information passed with origin handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hg_bulk_origin->addr != HG_CORE_ADDR_NULL
-        && hg_bulk_origin->context_id != origin_id) {
-        HG_LOG_ERROR("Mismatched context ID information passed with origin handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!size) {
-        HG_LOG_ERROR("Transfer size must be non-zero");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
-
-    if (size > hg_bulk_origin->total_size) {
-        HG_LOG_ERROR("Exceeding size of memory exposed by origin handle");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
-
-    if (size > hg_bulk_local->total_size) {
-        HG_LOG_ERROR("Exceeding size of memory exposed by local handle");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
+    HG_CHECK_ERROR(hg_bulk_origin == NULL || hg_bulk_local == NULL, done, ret,
+        HG_INVALID_ARG, "NULL memory handle passed");
+    HG_CHECK_ERROR(hg_bulk_origin->addr != HG_CORE_ADDR_NULL
+        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr, done, ret,
+        HG_INVALID_ARG, "Mismatched address information from origin handle");
+    HG_CHECK_ERROR(hg_bulk_origin->addr != HG_CORE_ADDR_NULL
+        && hg_bulk_origin->context_id != origin_id, done, ret, HG_INVALID_ARG,
+        "Mismatched context ID information from origin handle");
+    HG_CHECK_ERROR(size == 0, done, ret, HG_INVALID_ARG,
+        "Transfer size must be non-zero");
+    HG_CHECK_ERROR(size > hg_bulk_origin->total_size, done, ret, HG_INVALID_ARG,
+        "Exceeding size of memory exposed by origin handle");
+    HG_CHECK_ERROR(size > hg_bulk_local->total_size, done, ret, HG_INVALID_ARG,
+        "Exceeding size of memory exposed by local handle");
 
     switch (op) {
         case HG_BULK_PUSH:
-            if (!(hg_bulk_origin->flags & HG_BULK_WRITE_ONLY)
-                || !(hg_bulk_local->flags & HG_BULK_READ_ONLY)) {
-                HG_LOG_ERROR("Invalid permission flags for PUSH operation "
-                    "(origin=%d, local=%d)", hg_bulk_origin->flags,
-                    hg_bulk_local->flags);
-                ret = HG_INVALID_PARAM;
-                goto done;
-            }
+            HG_CHECK_ERROR(!(hg_bulk_origin->flags & HG_BULK_WRITE_ONLY)
+                || !(hg_bulk_local->flags & HG_BULK_READ_ONLY), done, ret,
+                HG_PERMISSION, "Invalid permission flags for PUSH operation "
+                "(origin=%d, local=%d)", hg_bulk_origin->flags,
+                hg_bulk_local->flags);
             break;
         case HG_BULK_PULL:
-            if (!(hg_bulk_origin->flags & HG_BULK_READ_ONLY)
-                || !(hg_bulk_local->flags & HG_BULK_WRITE_ONLY)) {
-                HG_LOG_ERROR("Invalid permission flags for PULL operation "
-                    "(origin=%d, local=%d)", hg_bulk_origin->flags,
-                    hg_bulk_local->flags);
-                ret = HG_INVALID_PARAM;
-                goto done;
-            }
+            HG_CHECK_ERROR(!(hg_bulk_origin->flags & HG_BULK_READ_ONLY)
+                || !(hg_bulk_local->flags & HG_BULK_WRITE_ONLY), done, ret,
+                HG_PERMISSION, "Invalid permission flags for PULL operation "
+                "(origin=%d, local=%d)", hg_bulk_origin->flags,
+                hg_bulk_local->flags);
             break;
         default:
-            HG_LOG_ERROR("Unknown bulk operation");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Unknown bulk operation");
     }
 
     ret = hg_bulk_transfer(context, callback, arg, op, origin_addr, origin_id,
         hg_bulk_origin, origin_offset, hg_bulk_local, local_offset, size,
         op_id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not transfer data");
+    if (ret == HG_AGAIN)
         goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not start transfer of bulk data");
 
 done:
     return ret;
@@ -2025,27 +1803,19 @@ HG_Bulk_cancel(hg_op_id_t op_id)
     struct hg_bulk_op_id *hg_bulk_op_id = (struct hg_bulk_op_id *) op_id;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk_op_id) {
-        HG_LOG_ERROR("NULL HG bulk operation ID");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk_op_id == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG bulk operation ID");
 
     if (HG_UTIL_TRUE != hg_atomic_cas32(&hg_bulk_op_id->completed, 1, 0)) {
         unsigned int i = 0;
 
         /* Cancel all NA operations issued */
         for (i = 0; i < hg_bulk_op_id->op_count; i++) {
-            na_return_t na_ret;
-
-            /* Cancel NA operation */
-            na_ret = NA_Cancel(hg_bulk_op_id->na_class,
+            na_return_t na_ret = NA_Cancel(hg_bulk_op_id->na_class,
                 hg_bulk_op_id->na_context, hg_bulk_op_id->na_op_ids[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("Could not cancel op id");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t ) na_ret, "Could not cancel NA op ID (%s)",
+                NA_Error_to_string(na_ret));
         }
     }
 
diff --git a/src/mercury_bulk.h b/src/mercury_bulk.h
index 9b60d8b..338f24d 100644
--- a/src/mercury_bulk.h
+++ b/src/mercury_bulk.h
@@ -54,7 +54,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_create(
         hg_class_t *hg_class,
         hg_uint32_t count,
@@ -71,7 +71,7 @@ HG_Bulk_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_free(
         hg_bulk_t handle
         );
@@ -83,7 +83,7 @@ HG_Bulk_free(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_ref_incr(
         hg_bulk_t handle
         );
@@ -112,7 +112,7 @@ HG_Bulk_ref_incr(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_bind(
         hg_bulk_t handle,
         hg_context_t *context
@@ -126,7 +126,7 @@ HG_Bulk_bind(
  *
  * \return abstract HG address or HG_ADDR_NULL in case of error
 */
-HG_EXPORT hg_addr_t
+HG_PUBLIC hg_addr_t
 HG_Bulk_get_addr(
        hg_bulk_t handle
        );
@@ -139,7 +139,7 @@ HG_Bulk_get_addr(
  *
  * \return valid context ID or 0 by default
 */
-HG_EXPORT hg_uint8_t
+HG_PUBLIC hg_uint8_t
 HG_Bulk_get_context_id(
        hg_bulk_t handle
        );
@@ -163,7 +163,7 @@ HG_Bulk_get_context_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_access(
         hg_bulk_t handle,
         hg_size_t offset,
@@ -182,7 +182,7 @@ HG_Bulk_access(
  *
  * \return Non-negative value
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 HG_Bulk_get_size(
         hg_bulk_t handle
         );
@@ -194,7 +194,7 @@ HG_Bulk_get_size(
  *
  * \return Non-negative value
  */
-HG_EXPORT hg_uint32_t
+HG_PUBLIC hg_uint32_t
 HG_Bulk_get_segment_count(
         hg_bulk_t handle
         );
@@ -209,7 +209,7 @@ HG_Bulk_get_segment_count(
  *
  * \return Non-negative value
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 HG_Bulk_get_serialize_size(
         hg_bulk_t handle,
         hg_bool_t request_eager
@@ -228,7 +228,7 @@ HG_Bulk_get_serialize_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_serialize(
         void *buf,
         hg_size_t buf_size,
@@ -246,7 +246,7 @@ HG_Bulk_serialize(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_deserialize(
         hg_class_t *hg_class,
         hg_bulk_t *handle,
@@ -261,7 +261,7 @@ HG_Bulk_deserialize(
  *
  * \return Pointer to buffer or NULL in case of error
  */
-HG_EXPORT void *
+HG_PUBLIC void *
 HG_Bulk_get_serialize_cached_ptr(
         hg_bulk_t handle
         );
@@ -273,7 +273,7 @@ HG_Bulk_get_serialize_cached_ptr(
  *
  * \return Non-negative value or 0 in case of error
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 HG_Bulk_get_serialize_cached_size(
         hg_bulk_t handle
         );
@@ -287,7 +287,7 @@ HG_Bulk_get_serialize_cached_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_set_serialize_cached_ptr(
         hg_bulk_t handle,
         void *buf,
@@ -315,7 +315,7 @@ HG_Bulk_set_serialize_cached_ptr(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_transfer(
         hg_context_t *context,
         hg_cb_t callback,
@@ -350,7 +350,7 @@ HG_Bulk_transfer(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_bind_transfer(
         hg_context_t *context,
         hg_cb_t callback,
@@ -387,7 +387,7 @@ HG_Bulk_bind_transfer(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_transfer_id(
         hg_context_t *context,
         hg_cb_t callback,
@@ -410,7 +410,7 @@ HG_Bulk_transfer_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_cancel(
         hg_op_id_t op_id
         );
diff --git a/src/mercury_config.h.in b/src/mercury_config.h.in
index fe0e00f..108ec03 100644
--- a/src/mercury_config.h.in
+++ b/src/mercury_config.h.in
@@ -89,19 +89,20 @@ typedef hg_uint8_t   hg_bool_t;
 #endif
 
 /* Environment variable names (to be removed) */
-#define HG_NA_PLUGIN "MERCURY_NA_PLUGIN"
 #define HG_PORT_NAME "MERCURY_PORT_NAME"
 
 /* Shared libraries */
 #cmakedefine HG_BUILD_SHARED_LIBS
 #ifdef HG_BUILD_SHARED_LIBS
 # ifdef mercury_EXPORTS
-#  define HG_EXPORT HG_ABI_EXPORT
+#  define HG_PUBLIC HG_ABI_EXPORT
 # else
-#  define HG_EXPORT HG_ABI_IMPORT
+#  define HG_PUBLIC HG_ABI_IMPORT
 # endif
+# define HG_PRIVATE HG_ABI_HIDDEN
 #else
-# define HG_EXPORT
+# define HG_PUBLIC
+# define HG_PRIVATE
 #endif
 
 /* Build Options */
@@ -116,5 +117,6 @@ typedef hg_uint8_t   hg_bool_t;
 #cmakedefine HG_HAS_COLLECT_STATS
 
 #cmakedefine HG_HAS_VERBOSE_ERROR
+#cmakedefine HG_HAS_DEBUG
 
 #endif /* MERCURY_CONFIG_H */
diff --git a/src/mercury_core.c b/src/mercury_core.c
index f114699..4a66d62 100644
--- a/src/mercury_core.c
+++ b/src/mercury_core.c
@@ -25,6 +25,7 @@
 #include "mercury_thread_pool.h"
 #include "mercury_thread_spin.h"
 #include "mercury_time.h"
+#include "mercury_error.h"
 
 #ifdef HG_HAS_SM_ROUTING
 #include <uuid/uuid.h>
@@ -37,11 +38,9 @@
 /* Local Macros */
 /****************/
 
-#define HG_CORE_MAX_SELF_THREADS    4
-#define HG_CORE_MASK_NBITS          8
 #define HG_CORE_ATOMIC_QUEUE_SIZE   1024
 #define HG_CORE_PENDING_INCR        256
-#define HG_CORE_PROCESSING_TIMEOUT  1000
+#define HG_CORE_CLEANUP_TIMEOUT     1000
 #define HG_CORE_MAX_TRIGGER_COUNT   1
 #ifdef HG_HAS_SM_ROUTING
 # define HG_CORE_UUID_MAX_LEN       36
@@ -93,51 +92,47 @@ struct hg_core_private_class {
     uuid_t na_sm_uuid;                  /* UUID for local identification */
 #endif
     hg_hash_table_t *func_map;          /* Function map */
-    hg_thread_spin_t func_map_lock;     /* Function map mutex */
-    hg_atomic_int32_t request_tag;      /* Atomic used for tag generation */
+    hg_return_t (*more_data_acquire)(hg_core_handle_t, hg_op_t,
+        hg_return_t (*done_callback)(hg_core_handle_t)); /* more_data_acquire */
+    void (*more_data_release)(hg_core_handle_t);         /* more_data_release */
     na_tag_t request_max_tag;           /* Max value for tag */
+    hg_atomic_int32_t n_contexts;       /* Atomic used for number of contexts */
+    hg_atomic_int32_t n_addrs;          /* Atomic used for number of addrs */
+    hg_atomic_int32_t request_tag;      /* Atomic used for tag generation */
+    hg_thread_spin_t func_map_lock;     /* Function map lock */
+    na_uint32_t progress_mode;          /* NA progress mode */
     hg_bool_t na_ext_init;              /* NA externally initialized */
-    na_progress_mode_t progress_mode;   /* NA progress mode */
 #ifdef HG_HAS_COLLECT_STATS
     hg_bool_t stats;                    /* (Debug) Print stats at exit */
 #endif
-    hg_atomic_int32_t n_contexts;       /* Atomic used for number of contexts */
-    hg_atomic_int32_t n_addrs;          /* Atomic used for number of addrs */
-
-    /* Callbacks */
-    hg_return_t (*more_data_acquire)(hg_core_handle_t, hg_op_t,
-        hg_return_t (*done_callback)(hg_core_handle_t)); /* more_data_acquire */
-    void (*more_data_release)(hg_core_handle_t); /* more_data_release */
 };
 
 /* HG context */
 struct hg_core_private_context {
     struct hg_core_context core_context;        /* Must remain as first field */
-    struct hg_poll_set *poll_set;               /* Context poll set */
-    /* Pointer to function used for making progress */
-    hg_return_t (*progress)(struct hg_core_private_context *context,
-        unsigned int timeout);
-    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
-    HG_QUEUE_HEAD(hg_completion_entry) backfill_queue; /* Backfill completion queue */
-    hg_atomic_int32_t backfill_queue_count;     /* Backfill queue count */
-    hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
     hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
-    hg_atomic_int32_t trigger_waiting;          /* Waiting in trigger */
+    hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
+    HG_QUEUE_HEAD(hg_completion_entry) backfill_queue;  /* Backfill completion queue */
+    struct hg_atomic_queue *completion_queue;           /* Default completion queue */
+    HG_LIST_HEAD(hg_core_private_handle) created_list;  /* List of handles for that context */
     HG_LIST_HEAD(hg_core_private_handle) pending_list;  /* List of pending handles */
-    hg_thread_spin_t pending_list_lock;         /* Pending list lock */
 #ifdef HG_HAS_SM_ROUTING
-    HG_LIST_HEAD(hg_core_private_handle) sm_pending_list; /* List of SM pending handles */
-    hg_thread_spin_t sm_pending_list_lock;      /* SM pending list lock */
+    HG_LIST_HEAD(hg_core_private_handle) sm_pending_list;   /* List of SM pending handles */
 #endif
-    HG_LIST_HEAD(hg_core_private_handle) created_list;  /* List of handles for that context */
+    hg_return_t (*handle_create)(hg_core_handle_t, void *); /* handle_create */
+    void *handle_create_arg;                    /* handle_create arg */
+    struct hg_poll_set *poll_set;               /* Context poll set */
+    hg_return_t (*progress)(struct hg_core_private_context *context,
+        unsigned int timeout);                  /* Progress function */
+    hg_atomic_int32_t backfill_queue_count;     /* Backfill queue count */
+    hg_atomic_int32_t trigger_waiting;          /* Waiting in trigger */
+    hg_atomic_int32_t n_handles;                /* Atomic used for number of handles */
     hg_thread_spin_t created_list_lock;         /* Handle list lock */
+    hg_thread_spin_t pending_list_lock;         /* Pending list lock */
 #ifdef HG_HAS_SELF_FORWARD
     int completion_queue_notify;                /* Self notification */
 #endif
-    hg_return_t (*handle_create)(hg_core_handle_t, void *); /* handle_create */
-    void *handle_create_arg;                    /* handle_create arg */
     hg_bool_t finalizing;                       /* Prevent reposts */
-    hg_atomic_int32_t n_handles;                /* Atomic used for number of handles */
 };
 
 #ifdef HG_HAS_SELF_FORWARD
@@ -156,8 +151,8 @@ struct hg_core_private_addr {
 #ifdef HG_HAS_SM_ROUTING
     uuid_t na_sm_uuid;                  /* NA SM UUID */
 #endif
-    hg_bool_t is_mine;                  /* Created internally or not */
     hg_atomic_int32_t ref_count;        /* Reference count */
+    hg_bool_t is_mine;                  /* Created internally or not */
 };
 
 /* HG core op type */
@@ -175,71 +170,59 @@ typedef enum {
 /* HG core handle */
 struct hg_core_private_handle {
     struct hg_core_handle core_handle;  /* Must remain as first field */
+    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
+    HG_LIST_ENTRY(hg_core_private_handle) created;  /* Created list entry */
+    HG_LIST_ENTRY(hg_core_private_handle) pending;  /* Pending list entry */
+    struct hg_core_header in_header;    /* Input header */
+    struct hg_core_header out_header;   /* Output header */
     na_class_t *na_class;               /* NA class */
     na_context_t *na_context;           /* NA context */
     hg_core_cb_t request_callback;      /* Request callback */
     void *request_arg;                  /* Request callback arguments */
     hg_core_cb_t response_callback;     /* Response callback */
     void *response_arg;                 /* Response callback arguments */
-    hg_core_op_type_t op_type;          /* Core operation type */
-    na_tag_t tag;                       /* Tag used for request and response */
-    hg_uint8_t cookie;                  /* Cookie */
-    hg_return_t ret;                    /* Return code associated to handle */
-    HG_LIST_ENTRY(hg_core_private_handle) created;  /* Created list entry */
-    HG_LIST_ENTRY(hg_core_private_handle) pending;  /* Pending list entry */
-    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
-    hg_bool_t repost;                   /* Repost handle on completion (listen) */
-    hg_bool_t is_self;                  /* Self processed */
-    hg_atomic_int32_t in_use;           /* Is in use */
-    hg_bool_t no_response;              /* Require response or not */
-
+    hg_return_t (*forward)(struct hg_core_private_handle *hg_core_handle);    /* forward */
+    hg_return_t (*respond)(struct hg_core_private_handle *hg_core_handle);    /* respond */
+    hg_return_t (*no_respond)(struct hg_core_private_handle *hg_core_handle); /* no_respond */
+    void *ack_buf;                      /* Ack buf for more data */
     void *in_buf_plugin_data;           /* Input buffer NA plugin data */
-    na_size_t in_buf_used;              /* Amount of input buffer used */
     void *out_buf_plugin_data;          /* Output buffer NA plugin data */
-    na_size_t out_buf_used;             /* Amount of output buffer used */
-    void *ack_buf;                      /* Ack buf for more data */
     void *ack_buf_plugin_data;          /* Ack plugin data */
-
     na_op_id_t na_send_op_id;           /* Operation ID for send */
     na_op_id_t na_recv_op_id;           /* Operation ID for recv */
     na_op_id_t na_ack_op_id;            /* Operation ID for ack */
-    unsigned int na_op_count;           /* Number of ongoing operations */
-    hg_atomic_int32_t na_op_completed_count;    /* Number of NA operations completed */
-    hg_bool_t na_op_id_mine;            /* Operation ID created by HG */
-
-    struct hg_core_header in_header;    /* Input header */
-    struct hg_core_header out_header;   /* Output header */
-
+    na_size_t in_buf_used;              /* Amount of input buffer used */
+    na_size_t out_buf_used;             /* Amount of output buffer used */
+    na_tag_t tag;                       /* Tag used for request and response */
+    hg_atomic_int32_t na_op_completed_count; /* Number of NA operations completed */
+    hg_atomic_int32_t in_use;           /* Is in use */
     hg_atomic_int32_t ref_count;        /* Reference count */
-
-    /* Callbacks */
-    hg_return_t (*forward)(
-        struct hg_core_private_handle *hg_core_handle
-        ); /* forward */
-    hg_return_t (*respond)(
-        struct hg_core_private_handle *hg_core_handle
-        ); /* respond */
-    hg_return_t (*no_respond)(
-        struct hg_core_private_handle *hg_core_handle
-        ); /* no_respond */
+    hg_atomic_int32_t posted;           /* Handle has been posted */
+    hg_atomic_int32_t canceling;        /* Handle is being canceled */
+    unsigned int na_op_count;           /* Number of ongoing operations */
+    hg_core_op_type_t op_type;          /* Core operation type */
+    hg_return_t ret;                    /* Return code associated to handle */
+    hg_uint8_t cookie;                  /* Cookie */
+    hg_bool_t repost;                   /* Repost handle on completion (listen) */
+    hg_bool_t is_self;                  /* Self processed */
+    hg_bool_t no_response;              /* Require response or not */
 };
 
 /* HG op id */
 struct hg_core_op_info_lookup {
-    struct hg_core_private_addr *hg_core_addr; /* Address */
-    na_op_id_t na_lookup_op_id;         /* Operation ID for lookup */
+    struct hg_core_private_addr *hg_core_addr;  /* Address */
+    na_op_id_t na_lookup_op_id;                 /* Operation ID for lookup */
 };
 
 struct hg_core_op_id {
-    struct hg_core_private_context *context; /* Context */
-    hg_cb_type_t type;                  /* Callback type */
-    hg_core_cb_t callback;              /* Callback */
-    void *arg;                          /* Callback arguments */
-    hg_atomic_int32_t completed;        /* Operation completed TODO needed ? */
+    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
     union {
         struct hg_core_op_info_lookup lookup;
     } info;
-    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
+    struct hg_core_private_context *context;        /* Context */
+    hg_core_cb_t callback;                          /* Callback */
+    void *arg;                                      /* Callback arguments */
+    hg_cb_type_t type;                              /* Callback type */
 };
 
 /********************/
@@ -317,21 +300,11 @@ hg_core_pending_list_cancel(
         struct hg_core_private_context *context
         );
 
-#ifdef HG_HAS_SM_ROUTING
-/**
- * Cancel entries from pending list.
- */
-static hg_return_t
-hg_core_sm_pending_list_cancel(
-        struct hg_core_private_context *context
-        );
-#endif
-
 /**
- * Wail until handle list is empty.
+ * Wail until handle lists are empty.
  */
 static hg_return_t
-hg_core_created_list_wait(
+hg_core_context_lists_wait(
         struct hg_core_private_context *context
         );
 
@@ -641,7 +614,6 @@ hg_core_process(
 static HG_INLINE hg_return_t
 hg_core_complete_na(
         struct hg_core_private_handle *hg_core_handle,
-        na_op_id_t *op_id,
         hg_bool_t *completed
         );
 
@@ -846,11 +818,8 @@ hg_core_get_sm_uuid(uuid_t *sm_uuid)
         uuid_generate(new_uuid);
 
         uuid_config = fopen(sm_path, "w");
-        if (!uuid_config) {
-            HG_LOG_ERROR("Could not open %s for write", sm_path);
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(uuid_config == NULL, done, ret, HG_NOENTRY,
+            "Could not open %s for write", sm_path);
         uuid_unparse(new_uuid, uuid_str);
         fprintf(uuid_config, "%s\n", uuid_str);
     } else {
@@ -884,7 +853,8 @@ hg_core_int_hash(void *vlocation)
 static void
 hg_core_func_map_value_free(hg_hash_table_value_t value)
 {
-    struct hg_core_rpc_info *hg_core_rpc_info = (struct hg_core_rpc_info *) value;
+    struct hg_core_rpc_info *hg_core_rpc_info =
+        (struct hg_core_rpc_info *) value;
 
     if (hg_core_rpc_info->free_callback)
         hg_core_rpc_info->free_callback(hg_core_rpc_info->data);
@@ -921,17 +891,11 @@ hg_core_proc_header_request(struct hg_core_handle *hg_core_handle,
     /* Proc request header */
     ret = hg_core_header_request_proc(op, header_buf, header_buf_size,
         hg_core_header);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process request header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process request header");
 
     if (op == HG_DECODE) {
         ret = hg_core_header_request_verify(hg_core_header);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not verify request header");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not verify request header");
     }
 
 done:
@@ -952,17 +916,11 @@ hg_core_proc_header_response(struct hg_core_handle *hg_core_handle,
     /* Proc response header */
     ret = hg_core_header_response_proc(op, header_buf, header_buf_size,
         hg_core_header);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process response header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process response header");
 
     if (op == HG_DECODE) {
         ret = hg_core_header_response_verify(hg_core_header);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not verify response header");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not verify response header");
     }
 
 done:
@@ -973,75 +931,55 @@ done:
 static hg_return_t
 hg_core_pending_list_cancel(struct hg_core_private_context *context)
 {
+    struct hg_core_private_handle *hg_core_handle;
     hg_return_t ret = HG_SUCCESS;
 
     hg_thread_spin_lock(&context->pending_list_lock);
 
-    while (!HG_LIST_IS_EMPTY(&context->pending_list)) {
-        struct hg_core_private_handle *hg_core_handle =
-            HG_LIST_FIRST(&context->pending_list);
-        HG_LIST_REMOVE(hg_core_handle, pending);
-
+    HG_QUEUE_FOREACH(hg_core_handle, &context->pending_list, pending) {
         /* Prevent reposts */
         hg_core_handle->repost = HG_FALSE;
 
         /* Cancel handle */
         ret = hg_core_cancel(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel handle");
-            break;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle");
     }
 
-    hg_thread_spin_unlock(&context->pending_list_lock);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
 #ifdef HG_HAS_SM_ROUTING
-static hg_return_t
-hg_core_sm_pending_list_cancel(struct hg_core_private_context *context)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    hg_thread_spin_lock(&context->sm_pending_list_lock);
-
-    while (!HG_LIST_IS_EMPTY(&context->sm_pending_list)) {
-        struct hg_core_private_handle *hg_core_handle =
-            HG_LIST_FIRST(&context->sm_pending_list);
-        HG_LIST_REMOVE(hg_core_handle, pending);
-
+    HG_QUEUE_FOREACH(hg_core_handle, &context->sm_pending_list, pending) {
         /* Prevent reposts */
         hg_core_handle->repost = HG_FALSE;
 
         /* Cancel handle */
         ret = hg_core_cancel(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel SM handle");
-            break;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle");
     }
+#endif
 
-    hg_thread_spin_unlock(&context->sm_pending_list_lock);
-
+done:
+    hg_thread_spin_unlock(&context->pending_list_lock);
     return ret;
 }
-#endif
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_created_list_wait(struct hg_core_private_context *context)
+hg_core_context_lists_wait(struct hg_core_private_context *context)
 {
     hg_util_bool_t created_list_empty = HG_UTIL_FALSE;
+    hg_util_bool_t pending_list_empty = HG_UTIL_FALSE;
+#ifdef HG_HAS_SM_ROUTING
+    hg_util_bool_t sm_pending_list_empty = HG_UTIL_FALSE;
+#else
+    hg_util_bool_t sm_pending_list_empty = HG_UTIL_TRUE;
+#endif
     /* Convert timeout in ms into seconds */
-    double remaining = HG_CORE_PROCESSING_TIMEOUT / 1000.0;
+    double remaining = HG_CORE_CLEANUP_TIMEOUT / 1000.0;
     hg_return_t ret = HG_SUCCESS;
 
-    while (remaining > 0) {
+    do {
         unsigned int actual_count = 0;
         hg_time_t t1, t2;
-        hg_return_t trigger_ret;
+        hg_return_t trigger_ret, progress_ret;
 
         hg_time_get_current(&t1);
 
@@ -1049,22 +987,35 @@ hg_core_created_list_wait(struct hg_core_private_context *context)
         do {
             trigger_ret = hg_core_trigger(context, 0, 1, &actual_count);
         } while ((trigger_ret == HG_SUCCESS) && actual_count);
+        HG_CHECK_ERROR(trigger_ret != HG_SUCCESS && trigger_ret != HG_TIMEOUT,
+            done, ret, trigger_ret, "Could not trigger entry");
 
         hg_thread_spin_lock(&context->created_list_lock);
         created_list_empty = HG_LIST_IS_EMPTY(&context->created_list);
         hg_thread_spin_unlock(&context->created_list_lock);
 
-        if (created_list_empty)
+        hg_thread_spin_lock(&context->pending_list_lock);
+        pending_list_empty = HG_LIST_IS_EMPTY(&context->pending_list);
+#ifdef HG_HAS_SM_ROUTING
+        sm_pending_list_empty = HG_LIST_IS_EMPTY(&context->sm_pending_list);
+#endif
+        hg_thread_spin_unlock(&context->pending_list_lock);
+
+        if (created_list_empty && pending_list_empty && sm_pending_list_empty)
             break;
 
-        ret = context->progress(context, (unsigned int) (remaining * 1000.0));
-        if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
-            HG_LOG_ERROR("Could not make progress");
-            goto done;
-        }
+        progress_ret = context->progress(context,
+            (unsigned int) (remaining * 1000.0));
+        HG_CHECK_ERROR(progress_ret != HG_SUCCESS && progress_ret != HG_TIMEOUT,
+            done, ret, progress_ret, "Could not make progress");
         hg_time_get_current(&t2);
         remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
-    }
+        if (remaining < 0)
+            remaining = 0;
+    } while (remaining > 0 || !pending_list_empty || !sm_pending_list_empty);
+
+    HG_LOG_DEBUG("Remaining %lf, Context list status: %d, %d, %d", remaining,
+        created_list_empty, pending_list_empty, sm_pending_list_empty);
 
 done:
     return ret;
@@ -1086,11 +1037,8 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     /* Create new HG class */
     hg_core_class = (struct hg_core_private_class *) malloc(
         sizeof(struct hg_core_private_class));
-    if (!hg_core_class) {
-        HG_LOG_ERROR("Could not allocate HG class");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, error, ret, HG_NOMEM,
+        "Could not allocate HG class");
     memset(hg_core_class, 0, sizeof(struct hg_core_private_class));
 
     /* Parse options */
@@ -1104,19 +1052,16 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
 #ifdef HG_HAS_SM_ROUTING
         auto_sm = hg_init_info->auto_sm;
 #else
-        if (hg_init_info->auto_sm) {
-            HG_LOG_WARNING("Auto SM requested but not enabled, "
-                "please turn ON MERCURY_USE_SM_ROUTING in CMake options");
-        }
+        HG_CHECK_WARNING(hg_init_info->auto_sm,
+            "Auto SM requested but not enabled, "
+            "please turn ON MERCURY_USE_SM_ROUTING in CMake options");
 #endif
 #ifdef HG_HAS_COLLECT_STATS
         hg_core_class->stats = hg_init_info->stats;
         if (hg_core_class->stats && !hg_core_print_stats_registered_g) {
-            if (atexit(hg_core_print_stats) != 0) {
-                HG_LOG_ERROR("Could not register hg_core_print_stats");
-                ret = HG_PROTOCOL_ERROR;
-                goto done;
-            }
+            int rc = atexit(hg_core_print_stats);
+            HG_CHECK_ERROR(rc != 0, error, ret, HG_PROTOCOL_ERROR,
+                "Could not register hg_core_print_stats");
             hg_core_print_stats_registered_g = HG_TRUE;
         }
 #endif
@@ -1126,62 +1071,44 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     if (!hg_core_class->na_ext_init) {
         hg_core_class->core_class.na_class = NA_Initialize_opt(
             na_info_string, na_listen, &hg_init_info->na_init_info);
-        if (!hg_core_class->core_class.na_class) {
-            HG_LOG_ERROR("Could not initialize NA class");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_core_class->core_class.na_class == NULL, error, ret,
+            HG_NA_ERROR, "Could not initialize NA class");
     }
 
 #ifdef HG_HAS_SM_ROUTING
     /* Initialize SM plugin */
     if (auto_sm) {
-        if (strcmp(NA_Get_class_name(hg_core_class->core_class.na_class),
-            "na") == 0) {
-            HG_LOG_ERROR("Cannot use auto SM mode if initialized NA class is "
-                "already using SM");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(strcmp(NA_Get_class_name(
+            hg_core_class->core_class.na_class), "na") == 0, error, ret,
+            HG_PROTONOSUPPORT, "Cannot use auto SM mode if initialized "
+                "NA class is already using SM");
 
         /* Initialize NA SM first so that tmp directories are created */
         hg_core_class->core_class.na_sm_class = NA_Initialize_opt("na+sm",
             na_listen, &hg_init_info->na_init_info);
-        if (!hg_core_class->core_class.na_sm_class) {
-            HG_LOG_ERROR("Could not initialize NA SM class");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_core_class->core_class.na_sm_class == NULL, error,
+            ret, HG_NA_ERROR, "Could not initialize NA SM class");
 
         /* Get SM UUID */
         ret = hg_core_get_sm_uuid(&hg_core_class->na_sm_uuid);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get SM UUID");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not get SM UUID");
     }
 #endif
 
     /* Compute max request tag */
     na_max_tag = NA_Msg_get_max_tag(hg_core_class->core_class.na_class);
-    if (!na_max_tag) {
-        HG_LOG_ERROR("NA Max tag is not defined");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(na_max_tag == 0, error, ret, HG_NA_ERROR,
+        "NA Max tag is not defined");
     hg_core_class->request_max_tag = na_max_tag;
 
 #ifdef HG_HAS_SM_ROUTING
     if (auto_sm) {
         na_sm_max_tag = NA_Msg_get_max_tag(
             hg_core_class->core_class.na_sm_class);
-        if (!na_max_tag) {
-            HG_LOG_ERROR("NA Max tag is not defined");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
-        hg_core_class->request_max_tag = HG_CORE_MIN(hg_core_class->request_max_tag,
-            na_sm_max_tag);
+        HG_CHECK_ERROR(na_sm_max_tag == 0, error, ret, HG_NA_ERROR,
+            "NA Max tag is not defined");
+        hg_core_class->request_max_tag = HG_CORE_MIN(
+            hg_core_class->request_max_tag, na_sm_max_tag);
     }
 #endif
 
@@ -1195,12 +1122,11 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     hg_atomic_init32(&hg_core_class->n_addrs, 0);
 
     /* Create new function map */
-    hg_core_class->func_map = hg_hash_table_new(hg_core_int_hash, hg_core_int_equal);
-    if (!hg_core_class->func_map) {
-        HG_LOG_ERROR("Could not create function map");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    hg_core_class->func_map = hg_hash_table_new(hg_core_int_hash,
+        hg_core_int_equal);
+    HG_CHECK_ERROR(hg_core_class->func_map == NULL, error, ret, HG_NOMEM,
+        "Could not create function map");
+
     /* Automatically free all the values with the hash map */
     hg_hash_table_register_free_functions(hg_core_class->func_map, free,
             hg_core_func_map_value_free);
@@ -1208,12 +1134,13 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     /* Initialize mutex */
     hg_thread_spin_init(&hg_core_class->func_map_lock);
 
-done:
-    if (ret != HG_SUCCESS) {
-        hg_core_finalize(hg_core_class);
-        hg_core_class = NULL;
-    }
+    // TODO
+    (void)ret;
     return hg_core_class;
+
+error:
+    hg_core_finalize(hg_core_class);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1222,24 +1149,19 @@ hg_core_finalize(struct hg_core_private_class *hg_core_class)
 {
     hg_util_int32_t n_addrs, n_contexts;
     hg_return_t ret = HG_SUCCESS;
+    na_return_t na_ret;
 
-    if (!hg_core_class) goto done;
+    if (!hg_core_class)
+        goto done;
 
     n_contexts = hg_atomic_get32(&hg_core_class->n_contexts);
-    if (n_contexts != 0) {
-        HG_LOG_ERROR("HG contexts must be destroyed before finalizing HG"
-            " (%d remaining)", n_contexts);
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(n_contexts != 0, done, ret, HG_BUSY,
+        "HG contexts must be destroyed before finalizing HG (%d remaining)",
+        n_contexts);
 
     n_addrs = hg_atomic_get32(&hg_core_class->n_addrs);
-    if (n_addrs != 0) {
-        HG_LOG_ERROR("HG addrs must be freed before finalizing HG"
-            " (%d remaining)", n_addrs);
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(n_addrs != 0, done, ret, HG_BUSY,
+        "HG addrs must be freed before finalizing HG (%d remaining)", n_addrs);
 
     /* Delete function map */
     if(hg_core_class->func_map)
@@ -1256,27 +1178,23 @@ hg_core_finalize(struct hg_core_private_class *hg_core_class)
 
     if (!hg_core_class->na_ext_init) {
         /* Finalize interface */
-        if (NA_Finalize(hg_core_class->core_class.na_class) != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not finalize NA interface");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        na_ret = NA_Finalize(hg_core_class->core_class.na_class);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not finalize NA interface (%s)", NA_Error_to_string(na_ret));
         hg_core_class->core_class.na_class = NULL;
     }
 
 #ifdef HG_HAS_SM_ROUTING
     /* Finalize SM interface */
-    if (NA_Finalize(hg_core_class->core_class.na_sm_class) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize NA SM interface");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    na_ret = NA_Finalize(hg_core_class->core_class.na_sm_class);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "Could not finalize NA SM interface (%s)", NA_Error_to_string(na_ret));
 #endif
 
-done:
     /* Free HG class */
     free(hg_core_class);
 
+done:
     return ret;
 }
 
@@ -1289,10 +1207,9 @@ hg_core_addr_create(struct hg_core_private_class *hg_core_class,
 
     hg_core_addr = (struct hg_core_private_addr *) malloc(
         sizeof(struct hg_core_private_addr));
-    if (!hg_core_addr) {
-        HG_LOG_ERROR("Could not allocate HG addr");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_addr == NULL, done,
+        "Could not allocate HG addr");
+
     memset(hg_core_addr, 0, sizeof(struct hg_core_private_addr));
     hg_core_addr->core_addr.na_class = na_class;
     hg_core_addr->core_addr.na_addr = NA_ADDR_NULL;
@@ -1317,6 +1234,7 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
     na_context_t *na_context = context->core_context.na_context;
     struct hg_core_op_id *hg_core_op_id = NULL;
     struct hg_core_private_addr *hg_core_addr = NULL;
+    na_addr_t na_addr = NA_ADDR_NULL;
     na_return_t na_ret;
 #ifdef HG_HAS_SM_ROUTING
     char lookup_name[HG_CORE_ADDR_MAX_SIZE] = {'\0'};
@@ -1325,27 +1243,21 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
     hg_return_t ret = HG_SUCCESS, progress_ret;
 
     /* Allocate op_id */
-    hg_core_op_id = (struct hg_core_op_id *) malloc(sizeof(struct hg_core_op_id));
-    if (!hg_core_op_id) {
-        HG_LOG_ERROR("Could not allocate HG operation ID");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    hg_core_op_id = (struct hg_core_op_id *) malloc(
+        sizeof(struct hg_core_op_id));
+    HG_CHECK_ERROR(hg_core_op_id == NULL, error, ret, HG_NOMEM,
+        "Could not allocate HG operation ID");
+
     hg_core_op_id->context = context;
     hg_core_op_id->type = HG_CB_LOOKUP;
     hg_core_op_id->callback = callback;
     hg_core_op_id->arg = arg;
-    hg_atomic_init32(&hg_core_op_id->completed, 0);
     hg_core_op_id->info.lookup.hg_core_addr = NULL;
-    hg_core_op_id->info.lookup.na_lookup_op_id = NA_OP_ID_NULL;
 
     /* Allocate addr */
     hg_core_addr = hg_core_addr_create(HG_CORE_CONTEXT_CLASS(context), NULL);
-    if (!hg_core_addr) {
-        HG_LOG_ERROR("Could not create HG addr");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_addr == NULL, error, ret, HG_NOMEM,
+        "Could not create HG addr");
     hg_core_op_id->info.lookup.hg_core_addr = hg_core_addr;
 
 #ifdef HG_HAS_SM_ROUTING
@@ -1359,11 +1271,9 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
         /* Get first part of address string with UUID */
         strtok_r(lookup_name, HG_CORE_ADDR_DELIMITER, &lookup_names);
 
-        if (!strstr(name, HG_CORE_PROTO_DELIMITER)) {
-            HG_LOG_ERROR("Malformed address format");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(strstr(name, HG_CORE_PROTO_DELIMITER) == NULL, error,
+            ret, HG_PROTOCOL_ERROR, "Malformed address format");
+
         /* Get address SM UUID */
         strtok_r(lookup_name, HG_CORE_PROTO_DELIMITER, &local_id_str);
         uuid_parse(local_id_str + 2, hg_core_addr->na_sm_uuid);
@@ -1388,33 +1298,47 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
     /* Assign corresponding NA class */
     hg_core_addr->core_addr.na_class = na_class;
 
-    /* Assign op_id */
-    if (op_id && op_id != HG_CORE_OP_ID_IGNORE)
-        *op_id = (hg_core_op_id_t) hg_core_op_id;
+    /* Try to use immediate lookup */
+    na_ret = NA_Addr_lookup2(na_class, name_str, &na_addr);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not start lookup for address %s (%s)", name_str,
+        NA_Error_to_string(na_ret));
+
+    if (na_addr != NA_ADDR_NULL) {
+        struct na_cb_info callback_info;
+        callback_info.arg = hg_core_op_id;
+        callback_info.ret = NA_SUCCESS;
+        callback_info.type = NA_CB_LOOKUP;
+        callback_info.info.lookup.addr = na_addr;
+        hg_core_op_id->info.lookup.na_lookup_op_id = NA_OP_ID_NULL;
+
+        hg_core_addr_lookup_cb(&callback_info);
+    } else {
+        /* Create operation ID */
+        hg_core_op_id->info.lookup.na_lookup_op_id = NA_Op_create(na_class);
 
-    na_ret = NA_Addr_lookup(na_class, na_context, hg_core_addr_lookup_cb,
-        hg_core_op_id, name_str, &hg_core_op_id->info.lookup.na_lookup_op_id);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not start lookup for address %s", name_str);
-        ret = HG_NA_ERROR;
-        goto done;
+        na_ret = NA_Addr_lookup(na_class, na_context, hg_core_addr_lookup_cb,
+            hg_core_op_id, name_str, &hg_core_op_id->info.lookup.na_lookup_op_id);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+            "Could not start lookup for address %s (%s)", name_str,
+            NA_Error_to_string(na_ret));
     }
 
     /* TODO to avoid blocking after lookup make progress on the HG layer with
      * timeout of 0 */
     progress_ret = context->progress(context, 0);
-    if (progress_ret != HG_SUCCESS && progress_ret != HG_TIMEOUT) {
-        HG_LOG_ERROR("Could not make progress");
-        ret = progress_ret;
-        goto done;
-    }
+    HG_CHECK_ERROR(progress_ret != HG_SUCCESS && progress_ret != HG_TIMEOUT,
+        error, ret, progress_ret, "Could not make progress");
 
-done:
-    if (ret != HG_SUCCESS) {
-        free(hg_core_op_id);
-        if (hg_core_addr != NULL)
-            hg_core_addr_free(HG_CORE_CONTEXT_CLASS(context), hg_core_addr);
-    }
+    /* Assign op_id */
+    if (op_id && op_id != HG_CORE_OP_ID_IGNORE)
+        *op_id = (hg_core_op_id_t) hg_core_op_id;
+
+    return ret;
+
+error:
+    free(hg_core_op_id);
+    hg_core_addr_free(HG_CORE_CONTEXT_CLASS(context), hg_core_addr);
 
     return ret;
 }
@@ -1425,26 +1349,24 @@ hg_core_addr_lookup_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_op_id *hg_core_op_id =
         (struct hg_core_op_id *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
+    na_return_t na_ret = callback_info->ret;
+    hg_return_t hg_ret;
     int ret = 0;
 
-    if (callback_info->ret != NA_SUCCESS) {
-        return ret;
-    }
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done, "(%s)",
+        NA_Error_to_string(na_ret));
 
     /* Assign addr */
     hg_core_op_id->info.lookup.hg_core_addr->core_addr.na_addr =
         callback_info->info.lookup.addr;
 
     /* Mark as completed */
-    if (hg_core_addr_lookup_complete(hg_core_op_id) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    hg_ret = hg_core_addr_lookup_complete(hg_core_op_id);
+    HG_CHECK_HG_ERROR(done, hg_ret, "Could not complete operation");
+
     ret++;
 
 done:
-    (void) na_ret;
     return ret;
 }
 
@@ -1457,17 +1379,12 @@ hg_core_addr_lookup_complete(struct hg_core_op_id *hg_core_op_id)
         &hg_core_op_id->hg_completion_entry;
     hg_return_t ret = HG_SUCCESS;
 
-    /* Mark operation as completed */
-    hg_atomic_incr32(&hg_core_op_id->completed);
-
     hg_completion_entry->op_type = HG_ADDR;
     hg_completion_entry->op_id.hg_core_op_id = hg_core_op_id;
 
     ret = hg_core_completion_add(context, hg_completion_entry, HG_FALSE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not add HG completion entry to completion queue");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret,
+        "Could not add HG completion entry to completion queue");
 
 done:
     return ret;
@@ -1481,12 +1398,12 @@ hg_core_addr_free(struct hg_core_private_class *hg_core_class,
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
-    if (!hg_core_addr) goto done;
+    if (!hg_core_addr)
+        goto done;
 
-    if (hg_atomic_decr32(&hg_core_addr->ref_count)) {
+    if (hg_atomic_decr32(&hg_core_addr->ref_count))
         /* Cannot free yet */
         goto done;
-    }
 
     /* Decrement N addrs from HG class */
     hg_atomic_decr32(&hg_core_class->n_addrs);
@@ -1496,22 +1413,17 @@ hg_core_addr_free(struct hg_core_private_class *hg_core_class,
     if (hg_core_addr->core_addr.na_sm_addr != NA_ADDR_NULL) {
         na_ret = NA_Addr_free(hg_core_class->core_class.na_sm_class,
             hg_core_addr->core_addr.na_sm_addr);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not free NA SM address");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not free NA SM address (%s)", NA_Error_to_string(na_ret));
     }
 #endif
 
     /* Free NA address */
     na_ret = NA_Addr_free(hg_core_addr->core_addr.na_class,
         hg_core_addr->core_addr.na_addr);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not free address");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "Could not free NA address (%s)", NA_Error_to_string(na_ret));
+
     free(hg_core_addr);
 
 done:
@@ -1529,30 +1441,21 @@ hg_core_addr_self(struct hg_core_private_class *hg_core_class,
 
     hg_core_addr = hg_core_addr_create(hg_core_class,
         hg_core_class->core_class.na_class);
-    if (!hg_core_addr) {
-        HG_LOG_ERROR("Could not create HG addr");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_addr == NULL, done, ret, HG_NOMEM,
+        "Could not create HG addr");
 
     na_ret = NA_Addr_self(hg_core_class->core_class.na_class,
         &hg_core_addr->core_addr.na_addr);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not get self address");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "Could not get self address (%s)", NA_Error_to_string(na_ret));
 
 #ifdef HG_HAS_SM_ROUTING
     if (hg_core_class->core_class.na_sm_class) {
         /* Get SM address */
         na_ret = NA_Addr_self(hg_core_class->core_class.na_sm_class,
             &hg_core_addr->core_addr.na_sm_addr);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not get self SM address");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not get self SM address (%s)", NA_Error_to_string(na_ret));
 
         /* Copy local UUID */
         uuid_copy(hg_core_addr->na_sm_uuid, hg_core_class->na_sm_uuid);
@@ -1584,18 +1487,14 @@ hg_core_addr_dup(struct hg_core_private_class *hg_core_class,
 
         dup = hg_core_addr_create(hg_core_class,
             hg_core_addr->core_addr.na_class);
-        if (!dup) {
-            HG_LOG_ERROR("Could not create HG addr");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(dup == NULL, done, ret, HG_NOMEM,
+            "Could not create dup HG addr");
+
         na_ret = NA_Addr_dup(hg_core_addr->core_addr.na_class,
             hg_core_addr->core_addr.na_addr, &dup->core_addr.na_addr);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not duplicate address");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not duplicate address (%s)", NA_Error_to_string(na_ret));
+
         *hg_new_addr = dup;
     } else {
         hg_atomic_incr32(&hg_core_addr->ref_count);
@@ -1616,11 +1515,6 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
-    if (!buf_size) {
-        HG_LOG_ERROR("NULL buffer size");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
     new_buf_size = *buf_size;
 
 #ifdef HG_HAS_SM_ROUTING
@@ -1633,11 +1527,9 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
         uuid_unparse(hg_core_addr->na_sm_uuid, uuid_str);
         desc_len = snprintf(addr_str, HG_CORE_ADDR_MAX_SIZE,
             "uid://%s" HG_CORE_ADDR_DELIMITER, uuid_str);
-        if (desc_len > HG_CORE_ADDR_MAX_SIZE) {
-            HG_LOG_ERROR("Exceeding max addr name");
-            ret = HG_SIZE_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(desc_len > HG_CORE_ADDR_MAX_SIZE, done, ret,
+            HG_OVERFLOW, "Exceeding max addr name");
+
         if (buf_ptr) {
             strcpy(buf_ptr, addr_str);
             buf_ptr += desc_len;
@@ -1649,11 +1541,10 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
         /* Get NA SM address string */
         na_ret = NA_Addr_to_string(hg_core_class->core_class.na_sm_class,
             buf_ptr, &new_buf_size, hg_core_addr->core_addr.na_sm_addr);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not convert SM address to string");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not convert SM address to string (%s)",
+            NA_Error_to_string(na_ret));
+
         if (buf_ptr) {
             buf_ptr[new_buf_size - 1] = *HG_CORE_ADDR_DELIMITER;
             buf_ptr += new_buf_size;
@@ -1667,11 +1558,9 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
     /* Get NA address string */
     na_ret = NA_Addr_to_string(hg_core_class->core_class.na_class, buf_ptr,
         &new_buf_size, hg_core_addr->core_addr.na_addr);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not convert address to string");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "Could not convert address to string (%s)", NA_Error_to_string(na_ret));
+
     *buf_size = new_buf_size + buf_size_used;
 
 done:
@@ -1687,10 +1576,9 @@ hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
 
     hg_core_handle = (struct hg_core_private_handle *) malloc(
         sizeof(struct hg_core_private_handle));
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("Could not allocate handle");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_handle == NULL, error,
+        "Could not allocate handle");
+
     memset(hg_core_handle, 0, sizeof(struct hg_core_private_handle));
 
     hg_core_handle->op_type = HG_CORE_PROCESS; /* Default */
@@ -1713,6 +1601,12 @@ hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
     /* Handle is not in use */
     hg_atomic_init32(&hg_core_handle->in_use, HG_FALSE);
 
+    /* Handle has not been posted */
+    hg_atomic_init32(&hg_core_handle->posted, HG_FALSE);
+
+    /* Handle is not being canceled */
+    hg_atomic_init32(&hg_core_handle->canceling, HG_FALSE);
+
     /* Init in/out header */
     hg_core_header_request_init(&hg_core_handle->in_header);
     hg_core_header_response_init(&hg_core_handle->out_header);
@@ -1725,25 +1619,21 @@ hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
 
     /* Alloc/init NA resources */
     ret = hg_core_alloc_na(hg_core_handle, use_sm);
-    if (ret != HG_SUCCESS) {
-        NA_LOG_ERROR("Could not allocate NA handle ops");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not allocate NA handle ops");
 
-done:
-    if (ret != HG_SUCCESS) {
-        hg_core_destroy(hg_core_handle);
-        hg_core_handle = NULL;
-    }
     return hg_core_handle;
+
+error:
+    hg_core_destroy(hg_core_handle);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
 static void
 hg_core_destroy(struct hg_core_private_handle *hg_core_handle)
 {
-    if (!hg_core_handle) goto done;
+    if (!hg_core_handle)
+        goto done;
 
     if (hg_atomic_decr32(&hg_core_handle->ref_count))
         goto done; /* Cannot free yet */
@@ -1788,6 +1678,7 @@ hg_core_alloc_na(struct hg_core_private_handle *hg_core_handle,
     hg_bool_t HG_UNUSED use_sm)
 {
     hg_return_t ret = HG_SUCCESS;
+    na_return_t na_ret;
 
     /* Set handle NA class/context */
     hg_core_handle->na_class =
@@ -1814,43 +1705,47 @@ hg_core_alloc_na(struct hg_core_private_handle *hg_core_handle,
     hg_core_handle->core_handle.in_buf = NA_Msg_buf_alloc(
         hg_core_handle->na_class, hg_core_handle->core_handle.in_buf_size,
         &hg_core_handle->in_buf_plugin_data);
-    if (!hg_core_handle->core_handle.in_buf) {
-        HG_LOG_ERROR("Could not allocate buffer for input");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    NA_Msg_init_unexpected(hg_core_handle->na_class,
+    HG_CHECK_ERROR(hg_core_handle->core_handle.in_buf == NULL, error, ret,
+        HG_NOMEM, "Could not allocate buffer for input");
+
+    na_ret = NA_Msg_init_unexpected(hg_core_handle->na_class,
         hg_core_handle->core_handle.in_buf,
         hg_core_handle->core_handle.in_buf_size);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not initialize input buffer (%s)",
+        NA_Error_to_string(na_ret));
 
     hg_core_handle->core_handle.out_buf = NA_Msg_buf_alloc(
         hg_core_handle->na_class, hg_core_handle->core_handle.out_buf_size,
         &hg_core_handle->out_buf_plugin_data);
-    if (!hg_core_handle->core_handle.out_buf) {
-        HG_LOG_ERROR("Could not allocate buffer for output");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    NA_Msg_init_expected(hg_core_handle->na_class,
+    HG_CHECK_ERROR(hg_core_handle->core_handle.out_buf == NULL, error, ret,
+        HG_NOMEM, "Could not allocate buffer for output");
+
+    na_ret = NA_Msg_init_expected(hg_core_handle->na_class,
         hg_core_handle->core_handle.out_buf,
         hg_core_handle->core_handle.out_buf_size);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not initialize output buffer (%s)",
+        NA_Error_to_string(na_ret));
 
     /* Create NA operation IDs */
     hg_core_handle->na_send_op_id = NA_Op_create(hg_core_handle->na_class);
+    HG_CHECK_ERROR(hg_core_handle->na_send_op_id == NA_OP_ID_NULL, error, ret,
+        HG_NA_ERROR, "Could not create NA op ID");
     hg_core_handle->na_recv_op_id = NA_Op_create(hg_core_handle->na_class);
-    if (hg_core_handle->na_recv_op_id || hg_core_handle->na_send_op_id) {
-        if ((hg_core_handle->na_recv_op_id == NA_OP_ID_NULL)
-            || (hg_core_handle->na_send_op_id == NA_OP_ID_NULL)) {
-            HG_LOG_ERROR("NULL operation ID");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
-        hg_core_handle->na_op_id_mine = HG_TRUE;
-    }
+    HG_CHECK_ERROR(hg_core_handle->na_recv_op_id == NA_OP_ID_NULL, error, ret,
+        HG_NA_ERROR, "Could not create NA op ID");
+    hg_core_handle->na_ack_op_id = NA_Op_create(hg_core_handle->na_class);
+    HG_CHECK_ERROR(hg_core_handle->na_ack_op_id == NA_OP_ID_NULL, error, ret,
+        HG_NA_ERROR, "Could not create NA op ID");
+
     hg_core_handle->na_op_count = 1; /* Default (no response) */
     hg_atomic_init32(&hg_core_handle->na_op_completed_count, 0);
 
-done:
+    return ret;
+
+error:
+    hg_core_free_na(hg_core_handle);
     return ret;
 }
 
@@ -1860,30 +1755,52 @@ hg_core_free_na(struct hg_core_private_handle *hg_core_handle)
 {
     na_return_t na_ret;
 
-    /* Free eventual ack buffer */
-    if (hg_core_handle->ack_buf) {
-        NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->ack_buf,
-            hg_core_handle->ack_buf_plugin_data);
-        hg_core_handle->ack_buf = NULL;
-    }
-
     /* Destroy NA op IDs */
-    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_send_op_id);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA op ID");
-    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_recv_op_id);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA op ID");
+    na_ret = NA_Op_destroy(hg_core_handle->na_class,
+        hg_core_handle->na_send_op_id);
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+        "Could not destroy send op ID (%s)", NA_Error_to_string(na_ret));
+    hg_core_handle->na_send_op_id = NA_OP_ID_NULL;
+
+    na_ret = NA_Op_destroy(hg_core_handle->na_class,
+        hg_core_handle->na_recv_op_id);
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+        "Could not destroy recv op ID (%s)", NA_Error_to_string(na_ret));
+    hg_core_handle->na_recv_op_id = NA_OP_ID_NULL;
+
+    na_ret = NA_Op_destroy(hg_core_handle->na_class,
+        hg_core_handle->na_ack_op_id);
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+        "Could not destroy ack op ID (%s)", NA_Error_to_string(na_ret));
+    hg_core_handle->na_ack_op_id = NA_OP_ID_NULL;
 
     /* Free buffers */
     na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
         hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_plugin_data);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA input msg buffer");
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+        "Could not free input buffer (%s)", NA_Error_to_string(na_ret));
+    hg_core_handle->core_handle.in_buf = NULL;
+    hg_core_handle->in_buf_plugin_data = NULL;
+
     na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
-        hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_plugin_data);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA output msg buffer");
+        hg_core_handle->core_handle.out_buf,
+        hg_core_handle->out_buf_plugin_data);
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+        "Could not free output buffer (%s)", NA_Error_to_string(na_ret));
+    hg_core_handle->core_handle.out_buf = NULL;
+    hg_core_handle->out_buf_plugin_data = NULL;
+
+    if (hg_core_handle->ack_buf) {
+        na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
+            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
+        HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
+        hg_core_handle->ack_buf = NULL;
+        hg_core_handle->ack_buf_plugin_data = NULL;
+    }
+
+done:
+    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1895,8 +1812,11 @@ hg_core_reset(struct hg_core_private_handle *hg_core_handle,
     if (reset_info) {
         if (hg_core_handle->core_handle.info.addr != HG_CORE_ADDR_NULL
             && hg_core_handle->core_handle.info.addr->na_addr != NA_ADDR_NULL) {
-            NA_Addr_free(hg_core_handle->core_handle.info.addr->na_class,
+            na_return_t na_ret = NA_Addr_free(
+                hg_core_handle->core_handle.info.addr->na_class,
                 hg_core_handle->core_handle.info.addr->na_addr);
+            HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+                "Could not free NA address (%s)", NA_Error_to_string(na_ret));
             hg_core_handle->core_handle.info.addr->na_addr = NA_ADDR_NULL;
         }
         hg_core_handle->core_handle.info.id = 0;
@@ -1921,14 +1841,19 @@ hg_core_reset(struct hg_core_private_handle *hg_core_handle,
         HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_release(
             (hg_core_handle_t) hg_core_handle);
     if (hg_core_handle->ack_buf) {
-        NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->ack_buf,
-            hg_core_handle->ack_buf_plugin_data);
+        na_return_t na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
+            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
+        HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
         hg_core_handle->ack_buf = NULL;
         hg_core_handle->ack_buf_plugin_data = NULL;
     }
 
     hg_core_header_request_reset(&hg_core_handle->in_header);
     hg_core_header_response_reset(&hg_core_handle->out_header);
+
+done:
+    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1974,11 +1899,9 @@ hg_core_set_rpc(struct hg_core_private_handle *hg_core_handle,
             (hg_hash_table_key_t) &id);
         hg_thread_spin_unlock(
             &HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map_lock);
-        if (!hg_core_rpc_info) {
-            /* HG_LOG_ERROR("Could not find RPC ID in function map"); */
-            ret = HG_NO_MATCH;
-            goto done;
-        }
+        if (!hg_core_rpc_info)
+            HG_GOTO_DONE(done, ret, HG_NOENTRY);
+
         hg_core_handle->core_handle.info.id = id;
 
         /* Cache RPC info */
@@ -2001,10 +1924,7 @@ hg_core_forward_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Post operation to self processing pool */
     ret = hg_core_process_self(hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not self process handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not self process handle");
 
 done:
     return ret;
@@ -2025,11 +1945,8 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
     hg_core_handle->tag = hg_core_gen_request_tag(
         HG_CORE_HANDLE_CLASS(hg_core_handle));
 
+    /* Pre-post recv (output) if response is expected */
     if (!hg_core_handle->no_response) {
-        /* Increment number of expected NA operations */
-        hg_core_handle->na_op_count++;
-
-        /* Pre-post the recv message (output) if response is expected */
         na_ret = NA_Msg_recv_expected(hg_core_handle->na_class,
             hg_core_handle->na_context, hg_core_recv_output_cb, hg_core_handle,
             hg_core_handle->core_handle.out_buf,
@@ -2038,14 +1955,21 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
             hg_core_handle->core_handle.info.addr->na_addr,
             hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
             &hg_core_handle->na_recv_op_id);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not post recv for output buffer");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not post recv for output buffer (%s)",
+            NA_Error_to_string(na_ret));
+
+        /* Increment number of expected NA operations */
+        hg_core_handle->na_op_count++;
+
+        /* Take reference to make sure the handle does not get freed */
+        hg_atomic_incr32(&hg_core_handle->ref_count);
     }
 
-    /* And post the send message (input) */
+    /* Mark handle as posted */
+    hg_atomic_set32(&hg_core_handle->posted, HG_TRUE);
+
+    /* Post send (input) */
     na_ret = NA_Msg_send_unexpected(hg_core_handle->na_class,
         hg_core_handle->na_context, hg_core_send_input_cb, hg_core_handle,
         hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_used,
@@ -2053,20 +1977,31 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
         hg_core_handle->core_handle.info.addr->na_addr,
         hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
         &hg_core_handle->na_send_op_id);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not post send for input buffer");
-        /* Cancel the above posted recv op */
-        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-            hg_core_handle->na_recv_op_id);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel recv op id");
-        }
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    if (na_ret == NA_AGAIN)
+        /* Silently return on NA_AGAIN error so that users can manually retry */
+        HG_GOTO_DONE(cancel, ret, HG_AGAIN);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, cancel, ret, (hg_return_t) na_ret,
+        "Could not post send for input buffer (%s)",
+        NA_Error_to_string(na_ret));
 
 done:
     return ret;
+
+cancel:
+    if (!hg_core_handle->no_response)
+        hg_core_handle->na_op_count--;
+
+    /* Handle is no longer posted and being canceled*/
+    hg_atomic_set32(&hg_core_handle->posted, HG_FALSE);
+    hg_atomic_set32(&hg_core_handle->canceling, HG_TRUE);
+
+    /* Cancel the above posted recv op */
+    na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
+        hg_core_handle->na_recv_op_id);
+    HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
+        "Could not cancel recv op id (%s)", NA_Error_to_string(na_ret));
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2081,10 +2016,7 @@ hg_core_respond_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Complete and add to completion queue */
     ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete handle");
 
 done:
     return ret;
@@ -2101,10 +2033,7 @@ hg_core_no_respond_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Complete and add to completion queue */
     ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete handle");
 
 done:
     return ret;
@@ -2117,6 +2046,7 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
+    hg_bool_t ack_recv_posted = HG_FALSE;
 
     /* Increment number of expected NA operations */
     hg_core_handle->na_op_count++;
@@ -2131,15 +2061,15 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
 
         hg_core_handle->ack_buf = NA_Msg_buf_alloc(hg_core_handle->na_class,
             sizeof(hg_uint8_t), &hg_core_handle->ack_buf_plugin_data);
-        if (!hg_core_handle->ack_buf) {
-            HG_LOG_ERROR("Could not allocate buffer for ack");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
-        NA_Msg_init_expected(hg_core_handle->na_class, hg_core_handle->ack_buf,
-            sizeof(hg_uint8_t));
+        HG_CHECK_ERROR(hg_core_handle->ack_buf == NULL, error, ret,
+            HG_NA_ERROR, "Could not allocate buffer for ack");
+
+        na_ret = NA_Msg_init_expected(hg_core_handle->na_class,
+            hg_core_handle->ack_buf, sizeof(hg_uint8_t));
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+            "Could not initialize ack buffer (%s)", NA_Error_to_string(na_ret));
 
-        /* Pre-post the recv message (output) if response is expected */
+        /* Pre-post recv (ack) if more data is expected */
         na_ret = NA_Msg_recv_expected(hg_core_handle->na_class,
             hg_core_handle->na_context, hg_core_recv_ack_cb, hg_core_handle,
             hg_core_handle->ack_buf, sizeof(hg_uint8_t),
@@ -2147,14 +2077,13 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
             hg_core_handle->core_handle.info.addr->na_addr,
             hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
             &hg_core_handle->na_ack_op_id);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not post recv for ack buffer");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+            "Could not post recv for ack buffer (%s)",
+            NA_Error_to_string(na_ret));
+        ack_recv_posted = HG_TRUE;
     }
 
-    /* Respond back */
+    /* Post expected send (output) */
     na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
         hg_core_handle->na_context, hg_core_send_output_cb, hg_core_handle,
         hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_used,
@@ -2162,13 +2091,30 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
         hg_core_handle->core_handle.info.addr->na_addr,
         hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
         &hg_core_handle->na_send_op_id);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not post send for output buffer");
-        ret = HG_NA_ERROR;
-        goto done;
+    /* Expected sends should always succeed after retry */
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not post send for output buffer (%s)",
+        NA_Error_to_string(na_ret));
+
+    return ret;
+
+error:
+    if (ack_recv_posted) {
+        /* Cancel the above posted recv ack op */
+        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
+            hg_core_handle->na_ack_op_id);
+        HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
+            "Could not cancel ack op id (%s)", NA_Error_to_string(na_ret));
+    }
+    if (hg_core_handle->ack_buf) {
+        na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
+            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
+        HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
+            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
+        hg_core_handle->ack_buf = NULL;
+        hg_core_handle->ack_buf_plugin_data = NULL;
     }
 
-done:
     return ret;
 }
 
@@ -2182,10 +2128,7 @@ hg_core_no_respond_na(struct hg_core_private_handle *hg_core_handle)
     hg_core_handle->op_type = HG_CORE_NO_RESPOND;
 
     ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
     return ret;
@@ -2197,27 +2140,20 @@ hg_core_send_input_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
-    if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
+    /* If canceled, mark handle as canceled */
+    if (callback_info->ret == NA_CANCELED)
         hg_core_handle->ret = HG_CANCELED;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_send_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Error in NA callback");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2230,103 +2166,77 @@ hg_core_recv_input_cb(const struct na_cb_info *callback_info)
     const struct na_cb_info_recv_unexpected *na_cb_info_recv_unexpected =
         &callback_info->info.recv_unexpected;
 #ifndef HG_HAS_POST_LIMIT
-    hg_bool_t pending_empty = NA_FALSE;
-# ifdef HG_HAS_SM_ROUTING
-    hg_bool_t sm_pending_empty = NA_FALSE;
-# endif
+    hg_bool_t pending_empty = HG_FALSE;
+    hg_bool_t use_sm = HG_FALSE;
 #endif
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
+
+    /* Remove handle from pending list */
+    hg_thread_spin_lock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+    HG_LIST_REMOVE(hg_core_handle, pending);
+    hg_thread_spin_unlock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
 
+    /* If canceled, mark handle as canceled */
     if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
         /* Only decrement refcount and exit */
         hg_core_destroy(hg_core_handle);
         goto done;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    } else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* Fill unexpected info */
     hg_core_handle->core_handle.info.addr->na_addr =
         na_cb_info_recv_unexpected->source;
     hg_core_handle->tag = na_cb_info_recv_unexpected->tag;
-    if (na_cb_info_recv_unexpected->actual_buf_size >
-    hg_core_handle->core_handle.in_buf_size) {
-        HG_LOG_ERROR("Actual transfer size is too large for unexpected recv");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(na_cb_info_recv_unexpected->actual_buf_size >
+        hg_core_handle->core_handle.in_buf_size, done,
+        "Actual transfer size is too large for unexpected recv");
     hg_core_handle->in_buf_used = na_cb_info_recv_unexpected->actual_buf_size;
 
-    /* Remove handle from pending list */
-#ifdef HG_HAS_SM_ROUTING
-    if (hg_core_handle->na_class ==
-        hg_core_handle->core_handle.info.core_class->na_sm_class) {
-        hg_thread_spin_lock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
-        HG_LIST_REMOVE(hg_core_handle, pending);
-# ifndef HG_HAS_POST_LIMIT
-        sm_pending_empty = HG_LIST_IS_EMPTY(
+#ifndef HG_HAS_POST_LIMIT
+    /* Check if we need more handles */
+    hg_thread_spin_lock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+
+# ifdef HG_HAS_SM_ROUTING
+    if (hg_core_handle->na_class
+        == hg_core_handle->core_handle.info.core_class->na_sm_class) {
+        pending_empty =  HG_LIST_IS_EMPTY(
             &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list);
+        use_sm = HG_TRUE;
+    } else
 # endif
-        hg_thread_spin_unlock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
-    } else {
-#endif
-        hg_thread_spin_lock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
-        HG_LIST_REMOVE(hg_core_handle, pending);
-#ifndef HG_HAS_POST_LIMIT
         pending_empty = HG_LIST_IS_EMPTY(
             &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list);
-#endif
-        hg_thread_spin_unlock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
-#ifdef HG_HAS_SM_ROUTING
-    }
-#endif
 
-#ifndef HG_HAS_POST_LIMIT
-    /* If pending list is empty, post more handles */
-    if (pending_empty
-        && hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
-        HG_CORE_PENDING_INCR, hg_core_handle->repost, HG_FALSE) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not post additional handles");
-        goto done;
-    }
-# ifdef HG_HAS_SM_ROUTING
+    hg_thread_spin_unlock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+
     /* If pending list is empty, post more handles */
-    if (sm_pending_empty
-        && hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
-        HG_CORE_PENDING_INCR, hg_core_handle->repost, HG_TRUE) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not post additional SM handles");
-        goto done;
+    if (pending_empty) {
+        ret = hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
+            HG_CORE_PENDING_INCR, hg_core_handle->repost, use_sm);
+        HG_CHECK_HG_ERROR(done, ret, "Could not post additional handles");
     }
-# endif
 #endif
 
     /* Set operation type for trigger */
     hg_core_handle->op_type = HG_CORE_PROCESS;
 
     /* Process input information */
-    if (hg_core_process_input(hg_core_handle, &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process input");
-        goto done;
-    }
+    ret = hg_core_process_input(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not process input");
 
     /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_recv_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2345,10 +2255,7 @@ hg_core_process_input(struct hg_core_private_handle *hg_core_handle,
     /* Get and verify input header */
     ret = hg_core_proc_header_request(&hg_core_handle->core_handle,
         &hg_core_handle->in_header, HG_DECODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get request header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get request header");
 
     /* Get operation ID from header */
     hg_core_handle->core_handle.info.id =
@@ -2372,21 +2279,17 @@ hg_core_process_input(struct hg_core_private_handle *hg_core_handle,
 
     /* Must let upper layer get extra payload if HG_CORE_MORE_DATA is set */
     if (hg_core_handle->in_header.msg.request.flags & HG_CORE_MORE_DATA) {
-        if (!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire) {
-            HG_LOG_ERROR("No callback defined for acquiring more data");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire,
+            done, ret, HG_OPNOTSUPPORTED,
+            "No callback defined for acquiring more data");
 #ifdef HG_HAS_COLLECT_STATS
         /* Increment counter */
         hg_core_stat_incr(&hg_core_rpc_extra_count_g);
 #endif
         ret = HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire(
             (hg_core_handle_t) hg_core_handle, HG_INPUT, hg_core_complete);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Error in HG core handle more data acquire callback");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret,
+            "Error in HG core handle more data acquire callback");
         *completed = HG_FALSE;
     } else
         *completed = HG_TRUE;
@@ -2401,28 +2304,21 @@ hg_core_send_output_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
-    if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
+    /* If canceled, mark handle as canceled */
+    if (callback_info->ret == NA_CANCELED)
         hg_core_handle->ret = HG_CANCELED;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_send_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2432,36 +2328,37 @@ hg_core_recv_output_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
+    /* If canceled, mark handle as canceled */
     if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+
+        /* Do not add handle to completion queue if it was not posted */
+        if (hg_atomic_get32(&hg_core_handle->posted))
+            goto complete;
+        else {
+            /* Cancelation has been processed */
+            hg_atomic_set32(&hg_core_handle->canceling, HG_FALSE);
+            goto done;
+        }
+    } else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* Process output information */
-    if (hg_core_handle->ret != HG_CANCELED
-        && hg_core_process_output(hg_core_handle, &completed, hg_core_send_ack)
-            != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process output");
-        goto done;
-    }
+    ret = hg_core_process_output(hg_core_handle, &completed, hg_core_send_ack);
+    HG_CHECK_HG_ERROR(done, ret, "Could not process output");
 
+complete:
     /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_recv_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
-    (void) na_ret; /* unused */
+    /* Only decrement refcount and exit */
+    hg_core_destroy(hg_core_handle);
     return (int) completed;
 }
 
@@ -2474,11 +2371,9 @@ hg_core_process_output(struct hg_core_private_handle *hg_core_handle,
     hg_return_t ret = HG_SUCCESS;
 
     /* Get and verify output header */
-    if (hg_core_proc_header_response(&hg_core_handle->core_handle,
-        &hg_core_handle->out_header, HG_DECODE) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode header");
-        goto done;
-    }
+    ret= hg_core_proc_header_response(&hg_core_handle->core_handle,
+        &hg_core_handle->out_header, HG_DECODE);
+    HG_CHECK_HG_ERROR(done, ret, "Could not decode header");
 
     /* Get return code from header */
     hg_core_handle->ret =
@@ -2488,17 +2383,14 @@ hg_core_process_output(struct hg_core_private_handle *hg_core_handle,
 
     /* Must let upper layer get extra payload if HG_CORE_MORE_DATA is set */
     if (hg_core_handle->out_header.msg.response.flags & HG_CORE_MORE_DATA) {
-        if (!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire) {
-            HG_LOG_ERROR("No callback defined for acquiring more data");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire,
+            done, ret, HG_OPNOTSUPPORTED,
+            "No callback defined for acquiring more data");
+
         ret = HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire(
             (hg_core_handle_t) hg_core_handle, HG_OUTPUT, done_callback);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Error in HG core handle more data acquire callback");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret,
+            "Error in HG core handle more data acquire callback");
         *completed = HG_FALSE;
     } else
         *completed = HG_TRUE;
@@ -2522,15 +2414,15 @@ hg_core_send_ack(hg_core_handle_t handle)
     /* Allocate buffer for ack */
     hg_core_handle->ack_buf = NA_Msg_buf_alloc(hg_core_handle->na_class,
         sizeof(hg_uint8_t), &hg_core_handle->ack_buf_plugin_data);
-    if (!hg_core_handle->ack_buf) {
-        HG_LOG_ERROR("Could not allocate buffer for ack");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    NA_Msg_init_expected(hg_core_handle->na_class, hg_core_handle->ack_buf,
-        sizeof(hg_uint8_t));
+    HG_CHECK_ERROR(hg_core_handle->ack_buf == NULL, error, ret, HG_NA_ERROR,
+        "Could not allocate buffer for ack");
 
-    /* Pre-post the recv message (output) if response is expected */
+    na_ret = NA_Msg_init_expected(hg_core_handle->na_class,
+        hg_core_handle->ack_buf, sizeof(hg_uint8_t));
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not initialize ack buffer (%s)", NA_Error_to_string(na_ret));
+
+    /* Post expected send (ack) */
     na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
         hg_core_handle->na_context, hg_core_send_ack_cb, hg_core_handle,
         hg_core_handle->ack_buf, sizeof(hg_uint8_t),
@@ -2538,13 +2430,21 @@ hg_core_send_ack(hg_core_handle_t handle)
         hg_core_handle->core_handle.info.addr->na_addr,
         hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
         &hg_core_handle->na_ack_op_id);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not post send for ack buffer");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    /* Expected sends should always succeed after retry */
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not post send for ack buffer (%s)", NA_Error_to_string(na_ret));
 
-done:
+    return ret;
+
+error:
+    if (hg_core_handle->ack_buf) {
+        na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
+            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
+        HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
+            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
+        hg_core_handle->ack_buf = NULL;
+        hg_core_handle->ack_buf_plugin_data = NULL;
+    }
     return ret;
 }
 
@@ -2554,28 +2454,21 @@ hg_core_send_ack_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
-    if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
+    /* If canceled, mark handle as canceled */
+    if (callback_info->ret == NA_CANCELED)
         hg_core_handle->ret = HG_CANCELED;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_ack_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2585,28 +2478,21 @@ hg_core_recv_ack_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
-    if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
+    /* If canceled, mark handle as canceled */
+    if (callback_info->ret == NA_CANCELED)
         hg_core_handle->ret = HG_CANCELED;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_ack_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2640,15 +2526,12 @@ hg_core_self_cb(const struct hg_core_cb_info *callback_info)
 
     /* Process output */
     ret = hg_core_process_output(hg_core_handle, &completed, hg_core_complete);
-    if (ret != HG_SUCCESS) {
-       HG_LOG_ERROR("Could not process output");
-       goto done;
-   }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process output");
 
     /* Mark as completed */
-    if (completed
-        && hg_core_complete((hg_core_handle_t) hg_core_handle) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
+    if (completed) {
+        ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
+        HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
     }
 
 done:
@@ -2667,18 +2550,12 @@ hg_core_process_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Process input */
     ret = hg_core_process_input(hg_core_handle, &completed);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process input");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process input");
 
     /* Mark as completed */
     if (completed) {
         ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
     }
 
 done:
@@ -2701,15 +2578,12 @@ hg_core_process(struct hg_core_private_handle *hg_core_handle)
     hg_thread_spin_unlock(&HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map_lock);
     if (!hg_core_rpc_info) {
         HG_LOG_WARNING("Could not find RPC ID in function map");
-        ret = HG_NO_MATCH;
+        ret = HG_NOENTRY;
         goto done;
     }
 
-    if (!hg_core_rpc_info->rpc_cb) {
-        HG_LOG_ERROR("No RPC callback registered");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_rpc_info->rpc_cb == NULL, done, ret,
+        HG_INVALID_ARG, "No RPC callback registered");
 
     /* Cache RPC info */
     hg_core_handle->core_handle.rpc_info = hg_core_rpc_info;
@@ -2720,10 +2594,7 @@ hg_core_process(struct hg_core_private_handle *hg_core_handle)
 
     /* Execute RPC callback */
     ret = hg_core_rpc_info->rpc_cb((hg_core_handle_t) hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error while executing RPC callback");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error while executing RPC callback");
 
 done:
     return ret;
@@ -2732,22 +2603,17 @@ done:
 /*---------------------------------------------------------------------------*/
 static HG_INLINE hg_return_t
 hg_core_complete_na(struct hg_core_private_handle *hg_core_handle,
-    na_op_id_t *op_id, hg_bool_t *completed)
+    hg_bool_t *completed)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    /* Reset op ID value */
-    if (!hg_core_handle->na_op_id_mine)
-        *op_id = NA_OP_ID_NULL;
-
     /* Add handle to completion queue when expected operations have completed */
     if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
         == (hg_util_int32_t) hg_core_handle->na_op_count && *completed) {
         /* Mark as completed */
-        if (hg_core_complete((hg_core_handle_t) hg_core_handle) != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
+        ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
+        HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
+
         /* Increment number of entries added to completion queue */
         *completed = HG_TRUE;
     } else
@@ -2773,10 +2639,8 @@ hg_core_complete(hg_core_handle_t handle)
 
     ret = hg_core_completion_add(context, hg_completion_entry,
         hg_core_handle->is_self);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not add HG completion entry to completion queue");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret,
+        "Could not add HG completion entry to completion queue");
 
 done:
     return ret;
@@ -2817,15 +2681,17 @@ hg_core_completion_add(struct hg_core_context *context,
 
 #ifdef HG_HAS_SELF_FORWARD
     /* TODO could prevent from self notifying if hg_poll_wait() not entered */
-    if (self_notify && private_context->completion_queue_notify
-        && hg_event_set(private_context->completion_queue_notify) != HG_UTIL_SUCCESS) {
-        HG_LOG_ERROR("Could not signal completion queue");
-        ret = HG_PROTOCOL_ERROR;
+    if (!(HG_CORE_CONTEXT_CLASS(private_context)->progress_mode & NA_NO_BLOCK)
+        && self_notify && private_context->completion_queue_notify) {
+        int rc = hg_event_set(private_context->completion_queue_notify);
+        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_FAULT,
+            "Could not signal completion queue");
     }
 #else
     (void) self_notify;
 #endif
 
+done:
     return ret;
 }
 
@@ -2843,32 +2709,27 @@ hg_core_context_post(struct hg_core_private_context *context,
         struct hg_core_private_addr *hg_core_addr = NULL;
 
         /* Create a new handle */
+        // TODO
         hg_core_handle = hg_core_create(context, use_sm);
-        if (!hg_core_handle) {
-            HG_LOG_ERROR("Could not create HG core handle");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_core_handle == NULL, error, ret, HG_NOMEM,
+            "Could not create HG core handle");
 
         /* Execute class callback on handle, this allows upper layers to
          * allocate private data on handle creation */
         if (context->handle_create) {
             ret = context->handle_create((hg_core_handle_t) hg_core_handle,
                 context->handle_create_arg);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Error in HG core handle create callback");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(error, ret,
+                "Error in HG core handle create callback");
         }
 
         /* Create internal addresses */
+        // TODO
         hg_core_addr = hg_core_addr_create(HG_CORE_CONTEXT_CLASS(context),
             hg_core_handle->na_class);
-        if (!hg_core_addr) {
-            HG_LOG_ERROR("Could not create HG addr");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_core_addr == NULL, error, ret, HG_NOMEM,
+            "Could not create HG addr");
+
         /* To safely repost handle and prevent externally referenced address */
         hg_core_addr->is_mine = HG_TRUE;
         hg_core_handle->core_handle.info.addr = (hg_core_addr_t) hg_core_addr;
@@ -2877,13 +2738,13 @@ hg_core_context_post(struct hg_core_private_context *context,
         hg_core_handle->repost = repost;
 
         ret = hg_core_post(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Cannot post handle");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Cannot post handle");
     }
 
-done:
+    return ret;
+
+error:
+    /* TODO */
     return ret;
 }
 
@@ -2901,12 +2762,12 @@ hg_core_post(struct hg_core_private_handle *hg_core_handle)
     if (hg_core_handle->na_class ==
         hg_core_handle->core_handle.info.core_class->na_sm_class) {
         hg_thread_spin_lock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
         HG_LIST_INSERT_HEAD(
             &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list,
             hg_core_handle, pending);
         hg_thread_spin_unlock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
     } else {
 #endif
         hg_thread_spin_lock(
@@ -2926,13 +2787,19 @@ hg_core_post(struct hg_core_private_handle *hg_core_handle)
         hg_core_handle->core_handle.in_buf,
         hg_core_handle->core_handle.in_buf_size,
         hg_core_handle->in_buf_plugin_data, &hg_core_handle->na_recv_op_id);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not post unexpected recv for input buffer");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not post unexpected recv for input buffer (%s)",
+        NA_Error_to_string(na_ret));
 
-done:
+    return ret;
+
+error:
+    hg_thread_spin_lock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+    HG_LIST_REMOVE(hg_core_handle, pending);
+    hg_thread_spin_unlock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+    hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
     return ret;
 }
 
@@ -2954,10 +2821,7 @@ hg_core_reset_post(struct hg_core_private_handle *hg_core_handle)
 
     /* Safe to repost */
     ret = hg_core_post(hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Cannot post handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Cannot post handle");
 
 done:
     return ret;
@@ -2972,15 +2836,15 @@ hg_core_completion_queue_notify_cb(void *arg,
     struct hg_core_private_context *context =
         (struct hg_core_private_context *) arg;
     hg_util_bool_t notified = HG_UTIL_FALSE;
-    int ret = HG_UTIL_SUCCESS;
+    int rc = HG_UTIL_SUCCESS;
 
-    /* TODO could prevent from self notifying if hg_poll_wait() not entered */
-    if (hg_event_get(context->completion_queue_notify,
-        &notified) != HG_UTIL_SUCCESS) {
-        HG_LOG_ERROR("Could not get completion notification");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
+    if (!(HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK)) {
+        /* TODO could prevent from self notifying if hg_poll_wait() not entered */
+        rc = hg_event_get(context->completion_queue_notify, &notified);
+        HG_CHECK_ERROR_NORET(rc != HG_UTIL_SUCCESS, done,
+            "Could not get completion notification");
     }
+
     if (notified || !hg_atomic_queue_is_empty(context->completion_queue)
         || hg_atomic_get32(&context->backfill_queue_count)) {
         *progressed = HG_UTIL_TRUE; /* Progressed */
@@ -2990,7 +2854,7 @@ hg_core_completion_queue_notify_cb(void *arg,
     *progressed = HG_UTIL_FALSE;
 
 done:
-    return ret;
+    return rc;
 }
 #endif
 
@@ -3002,24 +2866,21 @@ hg_core_progress_na_cb(void *arg, int HG_UNUSED error,
     struct hg_core_private_context *context =
         (struct hg_core_private_context *) arg;
      unsigned int actual_count = 0;
-    na_return_t na_ret;
     unsigned int completed_count = 0;
     int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
-    int ret = HG_UTIL_SUCCESS;
+    int rc = HG_UTIL_SUCCESS;
+    na_return_t na_ret;
 
     /* Check progress on NA (no need to call try_wait here) */
     na_ret = NA_Progress(HG_CORE_CONTEXT_CLASS(context)->core_class.na_class,
         context->core_context.na_context, 0);
-    if (na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT) {
-        HG_LOG_ERROR("Could not make progress on NA");
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-    if (na_ret != NA_SUCCESS) {
+    if (na_ret == NA_TIMEOUT) {
         /* Nothing progressed */
         *progressed = HG_UTIL_FALSE;
         goto done;
-    }
+    } else
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, rc, HG_UTIL_FAIL,
+            "Could not make progress on NA (%s)", NA_Error_to_string(na_ret));
 
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
@@ -3033,6 +2894,9 @@ hg_core_progress_na_cb(void *arg, int HG_UNUSED error,
         for (i = 0; i < actual_count; i++)
             completed_count += (unsigned int) cb_ret[i];
     } while ((na_ret == NA_SUCCESS) && actual_count);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, rc,
+        HG_UTIL_FAIL, "Could not trigger NA callback (%s)",
+        NA_Error_to_string(na_ret));
 
     /* We can't only verify that the completion queue is not empty, we need
      * to check what was added to the completion queue, as the completion queue
@@ -3047,7 +2911,7 @@ hg_core_progress_na_cb(void *arg, int HG_UNUSED error,
     *progressed = HG_UTIL_TRUE;
 
 done:
-    return ret;
+    return rc;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3059,24 +2923,22 @@ hg_core_progress_na_sm_cb(void *arg, int HG_UNUSED error,
     struct hg_core_private_context *context =
         (struct hg_core_private_context *) arg;
     unsigned int actual_count = 0;
-    na_return_t na_ret;
     unsigned int completed_count = 0;
     int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
-    int ret = HG_UTIL_SUCCESS;
+    int rc = HG_UTIL_SUCCESS;
+    na_return_t na_ret;
 
     /* Check progress on NA SM (no need to call try_wait here) */
     na_ret = NA_Progress(HG_CORE_CONTEXT_CLASS(context)->core_class.na_sm_class,
         context->core_context.na_sm_context, 0);
-    if (na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT) {
-        HG_LOG_ERROR("Could not make progress on NA SM");
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-    if (na_ret != NA_SUCCESS) {
+    if (na_ret == NA_TIMEOUT) {
         /* Nothing progressed */
         *progressed = HG_UTIL_FALSE;
         goto done;
-    }
+    } else
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, rc, HG_UTIL_FAIL,
+            "Could not make progress on NA SM (%s)",
+            NA_Error_to_string(na_ret));
 
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
@@ -3090,6 +2952,9 @@ hg_core_progress_na_sm_cb(void *arg, int HG_UNUSED error,
         for (i = 0; i < actual_count; i++)
             completed_count += (unsigned int)cb_ret[i];
     } while ((na_ret == NA_SUCCESS) && actual_count);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, rc,
+        HG_UTIL_FAIL, "Could not trigger NA SM callback (%s)",
+        NA_Error_to_string(na_ret));
 
     /* We can't only verify that the completion queue is not empty, we need
      * to check what was added to the completion queue, as the completion queue
@@ -3104,7 +2969,7 @@ hg_core_progress_na_sm_cb(void *arg, int HG_UNUSED error,
     *progressed = HG_UTIL_TRUE;
 
 done:
-    return ret;
+    return rc;
 }
 #endif
 
@@ -3113,17 +2978,9 @@ static hg_return_t
 hg_core_progress_na(struct hg_core_private_context *context,
     unsigned int timeout)
 {
-    double remaining;
+    double remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
     hg_return_t ret = HG_TIMEOUT;
 
-    /* Do not block if NA_NO_BLOCK option is passed */
-    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
-        timeout = 0;
-        remaining = 0;
-    } else {
-        remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
-    }
-
     for (;;) {
         unsigned int actual_count = 0;
         int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
@@ -3144,6 +3001,9 @@ hg_core_progress_na(struct hg_core_private_context *context,
             for (i = 0; i < actual_count; i++)
                 completed_count += (unsigned int)cb_ret[i];
         } while ((na_ret == NA_SUCCESS) && actual_count);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
+            (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
+            NA_Error_to_string(na_ret));
 
         /* We can't only verify that the completion queue is not empty, we need
          * to check what was added to the completion queue, as the completion
@@ -3179,16 +3039,14 @@ hg_core_progress_na(struct hg_core_private_context *context,
             remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
         }
 
-        if (na_ret == NA_SUCCESS) {
-            /* Trigger NA callbacks and check whether we completed something */
+        /* Trigger NA callbacks and check whether we completed something */
+        if (na_ret == NA_SUCCESS)
             continue;
-        } else if (na_ret == NA_TIMEOUT) {
+        else if (na_ret == NA_TIMEOUT && (remaining <= 0))
             break;
-        } else {
-            HG_LOG_ERROR("Could not make NA Progress");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        else if (na_ret != NA_TIMEOUT)
+            HG_GOTO_ERROR(done, ret, (hg_return_t) na_ret,
+                "Could not make NA Progress (%s)", NA_Error_to_string(na_ret));
     }
 
 done:
@@ -3203,7 +3061,7 @@ hg_core_poll_try_wait_cb(void *arg)
         (struct hg_core_private_context *) arg;
 
     /* Do not try to wait if NA_NO_BLOCK is set */
-    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK)
         return NA_FALSE;
 
     /* Something is in one of the completion queues */
@@ -3231,31 +3089,24 @@ static hg_return_t
 hg_core_progress_poll(struct hg_core_private_context *context,
     unsigned int timeout)
 {
-    double remaining;
+    double remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
     hg_return_t ret = HG_TIMEOUT;
 
-    /* Do not block if NA_NO_BLOCK option is passed */
-    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
-        timeout = 0;
-        remaining = 0;
-    } else {
-        remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
-    }
-
     do {
         hg_time_t t1, t2;
         hg_util_bool_t progressed;
+        unsigned int poll_timeout =
+            (HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK) ? 0 :
+            (unsigned int) (remaining * 1000.0);
+        int rc;
 
         if (timeout)
             hg_time_get_current(&t1);
 
         /* Will call hg_core_poll_try_wait_cb if timeout is not 0 */
-        if (hg_poll_wait(context->poll_set, (unsigned int)(remaining * 1000.0),
-            &progressed) != HG_UTIL_SUCCESS) {
-            HG_LOG_ERROR("hg_poll_wait() failed");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_poll_wait(context->poll_set, poll_timeout, &progressed);
+        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_PROTOCOL_ERROR,
+            "hg_poll_wait() failed");
 
         /* We progressed, return success */
         if (progressed) {
@@ -3278,18 +3129,10 @@ static hg_return_t
 hg_core_trigger(struct hg_core_private_context *context, unsigned int timeout,
     unsigned int max_count, unsigned int *actual_count)
 {
-    double remaining;
+    double remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
     unsigned int count = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    /* Do not block if NA_NO_BLOCK option is passed */
-    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
-        timeout = 0;
-        remaining = 0;
-    } else {
-        remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
-    }
-
     while (count < max_count) {
         struct hg_completion_entry *hg_completion_entry = NULL;
 
@@ -3345,50 +3188,42 @@ hg_core_trigger(struct hg_core_private_context *context, unsigned int timeout,
         }
 
         /* Completion queue should not be empty now */
-        if (!hg_completion_entry) {
-            HG_LOG_ERROR("NULL completion entry");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_completion_entry == NULL, done, ret,
+            HG_FAULT, "NULL completion entry");
 
         /* Trigger entry */
         switch(hg_completion_entry->op_type) {
             case HG_ADDR:
                 ret = hg_core_trigger_lookup_entry(
                     hg_completion_entry->op_id.hg_core_op_id);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not trigger completion entry");
-                    goto done;
-                }
+                HG_CHECK_HG_ERROR(done, ret,
+                    "Could not trigger addr completion entry");
                 break;
             case HG_RPC:
                 ret = hg_core_trigger_entry((struct hg_core_private_handle *)
                     hg_completion_entry->op_id.hg_core_handle);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not trigger completion entry");
-                    goto done;
-                }
+                HG_CHECK_HG_ERROR(done, ret,
+                    "Could not trigger RPC completion entry");
                 break;
             case HG_BULK:
                 ret = hg_bulk_trigger_entry(
                     hg_completion_entry->op_id.hg_bulk_op_id);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not trigger completion entry");
-                    goto done;
-                }
+                HG_CHECK_HG_ERROR(done, ret,
+                    "Could not trigger bulk completion entry");
                 break;
             default:
-                HG_LOG_ERROR("Invalid type of completion entry");
-                ret = HG_PROTOCOL_ERROR;
-                goto done;
+                HG_GOTO_ERROR(done, ret, HG_INVALID_ARG,
+                    "Invalid type of completion entry (%d)",
+                    (int) hg_completion_entry->op_type);
         }
 
         count++;
     }
 
-done:
-    if ((ret == HG_SUCCESS || ret == HG_TIMEOUT) && actual_count)
+    if (actual_count)
         *actual_count = count;
+
+done:
     return ret;
 }
 
@@ -3398,8 +3233,17 @@ hg_core_trigger_lookup_entry(struct hg_core_op_id *hg_core_op_id)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    /* Execute callback */
-    if (hg_core_op_id->callback) {
+    /* Free op */
+    if (hg_core_op_id->info.lookup.na_lookup_op_id != NA_OP_ID_NULL) {
+        na_return_t na_ret = NA_Op_destroy(
+            hg_core_op_id->info.lookup.hg_core_addr->core_addr.na_class,
+            hg_core_op_id->info.lookup.na_lookup_op_id);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not destroy addr op ID (%s)", NA_Error_to_string(na_ret));
+    }
+
+    /* Execute callback */
+    if (hg_core_op_id->callback) {
         struct hg_core_cb_info hg_core_cb_info;
 
         hg_core_cb_info.arg = hg_core_op_id->arg;
@@ -3411,7 +3255,7 @@ hg_core_trigger_lookup_entry(struct hg_core_op_id *hg_core_op_id)
         hg_core_op_id->callback(&hg_core_cb_info);
     }
 
-    /* Free op */
+done:
     free(hg_core_op_id);
     return ret;
 }
@@ -3436,19 +3280,13 @@ hg_core_trigger_entry(struct hg_core_private_handle *hg_core_handle)
             hg_core_handle->ret = ret;
             ret = HG_Core_respond((hg_core_handle_t) hg_core_handle, NULL, NULL,
                 0, header_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not respond");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(done, ret, "Could not respond");
         }
 
         /* No response callback */
         if (hg_core_handle->no_response) {
             ret = hg_core_handle->no_respond(hg_core_handle);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not complete handle");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(done, ret, "Could not complete handle");
         }
     } else {
         hg_core_cb_t hg_cb = NULL;
@@ -3491,9 +3329,8 @@ hg_core_trigger_entry(struct hg_core_private_handle *hg_core_handle)
                 break;
             case HG_CORE_PROCESS:
             default:
-                HG_LOG_ERROR("Invalid core operation type");
-                ret = HG_PROTOCOL_ERROR;
-                goto done;
+                HG_GOTO_ERROR(done, ret, HG_OPNOTSUPPORTED,
+                    "Invalid core operation type");
         }
 
         /* Execute user callback */
@@ -3506,10 +3343,7 @@ hg_core_trigger_entry(struct hg_core_private_handle *hg_core_handle)
         && !HG_CORE_HANDLE_CONTEXT(hg_core_handle)->finalizing) {
         /* Repost handle */
         ret = hg_core_reset_post(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Cannot repost handle");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Cannot repost handle");
     } else
         hg_core_destroy(hg_core_handle);
 
@@ -3523,54 +3357,30 @@ hg_core_cancel(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (hg_core_handle->is_self) {
-        HG_LOG_ERROR("Local cancelation is not supported");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->is_self, done, ret, HG_OPNOTSUPPORTED,
+        "Local cancellation is not supported");
 
     /* Cancel all NA operations issued */
     if (hg_core_handle->na_recv_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret;
-
-        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-            hg_core_handle->na_recv_op_id);
-        if (na_ret == NA_CANCEL_ERROR)
-            ret = HG_CANCEL_ERROR;
-        else if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel recv op id");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        na_return_t na_ret = NA_Cancel(hg_core_handle->na_class,
+            hg_core_handle->na_context, hg_core_handle->na_recv_op_id);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not cancel recv op id (%s)", NA_Error_to_string(na_ret));
     }
 
     if (hg_core_handle->na_send_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret;
-
-        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-            hg_core_handle->na_send_op_id);
-        if (na_ret == NA_CANCEL_ERROR)
-            ret = HG_CANCEL_ERROR;
-        else if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel send op id");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        na_return_t na_ret = NA_Cancel(hg_core_handle->na_class,
+            hg_core_handle->na_context, hg_core_handle->na_send_op_id);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not cancel send op id (%s)", NA_Error_to_string(na_ret));
     }
 
-    /* TODO
     if (hg_core_handle->na_ack_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret;
-
-        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-            hg_core_handle->na_ack_op_id);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel ack op id");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        na_return_t na_ret = NA_Cancel(hg_core_handle->na_class,
+            hg_core_handle->na_context, hg_core_handle->na_ack_op_id);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not cancel ack op id (%s)", NA_Error_to_string(na_ret));
     }
-    */
 
 done:
     return ret;
@@ -3589,19 +3399,12 @@ HG_Core_init_opt(const char *na_info_string, hg_bool_t na_listen,
     const struct hg_init_info *hg_init_info)
 {
     struct hg_core_private_class *hg_core_class = NULL;
-    hg_return_t ret = HG_SUCCESS;
 
     hg_core_class = hg_core_init(na_info_string, na_listen, hg_init_info);
-    if (!hg_core_class) {
-        HG_LOG_ERROR("Cannot initialize HG core layer");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_class == NULL, done,
+        "Cannot initialize HG core layer");
 
 done:
-    if (ret != HG_SUCCESS) {
-        /* Nothing */
-    }
     return (hg_core_class_t *) hg_core_class;
 }
 
@@ -3609,13 +3412,10 @@ done:
 hg_return_t
 HG_Core_finalize(hg_core_class_t *hg_core_class)
 {
-    hg_return_t ret = HG_SUCCESS;
+    hg_return_t ret;
 
     ret = hg_core_finalize((struct hg_core_private_class *) hg_core_class);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Cannot finalize HG core layer");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Cannot finalize HG core layer");
 
 done:
     return ret;
@@ -3639,11 +3439,8 @@ HG_Core_set_more_data_callback(struct hg_core_class *hg_core_class,
         (struct hg_core_private_class *) hg_core_class;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
 
     private_class->more_data_acquire = more_data_acquire_callback;
     private_class->more_data_release = more_data_release_callback;
@@ -3663,35 +3460,26 @@ HG_Core_context_create(hg_core_class_t *hg_core_class)
 hg_core_context_t *
 HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
 {
-    hg_return_t ret = HG_SUCCESS;
     struct hg_core_private_context *context = NULL;
     int na_poll_fd;
 #ifdef HG_HAS_SELF_FORWARD
     int fd;
 #endif
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_class == NULL, error, "NULL HG core class");
 
     context = (struct hg_core_private_context *) malloc(
         sizeof(struct hg_core_private_context));
-    if (!context) {
-        HG_LOG_ERROR("Could not allocate HG context");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(context == NULL, error,
+        "Could not allocate HG context");
+
     memset(context, 0, sizeof(struct hg_core_private_context));
     context->core_context.core_class = hg_core_class;
     context->completion_queue =
         hg_atomic_queue_alloc(HG_CORE_ATOMIC_QUEUE_SIZE);
-    if (!context->completion_queue) {
-        HG_LOG_ERROR("Could not allocate queue");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(context->completion_queue == NULL, error,
+        "Could not allocate queue");
+
     HG_QUEUE_INIT(&context->backfill_queue);
     hg_atomic_init32(&context->backfill_queue_count, 0);
     HG_LIST_INIT(&context->pending_list);
@@ -3709,46 +3497,31 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
     hg_atomic_init32(&context->trigger_waiting, 0);
 
     hg_thread_spin_init(&context->pending_list_lock);
-#ifdef HG_HAS_SM_ROUTING
-    hg_thread_spin_init(&context->sm_pending_list_lock);
-#endif
     hg_thread_spin_init(&context->created_list_lock);
 
     context->core_context.na_context = NA_Context_create_id(
         hg_core_class->na_class, id);
-    if (!context->core_context.na_context) {
-        HG_LOG_ERROR("Could not create NA context");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(context->core_context.na_context == NULL, error,
+        "Could not create NA context");
+
 #ifdef HG_HAS_SM_ROUTING
     if (hg_core_class->na_sm_class) {
         context->core_context.na_sm_context = NA_Context_create(
             hg_core_class->na_sm_class);
-        if (!context->core_context.na_sm_context) {
-            HG_LOG_ERROR("Could not create NA SM context");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR_NORET(context->core_context.na_sm_context == NULL, error,
+            "Could not create NA SM context");
     }
 #endif
 
     /* Create poll set */
     context->poll_set = hg_poll_create();
-    if (!context->poll_set) {
-        HG_LOG_ERROR("Could not create poll set");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(context->poll_set == NULL, error,
+        "Could not create poll set");
 
 #ifdef HG_HAS_SELF_FORWARD
     /* Create event for completion queue notification */
     fd = hg_event_create();
-    if (fd < 0) {
-        HG_LOG_ERROR("Could not create event");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(fd < 0, error, "Could not create event");
     context->completion_queue_notify = fd;
 
     /* Add event to context poll set */
@@ -3756,7 +3529,7 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
         hg_core_completion_queue_notify_cb, context);
 #endif
 
-    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK)
         /* Force to use progress poll */
         na_poll_fd = 0;
     else
@@ -3776,22 +3549,17 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
 #ifdef HG_HAS_SM_ROUTING
     /* Auto SM requires hg_core_progress_poll */
     if (context->core_context.na_sm_context) {
-        if (context->progress != hg_core_progress_poll) {
-            HG_LOG_ERROR("Auto SM mode not supported with selected plugin");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
-        if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
+        HG_CHECK_ERROR_NORET(context->progress != hg_core_progress_poll, error,
+            "Auto SM mode not supported with selected plugin");
+
+        if (HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK)
             /* Force to use progress poll */
             na_poll_fd = 0;
         else {
             na_poll_fd = NA_Poll_get_fd(hg_core_class->na_sm_class,
                 context->core_context.na_sm_context);
-            if (na_poll_fd < 0) {
-                HG_LOG_ERROR("Could not get NA SM poll fd");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR_NORET(na_poll_fd < 0, error,
+                "Could not get NA SM poll fd");
         }
         hg_poll_add(context->poll_set, na_poll_fd, HG_POLLIN,
             hg_core_progress_na_sm_cb, context);
@@ -3804,12 +3572,11 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
     /* Increment context count of parent class */
     hg_atomic_incr32(&HG_CORE_CONTEXT_CLASS(context)->n_contexts);
 
-done:
-    if (ret != HG_SUCCESS && context) {
-        HG_Core_context_destroy((hg_core_context_t *) context);
-        context = NULL;
-    }
     return (hg_core_context_t *) context;
+
+error:
+    HG_Core_context_destroy((hg_core_context_t *) context);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3818,41 +3585,32 @@ HG_Core_context_destroy(hg_core_context_t *context)
 {
     struct hg_core_private_context *private_context =
         (struct hg_core_private_context *) context;
-    na_return_t na_ret;
-    hg_return_t ret = HG_SUCCESS;
     unsigned int actual_count;
     int na_poll_fd;
     hg_util_int32_t n_handles;
+    hg_bool_t empty;
+    na_return_t na_ret;
+    hg_return_t ret = HG_SUCCESS;
+    int rc;
 
-    if (!context) goto done;
+    if (!context)
+        goto done;
 
     /* Prevent repost of handles */
     private_context->finalizing = HG_TRUE;
 
     /* Check pending list and cancel posted handles */
-    if (!HG_LIST_IS_EMPTY(&private_context->pending_list)) {
-        ret = hg_core_pending_list_cancel(private_context);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Cannot cancel list of pending entries");
-            goto done;
-        }
-    }
-#ifdef HG_HAS_SM_ROUTING
-    /* Check pending list and cancel posted handles */
-    if (!HG_LIST_IS_EMPTY(&private_context->sm_pending_list)) {
-        ret = hg_core_sm_pending_list_cancel(private_context);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Cannot cancel list of SM pending entries");
-            goto done;
-        }
-    }
-#endif
+    ret = hg_core_pending_list_cancel(private_context);
+    HG_CHECK_HG_ERROR(done, ret, "Cannot cancel list of pending entries");
 
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
     do {
         na_ret = NA_Trigger(context->na_context, 0, 1, NULL, &actual_count);
     } while ((na_ret == NA_SUCCESS) && actual_count);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
+        (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
+        NA_Error_to_string(na_ret));
 
 #ifdef HG_HAS_SM_ROUTING
     if (context->na_sm_context) {
@@ -3860,15 +3618,15 @@ HG_Core_context_destroy(hg_core_context_t *context)
             na_ret = NA_Trigger(context->na_sm_context, 0, 1, NULL,
                 &actual_count);
         } while ((na_ret == NA_SUCCESS) && actual_count);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
+            (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
+            NA_Error_to_string(na_ret));
     }
 #endif
 
     /* Check that operations have completed */
-    ret = hg_core_created_list_wait(private_context);
-    if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
-        HG_LOG_ERROR("Could not wait on HG core handle list");
-        goto done;
-    }
+    ret = hg_core_context_lists_wait(private_context);
+    HG_CHECK_HG_ERROR(done, ret, "Could not wait on HG core handle list");
 
     /* Number of handles for that context should be 0 */
     n_handles = hg_atomic_get32(&private_context->n_handles);
@@ -3882,101 +3640,85 @@ HG_Core_context_destroy(hg_core_context_t *context)
                 hg_core_handle);
         }
         hg_thread_spin_unlock(&private_context->created_list_lock);
-        ret = HG_PROTOCOL_ERROR;
+        ret = HG_BUSY;
         goto done;
     }
 
     /* Check that completion queue is empty now */
-    if (!hg_atomic_queue_is_empty(private_context->completion_queue)) {
-        HG_LOG_ERROR("Completion queue should be empty");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(!hg_atomic_queue_is_empty(private_context->completion_queue),
+        done, ret, HG_BUSY, "Completion queue should be empty");
     hg_atomic_queue_free(private_context->completion_queue);
 
     /* Check that completion queue is empty now */
     hg_thread_mutex_lock(&private_context->completion_queue_mutex);
-    if (!HG_QUEUE_IS_EMPTY(&private_context->backfill_queue)) {
-        HG_LOG_ERROR("Completion queue should be empty");
-        ret = HG_PROTOCOL_ERROR;
-        hg_thread_mutex_unlock(&private_context->completion_queue_mutex);
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&private_context->backfill_queue);
     hg_thread_mutex_unlock(&private_context->completion_queue_mutex);
+    HG_CHECK_ERROR(!empty, done, ret, HG_BUSY,
+        "Completion queue should be empty");
 
 #ifdef HG_HAS_SELF_FORWARD
     if (private_context->completion_queue_notify > 0) {
-        if (hg_poll_remove(private_context->poll_set,
-            private_context->completion_queue_notify) != HG_UTIL_SUCCESS) {
-            HG_LOG_ERROR("Could not remove self processing event from poll set");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
-        if (hg_event_destroy(private_context->completion_queue_notify)
-            != HG_UTIL_SUCCESS) {
-            HG_LOG_ERROR("Could not destroy self processing event");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_poll_remove(private_context->poll_set,
+            private_context->completion_queue_notify);
+        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
+            "Could not remove self processing event from poll set");
+
+        rc = hg_event_destroy(private_context->completion_queue_notify);
+        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
+            "Could not destroy self processing event");
     }
 #endif
 
-    if (HG_CORE_CONTEXT_CLASS(private_context)->progress_mode == NA_NO_BLOCK)
+    if (HG_CORE_CONTEXT_CLASS(private_context)->progress_mode & NA_NO_BLOCK)
         /* Was forced to use progress poll */
         na_poll_fd = 0;
     else
         /* If NA plugin exposes fd, remove it from poll set */
         na_poll_fd = NA_Poll_get_fd(context->core_class->na_class,
             context->na_context);
-    if ((na_poll_fd >= 0)
-        && hg_poll_remove(private_context->poll_set, na_poll_fd)
-        != HG_UTIL_SUCCESS) {
-        HG_LOG_ERROR("Could not remove NA poll descriptor from poll set");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
+    if (na_poll_fd >= 0) {
+        rc = hg_poll_remove(private_context->poll_set, na_poll_fd);
+        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
+            "Could not remove NA poll descriptor from poll set");
     }
 
 #ifdef HG_HAS_SM_ROUTING
     if (context->na_sm_context) {
-        if (HG_CORE_CONTEXT_CLASS(private_context)->progress_mode == NA_NO_BLOCK)
+        if (HG_CORE_CONTEXT_CLASS(private_context)->progress_mode & NA_NO_BLOCK)
             /* Was forced to use progress poll */
             na_poll_fd = 0;
         else
             /* If NA plugin exposes fd, remove it from poll set */
             na_poll_fd = NA_Poll_get_fd(context->core_class->na_sm_class,
                 context->na_sm_context);
-        if ((na_poll_fd >= 0)
-            && hg_poll_remove(private_context->poll_set, na_poll_fd)
-            != HG_UTIL_SUCCESS) {
-            HG_LOG_ERROR("Could not remove NA poll descriptor from poll set");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
+        if (na_poll_fd >= 0) {
+            rc = hg_poll_remove(private_context->poll_set, na_poll_fd);
+            HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
+                "Could not remove NA poll descriptor from poll set");
         }
     }
 #endif
 
     /* Destroy poll set */
-    if (hg_poll_destroy(private_context->poll_set) != HG_UTIL_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy poll set");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_poll_destroy(private_context->poll_set);
+    HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_FAULT,
+        "Could not destroy poll set");
 
     /* Destroy NA context */
-    if (context->na_context && NA_Context_destroy(context->core_class->na_class,
-            context->na_context) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy NA context");
-        ret = HG_NA_ERROR;
-        goto done;
+    if (context->na_context) {
+        na_ret = NA_Context_destroy(context->core_class->na_class,
+            context->na_context);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not destroy NA context (%s)", NA_Error_to_string(na_ret));
     }
 
 #ifdef HG_HAS_SM_ROUTING
     /* Destroy NA SM context */
-    if (context->na_sm_context && NA_Context_destroy(
-        context->core_class->na_sm_class, context->na_sm_context) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy NA SM context");
-        ret = HG_NA_ERROR;
-        goto done;
+    if (context->na_sm_context) {
+        na_ret = NA_Context_destroy(context->core_class->na_sm_class,
+            context->na_sm_context);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not destroy NA SM context");
     }
 #endif
 
@@ -3988,9 +3730,6 @@ HG_Core_context_destroy(hg_core_context_t *context)
     hg_thread_mutex_destroy(&private_context->completion_queue_mutex);
     hg_thread_cond_destroy(&private_context->completion_queue_cond);
     hg_thread_spin_destroy(&private_context->pending_list_lock);
-#ifdef HG_HAS_SM_ROUTING
-    hg_thread_spin_destroy(&private_context->sm_pending_list_lock);
-#endif
     hg_thread_spin_destroy(&private_context->created_list_lock);
 
     /* Decrement context count of parent class */
@@ -4011,11 +3750,8 @@ HG_Core_context_set_handle_create_callback(hg_core_context_t *context,
         (struct hg_core_private_context *) context;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core context");
 
     private_context->handle_create = callback;
     private_context->handle_create_arg = arg;
@@ -4032,26 +3768,18 @@ HG_Core_context_post(hg_core_context_t *context, unsigned int request_count,
     hg_bool_t use_sm = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!request_count) {
-        HG_LOG_ERROR("Request count must be greater than 0");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core context");
+    HG_CHECK_ERROR(request_count == 0, done, ret, HG_INVALID_ARG,
+        "Request count must be greater than 0");
 
 #ifdef HG_HAS_SM_ROUTING
     do {
 #endif
         ret = hg_core_context_post((struct hg_core_private_context *) context,
             request_count, repost, use_sm);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not post requests on context");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not post requests on context");
+
 #ifdef HG_HAS_SM_ROUTING
         if (context->na_sm_context)
             use_sm = !use_sm;
@@ -4074,11 +3802,8 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
     hg_return_t ret = HG_SUCCESS;
     int hash_ret;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, error, ret, HG_INVALID_ARG,
+        "NULL HG core class");
 
     /* Check if registered and set RPC CB */
     hg_thread_spin_lock(&private_class->func_map_lock);
@@ -4091,21 +3816,15 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
     if (!hg_core_rpc_info) {
         /* Allocate the key */
         func_key = (hg_id_t *) malloc(sizeof(hg_id_t));
-        if (!func_key) {
-            HG_LOG_ERROR("Could not allocate ID");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(func_key == NULL, error, ret, HG_NOMEM,
+            "Could not allocate ID key");
         *func_key = id;
 
         /* Fill info and store it into the function map */
         hg_core_rpc_info = (struct hg_core_rpc_info *) malloc(
             sizeof(struct hg_core_rpc_info));
-        if (!hg_core_rpc_info) {
-            HG_LOG_ERROR("Could not allocate HG info");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_core_rpc_info == NULL, error, ret, HG_NOMEM,
+            "Could not allocate HG info");
 
         hg_core_rpc_info->rpc_cb = rpc_cb;
         hg_core_rpc_info->data = NULL;
@@ -4115,18 +3834,16 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
         hash_ret = hg_hash_table_insert(private_class->func_map,
             (hg_hash_table_key_t) func_key, hg_core_rpc_info);
         hg_thread_spin_unlock(&private_class->func_map_lock);
-        if (!hash_ret) {
-            HG_LOG_ERROR("Could not insert RPC ID into function map (already registered?)");
-            ret = HG_INVALID_PARAM;
-            goto done;
-        }
+        HG_CHECK_ERROR(hash_ret == 0, error, ret, HG_INVALID_ARG,
+            "Could not insert RPC ID into function map (already registered?)");
     }
 
-done:
-    if (ret != HG_SUCCESS) {
-        free(func_key);
-        free(hg_core_rpc_info);
-    }
+    return ret;
+
+error:
+    free(func_key);
+    free(hg_core_rpc_info);
+
     return ret;
 }
 
@@ -4139,21 +3856,15 @@ HG_Core_deregister(hg_core_class_t *hg_core_class, hg_id_t id)
     hg_return_t ret = HG_SUCCESS;
     int hash_ret;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     hash_ret = hg_hash_table_remove(private_class->func_map,
         (hg_hash_table_key_t) &id);
     hg_thread_spin_unlock(&private_class->func_map_lock);
-    if (!hash_ret) {
-        HG_LOG_ERROR("Could not deregister RPC ID from function map");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hash_ret == 0, done, ret, HG_NOENTRY,
+        "Could not deregister RPC ID from function map");
 
 done:
     return ret;
@@ -4167,16 +3878,10 @@ HG_Core_registered(hg_core_class_t *hg_core_class, hg_id_t id, hg_bool_t *flag)
         (struct hg_core_private_class *) hg_core_class;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!flag) {
-        HG_LOG_ERROR("NULL flag");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+    HG_CHECK_ERROR(flag == NULL, done, ret, HG_INVALID_ARG,
+        "NULL flag");
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     *flag = (hg_bool_t) (hg_hash_table_lookup(private_class->func_map,
@@ -4197,24 +3902,18 @@ HG_Core_register_data(hg_core_class_t *hg_core_class, hg_id_t id, void *data,
     struct hg_core_rpc_info *hg_core_rpc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
         private_class->func_map, (hg_hash_table_key_t) &id);
     hg_thread_spin_unlock(&private_class->func_map_lock);
-    if (!hg_core_rpc_info) {
-        HG_LOG_ERROR("Could not find RPC ID in function map");
-        ret = HG_NO_MATCH;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_rpc_info == NULL, done, ret, HG_NOENTRY,
+        "Could not find RPC ID in function map");
 
-    if (hg_core_rpc_info->data)
-        HG_LOG_WARNING("Overriding data previously registered");
+    HG_CHECK_WARNING(hg_core_rpc_info->data,
+        "Overriding data previously registered");
     hg_core_rpc_info->data = data;
     hg_core_rpc_info->free_callback = free_callback;
 
@@ -4231,19 +3930,14 @@ HG_Core_registered_data(hg_core_class_t *hg_core_class, hg_id_t id)
     struct hg_core_rpc_info *hg_core_rpc_info = NULL;
     void *data = NULL;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_class == NULL, done, "NULL HG core class");
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
         private_class->func_map, (hg_hash_table_key_t) &id);
     hg_thread_spin_unlock(&private_class->func_map_lock);
-    if (!hg_core_rpc_info) {
-        HG_LOG_ERROR("Could not find RPC ID in function map");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_rpc_info == NULL, done,
+        "Could not find RPC ID in function map");
 
     data = hg_core_rpc_info->data;
 
@@ -4258,28 +3952,16 @@ HG_Core_addr_lookup(hg_core_context_t *context, hg_core_cb_t callback,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!callback) {
-        HG_LOG_ERROR("NULL callback");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!name) {
-        HG_LOG_ERROR("NULL lookup name");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core context");
+    HG_CHECK_ERROR(callback == NULL, done, ret, HG_INVALID_ARG,
+        "NULL callback");
+    HG_CHECK_ERROR(name == NULL, done, ret, HG_INVALID_ARG,
+        "NULL lookup");
 
     ret = hg_core_addr_lookup((struct hg_core_private_context *) context,
         callback, arg, name, op_id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not lookup address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not lookup address");
 
 done:
     return ret;
@@ -4291,25 +3973,16 @@ HG_Core_addr_create(hg_core_class_t *hg_core_class, hg_core_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (hg_core_class == NULL) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!addr) {
-        HG_LOG_ERROR("NULL pointer to address");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+    HG_CHECK_ERROR(addr == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to address");
 
     *addr = (hg_core_addr_t) hg_core_addr_create(
         (struct hg_core_private_class *) hg_core_class,
         hg_core_class->na_class);
-    if (*addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("Could not create address");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(*addr == HG_CORE_ADDR_NULL, done, ret, HG_NOMEM,
+        "Could not create address");
 
 done:
     return ret;
@@ -4321,18 +3994,33 @@ HG_Core_addr_free(hg_core_class_t *hg_core_class, hg_core_addr_t addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
 
     ret = hg_core_addr_free((struct hg_core_private_class *) hg_core_class,
         (struct hg_core_private_addr *) addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free address");
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
+HG_Core_addr_set_remove(hg_core_class_t *hg_core_class, hg_core_addr_t addr)
+{
+    struct hg_core_private_addr *hg_core_addr =
+        (struct hg_core_private_addr *) addr;
+    hg_return_t ret = HG_SUCCESS;
+    na_return_t na_ret;
+
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+
+    na_ret = NA_Addr_set_remove(hg_core_addr->core_addr.na_class,
+        hg_core_addr->core_addr.na_addr);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "Could not set address to be removed (%s)", NA_Error_to_string(na_ret));
 
 done:
     return ret;
@@ -4344,23 +4032,14 @@ HG_Core_addr_self(hg_core_class_t *hg_core_class, hg_core_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!addr) {
-        HG_LOG_ERROR("NULL pointer to address");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+    HG_CHECK_ERROR(addr == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to address");
 
     ret = hg_core_addr_self((struct hg_core_private_class *) hg_core_class,
         (struct hg_core_private_addr **) addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get self address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get self address");
 
 done:
     return ret;
@@ -4373,29 +4052,41 @@ HG_Core_addr_dup(hg_core_class_t *hg_core_class, hg_core_addr_t addr,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL addr");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!new_addr) {
-        HG_LOG_ERROR("NULL pointer to destination address");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+    HG_CHECK_ERROR(addr == HG_CORE_ADDR_NULL, done, ret, HG_INVALID_ARG,
+        "NULL addr");
+    HG_CHECK_ERROR(new_addr == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to dup addr");
 
     ret = hg_core_addr_dup((struct hg_core_private_class *) hg_core_class,
         (struct hg_core_private_addr *) addr,
         (struct hg_core_private_addr **) new_addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not duplicate address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not duplicate address");
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_bool_t
+HG_Core_addr_cmp(hg_core_class_t *hg_core_class, hg_core_addr_t addr1,
+    hg_core_addr_t addr2)
+{
+    hg_bool_t ret = HG_FALSE;
+
+    HG_CHECK_ERROR_NORET(hg_core_class == NULL, done, "NULL HG core class");
+
+    if (addr1 == HG_CORE_ADDR_NULL && addr2 == HG_CORE_ADDR_NULL)
+        HG_GOTO_DONE(done, ret, HG_TRUE);
+
+    if (addr1 == HG_CORE_ADDR_NULL || addr2 == HG_CORE_ADDR_NULL)
+        HG_GOTO_DONE(done, ret, HG_FALSE);
+
+    ret = NA_Addr_cmp(
+        ((struct hg_core_private_addr *) addr1)->core_addr.na_class,
+        ((struct hg_core_private_addr *) addr1)->core_addr.na_addr,
+        ((struct hg_core_private_addr *) addr2)->core_addr.na_addr);
 
 done:
     return ret;
@@ -4408,18 +4099,14 @@ HG_Core_addr_to_string(hg_core_class_t *hg_core_class, char *buf,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+    HG_CHECK_ERROR(buf_size == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to buffer size");
 
     ret = hg_core_addr_to_string((struct hg_core_private_class *) hg_core_class,
         buf, buf_size, (struct hg_core_private_addr *) addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not convert address to string");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not convert address to string");
 
 done:
     return ret;
@@ -4438,16 +4125,10 @@ HG_Core_create(hg_core_context_t *context, hg_core_addr_t addr, hg_id_t id,
     hg_bool_t use_sm = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, error, ret, HG_INVALID_ARG,
+        "NULL HG core context");
+    HG_CHECK_ERROR(handle == NULL, error, ret, HG_INVALID_ARG,
+        "NULL pointer to HG core handle");
 
 #ifdef HG_HAS_SM_ROUTING
     if (private_addr
@@ -4457,37 +4138,30 @@ HG_Core_create(hg_core_context_t *context, hg_core_addr_t addr, hg_id_t id,
 
     /* Create new handle */
     hg_core_handle = hg_core_create(private_context, use_sm);
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("Could not create HG core handle");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle == NULL, error, ret, HG_NOMEM,
+        "Could not create HG core handle");
 
     /* Set addr / RPC ID */
     ret = hg_core_set_rpc(hg_core_handle, private_addr, id);
-    if (ret != HG_SUCCESS) {
-        if (ret != HG_NO_MATCH) /* silence error if invalid ID is used */
-            HG_LOG_ERROR("Could not set rpc to handle");
-        goto done;
-    }
+    if (ret == HG_NOENTRY)
+        goto error;
+    HG_CHECK_HG_ERROR(error, ret, "Could not set rpc to handle");
 
     /* Execute class callback on handle, this allows upper layers to
      * allocate private data on handle creation */
     if (private_context->handle_create) {
         ret = private_context->handle_create((hg_core_handle_t) hg_core_handle,
             private_context->handle_create_arg);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Error in HG core handle create callback");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Error in HG handle create callback");
     }
 
     *handle = (hg_core_handle_t) hg_core_handle;
 
-done:
-    if (ret != HG_SUCCESS) {
-        hg_core_destroy(hg_core_handle);
-    }
+    return ret;
+
+error:
+    hg_core_destroy(hg_core_handle);
+
     return ret;
 }
 
@@ -4499,21 +4173,15 @@ HG_Core_destroy(hg_core_handle_t handle)
         (struct hg_core_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        ret = HG_INVALID_PARAM;
+    if (hg_core_handle == NULL)
         goto done;
-    }
 
     /* Repost handle if we were listening, otherwise destroy it */
     if (hg_core_handle->repost
         && !HG_CORE_HANDLE_CONTEXT(hg_core_handle)->finalizing) {
         /* Repost handle */
         ret = hg_core_reset_post(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Cannot repost handle");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Cannot repost handle");
     } else
         hg_core_destroy(hg_core_handle);
 
@@ -4531,36 +4199,26 @@ HG_Core_reset(hg_core_handle_t handle, hg_core_addr_t addr, hg_id_t id)
         (struct hg_core_private_addr *) addr;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG core handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core handle");
+
     /* Not safe to reset
      * TODO could add the ability to defer the reset operation */
-    if (hg_atomic_get32(&hg_core_handle->in_use)) {
-        HG_LOG_ERROR("Cannot reset HG core handle, handle is still in use, "
-            "refcount: %d",
-            hg_atomic_get32(&hg_core_handle->ref_count));
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_atomic_get32(&hg_core_handle->in_use), done, ret,
+        HG_BUSY, "Cannot reset HG core handle, still in use, "
+            "refcount: %d", hg_atomic_get32(&hg_core_handle->ref_count));
 
 #ifdef HG_HAS_SM_ROUTING
     if (hg_core_addr
         && (hg_core_addr->core_addr.na_class != hg_core_handle->na_class)) {
         struct hg_core_private_context *private_context =
             (struct hg_core_private_context *) hg_core_handle->core_handle.info.context;
-        hg_bool_t use_sm =
-            (private_context->core_context.core_class->na_sm_class
-                == hg_core_addr->core_addr.na_class);
+        hg_bool_t use_sm = (private_context->core_context.core_class->na_sm_class
+            == hg_core_addr->core_addr.na_class);
         /* In that case, we must free and re-allocate NA resources */
         hg_core_free_na(hg_core_handle);
         ret = hg_core_alloc_na(hg_core_handle, use_sm);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not re-allocate handle NA resources");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not re-allocate NA resources");
     }
 #endif
 
@@ -4569,9 +4227,9 @@ HG_Core_reset(hg_core_handle_t handle, hg_core_addr_t addr, hg_id_t id)
 
     /* Set addr / RPC ID */
     ret = hg_core_set_rpc(hg_core_handle, hg_core_addr, id);
-    if (ret != HG_SUCCESS) {
+    if (ret == HG_NOENTRY)
         goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not set rpc to handle");
 
 done:
     return ret;
@@ -4583,15 +4241,14 @@ HG_Core_ref_incr(hg_core_handle_t handle)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) handle;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
+    hg_return_t ret = HG_SUCCESS;
+
+    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core handle");
     hg_atomic_incr32(&hg_core_handle->ref_count);
 
-    return HG_SUCCESS;
+done:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4600,13 +4257,14 @@ HG_Core_ref_get(hg_core_handle_t handle)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) handle;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return -1;
-    }
-#endif
-    return (hg_int32_t) hg_atomic_get32(&hg_core_handle->ref_count);
+    hg_int32_t ret;
+
+    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, -1,
+        "NULL HG core handle");
+    ret = (hg_int32_t) hg_atomic_get32(&hg_core_handle->ref_count);
+
+done:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4617,39 +4275,40 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) handle;
     hg_size_t header_size;
+    hg_bool_t in_use;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (hg_core_handle->core_handle.info.addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL target addr");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!hg_core_handle->core_handle.info.id) {
-        HG_LOG_ERROR("NULL RPC ID");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core handle");
+    HG_CHECK_ERROR(hg_core_handle->core_handle.info.addr == HG_CORE_ADDR_NULL,
+        done, ret, HG_INVALID_ARG, "NULL target addr");
+    HG_CHECK_ERROR(hg_core_handle->core_handle.info.id == 0, done, ret,
+        HG_INVALID_ARG, "NULL RPC ID");
+
 #ifndef HG_HAS_SELF_FORWARD
-    if (hg_core_handle->is_self) {
-        HG_LOG_ERROR("Not enabled, please enable HG_USE_SELF_FORWARD");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->is_self, done, ret, HG_INVALID_PARAM,
+        "Forward to self not enabled, please enable HG_USE_SELF_FORWARD");
 #endif
-    if (hg_atomic_cas32(&hg_core_handle->in_use, HG_FALSE, HG_TRUE)
-        != HG_UTIL_TRUE) {
-        /* Not safe to reset
-         * TODO could add the ability to defer the reset operation */
-        HG_LOG_ERROR("Not safe to use HG core handle, handle is still in use, "
-            "refcount: %d", hg_atomic_get32(
-                &hg_core_handle->ref_count));
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
+    in_use = (hg_atomic_cas32(&hg_core_handle->in_use, HG_FALSE, HG_TRUE)
+        != HG_UTIL_TRUE);
+    /* Not safe to reset
+     * TODO could add the ability to defer the reset operation */
+    HG_CHECK_ERROR(in_use, done, ret, HG_BUSY,
+        "Not safe to use HG core handle, handle is still in use, refcount: %d",
+        hg_atomic_get32(&hg_core_handle->ref_count));
+
+    /* Make sure any cancelation has been processed on this handle before
+     * re-using it */
+    while (hg_atomic_get32(&hg_core_handle->canceling)) {
+        int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
+        unsigned int trigger_count = 0;
+        na_return_t na_ret;
+
+        na_ret = NA_Trigger(hg_core_handle->na_context, 0,
+            HG_CORE_MAX_TRIGGER_COUNT, cb_ret, &trigger_count);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
+            (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
+            NA_Error_to_string(na_ret));
     }
 
 #ifdef HG_HAS_COLLECT_STATS
@@ -4661,19 +4320,20 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     hg_core_handle->na_op_count = 1; /* Default (no response) */
     hg_atomic_set32(&hg_core_handle->na_op_completed_count, 0);
 
+    /* Increase ref count here so that a call to HG_Destroy does not free the
+     * handle but only schedules its completion
+     */
+    hg_atomic_incr32(&hg_core_handle->ref_count);
+
     /* Set header size */
     header_size = hg_core_header_request_get_size() +
         hg_core_handle->core_handle.na_in_header_offset;
 
     /* Set the actual size of the msg that needs to be transmitted */
     hg_core_handle->in_buf_used = header_size + payload_size;
-    if (hg_core_handle->in_buf_used > hg_core_handle->core_handle.in_buf_size) {
-        HG_LOG_ERROR("Exceeding input buffer size");
-        ret = HG_SIZE_ERROR;
-        /* Handle is no longer in use */
-        hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->in_buf_used
+        > hg_core_handle->core_handle.in_buf_size, error, ret, HG_MSGSIZE,
+        "Exceeding input buffer size");
 
     /* Parse flags */
     if (flags & HG_CORE_NO_RESPONSE)
@@ -4699,32 +4359,26 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     /* Encode request header */
     ret = hg_core_proc_header_request(&hg_core_handle->core_handle,
         &hg_core_handle->in_header, HG_ENCODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode header");
-        /* Handle is no longer in use */
-        hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
-        goto done;
-    }
-
-    /* Increase ref count here so that a call to HG_Destroy does not free the
-     * handle but only schedules its completion
-     */
-    hg_atomic_incr32(&hg_core_handle->ref_count);
+    HG_CHECK_HG_ERROR(error, ret, "Could not encode header");
 
     /* If addr is self, forward locally, otherwise send the encoded buffer
      * through NA and pre-post response */
     ret = hg_core_handle->forward(hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not forward buffer");
-        /* Handle is no longer in use */
-        hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
-        /* Rollback ref_count taken above */
-        hg_atomic_decr32(&hg_core_handle->ref_count);
-        goto done;
-    }
+    if (ret == HG_AGAIN)
+        goto error;
+
+    HG_CHECK_HG_ERROR(error, ret, "Could not forward buffer");
 
 done:
-     return ret;
+    return ret;
+
+error:
+    /* Handle is no longer in use */
+    hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
+    /* Rollback ref_count taken above */
+    hg_atomic_decr32(&hg_core_handle->ref_count);
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4737,25 +4391,12 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     hg_size_t header_size;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-#ifndef HG_HAS_SELF_FORWARD
-    if (NA_Addr_is_self(hg_core_handle->core_handle.info.addr->na_class,
-        hg_core_handle->core_handle.info.addr->na_addr)) {
-        HG_LOG_ERROR("Not enabled, please enable HG_USE_SELF_FORWARD");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-#endif
+    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core handle");
+
     /* Cannot respond if no_response flag set */
-    if (hg_core_handle->no_response) {
-        HG_LOG_ERROR("Sending response was disabled on that RPC");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->no_response, done, ret, HG_OPNOTSUPPORTED,
+        "Sending response was disabled on that RPC");
 
     /* Set header size */
     header_size = hg_core_header_response_get_size() +
@@ -4763,12 +4404,9 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
 
     /* Set the actual size of the msg that needs to be transmitted */
     hg_core_handle->out_buf_used = header_size + payload_size;
-    if (hg_core_handle->out_buf_used
-        > hg_core_handle->core_handle.out_buf_size) {
-        HG_LOG_ERROR("Exceeding output buffer size");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->out_buf_used
+        > hg_core_handle->core_handle.out_buf_size, done, ret, HG_MSGSIZE,
+        "Exceeding output buffer size");
 
     /* Set callback, keep request and response callbacks separate so that
      * they do not get overwritten when forwarding to ourself */
@@ -4783,18 +4421,12 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     /* Encode response header */
     ret = hg_core_proc_header_response(&hg_core_handle->core_handle,
         &hg_core_handle->out_header, HG_ENCODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode header");
 
     /* If addr is self, forward locally, otherwise send the encoded buffer
      * through NA and pre-post response */
     ret = hg_core_handle->respond(hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not respond");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not respond");
 
 done:
     return ret;
@@ -4808,18 +4440,13 @@ HG_Core_progress(hg_core_context_t *context, unsigned int timeout)
         (struct hg_core_private_context *) context;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core context");
 
     /* Make progress on the HG layer */
     ret = private_context->progress(private_context, timeout);
-    if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
-        HG_LOG_ERROR("Could not make progress");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        "Could not make progress");
 
 done:
     return ret;
@@ -4832,18 +4459,13 @@ HG_Core_trigger(hg_core_context_t *context, unsigned int timeout,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core context");
 
     ret = hg_core_trigger((struct hg_core_private_context *) context, timeout,
         max_count, actual_count);
-    if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
-        HG_LOG_ERROR("Could not trigger callbacks");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        "Could not trigger callbacks");
 
 done:
     return ret;
@@ -4855,17 +4477,11 @@ HG_Core_cancel(hg_core_handle_t handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_CORE_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core handle");
 
     ret = hg_core_cancel((struct hg_core_private_handle *) handle);
-    if (ret != HG_SUCCESS && ret != HG_CANCEL_ERROR) {
-        HG_LOG_ERROR("Could not cancel handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle");
 
 done:
     return ret;
diff --git a/src/mercury_core.h b/src/mercury_core.h
index 072a865..ce5974b 100644
--- a/src/mercury_core.h
+++ b/src/mercury_core.h
@@ -13,7 +13,6 @@
 
 #include "mercury_core_types.h"
 #include "mercury_core_header.h"
-#include "mercury_error.h"
 
 #include "na.h"
 
@@ -32,8 +31,8 @@ struct hg_core_info {
     hg_core_class_t *core_class;    /* HG core class */
     hg_core_context_t *context;     /* HG core context */
     hg_core_addr_t addr;            /* HG address at target/origin */
-    hg_uint8_t context_id;          /* Context ID at target/origin */
     hg_id_t id;                     /* RPC ID */
+    hg_uint8_t context_id;          /* Context ID at target/origin */
 };
 
 /* Callback info structs */
@@ -50,14 +49,14 @@ struct hg_core_cb_info_respond {
 };
 
 struct hg_core_cb_info {
-    void *arg;                  /* User data */
-    hg_return_t ret;            /* Return value */
-    hg_cb_type_t type;          /* Callback type */
     union {                     /* Union of callback info structures */
         struct hg_core_cb_info_lookup lookup;
         struct hg_core_cb_info_forward forward;
         struct hg_core_cb_info_respond respond;
     } info;
+    void *arg;                  /* User data */
+    hg_cb_type_t type;          /* Callback type */
+    hg_return_t ret;            /* Return value */
 };
 
 /* RPC / HG callbacks */
@@ -97,7 +96,7 @@ extern "C" {
  *
  * \return Pointer to HG core class or NULL in case of failure
  */
-HG_EXPORT hg_core_class_t *
+HG_PUBLIC hg_core_class_t *
 HG_Core_init(
         const char *na_info_string,
         hg_bool_t na_listen
@@ -116,7 +115,7 @@ HG_Core_init(
  *
  * \return Pointer to HG core class or NULL in case of failure
  */
-HG_EXPORT hg_core_class_t *
+HG_PUBLIC hg_core_class_t *
 HG_Core_init_opt(
         const char *na_info_string,
         hg_bool_t na_listen,
@@ -130,7 +129,7 @@ HG_Core_init_opt(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_finalize(
         hg_core_class_t *hg_core_class
         );
@@ -141,7 +140,7 @@ HG_Core_finalize(
  * to HG_Finalize(), this routine gives a chance to programs that terminate
  * abnormally to easily clean up those resources.
  */
-HG_EXPORT void
+HG_PUBLIC void
 HG_Core_cleanup(
         void
         );
@@ -161,7 +160,7 @@ HG_Core_cleanup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_set_more_data_callback(
         struct hg_core_class *hg_core_class,
         hg_return_t (*more_data_acquire_callback)(hg_core_handle_t, hg_op_t,
@@ -293,7 +292,7 @@ HG_Core_class_get_data(
  *
  * \return Pointer to HG core context or NULL in case of failure
  */
-HG_EXPORT hg_core_context_t *
+HG_PUBLIC hg_core_context_t *
 HG_Core_context_create(
         hg_core_class_t *hg_core_class
         );
@@ -309,7 +308,7 @@ HG_Core_context_create(
  *
  * \return Pointer to HG core context or NULL in case of failure
  */
-HG_EXPORT hg_core_context_t *
+HG_PUBLIC hg_core_context_t *
 HG_Core_context_create_id(
         hg_core_class_t *hg_core_class,
         hg_uint8_t id
@@ -322,7 +321,7 @@ HG_Core_context_create_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_context_destroy(
         hg_core_context_t *context
         );
@@ -418,7 +417,7 @@ HG_Core_context_get_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_context_set_handle_create_callback(
         hg_core_context_t *context,
         hg_return_t (*callback)(hg_core_handle_t, void *),
@@ -438,7 +437,7 @@ HG_Core_context_set_handle_create_callback(
  *
  * \return the associated class
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_context_post(
         hg_core_context_t *context,
         unsigned int request_count,
@@ -455,7 +454,7 @@ HG_Core_context_post(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_register(
         hg_core_class_t *hg_core_class,
         hg_id_t id,
@@ -472,7 +471,7 @@ HG_Core_register(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_deregister(
         hg_core_class_t *hg_core_class,
         hg_id_t id
@@ -487,7 +486,7 @@ HG_Core_deregister(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_registered(
         hg_core_class_t *hg_core_class,
         hg_id_t id,
@@ -506,7 +505,7 @@ HG_Core_registered(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_register_data(
         hg_core_class_t *hg_core_class,
         hg_id_t id,
@@ -523,7 +522,7 @@ HG_Core_register_data(
  *
  * \return Pointer to data or NULL
  */
-HG_EXPORT void *
+HG_PUBLIC void *
 HG_Core_registered_data(
         hg_core_class_t *hg_core_class,
         hg_id_t id
@@ -542,7 +541,7 @@ HG_Core_registered_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_lookup(
         hg_core_context_t *context,
         hg_core_cb_t callback,
@@ -559,7 +558,7 @@ HG_Core_addr_lookup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_create(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t *addr
@@ -573,13 +572,30 @@ HG_Core_addr_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_free(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t addr
         );
 
 /**
+ * Hint that the address is no longer valid. This may happen if the peer is
+ * no longer responding. This can be used to force removal of the
+ * peer address from the list of the peers, before freeing it and reclaim
+ * resources.
+ *
+ * \param hg_core_class [IN]    pointer to HG core class
+ * \param addr [IN]             abstract address
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_PUBLIC hg_return_t
+HG_Core_addr_set_remove(
+        hg_core_class_t *hg_core_class,
+        hg_core_addr_t addr
+        );
+
+/**
  * Set the underlying NA address to a HG address.
  *
  * \param core_addr [IN]        abstract address that not set NA address before
@@ -625,13 +641,29 @@ HG_Core_addr_get_na_class(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_self(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t *addr
         );
 
 /**
+ * Compare two addresses.
+ *
+ * \param hg_core_class [IN]    pointer to HG core class
+ * \param addr1 [IN]            abstract address
+ * \param addr2 [IN]            abstract address
+ *
+ * \return HG_TRUE if addresses are determined to be equal, HG_FALSE otherwise
+ */
+HG_PUBLIC hg_bool_t
+HG_Core_addr_cmp(
+        hg_core_class_t *hg_core_class,
+        hg_core_addr_t addr1,
+        hg_core_addr_t addr2
+        );
+
+/**
  * Duplicate an existing HG abstract address. The duplicated address can be
  * stored for later use and the origin address be freed safely. The duplicated
  * address must be freed with HG_Core_addr_free().
@@ -642,7 +674,7 @@ HG_Core_addr_self(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_dup(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t addr,
@@ -663,7 +695,7 @@ HG_Core_addr_dup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_to_string(
         hg_core_class_t *hg_core_class,
         char *buf,
@@ -684,7 +716,7 @@ HG_Core_addr_to_string(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_create(
         hg_core_context_t *context,
         hg_core_addr_t addr,
@@ -700,7 +732,7 @@ HG_Core_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_destroy(
         hg_core_handle_t handle
         );
@@ -717,7 +749,7 @@ HG_Core_destroy(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_reset(
         hg_core_handle_t handle,
         hg_core_addr_t addr,
@@ -731,7 +763,7 @@ HG_Core_reset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_ref_incr(
         hg_core_handle_t handle
         );
@@ -743,7 +775,7 @@ HG_Core_ref_incr(
  *
  * \return Non-negative value or negative if the handle is not valid
  */
-HG_EXPORT hg_int32_t
+HG_PUBLIC hg_int32_t
 HG_Core_ref_get(
         hg_core_handle_t handle
         );
@@ -871,7 +903,7 @@ HG_Core_get_output(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_forward(
         hg_core_handle_t handle,
         hg_core_cb_t callback,
@@ -893,7 +925,7 @@ HG_Core_forward(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_respond(
         hg_core_handle_t handle,
         hg_core_cb_t callback,
@@ -914,7 +946,7 @@ HG_Core_respond(
  *
  * \return HG_SUCCESS if any completion has occurred / HG error code otherwise
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_progress(
         hg_core_context_t *context,
         unsigned int timeout
@@ -932,7 +964,7 @@ HG_Core_progress(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_trigger(
         hg_core_context_t *context,
         unsigned int timeout,
@@ -947,7 +979,7 @@ HG_Core_trigger(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_cancel(
         hg_core_handle_t handle
         );
@@ -973,9 +1005,9 @@ struct hg_core_context {
 #ifdef HG_HAS_SM_ROUTING
     na_context_t *na_sm_context;        /* NA SM context */
 #endif
-    hg_uint8_t id;                      /* Context ID */
     void *data;                         /* User data */
     void (*data_free_callback)(void *); /* User data free callback */
+    hg_uint8_t id;                      /* Context ID */
 };
 
 /* HG core addr */
@@ -998,26 +1030,20 @@ struct hg_core_rpc_info {
 struct hg_core_handle {
     struct hg_core_info info;           /* HG info */
     struct hg_core_rpc_info *rpc_info;  /* Associated RPC registration info */
+    void *data;                         /* User data */
+    void (*data_free_callback)(void *); /* User data free callback */
     void *in_buf;                       /* Input buffer */
     void *out_buf;                      /* Output buffer */
     na_size_t in_buf_size;              /* Input buffer size */
     na_size_t out_buf_size;             /* Output buffer size */
     na_size_t na_in_header_offset;      /* Input NA header offset */
     na_size_t na_out_header_offset;     /* Output NA header offset */
-    void *data;                         /* User data */
-    void (*data_free_callback)(void *); /* User data free callback */
 };
 
 /*---------------------------------------------------------------------------*/
 static HG_INLINE const char *
 HG_Core_class_get_name(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return NULL;
-    }
-#endif
     return NA_Get_class_name(hg_core_class->na_class);
 }
 
@@ -1025,12 +1051,6 @@ HG_Core_class_get_name(const hg_core_class_t *hg_core_class)
 static HG_INLINE const char *
 HG_Core_class_get_protocol(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return NULL;
-    }
-#endif
     return NA_Get_class_protocol(hg_core_class->na_class);
 }
 
@@ -1038,12 +1058,6 @@ HG_Core_class_get_protocol(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_bool_t
 HG_Core_class_is_listening(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return HG_FALSE;
-    }
-#endif
     return NA_Is_listening(hg_core_class->na_class);
 }
 
@@ -1051,12 +1065,6 @@ HG_Core_class_is_listening(const hg_core_class_t *hg_core_class)
 static HG_INLINE na_class_t *
 HG_Core_class_get_na(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return NULL;
-    }
-#endif
     return hg_core_class->na_class;
 }
 
@@ -1065,12 +1073,6 @@ HG_Core_class_get_na(const hg_core_class_t *hg_core_class)
 static HG_INLINE na_class_t *
 HG_Core_class_get_na_sm(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return NULL;
-    }
-#endif
     return hg_core_class->na_sm_class;
 }
 #endif
@@ -1079,15 +1081,8 @@ HG_Core_class_get_na_sm(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_size_t
 HG_Core_class_get_input_eager_size(const hg_core_class_t *hg_core_class)
 {
-    hg_size_t unexp, header;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (hg_core_class == NULL) {
-        HG_LOG_ERROR("NULL HG core class");
-        return 0;
-    }
-#endif
-    unexp  = NA_Msg_get_max_unexpected_size(hg_core_class->na_class);
-    header = hg_core_header_request_get_size() +
+    hg_size_t unexp = NA_Msg_get_max_unexpected_size(hg_core_class->na_class),
+        header = hg_core_header_request_get_size() +
         NA_Msg_get_unexpected_header_size(hg_core_class->na_class);
 
     return (unexp > header) ? unexp - header : 0;
@@ -1097,15 +1092,8 @@ HG_Core_class_get_input_eager_size(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_size_t
 HG_Core_class_get_output_eager_size(const hg_core_class_t *hg_core_class)
 {
-    hg_size_t exp, header;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (hg_core_class == NULL) {
-        HG_LOG_ERROR("NULL HG core class");
-        return 0;
-    }
-#endif
-    exp    = NA_Msg_get_max_expected_size(hg_core_class->na_class);
-    header = hg_core_header_response_get_size() +
+    hg_size_t exp = NA_Msg_get_max_expected_size(hg_core_class->na_class),
+        header = hg_core_header_response_get_size() +
         NA_Msg_get_expected_header_size(hg_core_class->na_class);
 
     return (exp > header) ? exp - header : 0;
@@ -1116,12 +1104,6 @@ static HG_INLINE hg_return_t
 HG_Core_class_set_data(hg_core_class_t *hg_core_class, void *data,
     void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return HG_INVALID_PARAM;
-    }
-#endif
     hg_core_class->data = data;
     hg_core_class->data_free_callback = free_callback;
 
@@ -1132,12 +1114,6 @@ HG_Core_class_set_data(hg_core_class_t *hg_core_class, void *data,
 static HG_INLINE void *
 HG_Core_class_get_data(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return NULL;
-    }
-#endif
     return hg_core_class->data;
 }
 
@@ -1145,12 +1121,6 @@ HG_Core_class_get_data(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_core_class_t *
 HG_Core_context_get_class(const hg_core_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return NULL;
-    }
-#endif
     return context->core_class;
 }
 
@@ -1158,12 +1128,6 @@ HG_Core_context_get_class(const hg_core_context_t *context)
 static HG_INLINE na_context_t *
 HG_Core_context_get_na(const hg_core_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return NULL;
-    }
-#endif
     return context->na_context;
 }
 
@@ -1172,12 +1136,6 @@ HG_Core_context_get_na(const hg_core_context_t *context)
 static HG_INLINE na_context_t *
 HG_Core_context_get_na_sm(const hg_core_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return NULL;
-    }
-#endif
     return context->na_sm_context;
 }
 #endif
@@ -1186,12 +1144,6 @@ HG_Core_context_get_na_sm(const hg_core_context_t *context)
 static HG_INLINE hg_uint8_t
 HG_Core_context_get_id(const hg_core_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return HG_INVALID_PARAM;
-    }
-#endif
     return context->id;
 }
 
@@ -1200,12 +1152,6 @@ static HG_INLINE hg_return_t
 HG_Core_context_set_data(hg_core_context_t *context, void *data,
     void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return HG_INVALID_PARAM;
-    }
-#endif
     context->data = data;
     context->data_free_callback = free_callback;
 
@@ -1216,12 +1162,6 @@ HG_Core_context_set_data(hg_core_context_t *context, void *data,
 static HG_INLINE void *
 HG_Core_context_get_data(const hg_core_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return NULL;
-    }
-#endif
     return context->data;
 }
 
@@ -1229,12 +1169,6 @@ HG_Core_context_get_data(const hg_core_context_t *context)
 static HG_INLINE hg_return_t
 HG_Core_addr_set_na(hg_core_addr_t core_addr, na_addr_t na_addr)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (core_addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL HG core address");
-        return HG_INVALID_PARAM;
-    }
-#endif
     core_addr->na_addr = na_addr;
 
     return HG_SUCCESS;
@@ -1244,12 +1178,6 @@ HG_Core_addr_set_na(hg_core_addr_t core_addr, na_addr_t na_addr)
 static HG_INLINE na_addr_t
 HG_Core_addr_get_na(hg_core_addr_t addr)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL addr");
-        return NA_ADDR_NULL;
-    }
-#endif
     return addr->na_addr;
 }
 
@@ -1257,12 +1185,6 @@ HG_Core_addr_get_na(hg_core_addr_t addr)
 static HG_INLINE na_class_t *
 HG_Core_addr_get_na_class(hg_core_addr_t addr)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL addr");
-        return NULL;
-    }
-#endif
     return addr->na_class;
 }
 
@@ -1271,12 +1193,6 @@ static HG_INLINE hg_return_t
 HG_Core_set_data(hg_core_handle_t handle, void *data,
     void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
     handle->data = data;
     handle->data_free_callback = free_callback;
 
@@ -1287,12 +1203,6 @@ HG_Core_set_data(hg_core_handle_t handle, void *data,
 static HG_INLINE void *
 HG_Core_get_data(hg_core_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return NULL;
-    }
-#endif
     return handle->data;
 }
 
@@ -1300,12 +1210,6 @@ HG_Core_get_data(hg_core_handle_t handle)
 static HG_INLINE const struct hg_core_info *
 HG_Core_get_info(hg_core_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return NULL;
-    }
-#endif
     return &handle->info;
 }
 
@@ -1313,12 +1217,6 @@ HG_Core_get_info(hg_core_handle_t handle)
 static HG_INLINE const void *
 HG_Core_get_rpc_data(hg_core_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return NULL;
-    }
-#endif
     return (handle->rpc_info) ? handle->rpc_info->data : NULL;
 }
 
@@ -1326,12 +1224,6 @@ HG_Core_get_rpc_data(hg_core_handle_t handle)
 static HG_INLINE hg_return_t
 HG_Core_set_target_id(hg_core_handle_t handle, hg_uint8_t id)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG core handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
     handle->info.context_id = id;
 
     return HG_SUCCESS;
@@ -1342,21 +1234,7 @@ static HG_INLINE hg_return_t
 HG_Core_get_input(hg_core_handle_t handle, void **in_buf,
     hg_size_t *in_buf_size)
 {
-    hg_size_t header_offset;
-
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL handle");
-        return HG_INVALID_PARAM;
-    }
-
-    if (!in_buf || !in_buf_size) {
-        HG_LOG_ERROR("NULL pointer");
-        return HG_INVALID_PARAM;
-    }
-#endif
-
-    header_offset = hg_core_header_request_get_size() +
+    hg_size_t header_offset = hg_core_header_request_get_size() +
         handle->na_in_header_offset;
 
     /* Space must be left for request header */
@@ -1371,21 +1249,7 @@ static HG_INLINE hg_return_t
 HG_Core_get_output(hg_core_handle_t handle, void **out_buf,
     hg_size_t *out_buf_size)
 {
-    hg_size_t header_offset;
-
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL handle");
-        return HG_INVALID_PARAM;
-    }
-
-    if (!out_buf || !out_buf_size) {
-        HG_LOG_ERROR("NULL pointer");
-        return HG_INVALID_PARAM;
-    }
-#endif
-
-    header_offset = hg_core_header_response_get_size() +
+    hg_size_t header_offset = hg_core_header_response_get_size() +
         handle->na_out_header_offset;
 
     /* Space must be left for response header */
diff --git a/src/mercury_core_header.c b/src/mercury_core_header.c
index 8794f69..04e1c8f 100644
--- a/src/mercury_core_header.c
+++ b/src/mercury_core_header.c
@@ -160,11 +160,8 @@ hg_core_header_request_proc(hg_proc_op_t op, void *buf, size_t buf_size,
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-    if (buf_size < sizeof(struct hg_core_header_request)) {
-        HG_LOG_ERROR("Invalid buffer size");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(buf_size < sizeof(struct hg_core_header_request), done,
+        ret, HG_INVALID_ARG, "Invalid buffer size");
 
 #ifdef HG_HAS_CHECKSUMS
     /* Reset header checksum first */
@@ -195,12 +192,9 @@ hg_core_header_request_proc(hg_proc_op_t op, void *buf, size_t buf_size,
     hg_proc_buf_memcpy(buf_ptr, &n_hash_header, sizeof(n_hash_header), op);
     if (op == HG_DECODE) {
         hg_uint16_t h_hash_header = ntohs(n_hash_header);
-        if (header->hash.header != h_hash_header) {
-            HG_LOG_ERROR("checksum 0x%04X does not match (expected 0x%04X!)",
-                header->hash.header, h_hash_header);
-            ret = HG_CHECKSUM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(header->hash.header != h_hash_header, done, ret,
+            HG_CHECKSUM_ERROR,
+            "checksum 0x%04X does not match (expected 0x%04X!)");
     }
 #endif
 
@@ -220,11 +214,8 @@ hg_core_header_response_proc(hg_proc_op_t op, void *buf, size_t buf_size,
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-    if (buf_size < sizeof(struct hg_core_header_response)) {
-        HG_LOG_ERROR("Invalid buffer size");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(buf_size < sizeof(struct hg_core_header_response), done, ret,
+        HG_OVERFLOW, "Invalid buffer size");
 
 #ifdef HG_HAS_CHECKSUMS
     /* Reset header checksum first */
@@ -249,12 +240,9 @@ hg_core_header_response_proc(hg_proc_op_t op, void *buf, size_t buf_size,
     hg_proc_buf_memcpy(buf_ptr, &n_hash_header, sizeof(n_hash_header), op);
     if (op == HG_DECODE) {
         hg_uint16_t h_hash_header = ntohs(n_hash_header);
-        if (header->hash.header != h_hash_header) {
-            HG_LOG_ERROR("checksum 0x%04X does not match (expected 0x%04X!)",
-                header->hash.header, h_hash_header);
-            ret = HG_CHECKSUM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(header->hash.header != h_hash_header, done, ret,
+            HG_CHECKSUM_ERROR,
+            "checksum 0x%04X does not match (expected 0x%04X!)");
     }
 #endif
 
@@ -270,18 +258,12 @@ hg_core_header_request_verify(const struct hg_core_header *hg_core_header)
     hg_return_t ret = HG_SUCCESS;
 
     /* Must match HG */
-    if ((((header->hg >> 1)  & 'H') != 'H') ||
-        (((header->hg)       & 'G') != 'G')) {
-        HG_LOG_ERROR("Invalid HG byte");
-        ret = HG_NO_MATCH;
-        goto done;
-    }
+    HG_CHECK_ERROR(
+        (((header->hg >> 1) & 'H') != 'H') || (((header->hg) & 'G') != 'G'),
+        done, ret, HG_PROTOCOL_ERROR, "Invalid HG byte");
 
-    if (header->protocol != HG_CORE_PROTOCOL_VERSION) {
-        HG_LOG_ERROR("Invalid protocol version");
-        ret = HG_NO_MATCH;
-        goto done;
-    }
+    HG_CHECK_ERROR(header->protocol != HG_CORE_PROTOCOL_VERSION, done, ret,
+        HG_PROTONOSUPPORT, "Invalid protocol version");
 
 done:
     return ret;
@@ -294,9 +276,8 @@ hg_core_header_response_verify(const struct hg_core_header *hg_core_header)
     const struct hg_core_header_response *header = &hg_core_header->msg.response;
     hg_return_t ret = HG_SUCCESS;
 
-    if (header->ret_code)
-        HG_LOG_WARNING("Response return code: %s",
-            HG_Error_to_string((hg_return_t) header->ret_code));
+    HG_CHECK_WARNING(header->ret_code, "Response return code: %s",
+        HG_Error_to_string((hg_return_t) header->ret_code));
 
     return ret;
 }
diff --git a/src/mercury_core_header.h b/src/mercury_core_header.h
index a72e24f..a742da4 100644
--- a/src/mercury_core_header.h
+++ b/src/mercury_core_header.h
@@ -132,7 +132,7 @@ hg_core_header_response_get_size(void)
  * \param hg_core_header [IN/OUT]   pointer to request header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_request_init(
         struct hg_core_header *hg_core_header
         );
@@ -143,7 +143,7 @@ hg_core_header_request_init(
  * \param hg_core_header [IN/OUT]   pointer to response header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_response_init(
         struct hg_core_header *hg_core_header
         );
@@ -154,7 +154,7 @@ hg_core_header_response_init(
  * \param hg_core_header [IN/OUT]   pointer to request header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_request_finalize(
         struct hg_core_header *hg_core_header
         );
@@ -165,7 +165,7 @@ hg_core_header_request_finalize(
  * \param hg_core_header [IN/OUT]   pointer to response header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_response_finalize(
         struct hg_core_header *hg_core_header
         );
@@ -176,7 +176,7 @@ hg_core_header_response_finalize(
  * \param hg_core_header [IN/OUT]   pointer to request header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_request_reset(
         struct hg_core_header *hg_core_header
         );
@@ -187,7 +187,7 @@ hg_core_header_request_reset(
  * \param hg_core_header [IN/OUT]   pointer to response header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_response_reset(
         struct hg_core_header *hg_core_header
         );
@@ -202,7 +202,7 @@ hg_core_header_response_reset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PRIVATE hg_return_t
 hg_core_header_request_proc(
         hg_proc_op_t op,
         void *buf,
@@ -220,7 +220,7 @@ hg_core_header_request_proc(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PRIVATE hg_return_t
 hg_core_header_response_proc(
         hg_proc_op_t op,
         void *buf,
@@ -235,7 +235,7 @@ hg_core_header_response_proc(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PRIVATE hg_return_t
 hg_core_header_request_verify(
         const struct hg_core_header *hg_core_header
         );
@@ -247,7 +247,7 @@ hg_core_header_request_verify(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PRIVATE hg_return_t
 hg_core_header_response_verify(
         const struct hg_core_header *hg_core_header
         );
diff --git a/src/mercury_core_types.h b/src/mercury_core_types.h
index 4bec24a..e591f18 100644
--- a/src/mercury_core_types.h
+++ b/src/mercury_core_types.h
@@ -30,21 +30,42 @@ struct hg_init_info {
 };
 
 /* Error return codes:
- * Functions return 0 for success or HG_XXX_ERROR for failure */
-typedef enum hg_return {
-    HG_SUCCESS = 0,     /*!< operation succeeded */
-    HG_NA_ERROR,        /*!< error in NA layer */
-    HG_TIMEOUT,         /*!< reached timeout */
-    HG_INVALID_PARAM,   /*!< invalid parameter */
-    HG_SIZE_ERROR,      /*!< size error */
-    HG_NOMEM_ERROR,     /*!< no memory error */
-    HG_PROTOCOL_ERROR,  /*!< protocol does not match */
-    HG_NO_MATCH,        /*!< no function match */
-    HG_CHECKSUM_ERROR,  /*!< checksum error */
-    HG_CANCELED,        /*!< operation was canceled */
-    HG_CANCEL_ERROR,    /*!< operation could not be canceled */
-    HG_OTHER_ERROR      /*!< error from mercury_util or external to mercury */
-} hg_return_t;
+ * Functions return 0 for success or corresponding return code */
+#define HG_RETURN_VALUES                                                    \
+    X(HG_SUCCESS)           /*!< operation succeeded */                     \
+    X(HG_PERMISSION)        /*!< operation not permitted */                 \
+    X(HG_NOENTRY)           /*!< no such file or directory */               \
+    X(HG_INTERRUPT)         /*!< operation interrupted */                   \
+    X(HG_AGAIN)             /*!< operation must be retried */               \
+    X(HG_NOMEM)             /*!< out of memory */                           \
+    X(HG_ACCESS)            /*!< permission denied */                       \
+    X(HG_FAULT)             /*!< bad address */                             \
+    X(HG_BUSY)              /*!< device or resource busy */                 \
+    X(HG_NODEV)             /*!< no such device */                          \
+    X(HG_INVALID_ARG)       /*!< invalid argument */                        \
+    X(HG_PROTOCOL_ERROR)    /*!< protocol error */                          \
+    X(HG_OVERFLOW)          /*!< value too large */                         \
+    X(HG_MSGSIZE)           /*!< message size too long */                   \
+    X(HG_PROTONOSUPPORT)    /*!< protocol not supported */                  \
+    X(HG_OPNOTSUPPORTED)    /*!< operation not supported on endpoint */     \
+    X(HG_ADDRINUSE)         /*!< address already in use */                  \
+    X(HG_ADDRNOTAVAIL)      /*!< cannot assign requested address */         \
+    X(HG_TIMEOUT)           /*!< operation reached timeout */               \
+    X(HG_CANCELED)          /*!< operation canceled */                      \
+    X(HG_CHECKSUM_ERROR)    /*!< checksum error */                          \
+    X(HG_NA_ERROR)          /*!< generic NA error */                        \
+    X(HG_OTHER_ERROR)       /*!< generic HG error */                        \
+    X(HG_RETURN_MAX)
+
+#define X(a) a,
+typedef enum hg_return { HG_RETURN_VALUES } hg_return_t;
+#undef X
+
+/* Compat return codes */
+#define HG_INVALID_PARAM    HG_INVALID_ARG
+#define HG_SIZE_ERROR       HG_MSGSIZE
+#define HG_NOMEM_ERROR      HG_NOMEM
+#define HG_NO_MATCH         HG_NOENTRY
 
 /* Callback operation type */
 typedef enum hg_cb_type {
@@ -80,4 +101,8 @@ typedef enum {
 /* HG size max */
 #define HG_SIZE_MAX         UINT64_MAX
 
+/* HG init info initializer */
+#define HG_INIT_INFO_INITIALIZER \
+    { NA_INIT_INFO_INITIALIZER, NULL, HG_FALSE, HG_FALSE }
+
 #endif /* MERCURY_CORE_TYPES_H */
diff --git a/src/mercury_error.h b/src/mercury_error.h
index 5b49a1b..d22c1f7 100644
--- a/src/mercury_error.h
+++ b/src/mercury_error.h
@@ -19,18 +19,89 @@
 
 /* Default error macro */
 #ifdef HG_HAS_VERBOSE_ERROR
-  #include <mercury_log.h>
-  #define HG_LOG_MODULE_NAME "HG"
-  #define HG_LOG_ERROR(...)                                 \
-      HG_LOG_WRITE_ERROR(HG_LOG_MODULE_NAME, __VA_ARGS__)
-  #define HG_LOG_DEBUG(...)                                 \
-      HG_LOG_WRITE_DEBUG(HG_LOG_MODULE_NAME, __VA_ARGS__)
-  #define HG_LOG_WARNING(...)                               \
-      HG_LOG_WRITE_WARNING(HG_LOG_MODULE_NAME, __VA_ARGS__)
+# include <mercury_log.h>
+# define HG_LOG_MASK hg_log_mask
+/* Log mask will be initialized in init routine */
+extern HG_PRIVATE unsigned int HG_LOG_MASK;
+# define HG_LOG_MODULE_NAME    "HG"
+# define HG_LOG_ERROR(...) do {                                 \
+    if (HG_LOG_MASK & HG_LOG_TYPE_ERROR)                        \
+        HG_LOG_WRITE_ERROR(HG_LOG_MODULE_NAME, __VA_ARGS__);    \
+} while (0)
+# ifdef HG_HAS_DEBUG
+#  define HG_LOG_DEBUG(...) do {                                \
+    if (HG_LOG_MASK & HG_LOG_TYPE_DEBUG)                        \
+        HG_LOG_WRITE_DEBUG(HG_LOG_MODULE_NAME, __VA_ARGS__);    \
+} while (0)
+# else
+#  define HG_LOG_DEBUG(...)     (void)0
+# endif
+# define HG_LOG_WARNING(...) do {                               \
+    if (HG_LOG_MASK & HG_LOG_TYPE_WARNING)                      \
+        HG_LOG_WRITE_WARNING(HG_LOG_MODULE_NAME, __VA_ARGS__);  \
+} while (0)
 #else
-  #define HG_LOG_ERROR(...) (void)0
-  #define HG_LOG_DEBUG(...) (void)0
-  #define HG_LOG_WARNING(...) (void)0
+# define HG_LOG_ERROR(...)      (void)0
+# define HG_LOG_DEBUG(...)      (void)0
+# define HG_LOG_WARNING(...)    (void)0
 #endif
 
+/* Branch predictor hints */
+#ifndef _WIN32
+# define likely(x)       __builtin_expect(!!(x), 1)
+# define unlikely(x)     __builtin_expect(!!(x), 0)
+#else
+# define likely(x)       (x)
+# define unlikely(x)     (x)
+#endif
+
+/* Error macros */
+#define HG_GOTO_DONE(label, ret, ret_val) do {                  \
+    ret = ret_val;                                              \
+    goto label;                                                 \
+} while (0)
+
+#define HG_GOTO_ERROR(label, ret, err_val, ...) do {            \
+    HG_LOG_ERROR(__VA_ARGS__);                                  \
+    ret = err_val;                                              \
+    goto label;                                                 \
+} while (0)
+
+/* Check for hg_ret value and goto label */
+#define HG_CHECK_HG_ERROR(label, hg_ret, ...) do {              \
+    if (unlikely(hg_ret != HG_SUCCESS)) {                       \
+        HG_LOG_ERROR(__VA_ARGS__);                              \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+/* Check for cond, set ret to err_val and goto label */
+#define HG_CHECK_ERROR(cond, label, ret, err_val, ...) do {     \
+    if (unlikely(cond)) {                                       \
+        HG_LOG_ERROR(__VA_ARGS__);                              \
+        ret = err_val;                                          \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define HG_CHECK_ERROR_NORET(cond, label, ...) do {             \
+    if (unlikely(cond)) {                                       \
+        HG_LOG_ERROR(__VA_ARGS__);                              \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define HG_CHECK_ERROR_DONE(cond, ...) do {                     \
+    if (unlikely(cond)) {                                       \
+        HG_LOG_ERROR(__VA_ARGS__);                              \
+    }                                                           \
+} while (0)
+
+/* Check for cond and print warning */
+#define HG_CHECK_WARNING(cond, ...) do {                        \
+    if (unlikely(cond)) {                                       \
+        HG_LOG_WARNING(__VA_ARGS__);                            \
+    }                                                           \
+} while (0)
+
 #endif /* MERCURY_ERROR_H */
diff --git a/src/mercury_header.c b/src/mercury_header.c
index 296092b..a281eaf 100644
--- a/src/mercury_header.c
+++ b/src/mercury_header.c
@@ -92,29 +92,21 @@ hg_header_proc(hg_proc_op_t op, void *buf, size_t buf_size,
 
     switch (hg_header->op) {
         case HG_INPUT:
-            if (buf_size < sizeof(struct hg_header_input)) {
-                HG_LOG_ERROR("Invalid buffer size");
-                ret = HG_INVALID_PARAM;
-                goto done;
-            }
+            HG_CHECK_ERROR(buf_size < sizeof(struct hg_header_input), done, ret,
+                HG_INVALID_ARG, "Invalid buffer size");
 #ifdef HG_HAS_CHECKSUMS
             header_hash = &hg_header->msg.input.hash;
 #endif
             break;
         case HG_OUTPUT:
-            if (buf_size < sizeof(struct hg_header_output)) {
-                HG_LOG_ERROR("Invalid buffer size");
-                ret = HG_SIZE_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(buf_size < sizeof(struct hg_header_output), done,
+                ret, HG_INVALID_ARG, "Invalid buffer size");
 #ifdef HG_HAS_CHECKSUMS
             header_hash = &hg_header->msg.output.hash;
 #endif
             break;
         default:
-            HG_LOG_ERROR("Invalid header op");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid header op");
     }
 
 #ifdef HG_HAS_CHECKSUMS
diff --git a/src/mercury_header.h b/src/mercury_header.h
index 74c458f..48d7de6 100644
--- a/src/mercury_header.h
+++ b/src/mercury_header.h
@@ -102,7 +102,7 @@ hg_header_get_size(hg_op_t op)
  * \param hg_header [IN/OUT]    pointer to header structure
  * \param op [IN]               HG operation type: HG_INPUT / HG_OUTPUT
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_header_init(
         struct hg_header *hg_header,
         hg_op_t op
@@ -113,7 +113,7 @@ hg_header_init(
  *
  * \param hg_header [IN/OUT]    pointer to header structure
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_header_finalize(
         struct hg_header *hg_header
         );
@@ -124,7 +124,7 @@ hg_header_finalize(
  * \param hg_header [IN/OUT]    pointer to header structure
  * \param op [IN]               HG operation type: HG_INPUT / HG_OUTPUT
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_header_reset(
         struct hg_header *hg_header,
         hg_op_t op
@@ -140,7 +140,7 @@ hg_header_reset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PRIVATE hg_return_t
 hg_header_proc(
         hg_proc_op_t op,
         void *buf,
diff --git a/src/mercury_hl.c b/src/mercury_hl.c
index 4cbd025..fdd6296 100644
--- a/src/mercury_hl.c
+++ b/src/mercury_hl.c
@@ -74,6 +74,11 @@ hg_request_class_t *HG_REQUEST_CLASS_DEFAULT = NULL;
 /* For convenience, register HG_Hl_finalize() */
 static hg_bool_t hg_atexit_g = HG_FALSE;
 
+/* Default error log mask */
+#ifdef HG_HAS_VERBOSE_ERROR
+unsigned int HG_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
+#endif
+
 /*---------------------------------------------------------------------------*/
 static int
 hg_hl_request_progress(unsigned int timeout, void *arg)
@@ -153,11 +158,9 @@ HG_Hl_init(const char *na_info_string, hg_bool_t na_listen)
 
     /* First register finalize function if not set */
     if (!hg_atexit_g) {
-        if (atexit(hg_hl_finalize) != 0) {
-            HG_LOG_ERROR("Cannot set exit function");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        int rc = atexit(hg_hl_finalize);
+        HG_CHECK_ERROR(rc != 0, done, ret, HG_INVALID_ARG,
+            "Cannot set exit function");
         hg_atexit_g = HG_TRUE;
     }
 
@@ -165,40 +168,29 @@ HG_Hl_init(const char *na_info_string, hg_bool_t na_listen)
     if (!na_info_string) {
         na_info_string = getenv(HG_PORT_NAME);
     }
-    if (!na_info_string) {
-        HG_LOG_ERROR(HG_PORT_NAME " environment variable must be set");
-        goto done;
-    }
+    HG_CHECK_ERROR(na_info_string == NULL, done, ret, HG_INVALID_ARG,
+        HG_PORT_NAME " environment variable must be set");
 
     /* Initialize HG */
     if (!HG_CLASS_DEFAULT) {
         HG_CLASS_DEFAULT = HG_Init(na_info_string, na_listen);
-        if (!HG_CLASS_DEFAULT) {
-            HG_LOG_ERROR("Could not initialize HG class");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_CLASS_DEFAULT == NULL, done, ret, HG_FAULT,
+            "Could not initialize HG class");
     }
 
     /* Create HG context */
     if (!HG_CONTEXT_DEFAULT) {
         HG_CONTEXT_DEFAULT = HG_Context_create(HG_CLASS_DEFAULT);
-        if (!HG_CONTEXT_DEFAULT) {
-            HG_LOG_ERROR("Could not create HG context");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_CONTEXT_DEFAULT == NULL, done, ret, HG_FAULT,
+            "Could not create HG context");
     }
 
     /* Initialize request class */
     if (!HG_REQUEST_CLASS_DEFAULT) {
         HG_REQUEST_CLASS_DEFAULT = hg_request_init(hg_hl_request_progress,
                 hg_hl_request_trigger, HG_CONTEXT_DEFAULT);
-        if (!HG_REQUEST_CLASS_DEFAULT) {
-            HG_LOG_ERROR("Could not create HG request class");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_REQUEST_CLASS_DEFAULT == NULL, done, ret,
+            HG_FAULT, "Could not create HG request class");
     }
 
 done:
@@ -214,43 +206,32 @@ HG_Hl_init_opt(const char *na_info_string, hg_bool_t na_listen,
 
     /* First register finalize function if not set */
     if (!hg_atexit_g) {
-        if (atexit(hg_hl_finalize) != 0) {
-            HG_LOG_ERROR("Cannot set exit function");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        int rc = atexit(hg_hl_finalize);
+        HG_CHECK_ERROR(rc != 0, done, ret, HG_INVALID_ARG,
+            "Cannot set exit function");
         hg_atexit_g = HG_TRUE;
     }
 
     /* Initialize HG */
     if (!HG_CLASS_DEFAULT) {
         HG_CLASS_DEFAULT = HG_Init_opt(na_info_string, na_listen, hg_init_info);
-        if (!HG_CLASS_DEFAULT) {
-            HG_LOG_ERROR("Could not initialize HG class");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_CLASS_DEFAULT == NULL, done, ret, HG_FAULT,
+            "Could not initialize HG class");
     }
 
     /* Create HG context */
     if (!HG_CONTEXT_DEFAULT) {
         HG_CONTEXT_DEFAULT = HG_Context_create(HG_CLASS_DEFAULT);
-        if (!HG_CONTEXT_DEFAULT) {
-            HG_LOG_ERROR("Could not create HG context");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_CONTEXT_DEFAULT == NULL, done, ret, HG_FAULT,
+            "Could not create HG context");
     }
 
     /* Initialize request class */
     if (!HG_REQUEST_CLASS_DEFAULT) {
         HG_REQUEST_CLASS_DEFAULT = hg_request_init(hg_hl_request_progress,
                 hg_hl_request_trigger, HG_CONTEXT_DEFAULT);
-        if (!HG_REQUEST_CLASS_DEFAULT) {
-            HG_LOG_ERROR("Could not create HG request class");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_REQUEST_CLASS_DEFAULT == NULL, done, ret, HG_FAULT,
+            "Could not create HG request class");
     }
 
 done:
@@ -272,20 +253,14 @@ HG_Hl_finalize(void)
     /* Destroy context */
     if (HG_CONTEXT_DEFAULT) {
         ret = HG_Context_destroy(HG_CONTEXT_DEFAULT);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not destroy HG context");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not destroy HG context");
         HG_CONTEXT_DEFAULT = NULL;
     }
 
     /* Finalize interface */
     if (HG_CLASS_DEFAULT) {
         ret = HG_Finalize(HG_CLASS_DEFAULT);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not finalize HG class");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not finalize HG class");
         HG_CLASS_DEFAULT = NULL;
     }
 
@@ -303,11 +278,8 @@ HG_Hl_addr_lookup_wait(hg_context_t *context, hg_request_class_t *request_class,
     unsigned int flag = 0;
     struct hg_lookup_request_arg request_args;
 
-    if (!request_class) {
-        HG_LOG_ERROR("Uninitialized request class");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(request_class == NULL, done, ret, HG_INVALID_ARG,
+        "Uninitialized request class");
 
     request = hg_request_create(request_class);
     request_args.addr_ptr = addr;
@@ -316,18 +288,12 @@ HG_Hl_addr_lookup_wait(hg_context_t *context, hg_request_class_t *request_class,
     /* Forward call to remote addr and get a new request */
     ret = HG_Addr_lookup(context, hg_hl_addr_lookup_cb, &request_args, name,
             HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not lookup address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not lookup address");
 
     /* Wait for request to be marked completed */
     hg_request_wait(request, timeout, &flag);
-    if (!flag) {
-        HG_LOG_ERROR("Operation did not complete");
-        ret = HG_TIMEOUT;
-        goto done;
-    }
+    HG_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
+        "Operation did not complete");
 
     /* Free request */
     hg_request_destroy(request);
@@ -346,28 +312,19 @@ HG_Hl_forward_wait(hg_request_class_t *request_class, hg_handle_t handle,
     hg_return_t ret = HG_SUCCESS;
     unsigned int flag = 0;
 
-    if (!request_class) {
-        HG_LOG_ERROR("Uninitialized request class");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(request_class == NULL, done, ret, HG_INVALID_ARG,
+        "Uninitialized request class");
 
     request = hg_request_create(request_class);
 
     /* Forward call to remote addr and get a new request */
     ret = HG_Forward(handle, hg_hl_forward_cb, request, in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not forward call");
 
     /* Wait for request to be marked completed */
     hg_request_wait(request, timeout, &flag);
-    if (!flag) {
-        HG_LOG_ERROR("Operation did not complete");
-        ret = HG_TIMEOUT;
-        goto done;
-    }
+    HG_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
+        "Operation did not complete");
 
     /* Free request */
     hg_request_destroy(request);
@@ -388,11 +345,8 @@ HG_Hl_bulk_transfer_wait(hg_context_t *context,
     hg_return_t ret = HG_SUCCESS;
     unsigned int flag = 0;
 
-    if (!request_class) {
-        HG_LOG_ERROR("Uninitialized request class");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(request_class == NULL, done, ret, HG_INVALID_ARG,
+        "Uninitialized request class");
 
     request = hg_request_create(request_class);
 
@@ -400,18 +354,12 @@ HG_Hl_bulk_transfer_wait(hg_context_t *context,
     ret = HG_Bulk_transfer(context, hg_hl_bulk_transfer_cb, request, op,
             origin_addr, origin_handle, origin_offset, local_handle,
             local_offset, size, HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not transfer data");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not transfer data");
 
     /* Wait for request to be marked completed */
     hg_request_wait(request, timeout, &flag);
-    if (!flag) {
-        HG_LOG_ERROR("Operation did not complete");
-        ret = HG_TIMEOUT;
-        goto done;
-    }
+    HG_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
+        "Operation did not complete");
 
     /* Free request */
     hg_request_destroy(request);
diff --git a/src/mercury_hl.h b/src/mercury_hl.h
index 27938f3..1709e48 100644
--- a/src/mercury_hl.h
+++ b/src/mercury_hl.h
@@ -37,9 +37,9 @@ extern "C" {
 /********************/
 
 /* HG default */
-extern HG_EXPORT hg_class_t *HG_CLASS_DEFAULT;
-extern HG_EXPORT hg_context_t *HG_CONTEXT_DEFAULT;
-extern HG_EXPORT hg_request_class_t *HG_REQUEST_CLASS_DEFAULT;
+extern HG_PUBLIC hg_class_t *HG_CLASS_DEFAULT;
+extern HG_PUBLIC hg_context_t *HG_CONTEXT_DEFAULT;
+extern HG_PUBLIC hg_request_class_t *HG_REQUEST_CLASS_DEFAULT;
 
 /*********************/
 /* Public Prototypes */
@@ -60,7 +60,7 @@ extern HG_EXPORT hg_request_class_t *HG_REQUEST_CLASS_DEFAULT;
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_init(
         const char *na_info_string,
         hg_bool_t na_listen
@@ -81,7 +81,7 @@ HG_Hl_init(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_init_opt(
         const char *na_info_string,
         hg_bool_t na_listen,
@@ -93,7 +93,7 @@ HG_Hl_init_opt(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_finalize(
         void
         );
@@ -104,7 +104,7 @@ HG_Hl_finalize(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_addr_lookup_wait(
         hg_context_t *context,
         hg_request_class_t *request_class,
@@ -120,7 +120,7 @@ HG_Hl_addr_lookup_wait(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_forward_wait(
         hg_request_class_t *request_class,
         hg_handle_t handle,
@@ -144,7 +144,7 @@ HG_Hl_forward_wait(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_bulk_transfer_wait(
         hg_context_t *context,
         hg_request_class_t *request_class,
diff --git a/src/mercury_hl_macros.h b/src/mercury_hl_macros.h
index 49d983b..d527609 100644
--- a/src/mercury_hl_macros.h
+++ b/src/mercury_hl_macros.h
@@ -119,7 +119,6 @@
 #define HG_GET_OUTPUT(with_ret, ret_fail) \
         hg_ret = HG_Get_output(handle, &out_struct); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not get output"); \
             BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
             goto done; \
         }
@@ -128,7 +127,6 @@
 #define HG_FREE_OUTPUT(with_ret, ret_fail) \
         hg_ret = HG_Free_output(handle, &out_struct); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not free output"); \
             BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
             goto done; \
         }
@@ -157,7 +155,6 @@
                 BOOST_PP_IF(bulk_read, HG_BULK_READ_ONLY, HG_BULK_READWRITE), \
                 &bulk_handle); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not create HG bulk handle\n"); \
             BOOST_PP_IF(with_ret, ret = fail_ret;, BOOST_PP_EMPTY()) \
             goto done; \
         }
@@ -166,7 +163,6 @@
 #define HG_BULK_FREE(bulk_handle, with_ret, fail_ret) \
         hg_ret = HG_Bulk_free(bulk_handle); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not free HG bulk handle"); \
             BOOST_PP_IF(with_ret, ret = fail_ret;, BOOST_PP_EMPTY()) \
             goto done; \
         } \
@@ -194,7 +190,6 @@
 #define HG_BULK_LOCAL_FREE(local_bulk_handle) \
         hg_ret = HG_Bulk_free(local_bulk_handle); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not free block call"); \
             goto done; \
         } \
         free(HG_GEN_GET_NAME(BOOST_PP_SEQ_HEAD(HG_BULK_BUF)));
@@ -212,7 +207,6 @@
                 0, \
                 HG_GEN_GET_NAME(BOOST_PP_SEQ_HEAD(HG_BULK_COUNT))); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not transfer bulk data"); \
             goto done; \
         }
 
@@ -280,7 +274,6 @@
             hg_ret = HG_Create(HG_CLASS_DEFAULT, HG_CONTEXT_DEFAULT, \
                     NA_ADDR_DEFAULT, id, &handle); \
             if (hg_ret != HG_SUCCESS) { \
-                HG_LOG_ERROR("Could not create HG handle"); \
                 BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
                 goto done; \
             } \
@@ -302,7 +295,6 @@
             hg_ret = HG_Hl_forward_wait(handle, \
                     BOOST_PP_IF(with_input, &in_struct, NULL)); \
             if (hg_ret != HG_SUCCESS) { \
-                HG_LOG_ERROR("Could not forward call"); \
                 BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
                 goto done; \
             } \
@@ -331,7 +323,6 @@
             /* Destroy handle */ \
             hg_ret = HG_Destroy(handle); \
             if (hg_ret != HG_SUCCESS) { \
-                HG_LOG_ERROR("Could not destroy HG handle"); \
                 BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
                 goto done; \
             } \
@@ -375,7 +366,6 @@
                 BOOST_PP_IF(with_input, \
                         hg_ret = HG_Get_input(handle, &in_struct); \
                         if (hg_ret != HG_SUCCESS) { \
-                            HG_LOG_ERROR("Could not get input"); \
                             goto done; \
                         } \
                         \
@@ -432,7 +422,6 @@
                                 &out_struct, \
                                 NULL) ); \
                 if (hg_ret != HG_SUCCESS) { \
-                    HG_LOG_ERROR("Could not respond"); \
                     goto done; \
                 } \
                 \
@@ -440,7 +429,6 @@
                 BOOST_PP_IF(with_input, \
                         hg_ret = HG_Free_input(handle, &in_struct); \
                         if (hg_ret != HG_SUCCESS) { \
-                            HG_LOG_ERROR("Could not free input"); \
                             goto done; \
                         } \
                         , BOOST_PP_EMPTY()) \
@@ -448,7 +436,6 @@
                 /* Destroy handle */ \
                 hg_ret = HG_Destroy(handle); \
                 if (hg_ret != HG_SUCCESS) { \
-                    HG_LOG_ERROR("Could not destroy HG handle"); \
                     goto done; \
                 } \
                 \
diff --git a/src/mercury_macros.h b/src/mercury_macros.h
index 8f4e330..98f48d9 100644
--- a/src/mercury_macros.h
+++ b/src/mercury_macros.h
@@ -53,7 +53,6 @@ typedef struct \
     ret = BOOST_PP_CAT(hg_proc_, HG_GEN_GET_TYPE(field) \
             (proc, &struct_name->HG_GEN_GET_NAME(field))); \
     if (ret != HG_SUCCESS) { \
-      HG_LOG_ERROR("Proc error"); \
       return ret; \
     }
 
diff --git a/src/mercury_private.h b/src/mercury_private.h
index 781d906..ef610d9 100644
--- a/src/mercury_private.h
+++ b/src/mercury_private.h
@@ -28,13 +28,13 @@ typedef enum {
 
 /* Completion queue entry */
 struct hg_completion_entry {
-    hg_op_type_t op_type;
     union {
         struct hg_core_op_id *hg_core_op_id;
         hg_core_handle_t hg_core_handle;
         struct hg_bulk_op_id *hg_bulk_op_id;
     } op_id;
     HG_QUEUE_ENTRY(hg_completion_entry) entry;
+    hg_op_type_t op_type;
 };
 
 #endif /* MERCURY_PRIVATE_H */
diff --git a/src/mercury_proc.c b/src/mercury_proc.c
index 94fd0ca..3d5f684 100644
--- a/src/mercury_proc.c
+++ b/src/mercury_proc.c
@@ -10,11 +10,11 @@
 
 #include "mercury_proc.h"
 #include "mercury_proc_buf.h"
+#include "mercury_error.h"
 #include "mercury_mem.h"
 
 #ifdef HG_HAS_CHECKSUMS
 # include <mchecksum.h>
-# include <mchecksum_error.h>
 #endif
 
 /****************/
@@ -26,27 +26,27 @@
 /************************************/
 
 struct hg_proc_buf {
-    void *    buf;       /* Pointer to allocated buffer */
-    void *    buf_ptr;   /* Pointer to current position */
-    hg_size_t size;      /* Total buffer size */
-    hg_size_t size_left; /* Available size for user */
+    void *buf;              /* Pointer to allocated buffer */
+    void *buf_ptr;          /* Pointer to current position */
+    hg_size_t size;         /* Total buffer size */
+    hg_size_t size_left;    /* Available size for user */
     hg_bool_t is_mine;
 #ifdef HG_HAS_XDR
-    XDR      xdr;
+    XDR xdr;
 #endif
 };
 
 struct hg_proc {
-    hg_class_t *hg_class;               /* HG class */
-    hg_proc_op_t op;
     struct hg_proc_buf proc_buf;
     struct hg_proc_buf extra_buf;
+    hg_class_t *hg_class;           /* HG class */
     struct hg_proc_buf *current_buf;
 #ifdef HG_HAS_CHECKSUMS
     mchecksum_object_t checksum;    /* Checksum */
     void *checksum_hash;            /* Base checksum buf */
     size_t checksum_size;           /* Checksum size */
 #endif
+    hg_proc_op_t op;
 };
 
 /********************/
@@ -77,18 +77,13 @@ hg_proc_create(hg_class_t *hg_class, hg_proc_hash_t hash, hg_proc_t *proc)
     const char *hash_method;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, error, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_proc = (struct hg_proc *) malloc(sizeof(struct hg_proc));
-    if (!hg_proc) {
-        HG_LOG_ERROR("Could not allocate proc");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc == NULL, error, ret, HG_NOMEM,
+        "Could not allocate proc");
+
     memset(hg_proc, 0, sizeof(struct hg_proc));
     hg_proc->hg_class = hg_class;
 
@@ -110,22 +105,14 @@ hg_proc_create(hg_class_t *hg_class, hg_proc_hash_t hash, hg_proc_t *proc)
 
     if (hash_method) {
 #ifdef HG_HAS_CHECKSUMS
-        int checksum_ret;
-
-        checksum_ret = mchecksum_init(hash_method, &hg_proc->checksum);
-        if (checksum_ret != MCHECKSUM_SUCCESS) {
-            HG_LOG_ERROR("Could not initialize checksum");
-            ret = HG_CHECKSUM_ERROR;
-            goto done;
-        }
+        int rc = mchecksum_init(hash_method, &hg_proc->checksum);
+        HG_CHECK_ERROR(rc < 0, error, ret, HG_CHECKSUM_ERROR,
+            "Could not initialize checksum");
 
         hg_proc->checksum_size = mchecksum_get_size(hg_proc->checksum);
         hg_proc->checksum_hash = (char *) malloc(hg_proc->checksum_size);
-        if (!hg_proc->checksum_hash) {
-            HG_LOG_ERROR("Could not allocate space for checksum hash");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_proc->checksum_hash == NULL, error, ret,
+            HG_NOMEM, "Could not allocate space for checksum hash");
 #endif
     }
 
@@ -134,8 +121,16 @@ hg_proc_create(hg_class_t *hg_class, hg_proc_hash_t hash, hg_proc_t *proc)
 
     *proc = (struct hg_proc *) hg_proc;
 
-done:
-    if (ret != HG_SUCCESS) {
+    return ret;
+
+error:
+    if (hg_proc) {
+#ifdef HG_HAS_CHECKSUMS
+        if (hash_method && hg_proc->checksum != MCHECKSUM_OBJECT_NULL) {
+            free(hg_proc->checksum_hash);
+            mchecksum_destroy(hg_proc->checksum);
+        }
+#endif
         free(hg_proc);
     }
     return ret;
@@ -146,24 +141,23 @@ hg_return_t
 hg_proc_create_set(hg_class_t *hg_class, void *buf, hg_size_t buf_size,
     hg_proc_op_t op, hg_proc_hash_t hash, hg_proc_t *proc)
 {
-    hg_proc_t hg_proc;
+    hg_proc_t hg_proc = HG_PROC_NULL;
     hg_return_t ret = HG_SUCCESS;
 
     ret = hg_proc_create(hg_class, hash, &hg_proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not create proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not create proc");
 
     ret = hg_proc_reset(hg_proc, buf, buf_size, op);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not reset proc");
 
     *proc = hg_proc;
 
-done:
+    return ret;
+
+error:
+    if (hg_proc != HG_PROC_NULL)
+        hg_proc_free(hg_proc);
+
     return ret;
 }
 
@@ -174,19 +168,15 @@ hg_proc_free(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) goto done;
+    if (!hg_proc)
+        goto done;
 
 #ifdef HG_HAS_CHECKSUMS
     if (hg_proc->checksum != MCHECKSUM_OBJECT_NULL) {
-        int checksum_ret;
-
-        checksum_ret = mchecksum_destroy(hg_proc->checksum);
-        if (checksum_ret != MCHECKSUM_SUCCESS) {
-            HG_LOG_ERROR("Could not destroy checksum");
-            ret = HG_CHECKSUM_ERROR;
-        }
+        int rc = mchecksum_destroy(hg_proc->checksum);
+        HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
+            "Could not destroy checksum");
     }
-
     free(hg_proc->checksum_hash);
 #endif
 
@@ -208,13 +198,11 @@ hg_proc_reset(hg_proc_t proc, void *buf, hg_size_t buf_size, hg_proc_op_t op)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) goto done;
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG proc");
+    HG_CHECK_ERROR(!buf && op != HG_FREE, done, ret, HG_INVALID_ARG,
+        "NULL buffer");
 
-    if (!buf && op != HG_FREE) {
-        HG_LOG_ERROR("NULL buffer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
     hg_proc->op = op;
 #ifdef HG_HAS_XDR
     switch (op) {
@@ -228,9 +216,8 @@ hg_proc_reset(hg_proc_t proc, void *buf, hg_size_t buf_size, hg_proc_op_t op)
             xdrmem_create(&hg_proc->proc_buf.xdr, (char *) buf, buf_size, XDR_FREE);
             break;
         default:
-            HG_LOG_ERROR("Unknown proc operation");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_PARAM,
+                "Unknown proc operation");
     }
 #endif
 
@@ -254,13 +241,9 @@ hg_proc_reset(hg_proc_t proc, void *buf, hg_size_t buf_size, hg_proc_op_t op)
 #ifdef HG_HAS_CHECKSUMS
     /* Reset checksum */
     if (hg_proc->checksum != MCHECKSUM_OBJECT_NULL) {
-        int checksum_ret;
-
-        checksum_ret = mchecksum_reset(hg_proc->checksum);
-        if (checksum_ret != MCHECKSUM_SUCCESS) {
-            HG_LOG_ERROR("Could not reset checksum");
-            ret = HG_CHECKSUM_ERROR;
-        }
+        int rc = mchecksum_reset(hg_proc->checksum);
+        HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
+            "Could not reset checksum");
         memset(hg_proc->checksum_hash, 0, hg_proc->checksum_size);
     }
 #endif
@@ -276,10 +259,7 @@ hg_proc_get_class(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_class_t *hg_class = NULL;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     hg_class = hg_proc->hg_class;
 
@@ -294,10 +274,7 @@ hg_proc_get_op(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_proc_op_t proc_op = HG_ENCODE;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     proc_op = hg_proc->op;
 
@@ -312,10 +289,7 @@ hg_proc_get_size(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_size_t size = 0;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     size = hg_proc->proc_buf.size + hg_proc->extra_buf.size;
 
@@ -330,10 +304,7 @@ hg_proc_get_size_used(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_size_t size = 0;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     size = hg_proc->current_buf->size - hg_proc->current_buf->size_left;
 
@@ -351,31 +322,30 @@ hg_proc_set_size(hg_proc_t proc, hg_size_t req_buf_size)
     hg_size_t page_size = (hg_size_t) hg_mem_get_page_size();
     void *new_buf = NULL;
     ptrdiff_t current_pos;
+    hg_bool_t allocated = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, error, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
+
     /* Save current position */
     current_pos = (char *) hg_proc->current_buf->buf_ptr -
         (char *) hg_proc->current_buf->buf;
 
     /* Get one more page size buf */
     new_buf_size = ((hg_size_t)(req_buf_size / page_size) + 1) * page_size;
-    if (new_buf_size <= hg_proc_get_size(proc)) {
-        HG_LOG_ERROR("Buffer is already of the size requested");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(new_buf_size <= hg_proc_get_size(proc), error, ret,
+        HG_INVALID_ARG, "Buffer is already of the size requested");
 
     /* If was not using extra buffer init extra buffer */
-    if (!hg_proc->extra_buf.buf)
+    if (!hg_proc->extra_buf.buf) {
         /* Allocate buffer */
         new_buf = hg_mem_aligned_alloc(page_size, new_buf_size);
-    else
+        allocated = HG_TRUE;
+    } else
         new_buf = realloc(hg_proc->extra_buf.buf, new_buf_size);
-    if (!new_buf) {
-        HG_LOG_ERROR("Could not allocate buffer of size %zu", new_buf_size);
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(new_buf == NULL, error, ret, HG_NOMEM,
+        "Could not allocate buffer of size %zu", new_buf_size);
 
     if (!hg_proc->extra_buf.buf) {
         /* Copy proc_buf (should be small) */
@@ -391,7 +361,11 @@ hg_proc_set_size(hg_proc_t proc, hg_size_t req_buf_size)
     hg_proc->extra_buf.size_left = hg_proc->extra_buf.size - (hg_size_t) current_pos;
     hg_proc->extra_buf.is_mine = HG_TRUE;
 
-done:
+    return ret;
+
+error:
+    if (new_buf && allocated)
+        hg_mem_aligned_free(new_buf);
     return ret;
 }
 
@@ -402,10 +376,7 @@ hg_proc_get_size_left(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_size_t size = 0;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     size = hg_proc->current_buf->size_left;
 
@@ -423,10 +394,7 @@ hg_proc_save_ptr(hg_proc_t proc, hg_size_t data_size)
     unsigned int cur_pos;
 #endif
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     /* If not enough space allocate extra space if encoding or
      * just get extra buffer if decoding */
@@ -470,10 +438,7 @@ hg_proc_restore_ptr(hg_proc_t proc, void *data, hg_size_t data_size)
 
 #ifdef HG_HAS_CHECKSUMS
     ret = hg_proc_checksum_update(proc, data, data_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not update checksum");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not update checksum");
 #else
     /* Silent warning */
     (void)proc;
@@ -511,10 +476,10 @@ hg_proc_set_extra_buf_is_mine(hg_proc_t proc, hg_bool_t theirs)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc->extra_buf.buf) {
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
+    HG_CHECK_ERROR(hg_proc->extra_buf.buf == NULL, done, ret, HG_INVALID_ARG,
+        "Extra buf is not set");
 
     hg_proc->extra_buf.is_mine = (hg_bool_t) (!theirs);
 
@@ -526,26 +491,20 @@ done:
 hg_return_t
 hg_proc_flush(hg_proc_t proc)
 {
-    struct hg_proc *hg_proc = (struct hg_proc *) proc;
 #ifdef HG_HAS_CHECKSUMS
-    int checksum_ret;
+    struct hg_proc *hg_proc = (struct hg_proc *) proc;
+    int rc;
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
 
 #ifdef HG_HAS_CHECKSUMS
-    checksum_ret = mchecksum_get(hg_proc->checksum, hg_proc->checksum_hash,
+    rc = mchecksum_get(hg_proc->checksum, hg_proc->checksum_hash,
         hg_proc->checksum_size, MCHECKSUM_FINALIZE);
-    if (checksum_ret != MCHECKSUM_SUCCESS) {
-        HG_LOG_ERROR("Could not get checksum");
-        ret = HG_CHECKSUM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
+        "Could not get checksum");
 #endif
 
 done:
@@ -559,32 +518,26 @@ hg_proc_memcpy(hg_proc_t proc, void *data, hg_size_t data_size)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
 
-    if (hg_proc->op == HG_FREE) goto done;
+    if (hg_proc->op == HG_FREE)
+        goto done;
 
     /* If not enough space allocate extra space if encoding or
      * just get extra buffer if decoding */
     if (hg_proc->current_buf->size_left < data_size)
         hg_proc_set_size(proc, hg_proc->proc_buf.size +
-                hg_proc->extra_buf.size + data_size);
+            hg_proc->extra_buf.size + data_size);
 
     /* Process data */
-    hg_proc->current_buf->buf_ptr =
-            hg_proc_buf_memcpy(hg_proc->current_buf->buf_ptr, data, data_size,
-                    hg_proc->op);
+    hg_proc->current_buf->buf_ptr = hg_proc_buf_memcpy(
+        hg_proc->current_buf->buf_ptr, data, data_size, hg_proc->op);
     hg_proc->current_buf->size_left -= data_size;
 
 #ifdef HG_HAS_CHECKSUMS
     ret = hg_proc_checksum_update(proc, data, data_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not update checksum");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not update checksum");
 #endif
 
 done:
@@ -597,22 +550,16 @@ static HG_INLINE hg_return_t
 hg_proc_checksum_update(hg_proc_t proc, void *data, hg_size_t data_size)
 {
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
-    int checksum_ret;
     hg_return_t ret = HG_SUCCESS;
+    int rc;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
 
     /* Update checksum */
-    checksum_ret = mchecksum_update(hg_proc->checksum, data, data_size);
-    if (checksum_ret != MCHECKSUM_SUCCESS) {
-        HG_LOG_ERROR("Could not update checksum");
-        ret = HG_CHECKSUM_ERROR;
-        goto done;
-    }
+    rc = mchecksum_update(hg_proc->checksum, data, data_size);
+    HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
+        "Could not update checksum");
 
 done:
     return ret;
@@ -625,23 +572,12 @@ hg_proc_checksum_get(hg_proc_t proc, void *hash, hg_size_t hash_size)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!hash) {
-        HG_LOG_ERROR("NULL hash pointer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hash_size < hg_proc->checksum_size) {
-        HG_LOG_ERROR("Hash size passed is too small");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
+    HG_CHECK_ERROR(hash == NULL, done, ret, HG_INVALID_ARG,
+       "NULL hash pointer");
+    HG_CHECK_ERROR(hash_size < hg_proc->checksum_size, done, ret,
+        HG_INVALID_ARG, "Hash size passed is too small");
 
     memcpy(hash, hg_proc->checksum_hash, hg_proc->checksum_size);
 
@@ -656,17 +592,10 @@ hg_proc_checksum_verify(hg_proc_t proc, const void *hash, hg_size_t hash_size)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hash_size < hg_proc->checksum_size) {
-        HG_LOG_ERROR("Hash size is not valid");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
+    HG_CHECK_ERROR(hash_size < hg_proc->checksum_size, done, ret,
+        HG_INVALID_ARG, "Hash size passed is too small");
 
     /* Verify checksums */
     if (memcmp(hash, hg_proc->checksum_hash, hg_proc->checksum_size) != 0) {
diff --git a/src/mercury_proc.h b/src/mercury_proc.h
index 5553f7d..7b04069 100644
--- a/src/mercury_proc.h
+++ b/src/mercury_proc.h
@@ -12,7 +12,6 @@
 #define MERCURY_PROC_H
 
 #include "mercury_types.h"
-#include "mercury_error.h"
 
 #include <stdlib.h>
 #include <string.h>
@@ -72,7 +71,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_create(
         hg_class_t *hg_class,
         hg_proc_hash_t hash,
@@ -94,7 +93,7 @@ hg_proc_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_create_set(
         hg_class_t *hg_class,
         void *buf,
@@ -111,7 +110,7 @@ hg_proc_create_set(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_free(
         hg_proc_t proc
         );
@@ -127,7 +126,7 @@ hg_proc_free(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_reset(
         hg_proc_t proc,
         void *buf,
@@ -142,7 +141,7 @@ hg_proc_reset(
  *
  * \return HG class
  */
-HG_EXPORT hg_class_t *
+HG_PUBLIC hg_class_t *
 hg_proc_get_class(
         hg_proc_t proc
         );
@@ -154,7 +153,7 @@ hg_proc_get_class(
  *
  * \return Operation type
  */
-HG_EXPORT hg_proc_op_t
+HG_PUBLIC hg_proc_op_t
 hg_proc_get_op(
         hg_proc_t proc
         );
@@ -166,7 +165,7 @@ hg_proc_get_op(
  *
  * \return Non-negative size value
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 hg_proc_get_size(
         hg_proc_t proc
         );
@@ -178,7 +177,7 @@ hg_proc_get_size(
  *
  * \return Non-negative size value
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 hg_proc_get_size_used(
         hg_proc_t proc
         );
@@ -193,7 +192,7 @@ hg_proc_get_size_used(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_set_size(
         hg_proc_t proc,
         hg_size_t buf_size
@@ -206,7 +205,7 @@ hg_proc_set_size(
  *
  * \return Non-negative size value
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 hg_proc_get_size_left(
         hg_proc_t proc
         );
@@ -219,7 +218,7 @@ hg_proc_get_size_left(
  *
  * \return Buffer pointer
  */
-HG_EXPORT void *
+HG_PUBLIC void *
 hg_proc_save_ptr(
         hg_proc_t proc,
         hg_size_t data_size
@@ -233,7 +232,7 @@ hg_proc_save_ptr(
  *
  * \return XDR stream pointer
  */
-HG_EXPORT XDR *
+HG_PUBLIC XDR *
 hg_proc_get_xdr_ptr(
         hg_proc_t proc
         );
@@ -248,7 +247,7 @@ hg_proc_get_xdr_ptr(
  *
  * \return Buffer pointer
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_restore_ptr(
         hg_proc_t proc,
         void *data,
@@ -262,7 +261,7 @@ hg_proc_restore_ptr(
  *
  * \return Pointer to buffer or NULL if no extra buffer has been used
  */
-HG_EXPORT void *
+HG_PUBLIC void *
 hg_proc_get_extra_buf(
         hg_proc_t proc
         );
@@ -274,7 +273,7 @@ hg_proc_get_extra_buf(
  *
  * \return Size of buffer or 0 if no extra buffer has been used
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 hg_proc_get_extra_size(
         hg_proc_t proc
         );
@@ -287,7 +286,7 @@ hg_proc_get_extra_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_set_extra_buf_is_mine(
         hg_proc_t proc,
         hg_bool_t mine
@@ -301,7 +300,7 @@ hg_proc_set_extra_buf_is_mine(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_flush(
         hg_proc_t proc
         );
@@ -316,7 +315,7 @@ hg_proc_flush(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_memcpy(
         hg_proc_t proc,
         void *data,
@@ -335,7 +334,7 @@ hg_proc_memcpy(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_checksum_get(
         hg_proc_t proc,
         void *hash,
@@ -353,7 +352,7 @@ hg_proc_checksum_get(
  *
  * \return HG_SUCCESS if matches or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_checksum_verify(
         hg_proc_t proc,
         const void *hash,
diff --git a/src/mercury_proc_bulk.h b/src/mercury_proc_bulk.h
index fccbe9c..488c7c9 100644
--- a/src/mercury_proc_bulk.h
+++ b/src/mercury_proc_bulk.h
@@ -56,21 +56,18 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
             }
             /* Encode size */
             ret = hg_proc_uint64_t(proc, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
             if (!buf_size)
                 break;
             if (cached_ptr)
                 hg_proc_raw(proc, cached_ptr, buf_size);
             else {
                 buf = hg_proc_save_ptr(proc, buf_size);
-                ret = HG_Bulk_serialize(buf, buf_size, request_eager, *bulk_ptr);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not serialize bulk handle");
+                ret = HG_Bulk_serialize(buf, buf_size, request_eager,
+                    *bulk_ptr);
+                if (ret != HG_SUCCESS)
                     return ret;
-                }
                 hg_proc_restore_ptr(proc, buf, buf_size);
             }
             break;
@@ -80,10 +77,8 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
 
             /* Decode size */
             ret = hg_proc_uint64_t(proc, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
             if (!buf_size) {
                 /* If buf_size is 0, define handle to HG_BULK_NULL */
                 *bulk_ptr = HG_BULK_NULL;
@@ -92,16 +87,12 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
 
             buf = hg_proc_save_ptr(proc, buf_size);
             ret = HG_Bulk_deserialize(hg_class, bulk_ptr, buf, buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not deserialize bulk handle");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
             /* Cache serialize ptr to buf */
             ret = HG_Bulk_set_serialize_cached_ptr(*bulk_ptr, buf, buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not set serialize cached ptr");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
             hg_proc_restore_ptr(proc, buf, buf_size);
             break;
         }
@@ -113,16 +104,13 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
             }
             /* Set serialize ptr to NULL */
             ret = HG_Bulk_set_serialize_cached_ptr(*bulk_ptr, NULL, 0);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not set serialize cached ptr");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
+
             /* Decrement refcount on bulk handle */
             ret = HG_Bulk_free(*bulk_ptr);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not free bulk handle");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
             *bulk_ptr = HG_BULK_NULL;
             break;
         default:
diff --git a/src/mercury_types.h b/src/mercury_types.h
index d853875..6e7443c 100644
--- a/src/mercury_types.h
+++ b/src/mercury_types.h
@@ -30,8 +30,8 @@ struct hg_info {
     hg_class_t *hg_class;       /* HG class */
     hg_context_t *context;      /* HG context */
     hg_addr_t addr;             /* HG address at target/origin */
-    hg_uint8_t context_id;      /* Context ID at target/origin */
     hg_id_t id;                 /* RPC ID */
+    hg_uint8_t context_id;      /* Context ID at target/origin */
 };
 
 /**
@@ -62,15 +62,15 @@ struct hg_cb_info_bulk {
 };
 
 struct hg_cb_info {
-    void *arg;                  /* User data */
-    hg_return_t ret;            /* Return value */
-    hg_cb_type_t type;          /* Callback type */
     union {                     /* Union of callback info structures */
         struct hg_cb_info_lookup lookup;
         struct hg_cb_info_forward forward;
         struct hg_cb_info_respond respond;
         struct hg_cb_info_bulk bulk;
     } info;
+    void *arg;                  /* User data */
+    hg_cb_type_t type;          /* Callback type */
+    hg_return_t ret;            /* Return value */
 };
 
 /* RPC / HG callbacks */
diff --git a/src/na/CMakeLists.txt b/src/na/CMakeLists.txt
index c2ee09c..b6ca33a 100644
--- a/src/na/CMakeLists.txt
+++ b/src/na/CMakeLists.txt
@@ -225,6 +225,11 @@ endif()
 
 if(MERCURY_ENABLE_VERBOSE_ERROR)
   set(NA_HAS_VERBOSE_ERROR 1)
+  if(MERCURY_ENABLE_DEBUG)
+    set(NA_HAS_DEBUG 1)
+  else()
+    set(NA_HAS_DEBUG 0)
+  endif()
 else()
   set(NA_HAS_VERBOSE_ERROR 0)
 endif()
@@ -239,6 +244,7 @@ configure_file(
 #------------------------------------------------------------------------------
 set(NA_SRCS
   ${CMAKE_CURRENT_SOURCE_DIR}/na.c
+  ${CMAKE_CURRENT_SOURCE_DIR}/na_ip.c
 )
 
 if(NA_HAS_BMI)
@@ -327,7 +333,6 @@ install(
 set(NA_HEADERS
   ${CMAKE_CURRENT_BINARY_DIR}/na_config.h
   ${CMAKE_CURRENT_SOURCE_DIR}/na.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/na_error.h
   ${CMAKE_CURRENT_SOURCE_DIR}/na_types.h
 )
 
diff --git a/src/na/na.c b/src/na/na.c
index 3c33da2..0d919f0 100644
--- a/src/na/na.c
+++ b/src/na/na.c
@@ -19,9 +19,6 @@
 /****************/
 /* Local Macros */
 /****************/
-/* Convert value to string */
-#define NA_ERROR_STRING_MACRO(def, value, string) \
-  if (value == def) string = #def
 
 #define NA_CLASS_DELIMITER "+" /* e.g. "class+protocol" */
 
@@ -46,18 +43,22 @@ struct na_private_class {
 /* Private context / do not expose private members to plugins */
 struct na_private_context {
     struct na_context context;                  /* Must remain as first field */
-    na_class_t *na_class;                       /* Pointer to NA class */
+    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
 #ifdef NA_HAS_MULTI_PROGRESS
-    hg_thread_mutex_t progress_mutex;           /* Progress mutex */
     hg_thread_cond_t  progress_cond;            /* Progress cond */
-    hg_atomic_int32_t progressing;              /* Progressing count */
 #endif
-    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
     hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
-    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
+#ifdef NA_HAS_MULTI_PROGRESS
+    hg_thread_mutex_t progress_mutex;           /* Progress mutex */
+#endif
     HG_QUEUE_HEAD(na_cb_completion_data) backfill_queue; /* Backfill completion queue */
+    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
+    na_class_t *na_class;                       /* Pointer to NA class */
     hg_atomic_int32_t backfill_queue_count;     /* Number of entries in backfill queue */
     hg_atomic_int32_t trigger_waiting;          /* Polling/waiting in trigger */
+#ifdef NA_HAS_MULTI_PROGRESS
+    hg_atomic_int32_t progressing;              /* Progressing count */
+#endif
 };
 
 /********************/
@@ -77,52 +78,52 @@ na_info_free(
     struct na_info *na_info
     );
 
-#ifdef NA_DEBUG
-/* Print NA info */
-static void
-na_info_print(struct na_info *na_info);
-#endif
-
 /*******************/
 /* Local Variables */
 /*******************/
 
-static const struct na_class_ops *na_class_table[] = {
+/* NA plugin class table */
+static const struct na_class_ops *const na_class_table[] = {
 #ifdef NA_HAS_SM
-    &na_sm_class_ops_g, /* Keep NA SM first for protocol selection */
+    &NA_PLUGIN_OPS(sm), /* Keep NA SM first for protocol selection */
+#endif
+#ifdef NA_HAS_OFI
+    &NA_PLUGIN_OPS(ofi),
 #endif
 #ifdef NA_HAS_BMI
-    &na_bmi_class_ops_g,
+    &NA_PLUGIN_OPS(bmi),
 #endif
 #ifdef NA_HAS_MPI
-    &na_mpi_class_ops_g,
+    &NA_PLUGIN_OPS(mpi),
 #endif
 #ifdef NA_HAS_CCI
-    &na_cci_class_ops_g,
-#endif
-#ifdef NA_HAS_OFI
-    &na_ofi_class_ops_g,
+    &NA_PLUGIN_OPS(cci),
 #endif
     NULL
 };
 
+/* Return code string table */
+#define X(a) #a,
+static const char *const na_return_name[] = { NA_RETURN_VALUES };
+#undef X
+
+/* Default error log mask */
+#ifdef NA_HAS_VERBOSE_ERROR
+unsigned int NA_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
+#endif
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 {
     struct na_info *na_info = NULL;
+    char *input_string = NULL, *token = NULL, *locator = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    char *input_string = NULL;
-    char *token = NULL;
-    char *locator = NULL;
-
     na_info = (struct na_info *) malloc(sizeof(struct na_info));
-    if (!na_info) {
-        NA_LOG_ERROR("Could not allocate NA info struct");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_info == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA info struct");
+
     /* Initialize NA info */
     na_info->class_name = NULL;
     na_info->protocol_name = NULL;
@@ -130,11 +131,8 @@ na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 
     /* Copy info string and work from that */
     input_string = strdup(info_string);
-    if (!input_string) {
-        NA_LOG_ERROR("Could not duplicate host string");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(input_string == NULL, error, ret, NA_NOMEM,
+        "Could not duplicate host string");
 
     /**
      * Strings can be of the format:
@@ -152,58 +150,44 @@ na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 
         /* Get NA class name */
         na_info->class_name = strdup(token);
-        if (!na_info->class_name) {
-            NA_LOG_ERROR("Could not duplicate NA info class name");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_info->class_name == NULL, error, ret, NA_NOMEM,
+            "Could not duplicate NA info class name");
 
         /* Get protocol name */
         na_info->protocol_name = strdup(_locator);
-        if (!na_info->protocol_name) {
-            NA_LOG_ERROR("Could not duplicate NA info protocol name");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_info->protocol_name == NULL, error, ret,
+            NA_NOMEM, "Could not duplicate NA info protocol name");
     } else {
         /* Get protocol name */
         na_info->protocol_name = strdup(token);
-        if (!na_info->protocol_name) {
-            NA_LOG_ERROR("Could not duplicate NA info protocol name");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_info->protocol_name == NULL, error, ret,
+            NA_NOMEM, "Could not duplicate NA info protocol name");
     }
 
     /* Is the host string empty? */
-    if (!locator || locator[0] == '\0') {
+    if (!locator || locator[0] == '\0')
         goto done;
-    }
+
     /* Format sanity check ("://") */
-    else if (strncmp(locator, "//", 2) != 0) {
-        NA_LOG_ERROR("Bad address string format");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(strncmp(locator, "//", 2) != 0, error, ret,
+        NA_PROTONOSUPPORT, "Bad address string format");
+
     /* :// followed by empty hostname is allowed, explicitly check here */
-    else if (locator[2] == '\0') {
+    if (locator[2] == '\0')
         goto done;
-    }
-    else {
-        na_info->host_name = strdup(locator + 2);
-        if (!na_info->host_name) {
-            NA_LOG_ERROR("Could not duplicate NA info host name");
-            ret = NA_NOMEM_ERROR;
-        }
-    }
+
+    na_info->host_name = strdup(locator + 2);
+    NA_CHECK_ERROR(na_info->host_name == NULL, error, ret, NA_NOMEM,
+        "Could not duplicate NA info host name");
 
 done:
-    if (ret == NA_SUCCESS) {
-        *na_info_ptr = na_info;
-    }
-    else {
-        na_info_free(na_info);
-    }
+    *na_info_ptr = na_info;
+    free(input_string);
+
+    return ret;
+
+error:
+    na_info_free(na_info);
     free(input_string);
 
     return ret;
@@ -222,19 +206,6 @@ na_info_free(struct na_info *na_info)
 }
 
 /*---------------------------------------------------------------------------*/
-#ifdef NA_DEBUG
-static void
-na_info_print(struct na_info *na_info)
-{
-    if (!na_info) return;
-
-    printf("Class: %s\n", na_info->class_name);
-    printf("Protocol: %s\n", na_info->protocol_name);
-    printf("Hostname: %s\n", na_info->host_name);
-}
-#endif
-
-/*---------------------------------------------------------------------------*/
 na_class_t *
 NA_Initialize(const char *info_string, na_bool_t listen)
 {
@@ -248,75 +219,66 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
 {
     struct na_private_class *na_private_class = NULL;
     struct na_info *na_info = NULL;
-    unsigned int plugin_index = 0;
-    unsigned int plugin_count = 0;
+    unsigned int plugin_index;
+    const unsigned int plugin_count =
+        sizeof(na_class_table) / sizeof(na_class_table[0]) - 1;
     na_bool_t plugin_found = NA_FALSE;
+#ifdef NA_HAS_VERBOSE_ERROR
+    const char *log_level = NULL;
+#endif
     na_return_t ret = NA_SUCCESS;
 
-    if (!info_string) {
-        NA_LOG_ERROR("NULL info string");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(info_string == NULL, error, ret, NA_INVALID_ARG,
+        "NULL info string");
+
+#ifdef NA_HAS_VERBOSE_ERROR
+    /* Set log level */
+    log_level = getenv("HG_NA_LOG_LEVEL");
+    if (log_level && (strcmp(log_level, "debug") == 0))
+        NA_LOG_MASK |= HG_LOG_TYPE_DEBUG;
+#endif
 
     na_private_class = (struct na_private_class *) malloc(
         sizeof(struct na_private_class));
-    if (!na_private_class) {
-        NA_LOG_ERROR("Could not allocate class");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_class == NULL, error, ret, NA_NOMEM,
+        "Could not allocate class");
     memset(na_private_class, 0, sizeof(struct na_private_class));
 
-    plugin_count = sizeof(na_class_table) / sizeof(na_class_table[0]) - 1;
-
     ret = na_info_parse(info_string, &na_info);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not parse host string");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not parse host string");
+
     na_info->na_init_info = na_init_info;
     if (na_init_info)
         na_private_class->na_class.progress_mode = na_init_info->progress_mode;
 
-#ifdef NA_DEBUG
-    na_info_print(na_info);
-#endif
+    /* Print debug info */
+    NA_LOG_DEBUG("Class: %s, Protocol: %s, Hostname: %s" , na_info->class_name,
+        na_info->protocol_name, na_info->host_name);
 
-    while (plugin_index < plugin_count) {
+    for (plugin_index = 0; plugin_index < plugin_count; plugin_index++) {
         na_bool_t verified = NA_FALSE;
 
-        if (!na_class_table[plugin_index]->class_name) {
-            NA_LOG_ERROR("class name is not defined");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_class_table[plugin_index]->class_name == NULL, error,
+            ret, NA_PROTONOSUPPORT, "class name is not defined");
 
-        if (!na_class_table[plugin_index]->check_protocol) {
-            NA_LOG_ERROR("check_protocol plugin callback is not defined");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_class_table[plugin_index]->check_protocol == NULL,
+            error, ret, NA_OPNOTSUPPORTED,
+            "check_protocol plugin callback is not defined");
 
         /* Skip check protocol if class name does not match */
         if (na_info->class_name) {
             if (strcmp(na_class_table[plugin_index]->class_name,
-                na_info->class_name) != 0) {
-                plugin_index++;
+                na_info->class_name) != 0)
                 continue;
-            }
         }
 
         /* Check that protocol is supported */
         verified = na_class_table[plugin_index]->check_protocol(
             na_info->protocol_name);
         if (!verified) {
-            if (na_info->class_name) {
-                NA_LOG_ERROR("Specified class name does not support requested protocol");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
-            plugin_index++;
+            NA_CHECK_ERROR(na_info->class_name, error, ret,
+                NA_PROTONOSUPPORT,
+                "Specified class name does not support requested protocol");
             continue;
         }
 
@@ -326,11 +288,8 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
             /* While we're here, dup the class_name */
             na_info->class_name = strdup(
                 na_class_table[plugin_index]->class_name);
-            if (!na_info->class_name) {
-                NA_LOG_ERROR("unable to dup class name string");
-                ret = NA_NOMEM_ERROR;
-                goto done;
-            }
+            NA_CHECK_ERROR(na_info->class_name == NULL, error, ret,
+                NA_NOMEM, "Unable to dup class name string");
         }
 
         /* All checks have passed */
@@ -338,42 +297,37 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
         break;
     }
 
-    if (!plugin_found) {
-        NA_LOG_ERROR("No suitable plugin found that matches %s", info_string);
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(!plugin_found, error, ret, NA_PROTONOSUPPORT,
+        "No suitable plugin found that matches %s", info_string);
 
     na_private_class->na_class.ops = na_class_table[plugin_index];
-    if (!na_private_class->na_class.ops->initialize) {
-        NA_LOG_ERROR("initialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_class->na_class.ops == NULL, error, ret,
+        NA_INVALID_ARG, "NULL NA class ops");
+
+    NA_CHECK_ERROR(na_private_class->na_class.ops->initialize == NULL, error,
+        ret, NA_OPNOTSUPPORTED, "initialize plugin callback is not defined");
+
     ret = na_private_class->na_class.ops->initialize(
         &na_private_class->na_class, na_info, listen);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not initialize plugin");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not initialize plugin");
+
     na_private_class->na_class.protocol_name = strdup(na_info->protocol_name);
-    if (!na_private_class->na_class.protocol_name) {
-        NA_LOG_ERROR("Could not duplicate protocol name");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_class->na_class.protocol_name == NULL, error, ret,
+        NA_NOMEM, "Could not duplicate protocol name");
+
     na_private_class->na_class.listen = listen;
 
-done:
-    if (ret != NA_SUCCESS) {
-        if (na_private_class) {
-            free(na_private_class->na_class.protocol_name);
-        }
-        free(na_private_class);
-        na_private_class = NULL;
-    }
     na_info_free(na_info);
+
     return (na_class_t *) na_private_class;
+
+error:
+    na_info_free(na_info);
+    if (na_private_class) {
+        free(na_private_class->na_class.protocol_name);
+        free(na_private_class);
+    }
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -384,12 +338,13 @@ NA_Finalize(na_class_t *na_class)
         (struct na_private_class *) na_class;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_private_class) goto done;
-    if (!na_class->ops->finalize) {
-        NA_LOG_ERROR("finalize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
+    if (!na_private_class)
         goto done;
-    }
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->finalize == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "finalize plugin callback is not defined");
 
     ret = na_class->ops->finalize(&na_private_class->na_class);
 
@@ -430,37 +385,28 @@ NA_Context_create_id(na_class_t *na_class, na_uint8_t id)
     na_return_t ret = NA_SUCCESS;
     struct na_private_context *na_private_context = NULL;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, error, ret, NA_INVALID_ARG,
+        "NULL NA class");
 
     na_private_context = (struct na_private_context *) malloc(
         sizeof(struct na_private_context));
-    if (!na_private_context) {
-        NA_LOG_ERROR("Could not allocate context");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_context == NULL, error, ret, NA_NOMEM,
+        "Could not allocate context");
     na_private_context->na_class = na_class;
 
+    NA_CHECK_ERROR(na_class->ops == NULL, error, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
     if (na_class->ops->context_create) {
         ret = na_class->ops->context_create(na_class,
             &na_private_context->context.plugin_context, id);
-        if (ret != NA_SUCCESS) {
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(error, ret, "Could not create plugin context");
     }
 
     /* Initialize completion queue */
     na_private_context->completion_queue =
         hg_atomic_queue_alloc(NA_ATOMIC_QUEUE_SIZE);
-    if (!na_private_context->completion_queue) {
-        NA_LOG_ERROR("Could not allocate queue");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_context->completion_queue == NULL, error, ret,
+        NA_NOMEM, "Could not allocate queue");
     HG_QUEUE_INIT(&na_private_context->backfill_queue);
     hg_atomic_init32(&na_private_context->backfill_queue_count, 0);
 
@@ -476,12 +422,11 @@ NA_Context_create_id(na_class_t *na_class, na_uint8_t id)
     hg_atomic_init32(&na_private_context->progressing, 0);
 #endif
 
-done:
-    if (ret != NA_SUCCESS) {
-        free(na_private_context);
-        na_private_context = NULL;
-    }
     return (na_context_t *) na_private_context;
+
+error:
+    free(na_private_context);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -490,44 +435,38 @@ NA_Context_destroy(na_class_t *na_class, na_context_t *context)
 {
     struct na_private_context *na_private_context =
         (struct na_private_context *) context;
+    na_bool_t empty;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    if (!context)
         goto done;
-    }
-    if (!context) goto done;
 
     /* Check that completion queue is empty now */
-    if (!hg_atomic_queue_is_empty(na_private_context->completion_queue)) {
-        NA_LOG_ERROR("Completion queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = hg_atomic_queue_is_empty(na_private_context->completion_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_BUSY,
+        "Completion queue should be empty");
     hg_atomic_queue_free(na_private_context->completion_queue);
 
     /* Check that backfill completion queue is empty now */
     hg_thread_mutex_lock(&na_private_context->completion_queue_mutex);
-    if (!HG_QUEUE_IS_EMPTY(&na_private_context->backfill_queue)) {
-        NA_LOG_ERROR("Completion queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        hg_thread_mutex_unlock(&na_private_context->completion_queue_mutex);
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&na_private_context->backfill_queue);
     hg_thread_mutex_unlock(&na_private_context->completion_queue_mutex);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_BUSY,
+        "Completion queue should be empty");
 
     /* Destroy completion queue mutex/cond */
     hg_thread_mutex_destroy(&na_private_context->completion_queue_mutex);
     hg_thread_cond_destroy(&na_private_context->completion_queue_cond);
 
     /* Destroy NA plugin context */
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
     if (na_class->ops->context_destroy) {
         ret = na_class->ops->context_destroy(na_class,
             na_private_context->context.plugin_context);
-        if (ret != NA_SUCCESS) {
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not destroy plugin context");
     }
 
 #ifdef NA_HAS_MULTI_PROGRESS
@@ -548,14 +487,10 @@ NA_Op_create(na_class_t *na_class)
 {
     na_op_id_t ret = NA_OP_ID_NULL;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!na_class->ops->op_create) {
-        /* Not provided */
-        goto done;
-    }
+    NA_CHECK_ERROR_NORET(na_class == NULL, done, "NULL NA class");
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, done, "NULL NA class ops");
+    NA_CHECK_ERROR_NORET(na_class->ops->op_create == NULL, done,
+        "op_create plugin callback is not defined");
 
     ret = na_class->ops->op_create(na_class);
 
@@ -569,19 +504,17 @@ NA_Op_destroy(na_class_t *na_class, na_op_id_t op_id)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (op_id == NA_OP_ID_NULL) {
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+
+    if (op_id == NA_OP_ID_NULL)
         /* Nothing to do */
         goto done;
-    }
-    if (!na_class->ops->op_destroy) {
-        /* Not provided */
-        goto done;
-    }
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->op_destroy == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "op_destroy plugin callback is not defined");
 
     ret = na_class->ops->op_destroy(na_class, op_id);
 
@@ -598,34 +531,22 @@ NA_Addr_lookup(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     char *short_name = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!name) {
-        NA_LOG_ERROR("Lookup name is NULL");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_lookup) {
-        NA_LOG_ERROR("addr_lookup plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_ARG,
+        "NULL context");
+    NA_CHECK_ERROR(name == NULL, done, ret, NA_INVALID_ARG,
+        "Lookup name is NULL");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_lookup == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_lookup plugin callback is not defined");
 
     /* Copy name and work from that */
     name_string = strdup(name);
-    if (!name_string) {
-        NA_LOG_ERROR("Could not duplicate string");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM,
+        "Could not duplicate string");
 
     /* If NA class name was specified, we can remove the name here:
      * ie. bmi+tcp://hostname:port -> tcp://hostname:port */
@@ -636,9 +557,6 @@ NA_Addr_lookup(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
     ret = na_class->ops->addr_lookup(na_class, context, callback, arg,
         short_name, op_id);
-    if (ret != NA_SUCCESS) {
-        goto done;
-    }
 
 done:
     free(name_string);
@@ -647,60 +565,64 @@ done:
 
 /*---------------------------------------------------------------------------*/
 na_return_t
-NA_Addr_self(na_class_t *na_class, na_addr_t *addr)
+NA_Addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr)
 {
+    char *name_string = NULL;
+    char *short_name = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!addr) {
-        NA_LOG_ERROR("NULL pointer to na_addr_t");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_self) {
-        NA_LOG_ERROR("addr_self plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(name == NULL, done, ret, NA_INVALID_ARG,
+        "Lookup name is NULL");
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to na_addr_t");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (!na_class->ops->addr_lookup2)
+        /* Until we switch to new lookup, exit if no callback */
         goto done;
-    }
+//    NA_CHECK_ERROR(na_class->ops->addr_lookup2 == NULL, done, ret,
+//        NA_PROTOCOL_ERROR, "addr_lookup2 plugin callback is not defined");
 
-    ret = na_class->ops->addr_self(na_class, addr);
+    /* Copy name and work from that */
+    name_string = strdup(name);
+    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM,
+        "Could not duplicate string");
+
+    /* If NA class name was specified, we can remove the name here:
+     * ie. bmi+tcp://hostname:port -> tcp://hostname:port */
+    if (strstr(name_string, NA_CLASS_DELIMITER) != NULL)
+        strtok_r(name_string, NA_CLASS_DELIMITER, &short_name);
+    else
+        short_name = name_string;
+
+    ret = na_class->ops->addr_lookup2(na_class, short_name, addr);
 
 done:
+    free(name_string);
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 na_return_t
-NA_Addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr)
+NA_Addr_free(na_class_t *na_class, na_addr_t addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!new_addr) {
-        NA_LOG_ERROR("NULL pointer to NA addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_dup) {
-        NA_LOG_ERROR("addr_dup plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    if (addr == NA_ADDR_NULL)
+        /* Nothing to do */
         goto done;
-    }
 
-    ret = na_class->ops->addr_dup(na_class, addr, new_addr);
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_free == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_free plugin callback is not defined");
+
+    ret = na_class->ops->addr_free(na_class, addr);
 
 done:
     return ret;
@@ -708,25 +630,90 @@ done:
 
 /*---------------------------------------------------------------------------*/
 na_return_t
-NA_Addr_free(na_class_t *na_class, na_addr_t addr)
+NA_Addr_set_remove(na_class_t *na_class, na_addr_t addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
     if (addr == NA_ADDR_NULL)
         /* Nothing to do */
         goto done;
-    if (!na_class->ops->addr_free) {
-        NA_LOG_ERROR("addr_free plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
 
-    ret = na_class->ops->addr_free(na_class, addr);
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (na_class->ops->addr_set_remove)
+        ret = na_class->ops->addr_set_remove(na_class, addr);
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+na_return_t
+NA_Addr_self(na_class_t *na_class, na_addr_t *addr)
+{
+    na_return_t ret = NA_SUCCESS;
+
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to na_addr_t");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_self == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_self plugin callback is not defined");
+
+    ret = na_class->ops->addr_self(na_class, addr);
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+na_return_t
+NA_Addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr)
+{
+    na_return_t ret = NA_SUCCESS;
+
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
+        "NULL addr");
+    NA_CHECK_ERROR(new_addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to NA addr");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_dup == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_dup plugin callback is not defined");
+
+    ret = na_class->ops->addr_dup(na_class, addr, new_addr);
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+na_bool_t
+NA_Addr_cmp(na_class_t *na_class, na_addr_t addr1, na_addr_t addr2)
+{
+    na_bool_t ret = NA_FALSE;
+
+    NA_CHECK_ERROR_NORET(na_class == NULL, done, "NULL NA class");
+
+    if (addr1 == NA_ADDR_NULL && addr2 == NA_ADDR_NULL)
+        NA_GOTO_DONE(done, ret, NA_TRUE);
+
+    if (addr1 == NA_ADDR_NULL || addr2 == NA_ADDR_NULL)
+        NA_GOTO_DONE(done, ret, NA_FALSE);
+
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, done, "NULL NA class ops");
+    NA_CHECK_ERROR_NORET(na_class->ops->addr_cmp == NULL, done,
+        "addr_cmp plugin callback is not defined");
+
+    ret = na_class->ops->addr_cmp(na_class, addr1, addr2);
 
 done:
     return ret;
@@ -741,27 +728,18 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
     na_size_t buf_size_used = 0, plugin_buf_size = 0;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
     /* buf can be NULL */
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_to_string) {
-        NA_LOG_ERROR("addr_to_string plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
+        "NULL addr");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_to_string == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_to_string plugin callback is not defined");
 
     /* Automatically prepend string by plugin name with class delimiter,
      * except for MPI plugin (special case, because of generated string) */
@@ -769,21 +747,17 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
         buf_size_used = 0;
         plugin_buf_size = *buf_size;
     } else {
-        buf_size_used = strlen(na_class->ops->class_name) + 1;
+        buf_size_used = strlen(na_class->ops->class_name)
+            + strlen(NA_CLASS_DELIMITER);
         if (buf_ptr) {
-            if (*buf_size > buf_size_used) {
-                strcpy(buf_ptr, na_class->ops->class_name);
-                strcat(buf_ptr, NA_CLASS_DELIMITER);
-                buf_ptr += buf_size_used;
-                plugin_buf_size = *buf_size - buf_size_used;
-            } else {
-                NA_LOG_ERROR("Buffer size too small to copy addr");
-                ret = NA_SIZE_ERROR;
-                goto done;
-            }
-        } else {
+            NA_CHECK_ERROR(buf_size_used >= *buf_size, done, ret, NA_OVERFLOW,
+                "Buffer size too small to copy addr");
+            strcpy(buf_ptr, na_class->ops->class_name);
+            strcat(buf_ptr, NA_CLASS_DELIMITER);
+            buf_ptr += buf_size_used;
+            plugin_buf_size = *buf_size - buf_size_used;
+        } else
             plugin_buf_size = 0;
-        }
     }
 
     ret = na_class->ops->addr_to_string(na_class, buf_ptr, &plugin_buf_size,
@@ -802,31 +776,19 @@ NA_Addr_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_serialize) {
-        NA_LOG_ERROR("addr_serialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
+        "NULL addr");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_serialize == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_serialize plugin callback is not defined");
 
     ret = na_class->ops->addr_serialize(na_class, buf, buf_size, addr);
 
@@ -841,31 +803,19 @@ NA_Addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!addr) {
-        NA_LOG_ERROR("NULL pointer to addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_deserialize) {
-        NA_LOG_ERROR("addr_deserialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to addr");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_deserialize == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_deserialize plugin callback is not defined");
 
     ret = na_class->ops->addr_deserialize(na_class, addr, buf, buf_size);
 
@@ -879,29 +829,20 @@ NA_Msg_buf_alloc(na_class_t *na_class, na_size_t buf_size, void **plugin_data)
 {
     void *ret = NULL;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        goto done;
-    }
-    if (!plugin_data) {
-        NA_LOG_ERROR("NULL pointer to plugin data");
-        goto done;
-    }
+    NA_CHECK_ERROR_NORET(na_class == NULL, done, "NULL NA class");
+    NA_CHECK_ERROR_NORET(buf_size == 0, done, "NULL buffer size");
+    NA_CHECK_ERROR_NORET(plugin_data == NULL, done,
+        "NULL pointer to plugin data");
 
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, done, "NULL NA class ops");
     if (na_class->ops->msg_buf_alloc)
         ret = na_class->ops->msg_buf_alloc(na_class, buf_size, plugin_data);
     else {
         na_size_t page_size = (na_size_t) hg_mem_get_page_size();
 
         ret = hg_mem_aligned_alloc(page_size, buf_size);
-        if (!ret) {
-            NA_LOG_ERROR("Could not allocate %d bytes", (int) buf_size);
-            goto done;
-        }
+        NA_CHECK_ERROR_NORET(ret == NULL, done,
+            "Could not allocate %d bytes", (int) buf_size);
         memset(ret, 0, buf_size);
         *plugin_data = (void *)1; /* Sanity check on free */
     }
@@ -916,25 +857,18 @@ NA_Msg_buf_free(na_class_t *na_class, void *buf, void *plugin_data)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
 
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
     if (na_class->ops->msg_buf_free)
         ret = na_class->ops->msg_buf_free(na_class, buf, plugin_data);
     else {
-        if (plugin_data != (void *)1) {
-            NA_LOG_ERROR("Invalid plugin data value");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(plugin_data != (void *)1, done, ret, NA_FAULT,
+            "Invalid plugin data value");
         hg_mem_aligned_free(buf);
     }
 
@@ -948,22 +882,15 @@ NA_Msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
 
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
     if (na_class->ops->msg_init_unexpected)
         ret = na_class->ops->msg_init_unexpected(na_class, buf, buf_size);
 
@@ -977,22 +904,15 @@ NA_Msg_init_expected(na_class_t *na_class, void *buf, na_size_t buf_size)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
 
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
     if (na_class->ops->msg_init_expected)
         ret = na_class->ops->msg_init_expected(na_class, buf, buf_size);
 
@@ -1007,26 +927,17 @@ NA_Mem_handle_create(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_create) {
-        NA_LOG_ERROR("mem_handle_create plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_create == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "mem_handle_create plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_create(na_class, buf, buf_size, flags,
         mem_handle);
@@ -1043,26 +954,18 @@ NA_Mem_handle_create_segments(na_class_t *na_class, struct na_segment *segments,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!segments) {
-        NA_LOG_ERROR("NULL pointer to segments");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!segment_count) {
-        NA_LOG_ERROR("NULL segment count");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_create_segments) {
-        NA_LOG_ERROR("mem_handle_create_segments plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(segments == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to segments");
+    NA_CHECK_ERROR(segment_count == 0, done, ret, NA_INVALID_ARG,
+        "NULL segment count");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_create_segments == NULL, done, ret,
+        NA_OPNOTSUPPORTED,
+        "mem_handle_create_segments plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_create_segments(na_class, segments,
         segment_count, flags, mem_handle);
@@ -1077,21 +980,15 @@ NA_Mem_handle_free(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_free) {
-        NA_LOG_ERROR("mem_handle_free plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_free == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "mem_handle_free plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_free(na_class, mem_handle);
 
@@ -1105,21 +1002,16 @@ NA_Mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
 
-    if (na_class->ops->mem_register) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (na_class->ops->mem_register)
         /* Optional */
         ret = na_class->ops->mem_register(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1131,21 +1023,16 @@ NA_Mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
 
-    if (na_class->ops->mem_deregister) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (na_class->ops->mem_deregister)
         /* Optional */
         ret = na_class->ops->mem_deregister(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1157,21 +1044,16 @@ NA_Mem_publish(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
 
-    if (na_class->ops->mem_publish) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (na_class->ops->mem_publish)
         /* Optional */
         ret = na_class->ops->mem_publish(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1183,21 +1065,16 @@ NA_Mem_unpublish(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
 
-    if (na_class->ops->mem_unpublish) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (na_class->ops->mem_unpublish)
         /* Optional */
         ret = na_class->ops->mem_unpublish(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1210,31 +1087,20 @@ NA_Mem_handle_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_serialize) {
-        NA_LOG_ERROR("mem_handle_serialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_serialize == NULL, done, ret,
+        NA_OPNOTSUPPORTED,
+        "mem_handle_serialize plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_serialize(na_class, buf, buf_size,
         mem_handle);
@@ -1250,31 +1116,20 @@ NA_Mem_handle_deserialize(na_class_t *na_class, na_mem_handle_t *mem_handle,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!mem_handle) {
-        NA_LOG_ERROR("NULL pointer to memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_deserialize) {
-        NA_LOG_ERROR("mem_handle_deserialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NULL, done, ret,
+        NA_INVALID_ARG, "NULL pointer to memory handle");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_deserialize == NULL, done, ret,
+        NA_OPNOTSUPPORTED,
+        "mem_handle_deserialize plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_deserialize(na_class, mem_handle, buf,
         buf_size);
@@ -1289,69 +1144,52 @@ NA_Poll_try_wait(na_class_t *na_class, na_context_t *context)
 {
     struct na_private_context *na_private_context =
         (struct na_private_context *) context;
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_FALSE;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_FALSE;
-    }
-#endif
+    na_bool_t ret = NA_FALSE;
+
+    NA_CHECK_ERROR_NORET(na_class == NULL, error, "NULL NA class");
+    NA_CHECK_ERROR_NORET(context == NULL, error, "NULL context");
+
     /* Do not try to wait if NA_NO_BLOCK is set */
-    if (na_class->progress_mode == NA_NO_BLOCK)
+    if (na_class->progress_mode & NA_NO_BLOCK)
         return NA_FALSE;
 
     /* Something is in one of the completion queues */
     if (!hg_atomic_queue_is_empty(na_private_context->completion_queue) ||
-        hg_atomic_get32(&na_private_context->backfill_queue_count)) {
+        hg_atomic_get32(&na_private_context->backfill_queue_count))
         return NA_FALSE;
-    }
 
     /* Check plugin try wait */
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, error, "NULL NA class ops");
     if (na_class->ops->na_poll_try_wait)
         return na_class->ops->na_poll_try_wait(na_class, context);
 
     return NA_TRUE;
+
+error:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 na_return_t
 NA_Progress(na_class_t *na_class, na_context_t *context, unsigned int timeout)
 {
-    struct na_private_class *na_private_class =
-        (struct na_private_class *) na_class;
     struct na_private_context *na_private_context =
         (struct na_private_context *) context;
-    double remaining ;
+    double remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
 #ifdef NA_HAS_MULTI_PROGRESS
     hg_util_int32_t old, num;
 #endif
     na_return_t ret = NA_TIMEOUT;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_private_context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->progress) {
-        NA_LOG_ERROR("progress plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(na_private_context == NULL, done, ret, NA_INVALID_ARG,
+        "NULL context");
 
-    /* Do not block if NA_NO_BLOCK option is passed */
-    if (na_private_class->na_class.progress_mode == NA_NO_BLOCK) {
-        remaining = 0;
-    } else {
-        remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
-    }
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->progress == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "progress plugin callback is not defined");
 
 #ifdef NA_HAS_MULTI_PROGRESS
     hg_atomic_incr32(&na_private_context->progressing);
@@ -1437,27 +1275,14 @@ na_return_t
 NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
     int callback_ret[], unsigned int *actual_count)
 {
-    struct na_private_class *na_private_class;
     struct na_private_context *na_private_context =
         (struct na_private_context *) context;
-    double remaining;
+    double remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
     na_return_t ret = NA_SUCCESS;
     unsigned int count = 0;
 
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-
-    /* Do not block if NA_NO_BLOCK option is passed */
-    na_private_class = (struct na_private_class *) na_private_context->na_class;
-    if (na_private_class->na_class.progress_mode == NA_NO_BLOCK) {
-        timeout = 0;
-        remaining = 0;
-    } else {
-        remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
-    }
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_ARG,
+        "NULL context");
 
     while (count < max_count) {
         struct na_cb_completion_data *completion_data = NULL;
@@ -1477,7 +1302,7 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
                 hg_thread_mutex_unlock(
                     &na_private_context->completion_queue_mutex);
                 if (!completion_data)
-                    continue; /* Give another change to grab it */
+                    continue; /* Give another chance to grab it */
             } else {
                 hg_time_t t1, t2;
 
@@ -1518,16 +1343,13 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
 
                 hg_time_get_current(&t2);
                 remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
-                continue; /* Give another change to grab it */
+                continue; /* Give another chance to grab it */
             }
         }
 
-        /* Completion queue should not be empty now */
-        if (!completion_data) {
-            NA_LOG_ERROR("NULL completion data");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        /* Completion data should be valid */
+        NA_CHECK_ERROR(completion_data == NULL, done, ret, NA_INVALID_ARG,
+            "NULL completion data");
 
         /* Execute callback */
         if (completion_data->callback) {
@@ -1550,9 +1372,10 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
         count++;
     }
 
-done:
-    if ((ret == NA_SUCCESS || ret == NA_TIMEOUT) && actual_count)
+    if (actual_count)
         *actual_count = count;
+
+done:
     return ret;
 }
 
@@ -1562,26 +1385,17 @@ NA_Cancel(na_class_t *na_class, na_context_t *context, na_op_id_t op_id)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (op_id == NA_OP_ID_NULL) {
-        NA_LOG_ERROR("NULL operation ID");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->cancel) {
-        NA_LOG_ERROR("cancel plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_ARG,
+        "NULL context");
+    NA_CHECK_ERROR(op_id == NA_OP_ID_NULL, done, ret, NA_INVALID_ARG,
+        "NULL operation ID");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->cancel == NULL, done, ret, NA_OPNOTSUPPORTED,
+        "cancel plugin callback is not defined");
 
     ret = na_class->ops->cancel(na_class, context, op_id);
 
@@ -1593,20 +1407,7 @@ done:
 const char *
 NA_Error_to_string(na_return_t errnum)
 {
-    const char *na_error_string = "UNDEFINED/UNRECOGNIZED NA ERROR";
-
-    NA_ERROR_STRING_MACRO(NA_SUCCESS, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_CANCELED, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_TIMEOUT, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_INVALID_PARAM, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_SIZE_ERROR, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_ALIGNMENT_ERROR, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_PERMISSION_ERROR, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_NOMEM_ERROR, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_PROTOCOL_ERROR, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_ADDRINUSE_ERROR, errnum, na_error_string);
-
-    return na_error_string;
+    return na_return_name[errnum];
 }
 
 /*---------------------------------------------------------------------------*/
diff --git a/src/na/na.h b/src/na/na.h
index ada6784..4849ea7 100644
--- a/src/na/na.h
+++ b/src/na/na.h
@@ -12,7 +12,6 @@
 #define NA_H
 
 #include "na_types.h"
-#include "na_error.h"
 
 /*************************************/
 /* Public Type and Struct Definition */
@@ -45,7 +44,7 @@ extern "C" {
  *
  * \return Pointer to NA class or NULL in case of failure
  */
-NA_EXPORT na_class_t *
+NA_PUBLIC na_class_t *
 NA_Initialize(
         const char *info_string,
         na_bool_t   listen
@@ -63,7 +62,7 @@ NA_Initialize(
  *
  * \return Pointer to NA class or NULL in case of failure
  */
-NA_EXPORT na_class_t *
+NA_PUBLIC na_class_t *
 NA_Initialize_opt(
         const char                *info_string,
         na_bool_t                  listen,
@@ -77,7 +76,7 @@ NA_Initialize_opt(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Finalize(
         na_class_t *na_class
         );
@@ -89,7 +88,7 @@ NA_Finalize(
  * abnormally to easily clean up those resources. This includes instances
  * from all plugins.
  */
-NA_EXPORT void
+NA_PUBLIC void
 NA_Cleanup(
         void
         );
@@ -137,7 +136,7 @@ NA_Is_listening(
  *
  * \return Pointer to NA context or NULL in case of failure
  */
-NA_EXPORT na_context_t *
+NA_PUBLIC na_context_t *
 NA_Context_create(
         na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -150,7 +149,7 @@ NA_Context_create(
  *
  * \return Pointer to NA context or NULL in case of failure
  */
-NA_EXPORT na_context_t *
+NA_PUBLIC na_context_t *
 NA_Context_create_id(
         na_class_t *na_class,
         na_uint8_t id
@@ -164,7 +163,7 @@ NA_Context_create_id(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Context_destroy(
         na_class_t   *na_class,
         na_context_t *context
@@ -182,7 +181,7 @@ NA_Context_destroy(
  *
  * \return valid operation ID or NA_OP_ID_NULL
  */
-NA_EXPORT na_op_id_t
+NA_PUBLIC na_op_id_t
 NA_Op_create(
         na_class_t *na_class
         );
@@ -196,7 +195,7 @@ NA_Op_create(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Op_destroy(
         na_class_t *na_class,
         na_op_id_t op_id
@@ -221,7 +220,7 @@ NA_Op_destroy(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_lookup(
         na_class_t   *na_class,
         na_context_t *context,
@@ -232,6 +231,25 @@ NA_Addr_lookup(
         );
 
 /**
+ * Lookup an addr from a peer address/name. Addresses need to be
+ * freed by calling NA_Addr_free().
+ *
+ * \remark This is the immediate version of NA_Addr_lookup().
+ *
+ * \param na_class [IN/OUT]     pointer to NA class
+ * \param name [IN]             lookup name
+ * \param addr [OUT]            pointer to abstract address
+ *
+ * \return NA_SUCCESS or corresponding NA error code
+ */
+NA_PUBLIC na_return_t
+NA_Addr_lookup2(
+        na_class_t *na_class,
+        const char *name,
+        na_addr_t  *addr
+        );
+
+/**
  * Free the addr from the list of peers.
  *
  * \param na_class [IN/OUT]     pointer to NA class
@@ -239,13 +257,30 @@ NA_Addr_lookup(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_free(
         na_class_t *na_class,
         na_addr_t   addr
         );
 
 /**
+ * Hint that the address is no longer valid. This may happen if the peer is
+ * no longer responding. This can be used to force removal of the
+ * peer address from the list of the peers, before freeing it and reclaim
+ * resources.
+ *
+ * \param na_class [IN/OUT]     pointer to NA class
+ * \param addr [IN]             abstract address
+ *
+ * \return NA_SUCCESS or corresponding NA error code
+ */
+NA_PUBLIC na_return_t
+NA_Addr_set_remove(
+        na_class_t *na_class,
+        na_addr_t   addr
+        );
+
+/**
  * Access self address.
  *
  * \param na_class [IN/OUT]     pointer to NA class
@@ -253,7 +288,7 @@ NA_Addr_free(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_self(
         na_class_t *na_class,
         na_addr_t  *addr
@@ -270,7 +305,7 @@ NA_Addr_self(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_dup(
         na_class_t *na_class,
         na_addr_t   addr,
@@ -278,6 +313,22 @@ NA_Addr_dup(
         );
 
 /**
+ * Compare two addresses.
+ *
+ * \param na_class [IN/OUT]     pointer to NA class
+ * \param addr1 [IN]            abstract address
+ * \param addr2 [IN]            abstract address
+ *
+ * \return NA_TRUE if addresses are determined to be equal, NA_FALSE otherwise
+ */
+NA_PUBLIC na_bool_t
+NA_Addr_cmp(
+        na_class_t *na_class,
+        na_addr_t   addr1,
+        na_addr_t   addr2
+        );
+
+/**
  * Test whether address is self or not.
  *
  * \param na_class [IN/OUT]     pointer to NA class
@@ -305,7 +356,7 @@ NA_Addr_is_self(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_to_string(
         na_class_t *na_class,
         char       *buf,
@@ -337,7 +388,7 @@ NA_Addr_get_serialize_size(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_serialize(
         na_class_t  *na_class,
         void        *buf,
@@ -356,7 +407,7 @@ NA_Addr_serialize(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_deserialize(
         na_class_t      *na_class,
         na_addr_t       *addr,
@@ -441,7 +492,7 @@ NA_Msg_get_max_tag(
  *
  * \return Pointer to allocated memory or NULL in case of failure
  */
-NA_EXPORT void *
+NA_PUBLIC void *
 NA_Msg_buf_alloc(
         na_class_t *na_class,
         na_size_t buf_size,
@@ -459,7 +510,7 @@ NA_Msg_buf_alloc(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Msg_buf_free(
         na_class_t *na_class,
         void *buf,
@@ -478,7 +529,7 @@ NA_Msg_buf_free(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Msg_init_unexpected(
         na_class_t *na_class,
         void *buf,
@@ -580,7 +631,7 @@ NA_Msg_recv_unexpected(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Msg_init_expected(
         na_class_t *na_class,
         void *buf,
@@ -691,7 +742,7 @@ NA_Msg_recv_expected(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_handle_create(
         na_class_t      *na_class,
         void            *buf,
@@ -719,7 +770,7 @@ NA_Mem_handle_create(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_handle_create_segments(
         na_class_t        *na_class,
         struct na_segment *segments,
@@ -736,7 +787,7 @@ NA_Mem_handle_create_segments(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_handle_free(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -752,7 +803,7 @@ NA_Mem_handle_free(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_register(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -766,7 +817,7 @@ NA_Mem_register(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_deregister(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -782,7 +833,7 @@ NA_Mem_deregister(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_publish(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -796,7 +847,7 @@ NA_Mem_publish(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_unpublish(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -832,7 +883,7 @@ NA_Mem_handle_get_serialize_size(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_handle_serialize(
         na_class_t      *na_class,
         void            *buf,
@@ -850,7 +901,7 @@ NA_Mem_handle_serialize(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_handle_deserialize(
         na_class_t      *na_class,
         na_mem_handle_t *mem_handle,
@@ -967,7 +1018,7 @@ NA_Poll_get_fd(
  *
  * \return NA_TRUE if it is safe to block or NA_FALSE otherwise
  */
-NA_EXPORT na_bool_t
+NA_PUBLIC na_bool_t
 NA_Poll_try_wait(
         na_class_t      *na_class,
         na_context_t    *context
@@ -986,7 +1037,7 @@ NA_Poll_try_wait(
  *
  * \return NA_SUCCESS if any completion has occurred / NA error code otherwise
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Progress(
         na_class_t   *na_class,
         na_context_t *context,
@@ -1006,7 +1057,7 @@ NA_Progress(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Trigger(
         na_context_t *context,
         unsigned int  timeout,
@@ -1024,7 +1075,7 @@ NA_Trigger(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Cancel(
         na_class_t   *na_class,
         na_context_t *context,
@@ -1038,7 +1089,7 @@ NA_Cancel(
  *
  * \return String
  */
-NA_EXPORT const char *
+NA_PUBLIC const char *
 NA_Error_to_string(
         na_return_t errnum
         ) NA_WARN_UNUSED_RESULT;
@@ -1059,10 +1110,10 @@ struct na_info {
 /* NA class definition */
 struct na_class {
     const struct na_class_ops *ops;             /* Class operations */
+    void *plugin_class;                         /* Plugin private class */
     char *protocol_name;                        /* Name of protocol */
+    na_uint32_t progress_mode;                  /* NA progress mode */
     na_bool_t listen;                           /* Listen for connections */
-    na_progress_mode_t progress_mode;           /* NA progress mode */
-    void *plugin_class;                         /* Plugin private class */
 };
 
 /* NA context definition */
@@ -1121,11 +1172,22 @@ struct na_class_ops {
             na_op_id_t   *op_id
             );
     na_return_t
+    (*addr_lookup2)(
+            na_class_t *na_class,
+            const char *name,
+            na_addr_t  *addr
+            );
+    na_return_t
     (*addr_free)(
             na_class_t *na_class,
             na_addr_t   addr
             );
     na_return_t
+    (*addr_set_remove)(
+            na_class_t *na_class,
+            na_addr_t   addr
+            );
+    na_return_t
     (*addr_self)(
             na_class_t *na_class,
             na_addr_t  *addr
@@ -1137,6 +1199,12 @@ struct na_class_ops {
             na_addr_t  *new_addr
             );
     na_bool_t
+    (*addr_cmp)(
+            na_class_t *na_class,
+            na_addr_t   addr1,
+            na_addr_t   addr2
+            );
+    na_bool_t
     (*addr_is_self)(
             na_class_t *na_class,
             na_addr_t   addr
@@ -1382,12 +1450,6 @@ struct na_class_ops {
 static NA_INLINE const char *
 NA_Get_class_name(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NULL;
-    }
-#endif
     return na_class->ops->class_name;
 }
 
@@ -1395,12 +1457,6 @@ NA_Get_class_name(const na_class_t *na_class)
 static NA_INLINE const char *
 NA_Get_class_protocol(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NULL;
-    }
-#endif
     return na_class->protocol_name;
 }
 
@@ -1408,12 +1464,6 @@ NA_Get_class_protocol(const na_class_t *na_class)
 static NA_INLINE na_bool_t
 NA_Is_listening(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_FALSE;
-    }
-#endif
     return na_class->listen;
 }
 
@@ -1421,16 +1471,6 @@ NA_Is_listening(const na_class_t *na_class)
 static NA_INLINE na_bool_t
 NA_Addr_is_self(na_class_t *na_class, na_addr_t addr)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_FALSE;
-    }
-    if (!na_class->ops->addr_is_self) {
-        NA_LOG_ERROR("addr_is_self plugin callback is not defined");
-        return NA_FALSE;
-    }
-#endif
     return na_class->ops->addr_is_self(na_class, addr);
 }
 
@@ -1438,20 +1478,6 @@ NA_Addr_is_self(na_class_t *na_class, na_addr_t addr)
 static NA_INLINE na_size_t
 NA_Addr_get_serialize_size(na_class_t *na_class, na_addr_t addr)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        return 0;
-    }
-    if (!na_class->ops->addr_get_serialize_size) {
-        NA_LOG_ERROR("addr_get_serialize_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->addr_get_serialize_size(na_class, addr);
 }
 
@@ -1459,16 +1485,6 @@ NA_Addr_get_serialize_size(na_class_t *na_class, na_addr_t addr)
 static NA_INLINE na_size_t
 NA_Msg_get_max_unexpected_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (!na_class->ops->msg_get_max_unexpected_size) {
-        NA_LOG_ERROR("msg_get_max_unexpected_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->msg_get_max_unexpected_size(na_class);
 }
 
@@ -1476,16 +1492,6 @@ NA_Msg_get_max_unexpected_size(const na_class_t *na_class)
 static NA_INLINE na_size_t
 NA_Msg_get_max_expected_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (!na_class->ops->msg_get_max_expected_size) {
-        NA_LOG_ERROR("msg_get_max_expected_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->msg_get_max_expected_size(na_class);
 }
 
@@ -1493,12 +1499,6 @@ NA_Msg_get_max_expected_size(const na_class_t *na_class)
 static NA_INLINE na_size_t
 NA_Msg_get_unexpected_header_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-#endif
     return (na_class->ops->msg_get_unexpected_header_size) ?
         na_class->ops->msg_get_unexpected_header_size(na_class) : 0;
 }
@@ -1507,12 +1507,6 @@ NA_Msg_get_unexpected_header_size(const na_class_t *na_class)
 static NA_INLINE na_size_t
 NA_Msg_get_expected_header_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-#endif
     return (na_class->ops->msg_get_expected_header_size) ?
         na_class->ops->msg_get_expected_header_size(na_class) : 0;
 }
@@ -1521,16 +1515,6 @@ NA_Msg_get_expected_header_size(const na_class_t *na_class)
 static NA_INLINE na_tag_t
 NA_Msg_get_max_tag(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (!na_class->ops->msg_get_max_tag) {
-        NA_LOG_ERROR("msg_get_max_tag plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->msg_get_max_tag(na_class);
 }
 
@@ -1541,32 +1525,6 @@ NA_Msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (dest_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_send_unexpected) {
-        NA_LOG_ERROR("msg_send_unexpected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_send_unexpected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, dest_addr, dest_id, tag, op_id);
 }
@@ -1577,28 +1535,6 @@ NA_Msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
     void *plugin_data, na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_recv_unexpected) {
-        NA_LOG_ERROR("msg_recv_unexpected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_recv_unexpected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, op_id);
 }
@@ -1610,32 +1546,6 @@ NA_Msg_send_expected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (dest_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_send_expected) {
-        NA_LOG_ERROR("msg_send_expected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_send_expected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, dest_addr, dest_id, tag, op_id);
 }
@@ -1647,32 +1557,6 @@ NA_Msg_recv_expected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_addr_t source_addr, na_uint8_t source_id,
     na_tag_t tag, na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (source_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_recv_expected) {
-        NA_LOG_ERROR("msg_recv_expected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_recv_expected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, source_addr, source_id, tag, op_id);
 }
@@ -1682,20 +1566,6 @@ static NA_INLINE na_size_t
 NA_Mem_handle_get_serialize_size(na_class_t *na_class,
     na_mem_handle_t mem_handle)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return 0;
-    }
-    if (!na_class->ops->mem_handle_get_serialize_size) {
-        NA_LOG_ERROR("mem_handle_get_serialize_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->mem_handle_get_serialize_size(na_class, mem_handle);
 }
 
@@ -1707,36 +1577,6 @@ NA_Put(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
     na_size_t data_size, na_addr_t remote_addr, na_uint8_t remote_id,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (local_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (!data_size) {
-        NA_LOG_ERROR("NULL data size");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->put) {
-        NA_LOG_ERROR("put plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->put(na_class, context, callback, arg,
         local_mem_handle, local_offset, remote_mem_handle, remote_offset,
         data_size, remote_addr, remote_id, op_id);
@@ -1750,36 +1590,6 @@ NA_Get(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
     na_size_t data_size, na_addr_t remote_addr, na_uint8_t remote_id,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (local_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (!data_size) {
-        NA_LOG_ERROR("NULL data size");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->get) {
-        NA_LOG_ERROR("get plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->get(na_class, context, callback, arg,
         local_mem_handle, local_offset, remote_mem_handle, remote_offset,
         data_size, remote_addr, remote_id, op_id);
@@ -1789,16 +1599,6 @@ NA_Get(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
 static NA_INLINE int
 NA_Poll_get_fd(na_class_t *na_class, na_context_t *context)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return -1;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return -1;
-    }
-#endif
     return (na_class->ops->na_poll_get_fd) ?
         na_class->ops->na_poll_get_fd(na_class, context) : -1;
 }
diff --git a/src/na/na_bmi.c b/src/na/na_bmi.c
index 84daf0f..95e531f 100644
--- a/src/na/na_bmi.c
+++ b/src/na/na_bmi.c
@@ -9,6 +9,7 @@
  */
 
 #include "na_plugin.h"
+#include "na_ip.h"
 
 #include "mercury_time.h"
 
@@ -23,13 +24,16 @@
 /* Local Macros */
 /****************/
 
+/* Error compat */
+#define NA_INVALID_PARAM    NA_INVALID_ARG
+#define NA_SIZE_ERROR       NA_MSGSIZE
+#define NA_NOMEM_ERROR      NA_NOMEM
+#define NA_PERMISSION_ERROR NA_PERMISSION
+#define NA_ADDRINUSE_ERROR  NA_ADDRINUSE
+
 /* Max addr name */
 #define NA_BMI_MAX_ADDR_NAME 256
 
-/* Default port */
-#define NA_BMI_DEFAULT_PORT 22222
-#define NA_BMI_DEFAULT_PORT_TRIES 128
-
 /* Msg sizes */
 #define NA_BMI_UNEXPECTED_SIZE 4096
 #define NA_BMI_EXPECTED_SIZE   NA_BMI_UNEXPECTED_SIZE
@@ -156,6 +160,7 @@ struct na_bmi_class {
     char *listen_addr;                               /* Listen addr */
     int port;                                        /* Port used */
     char *protocol_name;                             /* Protocol used for this class */
+    char pref_anyip[16];                             /* for INADDR_ANY */
     hg_thread_mutex_t test_unexpected_mutex;         /* Mutex */
     HG_QUEUE_HEAD(na_bmi_unexpected_info) unexpected_msg_queue; /* Unexpected message queue */
     hg_thread_mutex_t unexpected_msg_queue_mutex;    /* Mutex */
@@ -247,6 +252,14 @@ na_bmi_addr_dup(
         na_addr_t  *new_addr
         );
 
+/* addr_cmp */
+static na_bool_t
+na_bmi_addr_cmp(
+        na_class_t *na_class,
+        na_addr_t addr1,
+        na_addr_t addr2
+        );
+
 /* addr_is_self */
 static na_bool_t
 na_bmi_addr_is_self(
@@ -502,7 +515,7 @@ na_bmi_cancel(
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN_OPS(bmi) = {
+const struct na_class_ops NA_PLUGIN_OPS(bmi) = {
         "bmi",                                /* name */
         na_bmi_check_protocol,                /* check_protocol */
         na_bmi_initialize,                    /* initialize */
@@ -513,9 +526,12 @@ NA_PLUGIN_OPS(bmi) = {
         na_bmi_op_create,                     /* op_create */
         na_bmi_op_destroy,                    /* op_destroy */
         na_bmi_addr_lookup,                   /* addr_lookup */
+        NULL,                                 /* addr_lookup2 */
         na_bmi_addr_free,                     /* addr_free */
+        NULL,                                 /* addr_set_remove */
         na_bmi_addr_self,                     /* addr_self */
         na_bmi_addr_dup,                      /* addr_dup */
+        na_bmi_addr_cmp,                      /* addr_cmp */
         na_bmi_addr_is_self,                  /* addr_is_self */
         na_bmi_addr_to_string,                /* addr_to_string */
         NULL,                                 /* addr_get_serialize_size */
@@ -602,7 +618,7 @@ na_bmi_check_protocol(const char *protocol_name)
 
     /* Obtain the list of transport protocols supported by BMI. */
     string_length = BMI_get_info(0, BMI_TRANSPORT_METHODS_STRING, &transport);
-    
+
     if (string_length <= 0 || transport == NULL) {
         /* bmi is not configured with any plugins, transport is NULL */
         return NA_FALSE;
@@ -641,7 +657,7 @@ na_bmi_initialize(na_class_t * na_class, const struct na_info *na_info,
     char listen_addr[NA_BMI_MAX_ADDR_NAME] = {'\0'};
     char *listen_addr_p = NULL;
     char my_hostname[NA_BMI_MAX_ADDR_NAME] = {'\0'};
-    int flag = (listen) ? BMI_INIT_SERVER : 0;
+    int flag = (listen) ? (BMI_INIT_SERVER | BMI_TCP_BIND_SPECIFIC) : 0;
     na_return_t ret = NA_SUCCESS;
     int bmi_ret;
     int port = 0;
@@ -681,42 +697,51 @@ na_bmi_initialize(na_class_t * na_class, const struct na_info *na_info,
                 port = atoi(port_str);
             }
         } else {
-            /* Addr unspecified but we are in server mode; get local
-             * hostname and then cycle through range of ports until we find
-             * one that works.
+            /* Addr unspecified but we are in server mode; use INADDR_ANY
+             * and let BMI choose port.
              */
-            if (gethostname(my_hostname, NA_BMI_MAX_ADDR_NAME) < 0)
-                sprintf(my_hostname, "localhost");
+            snprintf(my_hostname, sizeof(my_hostname), "0.0.0.0");
         }
 
         /* Pick a default port */
         if (!port)
-            port = NA_BMI_DEFAULT_PORT;
+            desc_len = snprintf(listen_addr, NA_BMI_MAX_ADDR_NAME, "%s://%s",
+                na_info->protocol_name, my_hostname);
+        else
+            desc_len = snprintf(listen_addr, NA_BMI_MAX_ADDR_NAME, "%s://%s:%d",
+                na_info->protocol_name, my_hostname, port);
 
-again:
-        desc_len = snprintf(listen_addr, NA_BMI_MAX_ADDR_NAME, "%s://%s:%d",
-            na_info->protocol_name, my_hostname, port);
         if (desc_len > NA_BMI_MAX_ADDR_NAME) {
             NA_LOG_ERROR("Exceeding max addr name");
             ret = NA_SIZE_ERROR;
             goto done;
         }
+
+        /* get pref IP addr by subnet for INADDR_ANY */
+        if (strcmp(my_hostname, "0.0.0.0") == 0) {
+            uint32_t subnet = 0, netmask = 0;
+
+            if (na_info->na_init_info && na_info->na_init_info->ip_subnet) {
+                ret = na_ip_parse_subnet(na_info->na_init_info->ip_subnet,
+                    &subnet, &netmask);
+                if (ret != NA_SUCCESS) {
+                    NA_LOG_ERROR("BMI_initialize() failed - NA_Parse_subnet");
+                    goto done;
+                }
+            }
+            ret = na_ip_pref_addr(subnet, netmask,
+                NA_BMI_CLASS(na_class)->pref_anyip);
+            if (ret != NA_SUCCESS) {
+                NA_LOG_ERROR("BMI_initialize() failed - NA_Pref_ipaddr");
+                goto done;
+            }
+        }
     }
 
     /* Initialize BMI */
     bmi_ret = BMI_initialize(method_list_p, listen_addr_p, flag);
     if (bmi_ret < 0) {
-        if (bmi_ret == -BMI_EADDRINUSE) {
-            port++;
-            if (port < (NA_BMI_DEFAULT_PORT + NA_BMI_DEFAULT_PORT_TRIES))
-                /* Try another port */
-                goto again;
-            else {
-                NA_LOG_ERROR("Exceeded number of tries");
-                ret = NA_ADDRINUSE_ERROR;
-            }
-        } else
-            ret = NA_PROTOCOL_ERROR;
+        ret = NA_PROTOCOL_ERROR;
         NA_LOG_ERROR("BMI_initialize() failed");
         goto done;
     } else
@@ -1008,6 +1033,17 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static na_bool_t
+na_bmi_addr_cmp(na_class_t NA_UNUSED *na_class, na_addr_t addr1,
+    na_addr_t addr2)
+{
+    struct na_bmi_addr *na_bmi_addr1 = (struct na_bmi_addr *) addr1;
+    struct na_bmi_addr *na_bmi_addr2 = (struct na_bmi_addr *) addr2;
+
+    return (na_bmi_addr1->bmi_addr == na_bmi_addr2->bmi_addr);
+}
+
+/*---------------------------------------------------------------------------*/
+static na_bool_t
 na_bmi_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
     struct na_bmi_addr *na_bmi_addr = (struct na_bmi_addr *) addr;
@@ -1021,10 +1057,13 @@ na_bmi_addr_to_string(na_class_t *na_class, char *buf,
         na_size_t *buf_size, na_addr_t addr)
 {
     struct na_bmi_addr *na_bmi_addr = NULL;
-    char full_rev_addr[NA_BMI_MAX_ADDR_NAME] = {'\0'};
+    char full_rev_addr[NA_BMI_MAX_ADDR_NAME + 3] = {'\0'};
     const char *bmi_rev_addr;
     na_size_t string_len;
     na_return_t ret = NA_SUCCESS;
+    int listen_port = 0;
+    char *anyaddr;
+    int preflen;
 
     na_bmi_addr = (struct na_bmi_addr *) addr;
 
@@ -1035,6 +1074,31 @@ na_bmi_addr_to_string(na_class_t *na_class, char *buf,
             ret = NA_PROTOCOL_ERROR;
             goto done;
         }
+
+        /* if port was not specified, then we'll need to query BMI and
+         * append it to the listen_addr to produce something resolvable
+         * by remote peers
+         */
+        if(NA_BMI_CLASS(na_class)->port <= 0) {
+            BMI_get_info(0, BMI_TCP_GET_PORT, &listen_port);
+            snprintf(full_rev_addr, NA_BMI_MAX_ADDR_NAME + 3, "%s:%d",
+                bmi_rev_addr, listen_port);
+            /* populate state; we can reuse this next time without querying
+             * BMI or manipulating strings
+             */
+            free(NA_BMI_CLASS(na_class)->listen_addr);
+            NA_BMI_CLASS(na_class)->listen_addr = strdup(full_rev_addr);
+            NA_BMI_CLASS(na_class)->port = listen_port;
+            bmi_rev_addr = NA_BMI_CLASS(na_class)->listen_addr;
+        }
+        anyaddr = strstr(bmi_rev_addr, "://0.0.0.0:");
+        if (anyaddr) {  /* can't advertise inaddr_any */
+            preflen = (int) (anyaddr - bmi_rev_addr);
+            snprintf(full_rev_addr, sizeof(full_rev_addr), "%.*s://%s:%s",
+                preflen, bmi_rev_addr, NA_BMI_CLASS(na_class)->pref_anyip,
+                anyaddr + sizeof("://0.0.0.0:") - 1);
+            bmi_rev_addr = full_rev_addr;
+        }
     } else {
         if (na_bmi_addr->unexpected) {
             int desc_len = 0;
@@ -2288,7 +2352,7 @@ na_bmi_complete(struct na_bmi_op_id *na_bmi_op_id)
         case NA_CB_RECV_UNEXPECTED:
         {
             struct BMI_unexpected_info *unexpected_info = NULL;
- 
+
             unexpected_info =
                     na_bmi_op_id->info.recv_unexpected.unexpected_info;
 
diff --git a/src/na/na_cci.c b/src/na/na_cci.c
index 2758ad8..fabe5b1 100644
--- a/src/na/na_cci.c
+++ b/src/na/na_cci.c
@@ -28,6 +28,14 @@
 /****************/
 /* Local Macros */
 /****************/
+
+/* Error compat */
+#define NA_INVALID_PARAM    NA_INVALID_ARG
+#define NA_SIZE_ERROR       NA_MSGSIZE
+#define NA_NOMEM_ERROR      NA_NOMEM
+#define NA_PERMISSION_ERROR NA_PERMISSION
+#define NA_ADDRINUSE_ERROR  NA_ADDRINUSE
+
 /* Max tag */
 #define NA_CCI_MAX_TAG ((1 << 30) -1)
 
@@ -360,7 +368,7 @@ na_cci_cancel(na_class_t * na_class, na_context_t * context, na_op_id_t op_id);
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN_OPS(cci) = {
+const struct na_class_ops NA_PLUGIN_OPS(cci) = {
     "cci",                                  /* name */
     na_cci_check_protocol,                  /* check_protocol */
     na_cci_initialize,                      /* initialize */
@@ -371,9 +379,12 @@ NA_PLUGIN_OPS(cci) = {
     na_cci_op_create,                       /* op_create */
     na_cci_op_destroy,                      /* op_destroy */
     na_cci_addr_lookup,                     /* addr_lookup */
+    NULL,                                   /* addr_lookup2 */
     na_cci_addr_free,                       /* addr_free */
+    NULL,                                   /* addr_set_remove */
     na_cci_addr_self,                       /* addr_self */
     na_cci_addr_dup,                        /* addr_dup */
+    NULL,                                   /* addr_cmp */
     na_cci_addr_is_self,                    /* addr_is_self */
     na_cci_addr_to_string,                  /* addr_to_string */
     NULL,                                   /* addr_get_serialize_size */
@@ -626,7 +637,7 @@ na_cci_initialize(na_class_t * na_class, const struct na_info *na_info,
     }
     memset(na_class->plugin_class, 0, sizeof(struct na_cci_class));
     if (na_info->na_init_info
-        && na_info->na_init_info->progress_mode == NA_NO_BLOCK)
+        && (na_info->na_init_info->progress_mode & NA_NO_BLOCK))
         fd_p = NULL;
 
     /* Create unspecified endpoint if service is set */
diff --git a/src/na/na_config.h.in b/src/na/na_config.h.in
index effe390..17a9bdf 100644
--- a/src/na/na_config.h.in
+++ b/src/na/na_config.h.in
@@ -13,21 +13,98 @@
 #ifndef NA_CONFIG_H
 #define NA_CONFIG_H
 
-/* Import/export declarations */
+/*************************************/
+/* Public Type and Struct Definition */
+/*************************************/
+
+/* Type definitions */
+#ifdef _WIN32
+  typedef signed   __int64 na_int64_t;
+  typedef signed   __int32 na_int32_t;
+  typedef signed   __int16 na_int16_t;
+  typedef signed   __int8  na_int8_t;
+  typedef unsigned __int64 na_uint64_t;
+  typedef unsigned __int32 na_uint32_t;
+  typedef unsigned __int16 na_uint16_t;
+  typedef unsigned __int8  na_uint8_t;
+#else
+# include <stdint.h>
+# include <stddef.h>
+  typedef int64_t  na_int64_t;
+  typedef int32_t  na_int32_t;
+  typedef int16_t  na_int16_t;
+  typedef int8_t   na_int8_t;
+  typedef uint64_t na_uint64_t;
+  typedef uint32_t na_uint32_t;
+  typedef uint16_t na_uint16_t;
+  typedef uint8_t  na_uint8_t;
+#endif
+typedef na_uint8_t   na_bool_t;
+typedef na_uint64_t  na_ptr_t;
+
+/* True / false */
+#define NA_TRUE     1
+#define NA_FALSE    0
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Visibility of symbols */
 #if defined(_WIN32)
-    #define NA_ABI_IMPORT __declspec(dllimport)
-    #define NA_ABI_EXPORT __declspec(dllexport)
-    #define NA_ABI_HIDDEN
+# define NA_ABI_IMPORT __declspec(dllimport)
+# define NA_ABI_EXPORT __declspec(dllexport)
+# define NA_ABI_HIDDEN
 #elif defined(__GNUC__) && (__GNUC__ >= 4)
-    #define NA_ABI_IMPORT __attribute__((visibility("default")))
-    #define NA_ABI_EXPORT __attribute__((visibility("default")))
-    #define NA_ABI_HIDDEN __attribute__((visibility("hidden")))
+# define NA_ABI_IMPORT __attribute__((visibility("default")))
+# define NA_ABI_EXPORT __attribute__((visibility("default")))
+# define NA_ABI_HIDDEN __attribute__((visibility("hidden")))
+#else
+# define NA_ABI_IMPORT
+# define NA_ABI_EXPORT
+# define NA_ABI_HIDDEN
+#endif
+
+/* Inline macro */
+#ifdef _WIN32
+# define NA_INLINE __inline
 #else
-    #define NA_ABI_IMPORT
-    #define NA_ABI_EXPORT
-    #define NA_ABI_HIDDEN
+# define NA_INLINE __inline__
 #endif
 
+/* Unused return values */
+#if defined(__GNUC__)
+# define NA_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
+#else
+# define NA_WARN_UNUSED_RESULT
+#endif
+
+/* Fallthrough macro */
+#if defined(__GNUC__) && (__GNUC__ >= 7)
+# define NA_FALLTHROUGH() __attribute__((fallthrough))
+#else
+# define NA_FALLTHROUGH()
+#endif
+
+/* Shared libraries */
+#cmakedefine NA_BUILD_SHARED_LIBS
+#ifdef NA_BUILD_SHARED_LIBS
+# ifdef na_EXPORTS
+#  define NA_PUBLIC NA_ABI_EXPORT
+# else
+#  define NA_PUBLIC NA_ABI_IMPORT
+# endif
+# define NA_PRIVATE NA_ABI_HIDDEN
+#else
+# define NA_PUBLIC
+# define NA_PRIVATE
+#endif
+
+/* Build Options */
+#cmakedefine NA_HAS_MULTI_PROGRESS
+#cmakedefine NA_HAS_VERBOSE_ERROR
+#cmakedefine NA_HAS_DEBUG
+
 /* BMI */
 #cmakedefine NA_HAS_BMI
 
@@ -49,66 +126,4 @@
 #cmakedefine NA_SM_SHM_PREFIX "@NA_SM_SHM_PREFIX@"
 #cmakedefine NA_SM_TMP_DIRECTORY "@NA_SM_TMP_DIRECTORY@"
 
-/* Build Options */
-#cmakedefine NA_HAS_MULTI_PROGRESS
-#cmakedefine NA_HAS_VERBOSE_ERROR
-
-/* Define if build shared libraries */
-#cmakedefine NA_BUILD_SHARED_LIBS
-
-/* Define export declaration */
-#ifdef NA_BUILD_SHARED_LIBS
-    #ifdef na_EXPORTS
-      #define NA_EXPORT NA_ABI_EXPORT
-    #else
-      #define NA_EXPORT NA_ABI_IMPORT
-    #endif
-#else
-    #define NA_EXPORT
-#endif
-
-/* Standard types */
-#ifdef _WIN32
-    typedef signed   __int64 na_int64_t;
-    typedef signed   __int32 na_int32_t;
-    typedef signed   __int16 na_int16_t;
-    typedef signed   __int8  na_int8_t;
-    typedef unsigned __int64 na_uint64_t;
-    typedef unsigned __int32 na_uint32_t;
-    typedef unsigned __int16 na_uint16_t;
-    typedef unsigned __int8  na_uint8_t;
-#else
-    #include <stdint.h>
-    #include <stddef.h>
-    typedef int64_t  na_int64_t;
-    typedef int32_t  na_int32_t;
-    typedef int16_t  na_int16_t;
-    typedef int8_t   na_int8_t;
-    typedef uint64_t na_uint64_t;
-    typedef uint32_t na_uint32_t;
-    typedef uint16_t na_uint16_t;
-    typedef uint8_t  na_uint8_t;
-#endif
-typedef na_uint8_t   na_bool_t;
-typedef na_uint64_t  na_ptr_t;
-
-/* Inline declarations */
-#ifdef _WIN32
-   #define NA_INLINE __inline
-#else
-   #define NA_INLINE __inline__
-#endif
-
-/* Unused return values */
-#if defined(__GNUC__)
-    #define NA_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
-#else
-    #define NA_WARN_UNUSED_RESULT
-#endif
-
-/* Return codes */
-#define NA_TRUE     1
-#define NA_FALSE    0
-
 #endif /* NA_CONFIG_H */
-
diff --git a/src/na/na_error.h b/src/na/na_error.h
index f04adb0..20c7f52 100644
--- a/src/na/na_error.h
+++ b/src/na/na_error.h
@@ -15,18 +15,89 @@
 
 /* Default error macro */
 #ifdef NA_HAS_VERBOSE_ERROR
-  #include <mercury_log.h>
-  #define NA_LOG_MODULE_NAME "NA"
-  #define NA_LOG_ERROR(...)                                 \
-      HG_LOG_WRITE_ERROR(NA_LOG_MODULE_NAME, __VA_ARGS__)
-  #define NA_LOG_DEBUG(...)                                 \
-      HG_LOG_WRITE_DEBUG(NA_LOG_MODULE_NAME, __VA_ARGS__)
-  #define NA_LOG_WARNING(...)                               \
-      HG_LOG_WRITE_WARNING(NA_LOG_MODULE_NAME, __VA_ARGS__)
+# include <mercury_log.h>
+# define NA_LOG_MASK na_log_mask
+/* Log mask will be initialized in init routine */
+extern NA_PRIVATE unsigned int NA_LOG_MASK;
+# define NA_LOG_MODULE_NAME "NA"
+# define NA_LOG_ERROR(...) do {                                 \
+    if (NA_LOG_MASK & HG_LOG_TYPE_ERROR)                        \
+        HG_LOG_WRITE_ERROR(NA_LOG_MODULE_NAME, __VA_ARGS__);    \
+} while (0)
+# ifdef NA_HAS_DEBUG
+#  define NA_LOG_DEBUG(...) do {                                \
+    if (NA_LOG_MASK & HG_LOG_TYPE_DEBUG)                        \
+        HG_LOG_WRITE_DEBUG(NA_LOG_MODULE_NAME, __VA_ARGS__);    \
+} while (0)
+# else
+#  define NA_LOG_DEBUG(...)     (void)0
+# endif
+# define NA_LOG_WARNING(...) do {                               \
+    if (NA_LOG_MASK & HG_LOG_TYPE_WARNING)                      \
+        HG_LOG_WRITE_WARNING(NA_LOG_MODULE_NAME, __VA_ARGS__);  \
+} while (0)
 #else
-  #define NA_LOG_ERROR(...) (void)0
-  #define NA_LOG_DEBUG(...) (void)0
-  #define NA_LOG_WARNING(...) (void)0
+# define NA_LOG_ERROR(...)      (void)0
+# define NA_LOG_DEBUG(...)      (void)0
+# define NA_LOG_WARNING(...)    (void)0
 #endif
 
+/* Branch predictor hints */
+#ifndef _WIN32
+# define likely(x)       __builtin_expect(!!(x), 1)
+# define unlikely(x)     __builtin_expect(!!(x), 0)
+#else
+# define likely(x)       (x)
+# define unlikely(x)     (x)
+#endif
+
+/* Error macros */
+#define NA_GOTO_DONE(label, ret, ret_val) do {                  \
+    ret = ret_val;                                              \
+    goto label;                                                 \
+} while (0)
+
+#define NA_GOTO_ERROR(label, ret, err_val, ...) do {            \
+    NA_LOG_ERROR(__VA_ARGS__);                                  \
+    ret = err_val;                                              \
+    goto label;                                                 \
+} while (0)
+
+/* Check for na_ret value and goto label */
+#define NA_CHECK_NA_ERROR(label, na_ret, ...) do {              \
+    if (unlikely(na_ret != NA_SUCCESS)) {                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+/* Check for cond, set ret to err_val and goto label */
+#define NA_CHECK_ERROR(cond, label, ret, err_val, ...) do {     \
+    if (unlikely(cond)) {                                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+        ret = err_val;                                          \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define NA_CHECK_ERROR_NORET(cond, label, ...) do {             \
+    if (unlikely(cond)) {                                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define NA_CHECK_ERROR_DONE(cond, ...) do {                     \
+    if (unlikely(cond)) {                                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+    }                                                           \
+} while (0)
+
+/* Check for cond and print warning */
+#define NA_CHECK_WARNING(cond, ...) do {                        \
+    if (unlikely(cond)) {                                       \
+        NA_LOG_WARNING(__VA_ARGS__);                            \
+    }                                                           \
+} while (0)
+
 #endif /* NA_ERROR_H */
diff --git a/src/na/na_ip.c b/src/na/na_ip.c
new file mode 100644
index 0000000..40faece
--- /dev/null
+++ b/src/na/na_ip.c
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#include "na_ip.h"
+#include "na_error.h"
+
+#include <ctype.h>
+#include <ifaddrs.h>
+#include <netdb.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <errno.h>
+
+/*---------------------------------------------------------------------------*/
+na_return_t
+na_ip_parse_subnet(const char *spec, na_uint32_t *netp, na_uint32_t *netmaskp)
+{
+    int addr[4], depth, nb;
+    const char *sp;
+    na_return_t ret = NA_SUCCESS;
+
+    memset(addr, 0, sizeof(addr));
+
+    /* parse the numbers in the address spec string */
+    for (sp = spec, depth = 0 ; *sp && *sp != '/' ; sp++) {
+        if (isdigit(*sp)) {
+            addr[depth] = (addr[depth] * 10) + (*sp - '0');
+            NA_CHECK_ERROR(addr[depth] > 255, done, ret, NA_INVALID_ARG,
+                "Malformed address");
+            continue;
+        }
+        NA_CHECK_ERROR(*sp != '.' || !isdigit(*(sp + 1)), done, ret,
+            NA_INVALID_ARG, "Malformed address");
+        depth++;
+        NA_CHECK_ERROR(depth > 3, done, ret, NA_INVALID_ARG,
+            "Malformed address");
+    }
+    if (*sp == '/') {
+        nb = atoi(sp + 1);
+        NA_CHECK_ERROR(nb < 1 || nb > 32, done, ret, NA_INVALID_ARG,
+            "Malformed subnet mask");
+    } else {
+        nb = (depth + 1) * 8;   /* no '/'... use depth to get network bits */
+    }
+    /* avoid right shifting by 32... it's undefined behavior */
+    *netmaskp = (nb == 32) ? 0xffffffff : ~(0xffffffff >> nb);
+    *netp = (na_uint32_t) ((addr[0] << 24) | (addr[1] << 16) |
+             (addr[2] << 8) | addr[3]) & *netmaskp;
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+na_return_t
+na_ip_pref_addr(na_uint32_t net, na_uint32_t netmask, char *outstr)
+{
+    struct ifaddrs *ifaddr, *cur;
+    struct sockaddr_in *sin;
+    uint32_t cur_ipaddr;
+    static uint32_t localhost = (127 << 24) | 1;  /* 127.0.0.1 */
+    na_return_t ret = NA_SUCCESS;
+    int rc;
+
+    rc = getifaddrs(&ifaddr);
+    NA_CHECK_ERROR(rc == -1, done, ret, NA_FAULT, "getifaddrs() failed (%s)",
+        strerror(errno));
+
+    /* walk list looking for a match */
+    for (cur = ifaddr ; cur != NULL ; cur = cur->ifa_next) {
+        if ((cur->ifa_flags & IFF_UP) == 0)
+            continue;    /* skip interfaces that are down */
+        if (cur->ifa_addr == NULL || cur->ifa_addr->sa_family != AF_INET)
+            continue;    /* skip interfaces w/o IP address */
+        sin = (struct sockaddr_in *) cur->ifa_addr;
+        cur_ipaddr = ntohl(sin->sin_addr.s_addr);
+        if (netmask) {
+            if ((cur_ipaddr & netmask) == net)
+                break;    /* got it! */
+            continue;
+        }
+        if (cur_ipaddr != localhost)
+            break;    /* no net given, randomly select first !localhost addr */
+    }
+
+    NA_CHECK_ERROR(cur == NULL, cleanup, ret, NA_ADDRNOTAVAIL,
+        "No match found for IP");
+
+    rc = getnameinfo(cur->ifa_addr, sizeof(struct sockaddr_in), outstr, 16,
+        NULL, 0, NI_NUMERICHOST);
+    NA_CHECK_ERROR(rc != 0, cleanup, ret, NA_ADDRNOTAVAIL,
+        "getnameinfo() failed (%s)", strerror(errno));
+
+cleanup:
+    freeifaddrs(ifaddr);
+
+done:
+    return ret;
+}
diff --git a/src/na/na_ip.h b/src/na/na_ip.h
new file mode 100644
index 0000000..0fa7d96
--- /dev/null
+++ b/src/na/na_ip.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#ifndef NA_IP_H
+#define NA_IP_H
+
+#include "na_types.h"
+
+/*************************************/
+/* Public Type and Struct Definition */
+/*************************************/
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Parse a subnet specification string.
+ *
+ * \param spec  [IN]    the specification string to parse
+ * \param netp  [OUT]   pointer to where to put network info
+ * \param maskp [OUT]   pointer to where to put the netmask info
+ *
+ * \return NA_SUCCESS or corresponding NA error code
+ */
+NA_PRIVATE na_return_t
+na_ip_parse_subnet(
+        const char *spec,
+        na_uint32_t *netp,
+        na_uint32_t *netmaskp
+        );
+
+/**
+ * Get preferred ip address (based on provided subnet).
+ *
+ * \param net     [IN]  desired network
+ * \param netmask [IN]  netmask for desired network, 0 if no preference given
+ * \param outstr  [OUT] result returned here (size should at least be 16 to fit)
+ *
+ * \return NA_SUCCESS or corresponding NA error code
+ */
+NA_PRIVATE na_return_t
+na_ip_pref_addr(
+        na_uint32_t net,
+        na_uint32_t netmask,
+        char *outstr
+        );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NA_IP_H */
diff --git a/src/na/na_mpi.c b/src/na/na_mpi.c
index 2ad315a..e63b8c8 100644
--- a/src/na/na_mpi.c
+++ b/src/na/na_mpi.c
@@ -25,6 +25,12 @@
 /* Local Macros */
 /****************/
 
+/* Error compat */
+#define NA_INVALID_PARAM    NA_INVALID_ARG
+#define NA_SIZE_ERROR       NA_MSGSIZE
+#define NA_NOMEM_ERROR      NA_NOMEM
+#define NA_PERMISSION_ERROR NA_PERMISSION
+
 /* MPI initialization flags */
 #define MPI_INIT_SERVER 0x01 /* set up to listen for unexpected messages */
 #define MPI_INIT_STATIC 0x10 /* set up static inter-communicator */
@@ -141,7 +147,8 @@ struct na_mpi_op_id {
     na_cb_type_t type;
     na_cb_t callback; /* Callback */
     void *arg;
-    na_bool_t completed; /* Operation completed */
+    hg_atomic_int32_t ref_count;    /* Ref count */
+    hg_atomic_int32_t completed;    /* Operation completed */
     na_bool_t canceled;  /* Operation canceled */
     union {
       struct na_mpi_info_lookup lookup;
@@ -262,6 +269,19 @@ na_mpi_finalize(
         na_class_t *na_class
         );
 
+/* op_create */
+static na_op_id_t
+na_mpi_op_create(
+        na_class_t      *na_class
+        );
+
+/* op_destroy */
+static na_return_t
+na_mpi_op_destroy(
+        na_class_t      *na_class,
+        na_op_id_t       op_id
+        );
+
 /* addr_lookup */
 static na_return_t
 na_mpi_addr_lookup(
@@ -287,6 +307,14 @@ na_mpi_addr_free(
         na_addr_t   addr
         );
 
+/* addr_cmp */
+static na_bool_t
+na_mpi_addr_cmp(
+        na_class_t *na_class,
+        na_addr_t addr1,
+        na_addr_t addr2
+        );
+
 /* addr_is_self */
 static na_bool_t
 na_mpi_addr_is_self(
@@ -531,7 +559,7 @@ na_mpi_cancel(
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN_OPS(mpi) = {
+const struct na_class_ops NA_PLUGIN_OPS(mpi) = {
         "mpi",                                /* name */
         na_mpi_check_protocol,                /* check_protocol */
         na_mpi_initialize,                    /* initialize */
@@ -539,12 +567,15 @@ NA_PLUGIN_OPS(mpi) = {
         NULL,                                 /* cleanup */
         NULL,                                 /* context_create */
         NULL,                                 /* context_destroy */
-        NULL,                                 /* op_create */
-        NULL,                                 /* op_destroy */
+        na_mpi_op_create,                     /* op_create */
+        na_mpi_op_destroy,                    /* op_destroy */
         na_mpi_addr_lookup,                   /* addr_lookup */
+        NULL,                                 /* addr_lookup2 */
         na_mpi_addr_free,                     /* addr_free */
+        NULL,                                 /* addr_set_remove */
         na_mpi_addr_self,                     /* addr_self */
         NULL,                                 /* addr_dup */
+        na_mpi_addr_cmp,                      /* addr_cmp */
         na_mpi_addr_is_self,                  /* addr_is_self */
         na_mpi_addr_to_string,                /* addr_to_string */
         NULL,                                 /* addr_get_serialize_size */
@@ -1215,6 +1246,43 @@ na_mpi_finalize(na_class_t *na_class)
 }
 
 /*---------------------------------------------------------------------------*/
+static na_op_id_t
+na_mpi_op_create(na_class_t NA_UNUSED *na_class)
+{
+    struct na_mpi_op_id *na_mpi_op_id = NULL;
+
+    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    if (!na_mpi_op_id) {
+        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
+        goto done;
+    }
+    memset(na_mpi_op_id, 0, sizeof(struct na_mpi_op_id));
+    hg_atomic_init32(&na_mpi_op_id->ref_count, 1);
+    /* Completed by default */
+    hg_atomic_init32(&na_mpi_op_id->completed, 1);
+
+done:
+    return (na_op_id_t) na_mpi_op_id;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_mpi_op_destroy(na_class_t NA_UNUSED *na_class, na_op_id_t op_id)
+{
+    struct na_mpi_op_id *na_mpi_op_id = (struct na_mpi_op_id *) op_id;
+    na_return_t ret = NA_SUCCESS;
+
+    if (hg_atomic_decr32(&na_mpi_op_id->ref_count)) {
+        /* Cannot free yet */
+        goto done;
+    }
+    free(na_mpi_op_id);
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
 static na_return_t
 na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
         na_cb_t callback, void *arg, const char *name, na_op_id_t *op_id)
@@ -1224,18 +1292,13 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     int mpi_ret;
 
-    /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_LOOKUP;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
 
     /* Allocate addr */
@@ -1256,9 +1319,6 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
     /* get port_name and remote server rank */
     na_mpi_get_port_info(name, na_mpi_addr->port_name, &na_mpi_addr->rank);
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     /* Try to connect, must prevent concurrent threads to
      * create new communicators */
     hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->accept_mutex);
@@ -1327,7 +1387,7 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
 done:
     if (ret != NA_SUCCESS) {
         free(na_mpi_addr);
-        free(na_mpi_op_id);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
 
     return ret;
@@ -1406,6 +1466,18 @@ na_mpi_addr_free(na_class_t *na_class, na_addr_t addr)
 
 /*---------------------------------------------------------------------------*/
 static na_bool_t
+na_mpi_addr_cmp(na_class_t NA_UNUSED *na_class, na_addr_t addr1,
+    na_addr_t addr2)
+{
+    struct na_mpi_addr *na_mpi_addr1 = (struct na_mpi_addr *) addr1;
+    struct na_mpi_addr *na_mpi_addr2 = (struct na_mpi_addr *) addr2;
+
+    return (na_mpi_addr1->comm == na_mpi_addr2->comm)
+        && (na_mpi_addr1->rank == na_mpi_addr2->rank);
+}
+
+/*---------------------------------------------------------------------------*/
+static na_bool_t
 na_mpi_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
     struct na_mpi_addr *na_mpi_addr = (struct na_mpi_addr *) addr;
@@ -1486,24 +1558,16 @@ na_mpi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     int mpi_ret;
 
-    /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_SEND_UNEXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.send_unexpected.data_request = MPI_REQUEST_NULL;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     mpi_ret = MPI_Isend(buf, mpi_buf_size, MPI_BYTE, mpi_addr->rank,
             mpi_tag, mpi_addr->comm,
             &na_mpi_op_id->info.send_unexpected.data_request);
@@ -1521,7 +1585,7 @@ na_mpi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1536,25 +1600,18 @@ na_mpi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
 
     /* Allocate na_op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_RECV_UNEXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.recv_unexpected.buf = buf;
     na_mpi_op_id->info.recv_unexpected.buf_size = (int) buf_size;
     na_mpi_op_id->info.recv_unexpected.remote_addr = NULL;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     /* Add op_id to queue of pending unexpected recv ops and make some progress
      * in case messages are already arrived */
     ret = na_mpi_msg_unexpected_op_push(na_class, na_mpi_op_id);
@@ -1577,7 +1634,7 @@ na_mpi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1597,23 +1654,16 @@ na_mpi_msg_send_expected(na_class_t *na_class, na_context_t *context,
     int mpi_ret;
 
     /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_SEND_EXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.send_expected.data_request = MPI_REQUEST_NULL;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     mpi_ret = MPI_Isend(buf, mpi_buf_size, MPI_BYTE, mpi_addr->rank,
             mpi_tag, mpi_addr->comm,
             &na_mpi_op_id->info.send_expected.data_request);
@@ -1631,7 +1681,7 @@ na_mpi_msg_send_expected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1651,25 +1701,18 @@ na_mpi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     int mpi_ret;
 
     /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_RECV_EXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.recv_expected.buf_size = mpi_buf_size;
     na_mpi_op_id->info.recv_expected.actual_size = 0;
     na_mpi_op_id->info.recv_expected.data_request = MPI_REQUEST_NULL;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     mpi_ret = MPI_Irecv(buf, mpi_buf_size, MPI_BYTE, mpi_addr->rank,
             mpi_tag, mpi_addr->comm,
             &na_mpi_op_id->info.recv_expected.data_request);
@@ -1687,7 +1730,7 @@ na_mpi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1846,18 +1889,13 @@ na_mpi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
             goto done;
     }
 
-    /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_PUT;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.put.rma_request = MPI_REQUEST_NULL;
     na_mpi_op_id->info.put.data_request = MPI_REQUEST_NULL;
@@ -1879,9 +1917,6 @@ na_mpi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_mpi_rma_info->tag = na_mpi_gen_rma_tag(na_class);
     na_mpi_op_id->info.put.rma_info = na_mpi_rma_info;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     /* Post the MPI send request */
     mpi_ret = MPI_Isend(na_mpi_rma_info, sizeof(struct na_mpi_rma_info),
             MPI_BYTE, na_mpi_addr->rank, NA_MPI_RMA_REQUEST_TAG,
@@ -1910,8 +1945,8 @@ na_mpi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
         free(na_mpi_rma_info);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1952,18 +1987,13 @@ na_mpi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
             goto done;
     }
 
-    /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_GET;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.get.rma_request = MPI_REQUEST_NULL;
     na_mpi_op_id->info.get.data_request = MPI_REQUEST_NULL;
@@ -1985,9 +2015,6 @@ na_mpi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_mpi_rma_info->tag = na_mpi_gen_rma_tag(na_class);
     na_mpi_op_id->info.get.rma_info = na_mpi_rma_info;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     /* Post the MPI send request */
     mpi_ret = MPI_Isend(na_mpi_rma_info, sizeof(struct na_mpi_rma_info),
             MPI_BYTE, na_mpi_addr->rank, NA_MPI_RMA_REQUEST_TAG,
@@ -2016,8 +2043,8 @@ na_mpi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
         free(na_mpi_rma_info);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -2216,7 +2243,7 @@ na_mpi_progress_unexpected_rma(na_class_t *na_class, na_context_t *context,
     }
 
     /* Allocate na_op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    na_mpi_op_id = (struct na_mpi_op_id *) na_mpi_op_create(na_class);
     if (!na_mpi_op_id) {
         NA_LOG_ERROR("Could not allocate NA MPI operation ID");
         ret = NA_NOMEM_ERROR;
@@ -2226,7 +2253,7 @@ na_mpi_progress_unexpected_rma(na_class_t *na_class, na_context_t *context,
     na_mpi_op_id->context = context;
     na_mpi_op_id->callback = NULL;
     na_mpi_op_id->arg = NULL;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
 
     switch (na_mpi_rma_info->op) {
@@ -2283,8 +2310,8 @@ na_mpi_progress_unexpected_rma(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
         free(na_mpi_rma_info);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -2309,7 +2336,7 @@ na_mpi_progress_expected(na_class_t *na_class, na_context_t NA_UNUSED *context,
         MPI_Status *status = MPI_STATUS_IGNORE;
 
         /* If the op_id is marked as completed, something is wrong */
-        if (na_mpi_op_id->completed) {
+        if (hg_atomic_get32(&na_mpi_op_id->completed)) {
             NA_LOG_ERROR("Op ID should not have completed yet");
             ret = NA_PROTOCOL_ERROR;
             goto done;
@@ -2389,7 +2416,7 @@ na_mpi_progress_expected(na_class_t *na_class, na_context_t NA_UNUSED *context,
         /* If internal operation call release directly otherwise add callback
          * to completion queue */
         if (internal) {
-            na_mpi_op_id->completed = NA_TRUE;
+            hg_atomic_set32(&na_mpi_op_id->completed, 1);
             /* Remove entry from list */
             HG_LIST_REMOVE(na_mpi_op_id, entry);
 
@@ -2428,7 +2455,7 @@ na_mpi_complete(struct na_mpi_op_id *na_mpi_op_id)
     int mpi_ret;
 
     /* Mark op id as completed */
-    na_mpi_op_id->completed = NA_TRUE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 1);
 
     /* Init callback info */
     callback_info = &na_mpi_op_id->completion_data.callback_info;
@@ -2551,10 +2578,10 @@ na_mpi_release(void *arg)
 {
     struct na_mpi_op_id *na_mpi_op_id = (struct na_mpi_op_id *) arg;
 
-    if (na_mpi_op_id && !na_mpi_op_id->completed) {
-        NA_LOG_ERROR("Releasing resources from an uncompleted operation");
+    if (na_mpi_op_id && !hg_atomic_get32(&na_mpi_op_id->completed)) {
+        NA_LOG_WARNING("Releasing resources from an uncompleted operation");
     }
-    free(na_mpi_op_id);
+    na_mpi_op_destroy(NULL, (na_op_id_t) na_mpi_op_id);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2566,8 +2593,8 @@ na_mpi_cancel(na_class_t *na_class, na_context_t NA_UNUSED *context,
     na_return_t ret = NA_SUCCESS;
     int mpi_ret;
 
-    /* TODO make this atomic */
-    if (na_mpi_op_id->completed) goto done;
+    if (hg_atomic_get32(&na_mpi_op_id->completed))
+        goto done;
 
     switch (na_mpi_op_id->type) {
         case NA_CB_LOOKUP:
diff --git a/src/na/na_mpi.h b/src/na/na_mpi.h
index 7014760..cc9ae46 100644
--- a/src/na/na_mpi.h
+++ b/src/na/na_mpi.h
@@ -28,7 +28,7 @@ extern "C" {
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_MPI_Set_init_intra_comm(MPI_Comm intra_comm);
 
 /**
@@ -39,7 +39,7 @@ NA_MPI_Set_init_intra_comm(MPI_Comm intra_comm);
  *
  * \return Pointer to string
  */
-NA_EXPORT const char *
+NA_PUBLIC const char *
 NA_MPI_Get_port_name(
         na_class_t *na_class
         );
diff --git a/src/na/na_ofi.c b/src/na/na_ofi.c
index aca1919..6c95eaa 100644
--- a/src/na/na_ofi.c
+++ b/src/na/na_ofi.c
@@ -74,8 +74,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#undef NDEBUG /* for assert */
-#include <assert.h>
 #include <unistd.h>
 #include <inttypes.h>
 #include <sys/uio.h> /* for struct iovec */
@@ -99,17 +97,17 @@
  * provider) 
  */
 /* requires domain verification in addition to provider match */
-#define NA_OFI_VERIFY_PROV_DOM (1<<0) 
+#define NA_OFI_VERIFY_PROV_DOM          (1 << 0)
 /* supports FI_WAIT_SET */
-#define NA_OFI_WAIT_SET        (1<<1)
+#define NA_OFI_WAIT_SET                 (1 << 1)
 /* supports FI_WAIT_FD */
-#define NA_OFI_WAIT_FD         (1<<2)
+#define NA_OFI_WAIT_FD                  (1 << 2)
 /* workaround to prevent calling fi_signal() for this provider */
-#define NA_OFI_SKIP_SIGNAL     (1<<4)
+#define NA_OFI_SKIP_SIGNAL              (1 << 4)
 /* workaround to serialize access to ofi domain */
-#define NA_OFI_DOMAIN_LOCK     (1<<5)
+#define NA_OFI_DOMAIN_LOCK              (1 << 5)
 /* disable scalable endpoint support */
-#define NA_OFI_NO_SEP          (1<<6)
+#define NA_OFI_NO_SEP                   (1 << 6)
 
 /* X-macro to define the following for each supported provider:
  * - enum type
@@ -130,15 +128,15 @@
         "",                                                             \
         FI_SOCKADDR_IN,                                                 \
         FI_PROGRESS_AUTO,                                               \
-        FI_DIRECTED_RECV,                                               \
+        (FI_SOURCE | FI_DIRECTED_RECV),                                 \
         (NA_OFI_VERIFY_PROV_DOM | NA_OFI_WAIT_FD)                       \
     )                                                                   \
     X(NA_OFI_PROV_TCP,                                                  \
         "tcp;ofi_rxm",                                                  \
         "tcp",                                                          \
         FI_SOCKADDR_IN,                                                 \
-        FI_PROGRESS_MANUAL,                                             \
-        FI_DIRECTED_RECV,                                               \
+        FI_PROGRESS_AUTO,                                               \
+        (FI_SOURCE | FI_DIRECTED_RECV),                                 \
         (NA_OFI_WAIT_FD | NA_OFI_NO_SEP | NA_OFI_SKIP_SIGNAL)           \
     )                                                                   \
     X(NA_OFI_PROV_PSM2,                                                 \
@@ -154,7 +152,7 @@
         "verbs",                                                        \
         FI_SOCKADDR_IN,                                                 \
         FI_PROGRESS_MANUAL,                                             \
-        (FI_DIRECTED_RECV),                                             \
+        (FI_SOURCE | FI_DIRECTED_RECV),                                 \
         (NA_OFI_VERIFY_PROV_DOM | NA_OFI_WAIT_FD | NA_OFI_NO_SEP | NA_OFI_SKIP_SIGNAL)   \
     )                                                                   \
     X(NA_OFI_PROV_GNI,                                                  \
@@ -171,10 +169,10 @@
 enum na_ofi_prov_type { NA_OFI_PROV_TYPES };
 #undef X
 #define X(a, b, c, d, e, f, g) b,
-static char * const na_ofi_prov_name[] = { NA_OFI_PROV_TYPES };
+static const char * const na_ofi_prov_name[] = { NA_OFI_PROV_TYPES };
 #undef X
 #define X(a, b, c, d, e, f, g) c,
-static char * const na_ofi_prov_alt_name[] = { NA_OFI_PROV_TYPES };
+static const char *const na_ofi_prov_alt_name[] = { NA_OFI_PROV_TYPES };
 #undef X
 #define X(a, b, c, d, e, f, g) d,
 static na_uint32_t const na_ofi_prov_addr_format[] = { NA_OFI_PROV_TYPES };
@@ -191,42 +189,50 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 
 /* Address / URI max len */
 #define NA_OFI_MAX_URI_LEN              (128)
-#define NA_OFI_GNI_AV_STR_ADDR_VERSION  1
+#define NA_OFI_GNI_AV_STR_ADDR_VERSION  (1)
 #define NA_OFI_GNI_IFACE_DEFAULT        "ipogif0"
 
 /* Memory pool (enabled by default, comment out to disable) */
 #define NA_OFI_HAS_MEM_POOL
-#define NA_OFI_MEM_BLOCK_COUNT  (256)
+#define NA_OFI_MEM_BLOCK_COUNT          (256)
 
 /* Max tag */
-#define NA_OFI_MAX_TAG          ((1 << 30) -1)
+#define NA_OFI_MAX_TAG                  UINT32_MAX
 
 /* Unexpected size */
-#define NA_OFI_UNEXPECTED_SIZE          4096
-#define NA_OFI_EXPECTED_TAG_FLAG        (0x100000000ULL)
-#define NA_OFI_UNEXPECTED_TAG_IGNORE    (0x0FFFFFFFFULL)
+#define NA_OFI_UNEXPECTED_SIZE          (4096)
+#define NA_OFI_UNEXPECTED_TAG           (0x100000000ULL)
+#define NA_OFI_TAG_MASK                 (0xFFFFFFFFULL)
 
 /* Number of CQ event provided for fi_cq_read() */
-#define NA_OFI_CQ_EVENT_NUM     (16)
+#define NA_OFI_CQ_EVENT_NUM             (16)
 /* CQ depth (the socket provider's default value is 256 */
-#define NA_OFI_CQ_DEPTH         (8192)
+#define NA_OFI_CQ_DEPTH                 (8192)
 /* CQ max err data size (fix to 48 to work around bug in gni provider code) */
-#define NA_OFI_CQ_MAX_ERR_DATA_SIZE (48)
+#define NA_OFI_CQ_MAX_ERR_DATA_SIZE     (48)
 
-/* The magic number for na_ofi_op_id verification */
-#define NA_OFI_OP_ID_MAGIC_1    (0x1928374655627384ULL)
-#define NA_OFI_OP_ID_MAGIC_2    (0x8171615141312111ULL)
+/* Number of retries when receiving FI_EINTR error */
+#define NA_OFI_MAX_EINTR_RETRY          (1000)
 
 /* The predefined RMA KEY for MR_SCALABLE */
-#define NA_OFI_RMA_KEY          (0x0F1B0F1BULL)
+#define NA_OFI_RMA_KEY                  (0x0F1B0F1BULL)
+
+/* The completion flags for PUT/GET operations */
+#define NA_OFI_PUT_COMPLETION           (FI_COMPLETION | FI_DELIVERY_COMPLETE)
+#define NA_OFI_GET_COMPLETION           (FI_COMPLETION)
 
 /* Receive context bits for SEP */
-#define NA_OFI_SEP_RX_CTX_BITS  (8)
+#define NA_OFI_SEP_RX_CTX_BITS          (8)
+
+/* Op ID status bits */
+#define NA_OFI_OP_COMPLETED             (1 << 0)
+#define NA_OFI_OP_CANCELED              (1 << 1)
+#define NA_OFI_OP_QUEUED                (1 << 2)
 
 /* Private data access */
-#define NA_OFI_CLASS(na_class) \
+#define NA_OFI_CLASS(na_class)      \
     ((struct na_ofi_class *)((na_class)->plugin_class))
-#define NA_OFI_CONTEXT(na_context)    \
+#define NA_OFI_CONTEXT(na_context)  \
     ((struct na_ofi_context *)((na_context)->plugin_context))
 
 /************************************/
@@ -235,13 +241,14 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 
 /* Address */
 struct na_ofi_addr {
-    void *addr;                 /* Native address */
-    na_size_t addrlen;          /* Native address len */
-    char *uri;                  /* Generated URI */
-    fi_addr_t fi_addr;          /* FI address */
-    hg_atomic_int32_t refcount; /* Reference counter (dup/free)  */
-    na_bool_t self;             /* Boolean for self */
-    na_bool_t unexpected;       /* Boolean for unexpected (no uri/addr) */
+    struct na_ofi_domain *domain;           /* Domain                   */
+    void *addr;                             /* Native address           */
+    na_size_t addrlen;                      /* Native address len       */
+    char *uri;                              /* Generated URI            */
+    fi_addr_t fi_addr;                      /* FI address               */
+    na_uint64_t ht_key;                     /* Key in hash-table        */
+    hg_atomic_int32_t refcount;             /* Reference counter        */
+    na_bool_t remove;                       /* Remove from AV on free   */
 };
 
 /* SIN address */
@@ -258,17 +265,17 @@ struct na_ofi_psm2_addr {
 /* GNI address */
 struct na_ofi_gni_addr {
     struct {
-        na_uint32_t device_addr;        /* physical NIC address */
-        na_uint32_t cdm_id;             /* user supplied id */
+        na_uint32_t device_addr;            /* physical NIC address     */
+        na_uint32_t cdm_id;                 /* user supplied id         */
     };
     struct {
-        na_uint32_t name_type : 8;      /* bound, unbound, SEP name types */
-        na_uint32_t cm_nic_cdm_id : 24; /* CM nic ID */
-        na_uint32_t cookie;             /* communication domain identifier */
+        na_uint32_t name_type : 8;          /* bound, unbound           */
+        na_uint32_t cm_nic_cdm_id : 24;     /* CM nic ID                */
+        na_uint32_t cookie;                 /* CDM identifier           */
     };
     struct {
-        na_uint32_t rx_ctx_cnt : 8;     /* number of contexts */
-        na_uint32_t key_offset : 12;    /* auth key offset */
+        na_uint32_t rx_ctx_cnt : 8;         /* number of contexts       */
+        na_uint32_t key_offset : 12;        /* auth key offset          */
         na_uint32_t unused1 : 12;
         na_uint32_t unused2;
     };
@@ -277,121 +284,106 @@ struct na_ofi_gni_addr {
 
 /* Memory handle */
 struct na_ofi_mem_desc {
-    na_uint64_t mr_key;                 /* FI MR key */
-    na_ptr_t    base;                   /* Base address of memory */
-    na_size_t   size;                   /* Size of registered region */
-    na_uint8_t  attr;                   /* Flag of operation access */
+    na_uint64_t fi_mr_key;                  /* FI MR key                */
+    na_ptr_t    base;                       /* Base address of memory   */
+    na_size_t   size;                       /* Size of region           */
+    na_uint8_t  attr;                       /* Flag of operation access */
 };
 
 struct na_ofi_mem_handle {
-    struct na_ofi_mem_desc desc;        /* Memory descriptor */
-    struct fid_mr *mr_hdl;              /* FI MR handle */
+    struct na_ofi_mem_desc desc;            /* Memory descriptor        */
+    struct fid_mr *fi_mr;                   /* FI MR handle             */
 };
 
-/* Lookup info */
-struct na_ofi_info_lookup {
-    na_addr_t noi_addr;
-};
-
-/* Unexpected recv info */
-struct na_ofi_info_recv_unexpected {
-    void *noi_buf;
-    na_size_t noi_buf_size;
-    na_size_t noi_msg_size;
-    na_tag_t noi_tag;
+/* Msg info */
+struct na_ofi_msg_info {
+    union {
+        const void *const_ptr;
+        void *ptr;
+    } buf;
+    struct fid_mr *fi_mr;
+    size_t buf_size;
+    na_size_t actual_buf_size;
+    fi_addr_t fi_addr;
+    na_tag_t tag;
 };
 
-/* Expected recv info */
-struct na_ofi_info_recv_expected {
-    void *noi_buf;
-    na_size_t noi_buf_size;
-    na_size_t noi_msg_size;
-    na_tag_t noi_tag;
+/* RMA info */
+struct na_ofi_rma_info {
+    struct fi_msg_rma fi_rma;
+    struct fi_rma_iov remote_iov;
+    struct iovec local_iov;
+    void *local_desc;
 };
 
 /* Operation ID */
 struct na_ofi_op_id {
-    /* noo_magic_1 and noo_magic_2 are for data verification */
-    na_uint64_t noo_magic_1;
-    na_context_t *noo_context;
-    struct fi_context noo_fi_ctx;
-    struct na_cb_completion_data noo_completion_data;
-    struct na_ofi_addr *noo_addr;
-    hg_atomic_int32_t noo_completed;/* Operation completed */
-    hg_atomic_int32_t noo_canceled; /* Operation canceled  */
+    struct na_cb_completion_data completion_data; /* Completion data    */
     union {
-        struct na_ofi_info_lookup noo_lookup;
-        struct na_ofi_info_recv_unexpected noo_recv_unexpected;
-        struct na_ofi_info_recv_expected noo_recv_expected;
-    } noo_info;
-    hg_atomic_int32_t noo_refcount; /* Ref count */
-    HG_QUEUE_ENTRY(na_ofi_op_id) noo_entry;
-    na_uint64_t noo_magic_2;
+        struct na_ofi_msg_info msg;
+        struct na_ofi_rma_info rma;
+    } info;                                 /* Op info                  */
+    HG_QUEUE_ENTRY(na_ofi_op_id) entry;     /* Entry in queue           */
+    struct fi_context fi_ctx;               /* Context handle           */
+    na_context_t *context;                  /* NA context associated    */
+    struct na_ofi_addr *addr;               /* Address associated       */
+    hg_atomic_int32_t status;               /* Operation status         */
+    hg_atomic_int32_t refcount;             /* Refcount                 */
 };
 
 /* Op queue */
 struct na_ofi_queue {
-    hg_thread_spin_t noq_lock;
-    HG_QUEUE_HEAD(na_ofi_op_id) noq_queue;
+    hg_thread_mutex_t mutex;
+    HG_QUEUE_HEAD(na_ofi_op_id) queue;
 };
 
 /* Context */
 struct na_ofi_context {
-    na_uint8_t      noc_idx; /* context index, [0, nop_max_contexts - 1] */
-    struct fid_ep   *noc_tx; /* Transmit context */
-    struct fid_ep   *noc_rx; /* Receive context */
-    struct fid_cq   *noc_cq; /* CQ for basic ep or tx/rx context for sep */
-    struct fid_wait *noc_wait;  /* Wait set handle */
-    /* Unexpected op queue per context for scalable endpoint, for regular
-     * endpoint just a reference to per class op queue. */
-    struct na_ofi_queue *noc_unexpected_op_queue;
+    struct fid_ep *fi_tx;                   /* Transmit context handle  */
+    struct fid_ep *fi_rx;                   /* Receive context handle   */
+    struct fid_cq *fi_cq;                   /* CQ handle                */
+    struct fid_wait *fi_wait;               /* Wait set handle          */
+    struct na_ofi_queue *retry_op_queue;    /* Retry op queue           */
+    na_uint8_t idx;                         /* Context index            */
 };
 
 /* Endpoint */
 struct na_ofi_endpoint {
-    struct na_ofi_addr *noe_addr;/* Endpoint address */
-    struct fi_info *noe_prov;   /* OFI provider info */
-    struct fid_ep *noe_ep;      /* Endpoint to communicate on */
-    struct fid_cq *noe_cq;      /* Completion queue handle, invalid for sep */
-    struct fid_wait *noe_wait;  /* Wait set handle, invalid for sep */
-    /* Unexpected op queue for regular endpoint */
-    struct na_ofi_queue *noe_unexpected_op_queue;
-    na_bool_t noe_sep;          /* True for SEP, false for basic EP */
+    struct na_ofi_addr *src_addr;           /* Endpoint address         */
+    struct fi_info *fi_prov;                /* Provider info            */
+    struct fid_ep *fi_ep;                   /* Endpoint handle          */
+    struct fid_wait *fi_wait;               /* Wait set handle          */
+    struct fid_cq *fi_cq;                   /* CQ handle                */
+    struct na_ofi_queue *retry_op_queue;    /* Retry op queue           */
+    na_bool_t sep;                          /* Scalable endpoint        */
 };
 
 /* Domain */
 struct na_ofi_domain {
-    enum na_ofi_prov_type nod_prov_type;    /* OFI provider type */
-    char *nod_prov_name;                    /* OFI provider name */
+    hg_thread_mutex_t mutex;                /* Mutex for AV etc         */
+    hg_thread_rwlock_t rwlock;              /* RW lock for addr_ht      */
+    HG_LIST_ENTRY(na_ofi_domain) entry;     /* Entry in domain list     */
 #ifdef NA_OFI_HAS_EXT_GNI_H
-    struct fi_gni_auth_key fi_gni_auth_key; /* GNI auth key */
+    struct fi_gni_auth_key fi_gni_auth_key; /* GNI auth key             */
 #endif
-    struct fi_info *nod_prov;               /* OFI provider info */
-    struct fid_fabric *nod_fabric;          /* Fabric domain handle */
-    struct fid_domain *nod_domain;          /* Access domain handle */
-    /* Memory region handle, only valid for MR_SCALABLE */
-    struct fid_mr *nod_mr;
-    na_uint64_t nod_mr_key;                 /* FI MR key */
-    struct fid_av *nod_av;                  /* Address vector handle */
-    /* mutex to protect per domain resource like av */
-    hg_thread_mutex_t nod_mutex;
-    /*
-     * Address hash-table, to map the source-side address to fi_addr_t.
-     * The key is 64bits value serialized from source-side IP+Port (see
-     * na_ofi_reqhdr_2_key), the value is fi_addr_t.
-     */
-    hg_hash_table_t *nod_addr_ht;
-    hg_thread_rwlock_t nod_rwlock;          /* RW lock to protect nod_addr_ht */
-    hg_atomic_int32_t nod_refcount;         /* Refcount of this domain */
-    HG_LIST_ENTRY(na_ofi_domain) nod_entry; /* Entry in nog_domain_list */
+    struct fid_fabric *fi_fabric;           /* Fabric handle            */
+    struct fid_domain *fi_domain;           /* Domain handle            */
+    struct fi_info *fi_prov;                /* Provider info            */
+    struct fid_mr *fi_mr;                   /* Global MR handle         */
+    na_uint64_t fi_mr_key;                  /* Global MR key            */
+    struct fid_av *fi_av;                   /* Address vector handle    */
+    hg_hash_table_t *addr_ht;               /* Address hash_table       */
+    char *prov_name;                        /* Provider name            */
+    enum na_ofi_prov_type prov_type;        /* Provider type            */
+    hg_atomic_int32_t refcount;             /* Refcount of this domain  */
 };
 
 /**
  * Memory node (points to actual data).
  */
 struct na_ofi_mem_node {
-    HG_QUEUE_ENTRY(na_ofi_mem_node) entry;  /* Entry in node_list */
-    char *block;                            /* Must be last */
+    HG_QUEUE_ENTRY(na_ofi_mem_node) entry;  /* Entry in node_list       */
+    char *block;                            /* Must be last             */
 };
 
 /**
@@ -400,25 +392,24 @@ struct na_ofi_mem_node {
  * functions.
  */
 struct na_ofi_mem_pool {
-    HG_QUEUE_ENTRY(na_ofi_mem_pool) entry;      /* Entry in pool list */
-    struct fid_mr *mr_hdl;                      /* MR handle */
-    na_size_t block_size;                       /* Node block size */
-    hg_thread_spin_t node_list_lock;            /* Node list lock */
-    HG_QUEUE_HEAD(na_ofi_mem_node) node_list;   /* Node list */
+    HG_QUEUE_HEAD(na_ofi_mem_node) node_list;   /* Node list            */
+    HG_QUEUE_ENTRY(na_ofi_mem_pool) entry;  /* Entry in pool list       */
+    struct fid_mr *mr_hdl;                  /* MR handle                */
+    na_size_t block_size;                   /* Node block size          */
+    hg_thread_spin_t node_list_lock;        /* Node list lock           */
 };
 
 /* Private data */
 struct na_ofi_class {
-    struct na_ofi_domain *nop_domain; /* Point back to access domain */
-    struct na_ofi_endpoint *nop_endpoint;
-    na_bool_t nop_listen; /* flag of listening, true for server */
-    na_uint8_t nop_contexts; /* number of context */
-    na_uint8_t nop_max_contexts; /* max number of contexts */
-    /* nop_mutex only used for verbs provider as it is not thread safe now */
-    hg_thread_mutex_t nop_mutex;
-    HG_QUEUE_HEAD(na_ofi_mem_pool) nop_buf_pool;    /* Msg buf pool head */
-    hg_thread_spin_t nop_buf_pool_lock;             /* Buf pool lock */
-    na_bool_t no_wait; /* Ignore wait object */
+    hg_thread_mutex_t mutex;                /* Mutex (for verbs prov)   */
+    HG_QUEUE_HEAD(na_ofi_mem_pool) buf_pool;/* Msg buf pool head        */
+    struct na_ofi_domain *domain;           /* Domain pointer           */
+    struct na_ofi_endpoint *endpoint;       /* Endpoint pointer         */
+    hg_thread_spin_t buf_pool_lock;         /* Buf pool lock            */
+    na_uint8_t contexts;                    /* Number of context        */
+    na_uint8_t max_contexts;                /* Max number of contexts   */
+    na_bool_t no_wait;                      /* Ignore wait object       */
+    na_bool_t no_retry;                     /* Do not retry operations  */
 };
 
 /********************/
@@ -504,13 +495,28 @@ na_ofi_addr_ht_key_equal(hg_hash_table_key_t vlocation1,
  * already exist.
  */
 static na_return_t
-na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
-    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr);
+na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
+    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key);
+
+/**
+ * Remove an addr from the AV and the hash-table.
+ */
+static na_return_t
+na_ofi_addr_ht_remove(struct na_ofi_domain *domain, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key);
+
+/**
+ * Lookup an FI addr from the AV.
+ */
+static na_return_t
+na_ofi_av_lookup(struct na_ofi_domain *na_ofi_domain, fi_addr_t fi_addr,
+    void **addr_ptr, size_t *addrlen_ptr);
 
 /**
  * Get info caps from providers and return matching providers.
  */
-static int
+static na_return_t
 na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers);
 
 /**
@@ -601,7 +607,7 @@ na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr);
  * Allocate address.
  */
 static struct na_ofi_addr *
-na_ofi_addr_alloc(void);
+na_ofi_addr_alloc(struct na_ofi_domain *na_ofi_domain);
 
 /**
  * Increment address refcount.
@@ -666,45 +672,18 @@ static NA_INLINE void
 na_ofi_op_id_decref(struct na_ofi_op_id *na_ofi_op_id);
 
 /**
- * OP ID is valid.
- */
-static NA_INLINE na_bool_t
-na_ofi_op_id_valid(struct na_ofi_op_id *na_ofi_op_id);
-
-/**
- * Push OP ID to unexpected queue.
- */
-static NA_INLINE void
-na_ofi_msg_unexpected_op_push(na_context_t *context,
-    struct na_ofi_op_id *na_ofi_op_id);
-
-/**
- * Remove OP ID from unexpected queue.
- */
-static NA_INLINE void
-na_ofi_msg_unexpected_op_remove(na_context_t *context,
-    struct na_ofi_op_id *na_ofi_op_id);
-
-/**
- * Pop and return first OP ID from unexpected queue.
- */
-static NA_INLINE struct na_ofi_op_id *
-na_ofi_msg_unexpected_op_pop(na_context_t *context);
-
-/**
  * Read from CQ.
  */
 static na_return_t
-na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
-    size_t max_count, struct fi_cq_tagged_entry cq_events[],
-    fi_addr_t src_addrs[], void **src_err_addr, size_t *src_err_addrlen,
-    size_t *actual_count);
+na_ofi_cq_read(na_context_t *context, size_t max_count,
+    struct fi_cq_tagged_entry cq_events[], fi_addr_t src_addrs[],
+    void **src_err_addr, size_t *src_err_addrlen, size_t *actual_count);
 
 /**
  * Process event from CQ.
  */
 static na_return_t
-na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
+na_ofi_cq_process_event(na_class_t *na_class,
     const struct fi_cq_tagged_entry *cq_event, fi_addr_t src_addr,
     void *err_addr, size_t err_addrlen);
 
@@ -719,7 +698,7 @@ na_ofi_cq_process_send_event(struct na_ofi_op_id *na_ofi_op_id);
  */
 static na_return_t
 na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
-    na_context_t *context, struct na_ofi_op_id *na_ofi_op_id,
+    struct na_ofi_op_id *na_ofi_op_id,
     fi_addr_t src_addr, void *src_err_addr, size_t src_err_addrlen,
     uint64_t tag, size_t len);
 
@@ -737,10 +716,16 @@ static NA_INLINE na_return_t
 na_ofi_cq_process_rma_event(struct na_ofi_op_id *na_ofi_op_id);
 
 /**
+ * Process retries.
+ */
+static na_return_t
+na_ofi_cq_process_retries(na_context_t *context);
+
+/**
  * Complete operation ID.
  */
 static na_return_t
-na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id, na_return_t ret);
+na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id);
 
 /**
  * Release OP ID resources.
@@ -783,8 +768,15 @@ na_ofi_op_destroy(na_class_t *na_class, na_op_id_t op_id);
 
 /* addr_lookup */
 static na_return_t
-na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, const char *name, na_op_id_t *op_id);
+na_ofi_addr_lookup(na_class_t *na_class, const char *name, na_addr_t *addr);
+
+/* addr_free */
+static NA_INLINE na_return_t
+na_ofi_addr_free(na_class_t *na_class, na_addr_t addr);
+
+/* addr_set_remove */
+static NA_INLINE na_return_t
+na_ofi_addr_set_remove(na_class_t *na_class, na_addr_t addr);
 
 /* addr_self */
 static NA_INLINE na_return_t
@@ -794,9 +786,9 @@ na_ofi_addr_self(na_class_t *na_class, na_addr_t *addr);
 static NA_INLINE na_return_t
 na_ofi_addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr);
 
-/* addr_free */
-static NA_INLINE na_return_t
-na_ofi_addr_free(na_class_t *na_class, na_addr_t addr);
+/* addr_dup */
+static na_bool_t
+na_ofi_addr_cmp(na_class_t *na_class, na_addr_t addr1, na_addr_t addr2);
 
 /* addr_is_self */
 static NA_INLINE na_bool_t
@@ -940,7 +932,7 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context, na_op_id_t op_id);
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN_OPS(ofi) = {
+const struct na_class_ops NA_PLUGIN_OPS(ofi) = {
     "ofi",                                  /* name */
     na_ofi_check_protocol,                  /* check_protocol */
     na_ofi_initialize,                      /* initialize */
@@ -950,10 +942,13 @@ NA_PLUGIN_OPS(ofi) = {
     na_ofi_context_destroy,                 /* context_destroy */
     na_ofi_op_create,                       /* op_create */
     na_ofi_op_destroy,                      /* op_destroy */
-    na_ofi_addr_lookup,                     /* addr_lookup */
+    NULL,                                   /* addr_lookup */
+    na_ofi_addr_lookup,                     /* addr_lookup2 */
     na_ofi_addr_free,                       /* addr_free */
+    na_ofi_addr_set_remove,                 /* addr_set_remove */
     na_ofi_addr_self,                       /* addr_self */
     na_ofi_addr_dup,                        /* addr_dup */
+    na_ofi_addr_cmp,                        /* addr_cmp */
     na_ofi_addr_is_self,                    /* addr_is_self */
     na_ofi_addr_to_string,                  /* addr_to_string */
     na_ofi_addr_get_serialize_size,         /* addr_get_serialize_size */
@@ -1017,34 +1012,34 @@ na_ofi_prov_name_to_type(const char *prov_name)
 static NA_INLINE void
 na_ofi_domain_lock(struct na_ofi_domain *domain)
 {
-    if (na_ofi_prov_flags[domain->nod_prov_type] & NA_OFI_DOMAIN_LOCK)
-        hg_thread_mutex_lock(&domain->nod_mutex);
+    if (na_ofi_prov_flags[domain->prov_type] & NA_OFI_DOMAIN_LOCK)
+        hg_thread_mutex_lock(&domain->mutex);
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE void
 na_ofi_domain_unlock(struct na_ofi_domain *domain)
 {
-    if (na_ofi_prov_flags[domain->nod_prov_type] & NA_OFI_DOMAIN_LOCK)
-        hg_thread_mutex_unlock(&domain->nod_mutex);
+    if (na_ofi_prov_flags[domain->prov_type] & NA_OFI_DOMAIN_LOCK)
+        hg_thread_mutex_unlock(&domain->mutex);
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
 na_ofi_with_sep(const na_class_t *na_class)
 {
-    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->nop_endpoint;
+    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->endpoint;
 
-    return ep->noe_sep;
+    return ep->sep;
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
 na_ofi_with_msg_hdr(const na_class_t *na_class)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
 
-    return (na_ofi_prov_addr_format[domain->nod_prov_type] == FI_SOCKADDR_IN);
+    return (na_ofi_prov_addr_format[domain->prov_type] == FI_SOCKADDR_IN);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1077,7 +1072,7 @@ na_ofi_str_to_addr(const char *str, na_uint32_t addr_format, void **addr,
             return na_ofi_str_to_gni(str, addr, len);
         default:
             NA_LOG_ERROR("Unsupported address format");
-            return NA_PROTOCOL_ERROR;
+            return NA_PROTONOSUPPORT;
     }
 }
 
@@ -1087,47 +1082,36 @@ na_ofi_str_to_sin(const char *str, void **addr, na_size_t *len)
 {
     struct na_ofi_sin_addr *sin_addr;
     char ip[16];
-    int ret;
+    na_return_t ret = NA_SUCCESS;
 
     *len = sizeof(*sin_addr);
     sin_addr = calloc(1, *len);
-    if (!sin_addr) {
-        NA_LOG_ERROR("Could not allocate sin address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(sin_addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate sin address");
 
     sin_addr->sin.sin_family = AF_INET;
-    ret = sscanf(str, "%*[^:]://:%" SCNu16, &sin_addr->sin.sin_port);
-    if (ret == 1)
-        goto match_port;
-
-    ret = sscanf(str, "%*[^:]://%15[^:]:%" SCNu16, ip, &sin_addr->sin.sin_port);
-    if (ret == 2)
-        goto match_ip;
-
-    ret = sscanf(str, "%*[^:]://%15[^:/]", ip);
-    if (ret == 1)
-        goto match_ip;
-
-    NA_LOG_ERROR("Malformed FI_ADDR_STR: %s\n", str);
+    if (sscanf(str, "%*[^:]://:%" SCNu16, &sin_addr->sin.sin_port) == 1) {
+        /* nothing */
+    } else if ((sscanf(str, "%*[^:]://%15[^:]:%" SCNu16, ip, &sin_addr->sin.sin_port) == 2)
+        || (sscanf(str, "%*[^:]://%15[^:/]", ip) == 1)) {
+        int rc;
 
-err:
-    free(sin_addr);
-    return NA_PROTOCOL_ERROR;
-
-match_ip:
-    ip[sizeof(ip) - 1] = '\0';
-    ret = inet_pton(AF_INET, ip, &sin_addr->sin.sin_addr);
-    if (ret != 1) {
-        NA_LOG_ERROR("Unable to convert IPv4 address: %s\n", ip);
-        goto err;
-    }
+        ip[sizeof(ip) - 1] = '\0';
+        rc = inet_pton(AF_INET, ip, &sin_addr->sin.sin_addr);
+        NA_CHECK_ERROR(rc != 1, error, ret, NA_PROTONOSUPPORT,
+            "Unable to convert IPv4 address: %s\n", ip);
+    } else
+        NA_GOTO_ERROR(error, ret, NA_PROTONOSUPPORT,
+            "Malformed FI_ADDR_STR: %s\n", str);
 
-match_port:
     sin_addr->sin.sin_port = htons(sin_addr->sin.sin_port);
     *addr = sin_addr;
 
-    return NA_SUCCESS;
+    return ret;
+
+error:
+    free(sin_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1135,26 +1119,26 @@ static na_return_t
 na_ofi_str_to_psm2(const char *str, void **addr, na_size_t *len)
 {
     struct na_ofi_psm2_addr *psm2_addr;
-    int ret;
+    na_return_t ret = NA_SUCCESS;
+    int rc;
 
     *len = sizeof(*psm2_addr);
     psm2_addr = calloc(1, *len);
-    if (!psm2_addr) {
-        NA_LOG_ERROR("Could not allocate psm2 address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(psm2_addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate psm2 address");
 
-    ret = sscanf(str, "%*[^:]://%" SCNx64 ":%" SCNx64,
+    rc = sscanf(str, "%*[^:]://%" SCNx64 ":%" SCNx64,
         (uint64_t *) &psm2_addr->addr0, (uint64_t *) &psm2_addr->addr1);
-    if (ret != 2) {
-        NA_LOG_ERROR("Could not convert addr string to PSM2 addr format");
-        free(psm2_addr);
-        return NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 2, error, ret, NA_PROTONOSUPPORT,
+        "Could not convert addr string to PSM2 addr format");
 
     *addr = psm2_addr;
 
-    return NA_SUCCESS;
+    return ret;
+
+error:
+    free(psm2_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1164,28 +1148,21 @@ na_ofi_str_to_gni(const char *str, void **addr, na_size_t *len)
     struct na_ofi_gni_addr *gni_addr;
     unsigned int version, name_type, rx_ctx_cnt;
     na_uint32_t device_addr, cdm_id, cm_nic_cdm_id, cookie;
-    int ret;
+    na_return_t ret = NA_SUCCESS;
+    int rc;
 
     *len = sizeof(*gni_addr);
     gni_addr = calloc(1, *len);
-    if (!gni_addr) {
-        NA_LOG_ERROR("Could not allocate gni address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(gni_addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate gni address");
 
-    ret = sscanf(str, "%*[^:]://%04u:0x%08" PRIx32 ":0x%08" PRIx32 ":%02u:0x%06"
+    rc = sscanf(str, "%*[^:]://%04u:0x%08" PRIx32 ":0x%08" PRIx32 ":%02u:0x%06"
         PRIx32 ":0x%08" PRIx32 ":%02u", &version, &device_addr, &cdm_id,
         &name_type, &cm_nic_cdm_id, &cookie, &rx_ctx_cnt);
-    if (ret != 7) {
-        NA_LOG_ERROR("Could not convert addr string to GNI addr format");
-        free(gni_addr);
-        return NA_PROTOCOL_ERROR;
-    }
-    if (version != NA_OFI_GNI_AV_STR_ADDR_VERSION) {
-        NA_LOG_ERROR("Unsupported GNI string addr format");
-        free(gni_addr);
-        return NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 7, error, ret, NA_PROTONOSUPPORT,
+            "Could not convert addr string to GNI addr format");
+    NA_CHECK_ERROR(version != NA_OFI_GNI_AV_STR_ADDR_VERSION, error, ret,
+        NA_PROTONOSUPPORT, "Unsupported GNI string addr format");
 
     gni_addr->device_addr = device_addr;
     gni_addr->cdm_id = cdm_id;
@@ -1193,16 +1170,18 @@ na_ofi_str_to_gni(const char *str, void **addr, na_size_t *len)
     gni_addr->cm_nic_cdm_id = cm_nic_cdm_id & 0xffffff;
     gni_addr->cookie = cookie;
     gni_addr->rx_ctx_cnt = rx_ctx_cnt & 0xff;
-    /*
     NA_LOG_DEBUG("GNI addr is: device_addr=%x, cdm_id=%x, name_type=%x, "
         "cm_nic_cdm_id=%x, cookie=%x, rx_ctx_cnt=%u",
         gni_addr->device_addr, gni_addr->cdm_id, gni_addr->name_type,
         gni_addr->cm_nic_cdm_id, gni_addr->cookie, gni_addr->rx_ctx_cnt);
-     */
 
     *addr = gni_addr;
 
-    return NA_SUCCESS;
+    return ret;
+
+error:
+    free(gni_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1211,18 +1190,27 @@ na_ofi_addr_to_key(na_uint32_t addr_format, const void *addr, na_size_t len)
 {
     switch (addr_format) {
         case FI_SOCKADDR_IN:
-            assert(len == sizeof(struct na_ofi_sin_addr));
+            NA_CHECK_ERROR_NORET(len != sizeof(struct na_ofi_sin_addr), out,
+                "Addr len (%zu) does not match for FI_SOCKADDR_IN (%zu)",
+                len, sizeof(struct na_ofi_sin_addr));
             return na_ofi_sin_to_key((const struct na_ofi_sin_addr *) addr);
         case FI_ADDR_PSMX2:
-            assert(len == sizeof(struct na_ofi_psm2_addr));
+            NA_CHECK_ERROR_NORET(len != sizeof(struct na_ofi_psm2_addr), out,
+                "Addr len (%zu) does not match for FI_ADDR_PSMX2 (%zu)",
+                len, sizeof(struct na_ofi_psm2_addr));
             return na_ofi_psm2_to_key((const struct na_ofi_psm2_addr *) addr);
         case FI_ADDR_GNI:
-            assert(len == sizeof(struct na_ofi_gni_addr));
+            NA_CHECK_ERROR_NORET(len != sizeof(struct na_ofi_gni_addr), out,
+                "Addr len (%zu) does not match for FI_ADDR_GNI (%zu)",
+                len, sizeof(struct na_ofi_gni_addr));
             return na_ofi_gni_to_key((const struct na_ofi_gni_addr *) addr);
         default:
             NA_LOG_ERROR("Unsupported address format");
-            return 0;
+            break;
     }
+
+out:
+    return 0;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1271,95 +1259,143 @@ na_ofi_addr_ht_key_equal(hg_hash_table_key_t vlocation1,
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
-    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr)
+na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
+    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
-    na_uint64_t addr_key;
-    hg_hash_table_key_t ht_key = NULL;
+    hg_hash_table_key_t ht_key = addr_key;
     hg_hash_table_value_t ht_value = NULL;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
     /* Generate key */
-    addr_key = na_ofi_addr_to_key(addr_format, addr, addrlen);
-    if (!addr_key) {
-        NA_LOG_ERROR("Could not generate key from addr");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    *addr_key = na_ofi_addr_to_key(addr_format, addr, addrlen);
+    NA_CHECK_ERROR(*addr_key == 0, out, ret, NA_PROTONOSUPPORT,
+        "Could not generate key from addr");
 
     /* Lookup key */
-    hg_thread_rwlock_rdlock(&domain->nod_rwlock);
-    ht_value = hg_hash_table_lookup(domain->nod_addr_ht, &addr_key);
+    hg_thread_rwlock_rdlock(&domain->rwlock);
+    ht_value = hg_hash_table_lookup(domain->addr_ht, ht_key);
+    hg_thread_rwlock_release_rdlock(&domain->rwlock);
     if (ht_value != HG_HASH_TABLE_NULL) {
+        /* Found */
         *fi_addr = *(fi_addr_t *) ht_value;
-        hg_thread_rwlock_release_rdlock(&domain->nod_rwlock);
-        return ret;
+        goto out;
     }
-    hg_thread_rwlock_release_rdlock(&domain->nod_rwlock);
 
     /* Insert addr into AV if key not found */
     na_ofi_domain_lock(domain);
-    rc = fi_av_insert(domain->nod_av, addr, 1, fi_addr, 0 /* flags */,
-        NULL /* context */);
+    rc = fi_av_insert(domain->fi_av, addr, 1, fi_addr, 0 /* flags */, NULL);
     na_ofi_domain_unlock(domain);
-    if (rc < 1) {
-        NA_LOG_ERROR("fi_av_insert failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc < 1, out, ret, NA_PROTOCOL_ERROR,
+        "fi_av_insert() failed, rc: %d (%s)", rc, fi_strerror((int) -rc));
 
-    hg_thread_rwlock_wrlock(&domain->nod_rwlock);
-    /* in race condition, use addr in HT and remove the new addr from AV */
-    ht_value = hg_hash_table_lookup(domain->nod_addr_ht, &addr_key);
+    hg_thread_rwlock_wrlock(&domain->rwlock);
+
+    ht_value = hg_hash_table_lookup(domain->addr_ht, ht_key);
     if (ht_value != HG_HASH_TABLE_NULL) {
-        fi_av_remove(domain->nod_av, fi_addr, 1, 0);
-        hg_thread_rwlock_release_wrlock(&domain->nod_rwlock);
+        /* in race condition, use addr in HT and remove the new addr from AV */
+        rc = fi_av_remove(domain->fi_av, fi_addr, 1, 0 /* flags */);
+        NA_CHECK_ERROR(rc != 0, unlock, ret, NA_PROTOCOL_ERROR,
+            "fi_av_remove() failed, rc: %d (%s)", rc, fi_strerror((int) -rc));
         *fi_addr = *(fi_addr_t *) ht_value;
-        return ret;
+        goto unlock;
     }
 
     /* Allocate new key */
     ht_key = malloc(sizeof(na_uint64_t));
-    if (!ht_key) {
-        NA_LOG_ERROR("cannot allocate memory for ht_key");
-        ret = NA_NOMEM_ERROR;
-        goto unlock;
-    }
+    NA_CHECK_ERROR(ht_key == NULL, error, ret, NA_NOMEM,
+        "Cannot allocate memory for ht_key");
 
     /* Allocate new value */
     ht_value = malloc(sizeof(*fi_addr));
-    if (!ht_value) {
-        NA_LOG_ERROR("cannot allocate memory for ht_key");
-        ret = NA_NOMEM_ERROR;
-        goto unlock;
-    }
+    NA_CHECK_ERROR(ht_value == NULL, error, ret, NA_NOMEM,
+        "cannot allocate memory for ht_key");
 
-    *((na_uint64_t *) ht_key) = addr_key;
+    *((na_uint64_t *) ht_key) = *addr_key;
     *((na_uint64_t *) ht_value) = *fi_addr;
 
     /* Insert new value */
-    if (!hg_hash_table_insert(domain->nod_addr_ht, ht_key, ht_value)) {
-        NA_LOG_ERROR("hg_hash_table_insert() failed.");
-        ret = NA_NOMEM_ERROR;
-        goto unlock;
-    }
+    rc = hg_hash_table_insert(domain->addr_ht, ht_key, ht_value);
+    NA_CHECK_ERROR(rc == 0, error, ret, NA_NOMEM,
+        "hg_hash_table_insert() failed");
 
 unlock:
-    hg_thread_rwlock_release_wrlock(&domain->nod_rwlock);
+    hg_thread_rwlock_release_wrlock(&domain->rwlock);
 
 out:
-    if (ret != NA_SUCCESS) {
-        free(ht_key);
-        free(ht_value);
+    return ret;
+
+error:
+    hg_thread_rwlock_release_wrlock(&domain->rwlock);
+    free(ht_key);
+    free(ht_value);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ofi_addr_ht_remove(struct na_ofi_domain *domain, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key)
+{
+    na_return_t ret = NA_SUCCESS;
+    int rc;
+
+    hg_thread_rwlock_wrlock(&domain->rwlock);
+    rc = hg_hash_table_remove(domain->addr_ht, (hg_hash_table_key_t) addr_key);
+    NA_CHECK_ERROR(rc != 1, unlock, ret, NA_NOENTRY,
+        "hg_hash_table_remove() failed");
+
+    rc = fi_av_remove(domain->fi_av, fi_addr, 1, 0 /* flags */);
+    NA_CHECK_ERROR(rc != 0, unlock, ret, NA_PROTOCOL_ERROR,
+        "fi_av_remove() failed, rc: %d (%s)", rc, fi_strerror((int) -rc));
+
+unlock:
+    hg_thread_rwlock_release_wrlock(&domain->rwlock);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ofi_av_lookup(struct na_ofi_domain *na_ofi_domain, fi_addr_t fi_addr,
+    void **addr_ptr, size_t *addrlen_ptr)
+{
+    void *addr = NULL;
+    size_t addrlen = na_ofi_domain->fi_prov->src_addrlen;
+    na_bool_t retried = NA_FALSE;
+    na_return_t ret = NA_SUCCESS;
+    int rc;
+
+retry:
+    addr = malloc(addrlen);
+    NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate %zu bytes for address", addrlen);
+
+    /* Lookup address from AV */
+    na_ofi_domain_lock(na_ofi_domain);
+    rc = fi_av_lookup(na_ofi_domain->fi_av, fi_addr, addr, &addrlen);
+    na_ofi_domain_unlock(na_ofi_domain);
+    if (rc == -FI_ETOOSMALL && retried == NA_FALSE) {
+        retried = NA_TRUE;
+        free(addr);
+        goto retry;
     }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_av_lookup() failed, rc: %d (%s)", rc,
+        fi_strerror((int ) -rc));
+
+    *addr_ptr = addr;
+    *addrlen_ptr = addrlen;
+
+    return ret;
+
+error:
+    free(addr);
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
-static int
+static na_return_t
 na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers)
 {
     struct fi_info *hints = NULL;
@@ -1370,19 +1406,13 @@ na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers)
       * Hints to query && filter providers.
       */
     hints = fi_allocinfo();
-    if (!hints) {
-        NA_LOG_ERROR("fi_allocinfo failed.\n");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM,
+        "fi_allocinfo() failed");
 
     /* Protocol name is provider name, filter out providers within libfabric */
     hints->fabric_attr->prov_name = strdup(na_ofi_prov_name[prov_type]);
-    if (!hints->fabric_attr->prov_name) {
-        NA_LOG_ERROR("Could not duplicate name");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(hints->fabric_attr->prov_name == NULL, cleanup, ret,
+        NA_NOMEM, "Could not duplicate name");
 
     /* mode: operational mode, NA_OFI passes in context for communication calls. */
     /* FI_ASYNC_IOV mode indicates  that  the  application  must  provide  the
@@ -1444,18 +1474,15 @@ na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers)
                     0ULL,  /* Optional flag */
                     hints, /* In: Hints to filter providers */
                     providers); /* Out: List of matching providers */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_getinfo failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, cleanup, ret, NA_PROTOCOL_ERROR,
+        "fi_getinfo() failed, rc: %d (%s)", rc, fi_strerror(-rc));
+
+cleanup:
+    free(hints->fabric_attr->prov_name);
+    hints->fabric_attr->prov_name = NULL;
+    fi_freeinfo(hints);
 
 out:
-    if (hints) {
-        free(hints->fabric_attr->prov_name);
-        hints->fabric_attr->prov_name = NULL;
-        fi_freeinfo(hints);
-    }
     return ret;
 }
 
@@ -1474,10 +1501,8 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
 
     /* Allocate new sin addr to store result */
     na_ofi_sin_addr = calloc(1, sizeof(*na_ofi_sin_addr));
-    if (!na_ofi_sin_addr) {
-        NA_LOG_ERROR("Could not allocate sin address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(na_ofi_sin_addr == NULL, out, ret, NA_NOMEM,
+        "Could not allocate sin address");
     na_ofi_sin_addr->sin.sin_family = AF_INET;
     na_ofi_sin_addr->sin.sin_port = htons(port & 0xffff);
 
@@ -1491,27 +1516,25 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
     if (s == 0) {
         struct addrinfo *rp;
 
+        /* Get IP */
         for (rp = hostname_res; rp != NULL; rp = rp->ai_next) {
-            /* Get IP */
-            if (!inet_ntop(rp->ai_addr->sa_family,
+            const char *ptr = inet_ntop(rp->ai_addr->sa_family,
                 &((struct sockaddr_in *) rp->ai_addr)->sin_addr, ip_res,
-                INET_ADDRSTRLEN)) {
-                NA_LOG_ERROR("IP could not be resolved");
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
+                INET_ADDRSTRLEN);
+            NA_CHECK_ERROR(ptr == NULL, out, ret, NA_ADDRNOTAVAIL,
+                "IP could not be resolved");
             break;
         }
     }
 
     /* Check and compare interfaces */
-    if (getifaddrs(&ifaddrs) == -1) {
-        NA_LOG_ERROR("getifaddrs() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    s = getifaddrs(&ifaddrs);
+    NA_CHECK_ERROR(s == -1, out, ret, NA_ADDRNOTAVAIL,
+        "getifaddrs() failed");
+
     for (ifaddr = ifaddrs; ifaddr != NULL; ifaddr = ifaddr->ifa_next) {
         char ip[INET_ADDRSTRLEN] = {'\0'}; /* This restricts to ipv4 addresses */
+        const char *ptr;
 
         if (ifaddr->ifa_addr == NULL)
             continue;
@@ -1520,13 +1543,11 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
             continue;
 
         /* Get IP */
-        if (!inet_ntop(ifaddr->ifa_addr->sa_family,
+        ptr = inet_ntop(ifaddr->ifa_addr->sa_family,
             &((struct sockaddr_in *) ifaddr->ifa_addr)->sin_addr, ip,
-            INET_ADDRSTRLEN)) {
-            NA_LOG_ERROR("IP could not be resolved for: %s", ifaddr->ifa_name);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+            INET_ADDRSTRLEN);
+        NA_CHECK_ERROR(ptr == NULL, out, ret, NA_ADDRNOTAVAIL,
+            "IP could not be resolved for: %s", ifaddr->ifa_name);
 
         /* Compare hostnames / device names */
         if (!strcmp(ip, ip_res) || !strcmp(ifaddr->ifa_name, hostname)) {
@@ -1541,10 +1562,8 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
         *na_ofi_sin_addr_ptr = na_ofi_sin_addr;
         if (ifa_name) {
             *ifa_name = strdup(ifaddr->ifa_name);
-            if (!*ifa_name) {
-                NA_LOG_ERROR("Could not dup ifa_name");
-                ret = NA_NOMEM_ERROR;
-            }
+            NA_CHECK_ERROR(*ifa_name == NULL, out, ret, NA_NOMEM,
+                "Could not dup ifa_name");
         }
     }
 
@@ -1554,6 +1573,7 @@ out:
     freeifaddrs(ifaddrs);
     if (hostname_res)
         freeaddrinfo(hostname_res);
+
     return ret;
 }
 
@@ -1562,26 +1582,21 @@ static NA_INLINE na_bool_t
 na_ofi_verify_provider(enum na_ofi_prov_type prov_type, const char *domain_name,
     const struct fi_info *fi_info)
 {
-    na_bool_t ret = NA_FALSE;
-
     /* Does not match provider name */
     if (strcmp(na_ofi_prov_name[prov_type], fi_info->fabric_attr->prov_name))
-        goto out;
+        return NA_FALSE;
 
     /* for some providers the provider name is ambiguous and we must check
      * the domain name as well
      */
-    if(na_ofi_prov_flags[prov_type] & NA_OFI_VERIFY_PROV_DOM) {
+    if (na_ofi_prov_flags[prov_type] & NA_OFI_VERIFY_PROV_DOM) {
         /* Does not match domain name */
         if (domain_name && strcmp("\0", domain_name)
             && strcmp(domain_name, fi_info->domain_attr->name))
-            goto out;
+            return NA_FALSE;
     }
 
-    ret = NA_TRUE;
-
-out:
-    return ret;
+    return NA_TRUE;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1594,20 +1609,14 @@ na_ofi_gni_set_domain_op_value(struct na_ofi_domain *na_ofi_domain, int op,
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    rc = fi_open_ops(&na_ofi_domain->nod_domain->fid, FI_GNI_DOMAIN_OPS_1,
+    rc = fi_open_ops(&na_ofi_domain->fi_domain->fid, FI_GNI_DOMAIN_OPS_1,
         0, (void **) &gni_domain_ops, NULL);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_open_ops failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_open_ops() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-    rc = gni_domain_ops->set_val(&na_ofi_domain->nod_domain->fid, op, value);
-    if (rc != 0) {
-        NA_LOG_ERROR("set_val failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = gni_domain_ops->set_val(&na_ofi_domain->fi_domain->fid, op, value);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "gni_domain_ops->set_val() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
 out:
     return ret;
@@ -1616,8 +1625,7 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_domain_open(struct na_ofi_class *priv,
-    enum na_ofi_prov_type prov_type,
+na_ofi_domain_open(struct na_ofi_class *priv, enum na_ofi_prov_type prov_type,
     const char *domain_name, const char *auth_key,
     struct na_ofi_domain **na_ofi_domain_p)
 {
@@ -1634,114 +1642,85 @@ na_ofi_domain_open(struct na_ofi_class *priv,
      * na_ofi_domain.
      */
     hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
-    HG_LIST_FOREACH(na_ofi_domain, &na_ofi_domain_list_g, nod_entry) {
+    HG_LIST_FOREACH(na_ofi_domain, &na_ofi_domain_list_g, entry) {
         if (na_ofi_verify_provider(prov_type, domain_name,
-            na_ofi_domain->nod_prov)) {
-            hg_atomic_incr32(&na_ofi_domain->nod_refcount);
+            na_ofi_domain->fi_prov)) {
+            hg_atomic_incr32(&na_ofi_domain->refcount);
             domain_found = NA_TRUE;
             break;
         }
     }
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
     if (domain_found) {
-        /*
-        NA_LOG_DEBUG("Found existing domain (%s)",
-            na_ofi_domain->nod_prov_name);
-        */
+        NA_LOG_DEBUG("Found existing domain (%s)", na_ofi_domain->prov_name);
         *na_ofi_domain_p = na_ofi_domain;
-        goto out;
+        return ret;
     }
 
     /* If no pre-existing domain, get OFI providers info */
     ret = na_ofi_getinfo(prov_type, &providers);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_getinfo failed, ret: %d.", ret);
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "na_ofi_getinfo() failed");
 
     /* Try to find provider that matches protocol and domain/host name */
     prov = providers;
     while (prov != NULL) {
         if (na_ofi_verify_provider(prov_type, domain_name, prov)) {
-            /*
             NA_LOG_DEBUG("mode 0x%llx, fabric_attr -> prov_name: %s, name: %s; "
-                         "domain_attr -> name: %s, threading: %d.",
-                         prov->mode, prov->fabric_attr->prov_name,
-                         prov->fabric_attr->name, prov->domain_attr->name,
-                         prov->domain_attr->threading);
-            */
+                "domain_attr -> name: %s, threading: %d.", prov->mode,
+                prov->fabric_attr->prov_name, prov->fabric_attr->name,
+                prov->domain_attr->name, prov->domain_attr->threading);
             prov_found = NA_TRUE;
             break;
         }
         prov = prov->next;
     }
-    if (!prov_found) {
-        NA_LOG_ERROR("No provider found for \"%s\" provider on domain \"%s\"",
-                     na_ofi_prov_name[prov_type], domain_name);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(!prov_found, error, ret, NA_NOENTRY,
+        "No provider found for \"%s\" provider on domain \"%s\"",
+        na_ofi_prov_name[prov_type], domain_name);
 
     na_ofi_domain = (struct na_ofi_domain *) malloc(
         sizeof(struct na_ofi_domain));
-    if (na_ofi_domain == NULL) {
-        NA_LOG_ERROR("Could not allocate na_ofi_domain");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_domain == NULL, error, ret, NA_NOMEM,
+        "Could not allocate na_ofi_domain");
     memset(na_ofi_domain, 0, sizeof(struct na_ofi_domain));
-    hg_atomic_set32(&na_ofi_domain->nod_refcount, 1);
+    hg_atomic_init32(&na_ofi_domain->refcount, 1);
 
     /* Init mutex */
-    rc = hg_thread_mutex_init(&na_ofi_domain->nod_mutex);
-    if (rc != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_thread_mutex_init failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    rc = hg_thread_mutex_init(&na_ofi_domain->mutex);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_NOMEM,
+        "hg_thread_mutex_init() failed");
 
     /* Init rw lock */
-    rc = hg_thread_rwlock_init(&na_ofi_domain->nod_rwlock);
-    if (rc != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_thread_rwlock_init failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    rc = hg_thread_rwlock_init(&na_ofi_domain->rwlock);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_NOMEM,
+        "hg_thread_rwlock_init() failed");
 
     /* Keep fi_info */
-    na_ofi_domain->nod_prov = fi_dupinfo(prov);
-    if (!na_ofi_domain->nod_prov) {
-        NA_LOG_ERROR("Could not duplicate fi_info");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_domain->fi_prov = fi_dupinfo(prov);
+    NA_CHECK_ERROR(na_ofi_domain->fi_prov == NULL, error, ret,
+        NA_NOMEM, "Could not duplicate fi_info");
 
     /* Dup provider name */
-    na_ofi_domain->nod_prov_name = strdup(prov->fabric_attr->prov_name);
-    if (!na_ofi_domain->nod_prov_name) {
-        NA_LOG_ERROR("Could not duplicate name");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_domain->prov_name = strdup(prov->fabric_attr->prov_name);
+    NA_CHECK_ERROR(na_ofi_domain->prov_name == NULL, error, ret,
+        NA_NOMEM, "Could not duplicate name");
 
-    na_ofi_domain->nod_prov_type = prov_type;
+    na_ofi_domain->prov_type = prov_type;
 
-    if(prov_type == NA_OFI_PROV_GNI) {
 #if defined(NA_OFI_HAS_EXT_GNI_H)
-        if (auth_key) {
-            na_ofi_domain->fi_gni_auth_key.type = GNIX_AKT_RAW;
-            na_ofi_domain->fi_gni_auth_key.raw.protection_key =
-                (uint32_t) strtoul(auth_key, NULL, 10);
-
-            na_ofi_domain->nod_prov->domain_attr->auth_key =
-                (void *) &na_ofi_domain->fi_gni_auth_key;
-            na_ofi_domain->nod_prov->domain_attr->auth_key_size =
-                sizeof(na_ofi_domain->fi_gni_auth_key);
-        }
+    if (prov_type == NA_OFI_PROV_GNI && auth_key) {
+        na_ofi_domain->fi_gni_auth_key.type = GNIX_AKT_RAW;
+        na_ofi_domain->fi_gni_auth_key.raw.protection_key =
+            (uint32_t) strtoul(auth_key, NULL, 10);
+
+        na_ofi_domain->fi_prov->domain_attr->auth_key =
+            (void *) &na_ofi_domain->fi_gni_auth_key;
+        na_ofi_domain->fi_prov->domain_attr->auth_key_size =
+            sizeof(na_ofi_domain->fi_gni_auth_key);
+    }
 #else
-        (void) auth_key;
+    (void) auth_key;
 #endif
-    }
 
     /* Force no wait if do not support FI_WAIT_FD/FI_WAIT_SET */
     if (!(na_ofi_prov_flags[prov_type] & (NA_OFI_WAIT_SET | NA_OFI_WAIT_FD)))
@@ -1749,129 +1728,120 @@ na_ofi_domain_open(struct na_ofi_class *priv,
 
     /* Force manual progress if no wait is set */
     if (priv->no_wait) {
-        na_ofi_domain->nod_prov->domain_attr->control_progress = FI_PROGRESS_MANUAL;
-        na_ofi_domain->nod_prov->domain_attr->data_progress = FI_PROGRESS_MANUAL;
+        na_ofi_domain->fi_prov->domain_attr->control_progress = FI_PROGRESS_MANUAL;
+        na_ofi_domain->fi_prov->domain_attr->data_progress = FI_PROGRESS_MANUAL;
     }
 
     /* Open fi fabric */
-    rc = fi_fabric(na_ofi_domain->nod_prov->fabric_attr,/* In:  Fabric attributes */
-                   &na_ofi_domain->nod_fabric,          /* Out: Fabric handle */
-                   NULL);                               /* Optional context for fabric events */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_fabric failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_fabric(na_ofi_domain->fi_prov->fabric_attr,/* In:  Fabric attributes */
+                   &na_ofi_domain->fi_fabric,          /* Out: Fabric handle */
+                   NULL);                              /* Optional context for fabric events */
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_fabric() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
     /* Create the fi access domain */
-    rc = fi_domain(na_ofi_domain->nod_fabric,   /* In:  Fabric object */
-                   na_ofi_domain->nod_prov,     /* In:  Provider */
-                   &na_ofi_domain->nod_domain,  /* Out: Domain object */
-                   NULL);                       /* Optional context for domain events */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_domain failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-    if (priv->nop_max_contexts > 1) {
+    rc = fi_domain(na_ofi_domain->fi_fabric,  /* In:  Fabric object */
+                   na_ofi_domain->fi_prov,    /* In:  Provider */
+                   &na_ofi_domain->fi_domain, /* Out: Domain object */
+                   NULL);                     /* Optional context for domain events */
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_domain() failed, rc: %d (%s)", rc, fi_strerror(-rc));
+
+    if (priv->max_contexts > 1) {
         size_t min_ctx_cnt =
-            MIN(na_ofi_domain->nod_prov->domain_attr->tx_ctx_cnt,
-                na_ofi_domain->nod_prov->domain_attr->rx_ctx_cnt);
-        if (priv->nop_max_contexts > min_ctx_cnt) {
-            NA_LOG_ERROR("Maximum number of requested contexts (%d) exceeds "
-                "provider limitation (%d).", priv->nop_max_contexts,
-                min_ctx_cnt);
-            ret = NA_INVALID_PARAM;
-            goto out;
-        }
-//        NA_LOG_DEBUG("fi_domain created, tx_ctx_cnt %d, rx_ctx_cnt %d.",
-//            na_ofi_domain->nod_prov->domain_attr->tx_ctx_cnt,
-//            na_ofi_domain->nod_prov->domain_attr->rx_ctx_cnt);
+            MIN(na_ofi_domain->fi_prov->domain_attr->tx_ctx_cnt,
+                na_ofi_domain->fi_prov->domain_attr->rx_ctx_cnt);
+        NA_CHECK_ERROR(priv->max_contexts > min_ctx_cnt, error, ret,
+            NA_INVALID_ARG, "Maximum number of requested contexts (%d) "
+            "exceeds provider limitation (%d)", priv->max_contexts,
+            min_ctx_cnt);
+        NA_LOG_DEBUG("fi_domain created, tx_ctx_cnt %d, rx_ctx_cnt %d",
+            na_ofi_domain->fi_prov->domain_attr->tx_ctx_cnt,
+            na_ofi_domain->fi_prov->domain_attr->rx_ctx_cnt);
     }
 
 #ifdef NA_OFI_HAS_EXT_GNI_H
-    if (na_ofi_domain->nod_prov_type == NA_OFI_PROV_GNI) {
-        int enable = 1;
+    if (na_ofi_domain->prov_type == NA_OFI_PROV_GNI) {
+        int32_t enable = 1;
 # ifdef NA_OFI_GNI_HAS_UDREG
         char *other_reg_type = "udreg";
+        int32_t udreg_limit = 1024;
 
         /* Enable use of udreg instead of internal MR cache */
         ret = na_ofi_gni_set_domain_op_value(na_ofi_domain, GNI_MR_CACHE,
             &other_reg_type);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not set domain op value for GNI_MR_CACHE");
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(error, ret,
+            "Could not set domain op value for GNI_MR_CACHE");
+
+        /* Experiments on Theta showed default value of 2048 too high if
+         * launching multiple clients on one node */
+        ret = na_ofi_gni_set_domain_op_value(na_ofi_domain,
+            GNI_MR_UDREG_REG_LIMIT, &udreg_limit);
+        NA_CHECK_NA_ERROR(error, ret,
+            "Could not set domain op value for GNI_MR_UDREG_REG_LIMIT");
 # endif
 
         /* Enable lazy deregistration in MR cache */
         ret = na_ofi_gni_set_domain_op_value(na_ofi_domain,
             GNI_MR_CACHE_LAZY_DEREG, &enable);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not set domain op value for GNI_MR_CACHE_LAZY_DEREG");
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(error, ret,
+            "Could not set domain op value for GNI_MR_CACHE_LAZY_DEREG");
     }
 #endif
 
     /* If memory does not need to be backed up by physical pages at the time of
      * registration, export all memory range for RMA
      * (this is equivalent to FI_MR_SCALABLE) */
-    if (!(na_ofi_domain->nod_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
+    if (!(na_ofi_domain->fi_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
         uint64_t requested_key =
-            (!(na_ofi_domain->nod_prov->domain_attr->mr_mode & FI_MR_PROV_KEY))
+            (!(na_ofi_domain->fi_prov->domain_attr->mr_mode & FI_MR_PROV_KEY))
             ? NA_OFI_RMA_KEY : 0;
 
-        rc = fi_mr_reg(na_ofi_domain->nod_domain, NULL, UINT64_MAX,
+        rc = fi_mr_reg(na_ofi_domain->fi_domain, NULL, UINT64_MAX,
             FI_REMOTE_READ | FI_REMOTE_WRITE | FI_SEND | FI_RECV
             | FI_READ | FI_WRITE, 0 /* offset */, requested_key, 0 /* flags */,
-            &na_ofi_domain->nod_mr, NULL /* context */);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_mr_reg failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+            &na_ofi_domain->fi_mr, NULL /* context */);
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_mr_reg failed(), rc: %d (%s)", rc, fi_strerror(-rc));
+
         /* Requested key may not be the same, currently RxM provider forces
          * the underlying provider to provide keys and ignores user-provided
          * key.
          */
-        na_ofi_domain->nod_mr_key = fi_mr_key(na_ofi_domain->nod_mr);
+        na_ofi_domain->fi_mr_key = fi_mr_key(na_ofi_domain->fi_mr);
     }
 
     /* Open fi address vector */
     av_attr.type = FI_AV_MAP;
     av_attr.rx_ctx_bits = NA_OFI_SEP_RX_CTX_BITS;
-    rc = fi_av_open(na_ofi_domain->nod_domain, &av_attr, &na_ofi_domain->nod_av,
+    rc = fi_av_open(na_ofi_domain->fi_domain, &av_attr, &na_ofi_domain->fi_av,
         NULL);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_av_open failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_av_open() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
     /* Create addr hash-table */
-    na_ofi_domain->nod_addr_ht = hg_hash_table_new(na_ofi_addr_ht_key_hash,
+    na_ofi_domain->addr_ht = hg_hash_table_new(na_ofi_addr_ht_key_hash,
         na_ofi_addr_ht_key_equal);
-    if (na_ofi_domain->nod_addr_ht == NULL) {
-        NA_LOG_ERROR("hg_hash_table_new failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    hg_hash_table_register_free_functions(na_ofi_domain->nod_addr_ht,
-        free, free);
+        NA_CHECK_ERROR(na_ofi_domain->addr_ht == NULL, error, ret,
+            NA_NOMEM, "hg_hash_table_new() failed");
+    hg_hash_table_register_free_functions(na_ofi_domain->addr_ht, free, free);
 
     /* Insert to global domain list */
     hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
-    HG_LIST_INSERT_HEAD(&na_ofi_domain_list_g, na_ofi_domain, nod_entry);
+    HG_LIST_INSERT_HEAD(&na_ofi_domain_list_g, na_ofi_domain, entry);
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
 
     *na_ofi_domain_p = na_ofi_domain;
 
-out:
-    if (ret != NA_SUCCESS)
-       na_ofi_domain_close(na_ofi_domain);
+    fi_freeinfo(providers);
+
+    return ret;
+
+error:
+    na_ofi_domain_close(na_ofi_domain);
     if (providers)
         fi_freeinfo(providers);
+
     return ret;
 }
 
@@ -1882,86 +1852,70 @@ na_ofi_domain_close(struct na_ofi_domain *na_ofi_domain)
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    if (!na_ofi_domain) goto out;
+    if (!na_ofi_domain)
+        goto out;
 
     /* Remove from global domain list if not used anymore */
-    hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
-    if (hg_atomic_decr32(&na_ofi_domain->nod_refcount)) {
+    if (hg_atomic_decr32(&na_ofi_domain->refcount))
         /* Cannot free yet */
-        hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
         goto out;
-    }
-    /* inserted to na_ofi_domain_list_g after nod_addr_ht created */
-    if (na_ofi_domain->nod_addr_ht != NULL)
-        HG_LIST_REMOVE(na_ofi_domain, nod_entry);
+
+    /* Remove from domain list */
+    hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
+    if (na_ofi_domain->entry.next || na_ofi_domain->entry.prev)
+        HG_LIST_REMOVE(na_ofi_domain, entry);
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
 
     /* Close MR */
-    if (na_ofi_domain->nod_mr) {
-        rc = fi_close(&na_ofi_domain->nod_mr->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close MR failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_mr = NULL;
+    if (na_ofi_domain->fi_mr) {
+        rc = fi_close(&na_ofi_domain->fi_mr->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() MR failed, rc: %d (%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_mr = NULL;
     }
 
     /* Close AV */
-    if (na_ofi_domain->nod_av) {
-        rc = fi_close(&na_ofi_domain->nod_av->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close AV failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_av = NULL;
+    if (na_ofi_domain->fi_av) {
+        rc = fi_close(&na_ofi_domain->fi_av->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() AV failed, rc: %d (%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_av = NULL;
     }
 
     /* Close domain */
-    if (na_ofi_domain->nod_domain) {
-        rc = fi_close(&na_ofi_domain->nod_domain->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close domain failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_domain = NULL;
+    if (na_ofi_domain->fi_domain) {
+        rc = fi_close(&na_ofi_domain->fi_domain->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() domain failed, rc: %d (%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_domain = NULL;
     }
 
     /* Close fabric */
-    if (na_ofi_domain->nod_fabric) {
-        rc = fi_close(&na_ofi_domain->nod_fabric->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close fabric failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_fabric = NULL;
+    if (na_ofi_domain->fi_fabric) {
+        rc = fi_close(&na_ofi_domain->fi_fabric->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() fabric failed, rc: %d (%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_fabric = NULL;
     }
 
     /* Free OFI info */
-    if (na_ofi_domain->nod_prov) {
+    if (na_ofi_domain->fi_prov) {
         /* Prevent fi_freeinfo from attempting to free the key */
-        if (na_ofi_domain->nod_prov->domain_attr->auth_key)
-            na_ofi_domain->nod_prov->domain_attr->auth_key = NULL;
-        if (na_ofi_domain->nod_prov->domain_attr->auth_key_size)
-            na_ofi_domain->nod_prov->domain_attr->auth_key_size = 0;
-        fi_freeinfo(na_ofi_domain->nod_prov);
-        na_ofi_domain->nod_prov = NULL;
+        if (na_ofi_domain->fi_prov->domain_attr->auth_key)
+            na_ofi_domain->fi_prov->domain_attr->auth_key = NULL;
+        if (na_ofi_domain->fi_prov->domain_attr->auth_key_size)
+            na_ofi_domain->fi_prov->domain_attr->auth_key_size = 0;
+        fi_freeinfo(na_ofi_domain->fi_prov);
+        na_ofi_domain->fi_prov = NULL;
     }
 
-    if (na_ofi_domain->nod_addr_ht)
-        hg_hash_table_free(na_ofi_domain->nod_addr_ht);
+    if (na_ofi_domain->addr_ht)
+        hg_hash_table_free(na_ofi_domain->addr_ht);
 
-    hg_thread_mutex_destroy(&na_ofi_domain->nod_mutex);
-    hg_thread_rwlock_destroy(&na_ofi_domain->nod_rwlock);
+    hg_thread_mutex_destroy(&na_ofi_domain->mutex);
+    hg_thread_rwlock_destroy(&na_ofi_domain->rwlock);
 
-    free(na_ofi_domain->nod_prov_name);
+    free(na_ofi_domain->prov_name);
     free(na_ofi_domain);
 
 out:
@@ -1983,25 +1937,19 @@ na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
 
     na_ofi_endpoint = (struct na_ofi_endpoint *) malloc(
         sizeof(struct na_ofi_endpoint));
-    if (na_ofi_endpoint == NULL) {
-        NA_LOG_ERROR("Could not allocate na_ofi_endpoint");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_endpoint == NULL, out, ret, NA_NOMEM,
+        "Could not allocate na_ofi_endpoint");
     memset(na_ofi_endpoint, 0, sizeof(struct na_ofi_endpoint));
 
     /* Dup fi_info */
-    hints = fi_dupinfo(na_ofi_domain->nod_prov);
-    if (!hints) {
-        NA_LOG_ERROR("Could not duplicate fi_info");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    hints = fi_dupinfo(na_ofi_domain->fi_prov);
+    NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM,
+        "Could not duplicate fi_info");
 
     if (src_addr) {
         /* Set src addr hints (FI_SOURCE must not be set in that case) */
         free(hints->src_addr);
-        hints->addr_format = na_ofi_prov_addr_format[na_ofi_domain->nod_prov_type];
+        hints->addr_format = na_ofi_prov_addr_format[na_ofi_domain->prov_type];
         hints->src_addr = src_addr;
         hints->src_addrlen = src_addrlen;
     }
@@ -2011,27 +1959,17 @@ na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
     hints->ep_attr->rx_ctx_cnt = max_contexts;
 
     rc = fi_getinfo(NA_OFI_VERSION, node, NULL, flags, hints,
-        &na_ofi_endpoint->noe_prov);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_getinfo(%s) failed, rc: %d(%s).", node,
-            rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+        &na_ofi_endpoint->fi_prov);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_getinfo(%s) failed, rc: %d (%s)", node, rc, fi_strerror(-rc));
 
-    if ((na_ofi_prov_flags[na_ofi_domain->nod_prov_type] & NA_OFI_NO_SEP)
+    if ((na_ofi_prov_flags[na_ofi_domain->prov_type] & NA_OFI_NO_SEP)
         || max_contexts < 2) {
         ret = na_ofi_basic_ep_open(na_ofi_domain, no_wait, na_ofi_endpoint);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("na_ofi_basic_ep_open failed, ret: %d.", ret);
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(out, ret, "na_ofi_basic_ep_open() failed");
     } else {
         ret = na_ofi_sep_open(na_ofi_domain, na_ofi_endpoint);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("na_ofi_sep_open failed, ret: %d.", ret);
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(out, ret, "na_ofi_sep_open() failed");
     }
 
     *na_ofi_endpoint_p = na_ofi_endpoint;
@@ -2060,82 +1998,60 @@ na_ofi_basic_ep_open(const struct na_ofi_domain *na_ofi_domain,
     int rc;
 
     /* Create a transport level communication endpoint */
-    rc = fi_endpoint(na_ofi_domain->nod_domain, /* In:  Domain object */
-                     na_ofi_endpoint->noe_prov, /* In:  Provider */
-                     &na_ofi_endpoint->noe_ep,  /* Out: Endpoint object */
+    rc = fi_endpoint(na_ofi_domain->fi_domain,  /* In:  Domain object */
+                     na_ofi_endpoint->fi_prov,  /* In:  Provider */
+                     &na_ofi_endpoint->fi_ep,   /* Out: Endpoint object */
                      NULL);                     /* Optional context */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_endpoint failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_endpoint() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
     /* Initialize queue / mutex */
-    na_ofi_endpoint->noe_unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
-    if (!na_ofi_endpoint->noe_unexpected_op_queue) {
-        NA_LOG_ERROR("Could not allocate noe_unexpected_op_queue");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    HG_QUEUE_INIT(&na_ofi_endpoint->noe_unexpected_op_queue->noq_queue);
-    hg_thread_spin_init(&na_ofi_endpoint->noe_unexpected_op_queue->noq_lock);
+    na_ofi_endpoint->retry_op_queue = malloc(sizeof(struct na_ofi_queue));
+    NA_CHECK_ERROR(na_ofi_endpoint->retry_op_queue == NULL, out,
+        ret, NA_NOMEM, "Could not allocate retry_op_queue");
+    HG_QUEUE_INIT(&na_ofi_endpoint->retry_op_queue->queue);
+    hg_thread_mutex_init(&na_ofi_endpoint->retry_op_queue->mutex);
 
     if (!no_wait) {
-        if (na_ofi_prov_flags[na_ofi_domain->nod_prov_type] & NA_OFI_WAIT_FD)
+        if (na_ofi_prov_flags[na_ofi_domain->prov_type] & NA_OFI_WAIT_FD)
             cq_attr.wait_obj = FI_WAIT_FD; /* Wait on fd */
         else {
             struct fi_wait_attr wait_attr = {0};
 
             /* Open wait set for other providers. */
             wait_attr.wait_obj = FI_WAIT_UNSPEC;
-            rc = fi_wait_open(na_ofi_domain->nod_fabric, &wait_attr,
-                &na_ofi_endpoint->noe_wait);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_wait_open failed, rc: %d(%s).", rc,
-                    fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
+            rc = fi_wait_open(na_ofi_domain->fi_fabric, &wait_attr,
+                &na_ofi_endpoint->fi_wait);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_wait_open() failed, rc: %d (%s)", rc, fi_strerror(-rc));
             cq_attr.wait_obj = FI_WAIT_SET; /* Wait on wait set */
-            cq_attr.wait_set = na_ofi_endpoint->noe_wait;
+            cq_attr.wait_set = na_ofi_endpoint->fi_wait;
         }
     }
     cq_attr.wait_cond = FI_CQ_COND_NONE;
     cq_attr.format = FI_CQ_FORMAT_TAGGED;
     cq_attr.size = NA_OFI_CQ_DEPTH;
-    rc = fi_cq_open(na_ofi_domain->nod_domain, &cq_attr,
-        &na_ofi_endpoint->noe_cq, NULL);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_cq_open failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_cq_open(na_ofi_domain->fi_domain, &cq_attr, &na_ofi_endpoint->fi_cq,
+        NULL);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_cq_open failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
     /* Bind the CQ and AV to the endpoint */
-    rc = fi_ep_bind(na_ofi_endpoint->noe_ep, &na_ofi_endpoint->noe_cq->fid,
+    rc = fi_ep_bind(na_ofi_endpoint->fi_ep, &na_ofi_endpoint->fi_cq->fid,
         FI_TRANSMIT | FI_RECV);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_ep_bind failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_ep_bind() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-    rc = fi_ep_bind(na_ofi_endpoint->noe_ep, &na_ofi_domain->nod_av->fid, 0);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_ep_bind failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_ep_bind(na_ofi_endpoint->fi_ep, &na_ofi_domain->fi_av->fid, 0);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_ep_bind() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
     /* Enable the endpoint for communication, and commits the bind operations */
-    rc = fi_enable(na_ofi_endpoint->noe_ep);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_enable failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_enable(na_ofi_endpoint->fi_ep);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_enable() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-    na_ofi_endpoint->noe_sep = NA_FALSE;
+    na_ofi_endpoint->sep = NA_FALSE;
 
 out:
     return ret;
@@ -2150,34 +2066,24 @@ na_ofi_sep_open(const struct na_ofi_domain *na_ofi_domain,
     int rc;
 
     /* Create a transport level communication endpoint (sep) */
-    rc = fi_scalable_ep(na_ofi_domain->nod_domain, /* In:  Domain object */
-                        na_ofi_endpoint->noe_prov, /* In:  Provider */
-                        &na_ofi_endpoint->noe_ep,  /* Out: Endpoint object */
-                        NULL);                     /* Optional context */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_scalable_ep failed, rc: %d(%s).",
-                     rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-
-    rc = fi_scalable_ep_bind(na_ofi_endpoint->noe_ep,
-        &na_ofi_domain->nod_av->fid, 0);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_ep_bind failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_scalable_ep(na_ofi_domain->fi_domain, /* In:  Domain object */
+                        na_ofi_endpoint->fi_prov, /* In:  Provider */
+                        &na_ofi_endpoint->fi_ep,  /* Out: Endpoint object */
+                        NULL);                    /* Optional context */
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_scalable_ep() failed, rc: %d (%s)", rc, fi_strerror(-rc));
+
+    rc = fi_scalable_ep_bind(na_ofi_endpoint->fi_ep, &na_ofi_domain->fi_av->fid,
+        0);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_ep_bind() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
     /* Enable the endpoint for communication, and commits the bind operations */
-    ret = fi_enable(na_ofi_endpoint->noe_ep);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_enable failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    ret = fi_enable(na_ofi_endpoint->fi_ep);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_enable() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-    na_ofi_endpoint->noe_sep = NA_TRUE;
+    na_ofi_endpoint->sep = NA_TRUE;
 
 out:
     return ret;
@@ -2190,64 +2096,52 @@ na_ofi_endpoint_close(struct na_ofi_endpoint *na_ofi_endpoint)
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    if (!na_ofi_endpoint) goto out;
+    if (!na_ofi_endpoint)
+        goto out;
 
     /* When not using SEP */
-    if (na_ofi_endpoint->noe_unexpected_op_queue) {
+    if (na_ofi_endpoint->retry_op_queue) {
         /* Check that unexpected op queue is empty */
-        if (!HG_QUEUE_IS_EMPTY(
-            &na_ofi_endpoint->noe_unexpected_op_queue->noq_queue)) {
-            NA_LOG_ERROR("Unexpected op queue should be empty");
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        hg_thread_spin_destroy(
-            &na_ofi_endpoint->noe_unexpected_op_queue->noq_lock);
-        free(na_ofi_endpoint->noe_unexpected_op_queue);
+        na_bool_t empty = HG_QUEUE_IS_EMPTY(
+            &na_ofi_endpoint->retry_op_queue->queue);
+        NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_BUSY,
+            "Retry op queue should be empty");
+        hg_thread_mutex_destroy(&na_ofi_endpoint->retry_op_queue->mutex);
+        free(na_ofi_endpoint->retry_op_queue);
     }
 
     /* Close endpoint */
-    if (na_ofi_endpoint->noe_ep) {
-        rc = fi_close(&na_ofi_endpoint->noe_ep->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close endpoint failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_endpoint->noe_ep = NULL;
+    if (na_ofi_endpoint->fi_ep) {
+        rc = fi_close(&na_ofi_endpoint->fi_ep->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() endpoint failed, rc: %d (%s)", rc, fi_strerror(-rc));
+        na_ofi_endpoint->fi_ep = NULL;
     }
 
     /* Close completion queue */
-    if (na_ofi_endpoint->noe_cq) {
-        rc = fi_close(&na_ofi_endpoint->noe_cq->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close CQ failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_endpoint->noe_cq = NULL;
+    if (na_ofi_endpoint->fi_cq) {
+        rc = fi_close(&na_ofi_endpoint->fi_cq->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() CQ failed, rc: %d (%s)", rc, fi_strerror(-rc));
+        na_ofi_endpoint->fi_cq = NULL;
     }
 
     /* Close wait set */
-    if (na_ofi_endpoint->noe_wait) {
-        rc = fi_close(&na_ofi_endpoint->noe_wait->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close wait failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_endpoint->noe_wait = NULL;
+    if (na_ofi_endpoint->fi_wait) {
+        rc = fi_close(&na_ofi_endpoint->fi_wait->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() wait failed, rc: %d (%s)", rc, fi_strerror(-rc));
+        na_ofi_endpoint->fi_wait = NULL;
     }
 
     /* Free OFI info */
-    if (na_ofi_endpoint->noe_prov) {
-        fi_freeinfo(na_ofi_endpoint->noe_prov);
-        na_ofi_endpoint->noe_prov = NULL;
+    if (na_ofi_endpoint->fi_prov) {
+        fi_freeinfo(na_ofi_endpoint->fi_prov);
+        na_ofi_endpoint->fi_prov = NULL;
     }
 
-    if (na_ofi_endpoint->noe_addr)
-        na_ofi_addr_decref(na_ofi_endpoint->noe_addr);
+    if (na_ofi_endpoint->src_addr)
+        na_ofi_addr_decref(na_ofi_endpoint->src_addr);
     free(na_ofi_endpoint);
 
 out:
@@ -2259,63 +2153,50 @@ static na_return_t
 na_ofi_get_ep_addr(na_class_t *na_class, struct na_ofi_addr **na_ofi_addr_ptr)
 {
     struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_domain *na_ofi_domain = priv->nop_domain;
-    struct na_ofi_endpoint *na_ofi_endpoint = priv->nop_endpoint;
+    struct na_ofi_domain *na_ofi_domain = priv->domain;
+    struct na_ofi_endpoint *na_ofi_endpoint = priv->endpoint;
     struct na_ofi_addr *na_ofi_addr = NULL;
     void *addr = NULL;
-    size_t addrlen = na_ofi_domain->nod_prov->src_addrlen;
+    size_t addrlen = na_ofi_domain->fi_prov->src_addrlen;
     na_bool_t retried = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("Could not allocate NA OFI addr");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_addr = na_ofi_addr_alloc(priv->domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA OFI addr");
 
-retry_getname:
-    if (retried)
-        free(addr);
+retry:
     addr = malloc(addrlen);
-    if (addr == NULL) {
-        NA_LOG_ERROR("Could not allocate addr.");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate addr");
 
-    rc = fi_getname(&na_ofi_endpoint->noe_ep->fid, addr, &addrlen);
-    if (rc != FI_SUCCESS) {
-        if (rc == -FI_ETOOSMALL && retried == NA_FALSE) {
-            retried = NA_TRUE;
-            goto retry_getname;
-        }
-        NA_LOG_ERROR("fi_getname failed, rc: %d(%s), addrlen: %zu.",
-                     rc, fi_strerror(-rc), addrlen);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
+    rc = fi_getname(&na_ofi_endpoint->fi_ep->fid, addr, &addrlen);
+    if (rc == -FI_ETOOSMALL && retried == NA_FALSE) {
+        retried = NA_TRUE;
+        free(addr);
+        goto retry;
     }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_getname() failed, rc: %d (%s), addrlen: %zu", rc, fi_strerror(-rc),
+        addrlen);
 
     na_ofi_addr->addr = addr;
     na_ofi_addr->addrlen = addrlen;
-    na_ofi_addr->self = NA_TRUE;
 
     /* Get URI from address */
     ret = na_ofi_get_uri(na_class, na_ofi_addr->addr, &na_ofi_addr->uri);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not get URI from endpoint address");
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not get URI from endpoint address");
 
     /* TODO check address size */
    *na_ofi_addr_ptr = na_ofi_addr;
 
-out:
-    if (ret != NA_SUCCESS) {
-        free(addr);
-        free(na_ofi_addr);
-    }
+    return ret;
+
+error:
+    free(addr);
+    free(na_ofi_addr);
+
     return ret;
 }
 
@@ -2323,8 +2204,7 @@ out:
 static na_return_t
 na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_domain *na_ofi_domain = priv->nop_domain;
+    struct na_ofi_domain *na_ofi_domain = NA_OFI_CLASS(na_class)->domain;
     char addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         fi_addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         *fi_addr_str_ptr, *uri = NULL;
@@ -2333,42 +2213,31 @@ na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
     int rc;
 
     /* Convert FI address to a printable string */
-    fi_av_straddr(na_ofi_domain->nod_av, addr, fi_addr_str, &fi_addr_strlen);
-    if (fi_addr_strlen > NA_OFI_MAX_URI_LEN) {
-        NA_LOG_ERROR("fi_av_straddr() address truncated, addrlen: %zu",
-            fi_addr_strlen);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    fi_av_straddr(na_ofi_domain->fi_av, addr, fi_addr_str, &fi_addr_strlen);
+    NA_CHECK_ERROR(fi_addr_strlen > NA_OFI_MAX_URI_LEN, out, ret,
+        NA_PROTOCOL_ERROR, "fi_av_straddr() address truncated, addrlen: %zu",
+        fi_addr_strlen);
 
     /* Remove unnecessary "://" prefix from string if present */
     if (strstr(fi_addr_str, "://")) {
         strtok_r(fi_addr_str, ":", &fi_addr_str_ptr);
-        if (strncmp(fi_addr_str_ptr, "//", 2) != 0) {
-            NA_LOG_ERROR("Bad address string format");
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = strncmp(fi_addr_str_ptr, "//", 2);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTONOSUPPORT,
+            "Bad address string format");
         fi_addr_str_ptr += 2;
     } else
         fi_addr_str_ptr = fi_addr_str;
 
     /* Generate URI */
     rc = snprintf(addr_str, NA_OFI_MAX_URI_LEN, "%s://%s",
-        na_ofi_domain->nod_prov->fabric_attr->prov_name, fi_addr_str_ptr);
-    if (rc < 0 || rc > NA_OFI_MAX_URI_LEN) {
-        NA_LOG_ERROR("snprintf failed or name truncated, rc: %d.", rc);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+        na_ofi_domain->fi_prov->fabric_attr->prov_name, fi_addr_str_ptr);
+    NA_CHECK_ERROR(rc < 0 || rc > NA_OFI_MAX_URI_LEN, out, ret,
+        NA_OVERFLOW, "snprintf() failed or name truncated, rc: %d", rc);
 
     /* Dup URI */
     uri = strdup(addr_str);
-    if (uri == NULL) {
-        NA_LOG_ERROR("Could not strdup EP address string.");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(uri == NULL, out, ret, NA_NOMEM,
+        "Could not strdup address string");
 
     *uri_ptr = uri;
 
@@ -2378,19 +2247,22 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static struct na_ofi_addr *
-na_ofi_addr_alloc(void)
+na_ofi_addr_alloc(struct na_ofi_domain *na_ofi_domain)
 {
     struct na_ofi_addr *na_ofi_addr;
 
     na_ofi_addr = (struct na_ofi_addr *)calloc(1, sizeof(*na_ofi_addr));
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("Could not allocate addr");
-        return NULL;
-    }
+    NA_CHECK_ERROR_NORET(na_ofi_addr == NULL, out,
+        "Could not allocate addr");
+
+    /* Keep reference to domain */
+    na_ofi_addr->domain = na_ofi_domain;
+    hg_atomic_incr32(&na_ofi_domain->refcount);
 
     /* One refcount for the caller to hold until addr_free */
-    hg_atomic_set32(&na_ofi_addr->refcount, 1);
+    hg_atomic_init32(&na_ofi_addr->refcount, 1);
 
+out:
     return na_ofi_addr;
 }
 
@@ -2398,7 +2270,6 @@ na_ofi_addr_alloc(void)
 static NA_INLINE void
 na_ofi_addr_addref(struct na_ofi_addr *na_ofi_addr)
 {
-    assert(hg_atomic_get32(&na_ofi_addr->refcount));
     hg_atomic_incr32(&na_ofi_addr->refcount);
 }
 
@@ -2406,13 +2277,19 @@ na_ofi_addr_addref(struct na_ofi_addr *na_ofi_addr)
 static NA_INLINE void
 na_ofi_addr_decref(struct na_ofi_addr *na_ofi_addr)
 {
-    assert(hg_atomic_get32(&na_ofi_addr->refcount) > 0);
-
     /* If there are more references, return */
     if (hg_atomic_decr32(&na_ofi_addr->refcount))
         return;
 
-    /* TODO need to fi_av_remove? */
+    /* Do not call fi_av_remove() here to prevent multiple insert/remove calls
+     * into AV */
+    if (na_ofi_addr->remove) {
+        NA_LOG_DEBUG("fi_addr=%" SCNx64 " ht_key=%" SCNx64,
+            na_ofi_addr->fi_addr, na_ofi_addr->ht_key);
+        na_ofi_addr_ht_remove(na_ofi_addr->domain, &na_ofi_addr->fi_addr,
+            &na_ofi_addr->ht_key);
+    }
+    na_ofi_domain_close(na_ofi_addr->domain);
     free(na_ofi_addr->addr);
     free(na_ofi_addr->uri);
     free(na_ofi_addr);
@@ -2428,16 +2305,13 @@ na_ofi_mem_pool_create(na_class_t *na_class, na_size_t block_size,
         + sizeof(struct na_ofi_mem_pool)
         + block_count * (offsetof(struct na_ofi_mem_node, block));
     struct fid_mr *mr_hdl = NULL;
-    char *mem_ptr = NULL;
     na_size_t i;
 
-    mem_ptr = (char *) na_ofi_mem_alloc(na_class, pool_size, &mr_hdl);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate %d bytes", (int) pool_size);
-        goto out;
-    }
+    na_ofi_mem_pool = (struct na_ofi_mem_pool *) na_ofi_mem_alloc(na_class,
+        pool_size, &mr_hdl);
+    NA_CHECK_ERROR_NORET(na_ofi_mem_pool == NULL, out,
+        "Could not allocate %d bytes", (int) pool_size);
 
-    na_ofi_mem_pool = (struct na_ofi_mem_pool *) mem_ptr;
     HG_QUEUE_INIT(&na_ofi_mem_pool->node_list);
     hg_thread_spin_init(&na_ofi_mem_pool->node_list_lock);
     na_ofi_mem_pool->mr_hdl = mr_hdl;
@@ -2446,7 +2320,8 @@ na_ofi_mem_pool_create(na_class_t *na_class, na_size_t block_size,
     /* Assign nodes and insert them to free list */
     for (i = 0; i < block_count; i++) {
         struct na_ofi_mem_node *na_ofi_mem_node =
-            (struct na_ofi_mem_node *) (mem_ptr + sizeof(struct na_ofi_mem_pool)
+            (struct na_ofi_mem_node *) ((char *) na_ofi_mem_pool
+                + sizeof(struct na_ofi_mem_pool)
                 + i * (offsetof(struct na_ofi_mem_node, block) + block_size));
         HG_QUEUE_PUSH_TAIL(&na_ofi_mem_pool->node_list, na_ofi_mem_node, entry);
     }
@@ -2467,29 +2342,27 @@ na_ofi_mem_pool_destroy(struct na_ofi_mem_pool *na_ofi_mem_pool)
 static NA_INLINE void *
 na_ofi_mem_alloc(na_class_t *na_class, na_size_t size, struct fid_mr **mr_hdl)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     na_size_t page_size = (na_size_t) hg_mem_get_page_size();
     void *mem_ptr = NULL;
 
     /* Allocate backend buffer */
     mem_ptr = hg_mem_aligned_alloc(page_size, size);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate %d bytes", (int) size);
-        goto out;
-    }
+    NA_CHECK_ERROR_NORET(mem_ptr == NULL, out,
+        "Could not allocate %d bytes", (int) size);
     memset(mem_ptr, 0, size);
 
     /* Register memory if FI_MR_LOCAL is set and provider uses it */
-    if (domain->nod_prov->domain_attr->mr_mode & FI_MR_LOCAL) {
+    if (domain->fi_prov->domain_attr->mr_mode & FI_MR_LOCAL) {
         int rc;
 
-        rc = fi_mr_reg(domain->nod_domain, mem_ptr, size, FI_REMOTE_READ
+        rc = fi_mr_reg(domain->fi_domain, mem_ptr, size, FI_REMOTE_READ
             | FI_REMOTE_WRITE | FI_SEND | FI_RECV | FI_READ | FI_WRITE, 0 /* offset */,
             0 /* requested key */, 0 /* flags */, mr_hdl, NULL /* context */);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_mr_reg failed, rc: %d (%s).", rc, fi_strerror(-rc));
+        if (unlikely(rc != 0)) {
             hg_mem_aligned_free(mem_ptr);
-            goto out;
+            NA_GOTO_ERROR(out, mem_ptr, NULL,
+                "fi_mr_reg() failed, rc: %d (%s)", rc, fi_strerror(-rc));
         }
     }
 
@@ -2503,16 +2376,14 @@ na_ofi_mem_free(void *mem_ptr, struct fid_mr *mr_hdl)
 {
     /* Release MR handle is there was any */
     if (mr_hdl) {
-        int rc;
-
-        rc = fi_close(&mr_hdl->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close mr_hdl failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-        }
+        int rc = fi_close(&mr_hdl->fid);
+        NA_CHECK_ERROR_NORET(rc != 0, out,
+            "fi_close() mr_hdl failed, rc: %d (%s)", rc, fi_strerror(-rc));
     }
 
+out:
     hg_mem_aligned_free(mem_ptr);
+    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2527,16 +2398,16 @@ na_ofi_mem_pool_alloc(na_class_t *na_class, na_size_t size,
 
 retry:
     /* Check whether we can get a block from one of the pools */
-    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
     HG_QUEUE_FOREACH(na_ofi_mem_pool,
-        &NA_OFI_CLASS(na_class)->nop_buf_pool, entry) {
+        &NA_OFI_CLASS(na_class)->buf_pool, entry) {
         hg_thread_spin_lock(&na_ofi_mem_pool->node_list_lock);
         found = !HG_QUEUE_IS_EMPTY(&na_ofi_mem_pool->node_list);
         hg_thread_spin_unlock(&na_ofi_mem_pool->node_list_lock);
         if (found)
             break;
     }
-    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
 
     /* If not, allocate and register a new pool */
     if (!found) {
@@ -2544,16 +2415,14 @@ retry:
             na_ofi_mem_pool_create(na_class,
                 na_ofi_msg_get_max_unexpected_size(na_class),
                 NA_OFI_MEM_BLOCK_COUNT);
-        hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
-        HG_QUEUE_PUSH_TAIL(&NA_OFI_CLASS(na_class)->nop_buf_pool,
+        hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
+        HG_QUEUE_PUSH_TAIL(&NA_OFI_CLASS(na_class)->buf_pool,
             na_ofi_mem_pool, entry);
-        hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+        hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
     }
 
-    if (size > na_ofi_mem_pool->block_size) {
-        NA_LOG_ERROR("Block size is too small for requested size");
-        goto out;
-    }
+    NA_CHECK_ERROR(size > na_ofi_mem_pool->block_size, out, mem_ptr, NULL,
+        "Block size is too small for requested size");
 
     /* Pick a node from one of the available pools */
     hg_thread_spin_lock(&na_ofi_mem_pool->node_list_lock);
@@ -2580,9 +2449,9 @@ na_ofi_mem_pool_free(na_class_t *na_class, void *mem_ptr, struct fid_mr *mr_hdl)
         container_of(mem_ptr, struct na_ofi_mem_node, block);
 
     /* Put the node back to the pool */
-    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
     HG_QUEUE_FOREACH(na_ofi_mem_pool,
-        &NA_OFI_CLASS(na_class)->nop_buf_pool, entry) {
+        &NA_OFI_CLASS(na_class)->buf_pool, entry) {
         /* If MR handle is NULL, it does not really matter which pool we push
          * the node back to.
          */
@@ -2593,18 +2462,14 @@ na_ofi_mem_pool_free(na_class_t *na_class, void *mem_ptr, struct fid_mr *mr_hdl)
             break;
         }
     }
-    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE void
 na_ofi_op_id_addref(struct na_ofi_op_id *na_ofi_op_id)
 {
-    /* init as 1 when op_create */
-    assert(hg_atomic_get32(&na_ofi_op_id->noo_refcount));
-    hg_atomic_incr32(&na_ofi_op_id->noo_refcount);
-
-    return;
+    hg_atomic_incr32(&na_ofi_op_id->refcount);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2614,177 +2479,86 @@ na_ofi_op_id_decref(struct na_ofi_op_id *na_ofi_op_id)
     if (na_ofi_op_id == NULL)
         return;
 
-    assert(hg_atomic_get32(&na_ofi_op_id->noo_refcount) > 0);
-
     /* If there are more references, return */
-    if (hg_atomic_decr32(&na_ofi_op_id->noo_refcount))
+    if (hg_atomic_decr32(&na_ofi_op_id->refcount))
         return;
 
     /* No more references, cleanup */
-    na_ofi_op_id->noo_magic_1 = 0;
-    na_ofi_op_id->noo_magic_2 = 0;
     free(na_ofi_op_id);
-
-    return;
-}
-
-/*---------------------------------------------------------------------------*/
-static NA_INLINE na_bool_t
-na_ofi_op_id_valid(struct na_ofi_op_id *na_ofi_op_id)
-{
-    if (na_ofi_op_id == NULL)
-        return NA_FALSE;
-
-    if (na_ofi_op_id->noo_magic_1 != NA_OFI_OP_ID_MAGIC_1 ||
-        na_ofi_op_id->noo_magic_2 != NA_OFI_OP_ID_MAGIC_2) {
-        NA_LOG_ERROR("invalid magic number for na_ofi_op_id.");
-        return NA_FALSE;
-    }
-
-    return NA_TRUE;
-}
-
-/*---------------------------------------------------------------------------*/
-static NA_INLINE void
-na_ofi_msg_unexpected_op_push(na_context_t *context,
-    struct na_ofi_op_id *na_ofi_op_id)
-{
-    struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-
-    hg_thread_spin_lock(&ctx->noc_unexpected_op_queue->noq_lock);
-    HG_QUEUE_PUSH_TAIL(&ctx->noc_unexpected_op_queue->noq_queue, na_ofi_op_id,
-        noo_entry);
-    hg_thread_spin_unlock(&ctx->noc_unexpected_op_queue->noq_lock);
-}
-
-/*---------------------------------------------------------------------------*/
-static NA_INLINE void
-na_ofi_msg_unexpected_op_remove(na_context_t *context,
-    struct na_ofi_op_id *na_ofi_op_id)
-{
-    struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-
-    hg_thread_spin_lock(&ctx->noc_unexpected_op_queue->noq_lock);
-    HG_QUEUE_REMOVE(&ctx->noc_unexpected_op_queue->noq_queue, na_ofi_op_id,
-        na_ofi_op_id, noo_entry);
-    hg_thread_spin_unlock(&ctx->noc_unexpected_op_queue->noq_lock);
-}
-
-/*---------------------------------------------------------------------------*/
-static NA_INLINE struct na_ofi_op_id *
-na_ofi_msg_unexpected_op_pop(na_context_t *context)
-{
-    struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct na_ofi_op_id *na_ofi_op_id;
-
-    hg_thread_spin_lock(&ctx->noc_unexpected_op_queue->noq_lock);
-    na_ofi_op_id = HG_QUEUE_FIRST(&ctx->noc_unexpected_op_queue->noq_queue);
-    HG_QUEUE_POP_HEAD(&ctx->noc_unexpected_op_queue->noq_queue, noo_entry);
-    hg_thread_spin_unlock(&ctx->noc_unexpected_op_queue->noq_lock);
-
-    return na_ofi_op_id;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
-    size_t max_count, struct fi_cq_tagged_entry cq_events[],
-    fi_addr_t src_addrs[], void **src_err_addr, size_t *src_err_addrlen,
-    size_t *actual_count)
+na_ofi_cq_read(na_context_t *context, size_t max_count,
+    struct fi_cq_tagged_entry cq_events[], fi_addr_t src_addrs[],
+    void **src_err_addr, size_t *src_err_addrlen, size_t *actual_count)
 {
-    struct fid_cq *cq_hdl = NA_OFI_CONTEXT(context)->noc_cq;
-    char err_data[NA_OFI_CQ_MAX_ERR_DATA_SIZE];
+    struct fid_cq *cq_hdl = NA_OFI_CONTEXT(context)->fi_cq;
     struct fi_cq_err_entry cq_err;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
     rc = fi_cq_readfrom(cq_hdl, cq_events, max_count, src_addrs);
     if (rc > 0) { /* events available */
+        *src_err_addrlen = 0;
         *actual_count = (size_t) rc;
         goto out;
     }
     if (rc == -FI_EAGAIN) { /* no event available */
+        *src_err_addrlen = 0;
         *actual_count = 0;
         goto out;
     }
-    if (rc != -FI_EAVAIL) { /* no error available */
-        NA_LOG_ERROR("fi_cq_readfrom() failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != -FI_EAVAIL, out, ret, NA_PROTOCOL_ERROR,
+        "fi_cq_readfrom() failed, rc: %d (%s)", rc, fi_strerror((int) -rc));
 
     memset(&cq_err, 0, sizeof(cq_err));
-    memset(&err_data, 0, sizeof(err_data));
+
     /* Prevent provider from internally allocating resources */
-    cq_err.err_data = err_data;
-    cq_err.err_data_size = NA_OFI_CQ_MAX_ERR_DATA_SIZE;
+    cq_err.err_data = *src_err_addr;
+    cq_err.err_data_size = *src_err_addrlen;
 
     /* Read error entry */
     rc = fi_cq_readerr(cq_hdl, &cq_err, 0 /* flags */);
-    if (rc != 1) {
-        NA_LOG_ERROR("fi_cq_readerr() failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 1, out, ret, NA_PROTOCOL_ERROR,
+        "fi_cq_readerr() failed, rc: %d (%s)", rc, fi_strerror((int) -rc));
 
     switch (cq_err.err) {
-        case FI_ECANCELED:
-//            NA_LOG_DEBUG("got a FI_ECANCELED event, cq_event.flags 0x%x.",
-//                         cq_err.flags);
-            goto out;
-
-        case FI_EADDRNOTAVAIL: {
-            struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-            struct fid_av *av_hdl = priv->nop_domain->nod_av;
-            void *err_addr = NULL;
-            size_t err_addrlen;
-
-            /* Copy addr information */
-            err_addr = malloc(cq_err.err_data_size);
-            if (!err_addr) {
-                NA_LOG_ERROR("Could not allocate err_addr");
-                ret = NA_NOMEM_ERROR;
-                goto out;
-            }
-            err_addrlen = cq_err.err_data_size;
-            memcpy(err_addr, cq_err.err_data, err_addrlen);
-
-            na_ofi_domain_lock(priv->nop_domain);
-            /* Insert new source addr into AV if address was not found */
-            rc = fi_av_insert(av_hdl, err_addr, 1, &src_addrs[0],
-                0 /* flags */, NULL /* context */);
-            na_ofi_domain_unlock(priv->nop_domain);
-            if (rc < 1) {
-                NA_LOG_ERROR("fi_av_insert failed, rc: %d(%s).",
-                    rc, fi_strerror((int) -rc));
-                ret = NA_PROTOCOL_ERROR;
-                free(err_addr);
-                goto out;
-            }
+        case FI_ECANCELED: {
+            struct na_ofi_op_id *na_ofi_op_id = container_of(
+                cq_err.op_context, struct na_ofi_op_id, fi_ctx);
+
+            NA_CHECK_ERROR(na_ofi_op_id == NULL, out, ret, NA_INVALID_ARG,
+                "Invalid operation ID");
+            NA_CHECK_ERROR(
+                hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED,
+                out, ret, NA_FAULT, "Operation ID was completed");
+            NA_LOG_DEBUG("FI_ECANCELED event on operation ID %p", na_ofi_op_id);
+            NA_CHECK_ERROR(
+                !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_CANCELED),
+                out, ret, NA_FAULT, "Operation ID was not canceled");
+
+            /* Complete operation in canceled state */
+            ret = na_ofi_complete(na_ofi_op_id);
+            NA_CHECK_NA_ERROR(out, ret, "Unable to complete operation");
+         }
+            break;
+
+        case FI_EADDRNOTAVAIL:
             /* Only one error event processed in that case */
             memcpy(&cq_events[0], &cq_err, sizeof(cq_events[0]));
+            *src_err_addr = cq_err.err_data;
+            *src_err_addrlen = cq_err.err_data_size;
             *actual_count = 1;
-            *src_err_addr = err_addr;
-            *src_err_addrlen = err_addrlen;
             break;
-        }
-        case FI_EIO:
-            NA_LOG_ERROR("fi_cq_readerr got err: %d(%s), "
-                "prov_errno: %d(%s).",
-                cq_err.err, fi_strerror(cq_err.err),
-                cq_err.prov_errno,
-                fi_strerror(-cq_err.prov_errno));
-            goto out;
+
         default:
-            NA_LOG_ERROR("fi_cq_readerr got err: %d(%s), "
-                "prov_errno: %d(%s).",
-                cq_err.err, fi_strerror(cq_err.err),
-                cq_err.prov_errno,
+            /* Ignore errors from OFI that we cannot handle */
+            NA_LOG_WARNING(
+                "fi_cq_readerr() got err: %d (%s), prov_errno: %d (%s)",
+                cq_err.err, fi_strerror(cq_err.err), cq_err.prov_errno,
                 fi_strerror(-cq_err.prov_errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
+            break;
     }
 
 out:
@@ -2793,70 +2567,46 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
+na_ofi_cq_process_event(na_class_t *na_class,
     const struct fi_cq_tagged_entry *cq_event, fi_addr_t src_addr,
     void *src_err_addr, size_t src_err_addrlen)
 {
     struct na_ofi_op_id *na_ofi_op_id = container_of(
-        cq_event->op_context, struct na_ofi_op_id, noo_fi_ctx);
+        cq_event->op_context, struct na_ofi_op_id, fi_ctx);
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_ofi_op_id_valid(na_ofi_op_id)) {
-        NA_LOG_ERROR("Bad na_ofi_op_id, ignoring event.");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-    if (hg_atomic_get32(&na_ofi_op_id->noo_canceled)) {
-        ret = NA_CANCELED;
-        goto complete;
-    }
-    if (hg_atomic_get32(&na_ofi_op_id->noo_completed)) {
-        NA_LOG_ERROR("Ignoring CQ event as the op is completed.");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_op_id == NULL, out, ret, NA_INVALID_ARG,
+        "Invalid operation ID");
+    /* Cannot have an already completed operation ID, sanity check */
+    NA_CHECK_ERROR(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED,
+        out, ret, NA_FAULT, "Operation ID was completed");
 
     if (cq_event->flags & FI_SEND) {
         ret = na_ofi_cq_process_send_event(na_ofi_op_id);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not process send event");
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(out, ret, "Could not process send event");
     } else if (cq_event->flags & FI_RECV) {
-        if (cq_event->tag & ~NA_OFI_UNEXPECTED_TAG_IGNORE) {
-            ret = na_ofi_cq_process_recv_expected_event(na_ofi_op_id,
+        if (cq_event->tag & NA_OFI_UNEXPECTED_TAG) {
+            ret = na_ofi_cq_process_recv_unexpected_event(na_class,
+                na_ofi_op_id, src_addr, src_err_addr, src_err_addrlen,
                 cq_event->tag, cq_event->len);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not process expected recv event");
-                goto out;
-            }
+            NA_CHECK_NA_ERROR(out, ret,
+                "Could not process unexpected recv event");
         } else {
-            ret = na_ofi_cq_process_recv_unexpected_event(na_class, context,
-                na_ofi_op_id, src_addr, src_err_addr, src_err_addrlen,
+            ret = na_ofi_cq_process_recv_expected_event(na_ofi_op_id,
                 cq_event->tag, cq_event->len);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not process unexpected recv event");
-                goto out;
-            }
+            NA_CHECK_NA_ERROR(out, ret,
+                "Could not process expected recv event");
         }
     } else if (cq_event->flags & FI_RMA) {
         ret = na_ofi_cq_process_rma_event(na_ofi_op_id);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not process rma event");
-            goto out;
-        }
-    } else {
-        NA_LOG_ERROR("bad cq event flags: 0x%x.", cq_event->flags);
-        goto out;
-    }
+        NA_CHECK_NA_ERROR(out, ret, "Could not process rma event");
+    } else
+        NA_GOTO_ERROR(out, ret, NA_PROTONOSUPPORT,
+            "Unsupported CQ event flags: 0x%x.", cq_event->flags);
 
-complete:
     /* Complete operation */
-    ret = na_ofi_complete(na_ofi_op_id, ret);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Unable to complete operation");
-        goto out;
-    }
+    ret = na_ofi_complete(na_ofi_op_id);
+    NA_CHECK_NA_ERROR(out, ret, "Unable to complete operation");
 
 out:
     return ret;
@@ -2866,15 +2616,12 @@ out:
 static NA_INLINE na_return_t
 na_ofi_cq_process_send_event(struct na_ofi_op_id *na_ofi_op_id)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_SEND_EXPECTED && cb_type != NA_CB_SEND_UNEXPECTED) {
-        NA_LOG_ERROR("ignore the send_event as cb_type %d mismatched with "
-            "NA_CB_SEND_EXPECTED/_UNEXPECTED.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_SEND_EXPECTED
+        && cb_type != NA_CB_SEND_UNEXPECTED, out, ret, NA_PROTOCOL_ERROR,
+        "Invalid cb_type %d, expected NA_CB_SEND_EXPECTED/UNEXPECTED", cb_type);
 
 out:
     return ret;
@@ -2883,56 +2630,59 @@ out:
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
-    na_context_t *context, struct na_ofi_op_id *na_ofi_op_id,
-    fi_addr_t src_addr, void *src_err_addr, size_t src_err_addrlen,
-    uint64_t tag, size_t len)
+    struct na_ofi_op_id *na_ofi_op_id, fi_addr_t src_addr, void *src_err_addr,
+    size_t src_err_addrlen, uint64_t tag, size_t len)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_RECV_UNEXPECTED) {
-        NA_LOG_ERROR("ignore the recv_event as cb_type %d mismatched with "
-            "NA_CB_RECV_UNEXPECTED.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_RECV_UNEXPECTED, out, ret,
+        NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_RECV_UNEXPECTED",
+        cb_type);
+    NA_CHECK_ERROR((tag & ~NA_OFI_UNEXPECTED_TAG) > NA_OFI_MAX_TAG, out, ret,
+        NA_OVERFLOW, "Invalid tag value %llu", tag);
 
     /* Allocate new address */
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("na_ofi_addr_alloc failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    na_ofi_addr->addr = src_err_addr; /* may be NULL */
-    na_ofi_addr->addrlen = src_err_addrlen;
-    /* Unexpected address may not have addr/addrlen info */
-    na_ofi_addr->unexpected = NA_TRUE;
+    na_ofi_addr = na_ofi_addr_alloc(domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM,
+        "na_ofi_addr_alloc() failed");
+    /* Unexpected addresses do not need to set addr/addrlen info, fi_av_lookup()
+     * can be used when needed. */
+
+    /* Use src_addr when available */
+    if (src_addr != FI_ADDR_UNSPEC)
+        na_ofi_addr->fi_addr = src_addr;
+    else if (src_err_addr && src_err_addrlen) { /* addr from error info */
+        /* We do not need to keep a copy of src_err_addr */
+        ret = na_ofi_addr_ht_lookup(domain,
+            na_ofi_prov_addr_format[domain->prov_type], src_err_addr,
+            src_err_addrlen, &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
+        NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
+    } else if (na_ofi_with_msg_hdr(na_class)) { /* addr from msg header */
+        /* We do not need to keep a copy of msg header */
+        ret = na_ofi_addr_ht_lookup(domain, FI_SOCKADDR_IN,
+            na_ofi_op_id->info.msg.buf.ptr, sizeof(struct na_ofi_sin_addr),
+            &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
+        NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
+    } else
+        NA_GOTO_ERROR(error, ret, NA_PROTONOSUPPORT,
+            "Insufficient address information");
 
-    /* Process address info from msg header */
-    if (na_ofi_with_msg_hdr(na_class)) {
-        ret = na_ofi_addr_ht_lookup(na_class, FI_SOCKADDR_IN,
-            na_ofi_op_id->noo_info.noo_recv_unexpected.noi_buf,
-            sizeof(struct na_ofi_sin_addr), &src_addr);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("na_ofi_addr_ht_lookup_reqhdr failed, ret: %d.", ret);
-            na_ofi_addr_decref(na_ofi_addr);
-            goto out;
-        }
-    }
-    na_ofi_addr->fi_addr = src_addr;
-    /* For unexpected msg, take one extra ref to be released by addr_free() */
-    na_ofi_addr_addref(na_ofi_addr);
+    na_ofi_op_id->addr = na_ofi_addr;
+    na_ofi_op_id->info.msg.tag = tag & NA_OFI_TAG_MASK;
+    na_ofi_op_id->info.msg.actual_buf_size = len;
 
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    /* TODO check max tag */
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_tag = (na_tag_t) tag;
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_msg_size = len;
-    na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
+    NA_LOG_DEBUG("Received unexpected message with tag=%llu, len=%zu",
+        tag, len);
 
 out:
     return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2940,26 +2690,18 @@ static NA_INLINE na_return_t
 na_ofi_cq_process_recv_expected_event(struct na_ofi_op_id *na_ofi_op_id,
     uint64_t tag, size_t len)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_RECV_EXPECTED) {
-        NA_LOG_ERROR("ignore the recv_event as cb_type %d mismatched with "
-            "NA_CB_RECV_EXPECTED.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-    if (na_ofi_op_id->noo_info.noo_recv_expected.noi_tag
-        != (tag & ~NA_OFI_EXPECTED_TAG_FLAG)) {
-        NA_LOG_ERROR("ignore the recv_event as noi_tag 0x%x mismatch with "
-            "cq_event->tag: 0x%x.",
-            na_ofi_op_id->noo_info.noo_recv_expected.noi_tag,
-            tag & ~NA_OFI_EXPECTED_TAG_FLAG);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_RECV_EXPECTED, out, ret,
+        NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_RECV_EXPECTED",
+        cb_type);
+    NA_CHECK_ERROR(tag > NA_OFI_MAX_TAG, out, ret, NA_OVERFLOW,
+        "Invalid tag value");
 
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_msg_size = len;
+    na_ofi_op_id->info.msg.actual_buf_size = len;
+
+    NA_LOG_DEBUG("Received expected message with tag=%llu, len=%zu", tag, len);
 
 out:
     return ret;
@@ -2969,15 +2711,12 @@ out:
 static NA_INLINE na_return_t
 na_ofi_cq_process_rma_event(struct na_ofi_op_id *na_ofi_op_id)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_PUT && cb_type != NA_CB_GET) {
-        NA_LOG_ERROR("ignore the send_event as cb_type %d mismatched with "
-            "NA_CB_PUT/_GET.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_PUT && cb_type != NA_CB_GET, out, ret,
+        NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_PUT/GET",
+        cb_type);
 
 out:
     return ret;
@@ -2985,64 +2724,178 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id, na_return_t op_ret)
+na_ofi_cq_process_retries(na_context_t *context)
+{
+    struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
+    struct na_ofi_op_id *na_ofi_op_id = NULL;
+    na_return_t ret = NA_SUCCESS, complete_ret;
+
+    do {
+        ssize_t rc = 0;
+
+        hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+
+        na_ofi_op_id = HG_QUEUE_FIRST(&ctx->retry_op_queue->queue);
+        if (!na_ofi_op_id)
+            break;
+
+        NA_LOG_DEBUG("Attempting to retry %p", na_ofi_op_id);
+        NA_CHECK_ERROR(
+            hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_CANCELED,
+            error, ret, NA_FAULT, "Operation ID was canceled");
+
+        /* Dequeue OP ID */
+        HG_QUEUE_POP_HEAD(&ctx->retry_op_queue->queue, entry);
+        hg_atomic_and32(&na_ofi_op_id->status, ~NA_OFI_OP_QUEUED);
+
+        /* Retry operation */
+        switch (na_ofi_op_id->completion_data.callback_info.type) {
+            case NA_CB_SEND_UNEXPECTED:
+                rc = fi_tsend(ctx->fi_tx, na_ofi_op_id->info.msg.buf.const_ptr,
+                    na_ofi_op_id->info.msg.buf_size,
+                    na_ofi_op_id->info.msg.fi_mr,
+                    na_ofi_op_id->info.msg.fi_addr,
+                    na_ofi_op_id->info.msg.tag | NA_OFI_UNEXPECTED_TAG,
+                    &na_ofi_op_id->fi_ctx);
+                break;
+            case NA_CB_RECV_UNEXPECTED:
+                rc = fi_trecv(ctx->fi_rx, na_ofi_op_id->info.msg.buf.ptr,
+                    na_ofi_op_id->info.msg.buf_size,
+                    na_ofi_op_id->info.msg.fi_mr,
+                    na_ofi_op_id->info.msg.fi_addr,
+                    NA_OFI_UNEXPECTED_TAG, NA_OFI_TAG_MASK,
+                    &na_ofi_op_id->fi_ctx);
+                break;
+            case NA_CB_SEND_EXPECTED:
+                rc = fi_tsend(ctx->fi_tx, na_ofi_op_id->info.msg.buf.const_ptr,
+                    na_ofi_op_id->info.msg.buf_size,
+                    na_ofi_op_id->info.msg.fi_mr,
+                    na_ofi_op_id->info.msg.fi_addr, na_ofi_op_id->info.msg.tag,
+                    &na_ofi_op_id->fi_ctx);
+                break;
+            case NA_CB_RECV_EXPECTED:
+                rc = fi_trecv(ctx->fi_rx, na_ofi_op_id->info.msg.buf.ptr,
+                    na_ofi_op_id->info.msg.buf_size,
+                    na_ofi_op_id->info.msg.fi_mr,
+                    na_ofi_op_id->info.msg.fi_addr, na_ofi_op_id->info.msg.tag,
+                    0, &na_ofi_op_id->fi_ctx);
+                break;
+            case NA_CB_PUT:
+                rc = fi_writemsg(ctx->fi_tx, &na_ofi_op_id->info.rma.fi_rma,
+                    NA_OFI_PUT_COMPLETION);
+                break;
+            case NA_CB_GET:
+                rc = fi_readmsg(ctx->fi_tx, &na_ofi_op_id->info.rma.fi_rma,
+                    NA_OFI_GET_COMPLETION);
+                break;
+            case NA_CB_LOOKUP:
+            default:
+                NA_GOTO_ERROR(error, ret, NA_INVALID_ARG,
+                    "Operation type %d not supported",
+                    na_ofi_op_id->completion_data.callback_info.type);
+        }
+
+        if (unlikely(rc == -FI_EAGAIN)) {
+            NA_LOG_DEBUG("Re-pushing %p for retry", na_ofi_op_id);
+
+            /* Re-push op ID to retry queue */
+            HG_QUEUE_PUSH_TAIL(&NA_OFI_CONTEXT(context)->retry_op_queue->queue,
+                na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+
+            /* Do not attempt to retry again and continue making progress */
+            break;
+        } else
+            NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+                "retry operation of %d failed, rc: %d (%s)",
+                na_ofi_op_id->completion_data.callback_info.type, rc,
+                fi_strerror((int ) -rc));
+
+        hg_thread_mutex_unlock(&NA_OFI_CONTEXT(context)->retry_op_queue->mutex);
+
+    } while (1);
+
+    hg_thread_mutex_unlock(&NA_OFI_CONTEXT(context)->retry_op_queue->mutex);
+
+    return ret;
+
+error:
+    /* Force internal cancelation */
+    hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_CANCELED);
+    complete_ret = na_ofi_complete(na_ofi_op_id);
+    NA_CHECK_ERROR_DONE(complete_ret != NA_SUCCESS,
+        "Could not complete operation");
+
+    hg_thread_mutex_unlock(&NA_OFI_CONTEXT(context)->retry_op_queue->mutex);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id)
 {
-    struct na_ofi_addr *na_ofi_addr = na_ofi_op_id->noo_addr;
     struct na_cb_info *callback_info = NULL;
+    na_bool_t canceled = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
 
-    /* Mark op id as completed */
-    if (!hg_atomic_cas32(&na_ofi_op_id->noo_completed, 0, 1))
-        return ret;
+    /* Mark op id as completed before checking for cancelation */
+    if (hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED)
+        & NA_OFI_OP_CANCELED) {
+        /* If it was canceled while being processed, set callback ret accordingly */
+        NA_LOG_DEBUG("Operation ID %p was canceled", na_ofi_op_id);
+        canceled = NA_TRUE;
+    }
 
     /* Init callback info */
-    callback_info = &na_ofi_op_id->noo_completion_data.callback_info;
-    callback_info->ret = op_ret;
+    callback_info = &na_ofi_op_id->completion_data.callback_info;
+    callback_info->ret = (canceled) ? NA_CANCELED : ret;
 
     switch (callback_info->type) {
-    case NA_CB_LOOKUP:
-        callback_info->info.lookup.addr =
-            na_ofi_op_id->noo_info.noo_lookup.noi_addr;
-        break;
-    case NA_CB_RECV_UNEXPECTED:
-        /* Fill callback info */
-        callback_info->info.recv_unexpected.actual_buf_size =
-            na_ofi_op_id->noo_info.noo_recv_unexpected.noi_msg_size;
-        callback_info->info.recv_unexpected.source =
-            na_ofi_op_id->noo_addr;
-        callback_info->info.recv_unexpected.tag =
-            na_ofi_op_id->noo_info.noo_recv_unexpected.noi_tag;
-        break;
-    case NA_CB_RECV_EXPECTED:
-        /* Check buf_size and msg_size */
-        if (na_ofi_op_id->noo_info.noo_recv_expected.noi_msg_size >
-            na_ofi_op_id->noo_info.noo_recv_expected.noi_buf_size) {
-            NA_LOG_ERROR("Expected recv too large for buffer");
-            ret = NA_SIZE_ERROR;
-            goto out;
-        }
-        break;
-    case NA_CB_SEND_UNEXPECTED:
-    case NA_CB_SEND_EXPECTED:
-    case NA_CB_PUT:
-    case NA_CB_GET:
-        break;
-    default:
-        NA_LOG_ERROR("Operation type %d not supported.", callback_info->type);
-        ret = NA_INVALID_PARAM;
-        break;
+        case NA_CB_RECV_UNEXPECTED:
+            if (canceled) {
+                /* In case of cancellation where no recv'd data */
+                callback_info->info.recv_unexpected.actual_buf_size = 0;
+                callback_info->info.recv_unexpected.source = NA_ADDR_NULL;
+                callback_info->info.recv_unexpected.tag = 0;
+            } else {
+                /* Increment addr ref count */
+                na_ofi_addr_addref(na_ofi_op_id->addr);
+
+                /* Fill callback info */
+                callback_info->info.recv_unexpected.actual_buf_size =
+                    na_ofi_op_id->info.msg.actual_buf_size;
+                callback_info->info.recv_unexpected.source =
+                    (na_addr_t) na_ofi_op_id->addr;
+                callback_info->info.recv_unexpected.tag =
+                    na_ofi_op_id->info.msg.tag;
+            }
+            break;
+        case NA_CB_RECV_EXPECTED:
+            /* Check buf_size and msg_size */
+            NA_CHECK_ERROR(
+                na_ofi_op_id->info.msg.actual_buf_size
+                    > na_ofi_op_id->info.msg.buf_size, out, ret, NA_MSGSIZE,
+                "Expected recv msg size too large for buffer");
+            break;
+        case NA_CB_SEND_UNEXPECTED:
+        case NA_CB_SEND_EXPECTED:
+        case NA_CB_PUT:
+        case NA_CB_GET:
+            break;
+        case NA_CB_LOOKUP:
+        default:
+            NA_GOTO_ERROR(out, ret, NA_INVALID_ARG,
+                "Operation type %d not supported", callback_info->type);
+            break;
     }
 
     /* Add OP to NA completion queue */
-    ret = na_cb_completion_add(na_ofi_op_id->noo_context,
-       &na_ofi_op_id->noo_completion_data);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add callback to completion queue");
-    }
+    ret = na_cb_completion_add(na_ofi_op_id->context,
+        &na_ofi_op_id->completion_data);
+    NA_CHECK_NA_ERROR(out, ret, "Could not add callback to completion queue");
 
 out:
-    if (na_ofi_addr)
-        na_ofi_addr_decref(na_ofi_addr);
     return ret;
 }
 
@@ -3052,9 +2905,14 @@ na_ofi_release(void *arg)
 {
     struct na_ofi_op_id *na_ofi_op_id = (struct na_ofi_op_id *) arg;
 
-    if (na_ofi_op_id && !hg_atomic_get32(&na_ofi_op_id->noo_completed))
-        NA_LOG_WARNING("Releasing resources from an uncompleted operation");
+    NA_CHECK_WARNING(na_ofi_op_id &&
+        (!(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED)),
+        "Releasing resources from an uncompleted operation");
 
+    if (na_ofi_op_id->addr) {
+        na_ofi_addr_decref(na_ofi_op_id->addr);
+        na_ofi_op_id->addr = NULL;
+    }
     na_ofi_op_id_decref(na_ofi_op_id);
 }
 
@@ -3071,25 +2929,20 @@ na_ofi_check_protocol(const char *protocol_name)
     enum na_ofi_prov_type type;
 
     type = na_ofi_prov_name_to_type(protocol_name);
-    if(type == NA_OFI_PROV_NULL) {
-        NA_LOG_ERROR("protocol %s not supported", protocol_name);
-        goto out;
-    }
+    NA_CHECK_ERROR(type == NA_OFI_PROV_NULL, out, ret, NA_PROTONOSUPPORT,
+        "Protocol %s not supported", protocol_name);
 
     /* Get info from provider */
     ret = na_ofi_getinfo(type, &providers);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_getinfo failed, ret: %d.", ret);
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(out, ret, "na_ofi_getinfo() failed");
 
     prov = providers;
     while (prov != NULL) {
-        /*
         NA_LOG_DEBUG("fabric_attr - prov_name %s, name - %s, "
-                     "domain_attr - name %s, mode: 0x%llx, domain_attr->mode 0x%llx, caps: 0x%llx.", prov->fabric_attr->prov_name,
-                     prov->fabric_attr->name, prov->domain_attr->name, prov->mode, prov->domain_attr->mode, prov->caps);
-        */
+            "domain_attr - name %s, mode: 0x%llx, domain_attr->mode 0x%llx, "
+            "caps: 0x%llx", prov->fabric_attr->prov_name,
+            prov->fabric_attr->name, prov->domain_attr->name, prov->mode,
+            prov->domain_attr->mode, prov->caps);
         if (!strcmp(na_ofi_prov_name[type], prov->fabric_attr->prov_name)) {
             accept = NA_TRUE;
             break;
@@ -3097,82 +2950,75 @@ na_ofi_check_protocol(const char *protocol_name)
         prov = prov->next;
     }
 
+    fi_freeinfo(providers);
+
 out:
-    if (providers)
-        fi_freeinfo(providers);
     return accept;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
-    na_bool_t listen)
+    na_bool_t NA_UNUSED listen)
 {
     struct na_ofi_class *priv;
     void *src_addr = NULL;
     na_size_t src_addrlen = 0;
     char *resolve_name = NULL;
+    char *host_name = NULL;
     unsigned int port = 0;
     const char *node_ptr = NULL;
     char node[NA_OFI_MAX_URI_LEN] = {'\0'};
+    char *domain_name_ptr = NULL;
     char domain_name[NA_OFI_MAX_URI_LEN] = {'\0'};
-    na_bool_t no_wait = NA_FALSE;
+    na_bool_t no_wait = NA_FALSE, no_retry = NA_FALSE;
     na_uint8_t max_contexts = 1; /* Default */
     const char *auth_key = NULL;
     na_return_t ret = NA_SUCCESS;
     enum na_ofi_prov_type prov_type;
 
-    /*
-    NA_LOG_DEBUG("Entering na_ofi_initialize class_name %s, protocol_name %s, "
-                 "host_name %s.\n", na_info->class_name, na_info->protocol_name,
-                 na_info->host_name);
-    */
+    NA_LOG_DEBUG("Entering na_ofi_initialize() class_name %s, protocol_name %s,"
+        " host_name %s", na_info->class_name, na_info->protocol_name,
+        na_info->host_name);
 
     prov_type = na_ofi_prov_name_to_type(na_info->protocol_name);
-    if(prov_type == NA_OFI_PROV_NULL) {
-        NA_LOG_ERROR("protocol %s not supported", na_info->protocol_name);
-        ret = NA_INVALID_PARAM;
-        goto out;
-    }
+    NA_CHECK_ERROR(prov_type == NA_OFI_PROV_NULL, out, ret,
+        NA_INVALID_ARG, "Protocol %s not supported", na_info->protocol_name);
 
 #if defined(NA_OFI_HAS_EXT_GNI_H) && defined(NA_OFI_GNI_HAS_UDREG)
     /* In case of GNI using udreg, we check to see whether MPICH_GNI_NDREG_ENTRIES
      * environment variable is set or not.  If not, this code is not likely
      * to work if Cray MPI is also used. Print error msg suggesting workaround.
      */
-    if (prov_type == NA_OFI_PROV_GNI && !getenv("MPICH_GNI_NDREG_ENTRIES"))
-    {
-        NA_LOG_ERROR("ofi+gni provider requested, but the MPICH_GNI_NDREG_ENTRIES environment variable is not set.");
-        NA_LOG_ERROR("Please run this executable with \"export MPICH_GNI_NDREG_ENTRIES=1024\" to ensure compatibility.");
-        ret = NA_INVALID_PARAM;
-        goto out;
-    }
+    NA_CHECK_ERROR(prov_type == NA_OFI_PROV_GNI
+        && !getenv("MPICH_GNI_NDREG_ENTRIES"), out, ret, NA_INVALID_ARG,
+        "ofi+gni provider requested, but the MPICH_GNI_NDREG_ENTRIES "
+        "environment variable is not set.\n" "Please run this executable with "
+        "\"export MPICH_GNI_NDREG_ENTRIES=1024\" to ensure compatibility."
+    );
 #endif
 
     /* Use default interface name if no hostname was passed */
     if (na_info->host_name) {
-        resolve_name = strdup(na_info->host_name);
-        if (!resolve_name) {
-            NA_LOG_ERROR("strdup() of host_name failed");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
+        host_name = strdup(na_info->host_name);
+        NA_CHECK_ERROR(host_name == NULL, out, ret, NA_NOMEM,
+            "strdup() of host_name failed");
 
         /* Extract hostname */
-        if (strstr(resolve_name, ":")) {
+        if (strstr(host_name, ":")) {
             char *port_str = NULL;
-
-            strtok_r(resolve_name, ":", &port_str);
+            strtok_r(host_name, ":", &port_str);
             port = (unsigned int) strtoul(port_str, NULL, 10);
         }
-    } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI) {
-        resolve_name = strdup(NA_OFI_GNI_IFACE_DEFAULT);
-        if (!resolve_name) {
-            NA_LOG_ERROR("strdup() of NA_OFI_GNI_IFACE_DEFAULT failed");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
+
+        /* Extract domain (if specified) */
+        if (strstr(host_name, "/")) {
+            strtok_r(host_name, "/", &resolve_name);
+            domain_name_ptr = host_name;
+        } else
+            resolve_name = host_name;
+    } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI)
+        resolve_name = NA_OFI_GNI_IFACE_DEFAULT;
 
     /* Get hostname/port info if available */
     if (resolve_name) {
@@ -3183,43 +3029,40 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
             /* Try to get matching IP/device */
             ret = na_ofi_check_interface(resolve_name, port, &ifa_name,
                 &na_ofi_sin_addr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not check interfaces");
-                goto out;
-            }
+            NA_CHECK_NA_ERROR(out, ret, "Could not check interfaces");
 
             /* Set SIN addr if found */
             if (na_ofi_sin_addr && ifa_name) {
                 src_addr = na_ofi_sin_addr;
                 src_addrlen = sizeof(*na_ofi_sin_addr);
-                /* Make sure we are using the right domain */
-                strncpy(domain_name, ifa_name, NA_OFI_MAX_URI_LEN - 1);
+                if (!domain_name_ptr) {
+                    /* Attempt to pass domain name as ifa_name if not set */
+                    strncpy(domain_name, ifa_name, NA_OFI_MAX_URI_LEN - 1);
+                    domain_name_ptr = domain_name;
+                }
                 free(ifa_name);
-            } else {
-                /* Allow for passing domain name directly */
+            } else if (!domain_name_ptr) {
+                /* Pass domain name as hostname if not set */
                 strncpy(domain_name, resolve_name, NA_OFI_MAX_URI_LEN - 1);
+                domain_name_ptr = domain_name;
             }
         } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI) {
             struct na_ofi_sin_addr *na_ofi_sin_addr = NULL;
+            const char *ptr;
 
             /* Try to get matching IP/device (do not use port) */
             ret = na_ofi_check_interface(resolve_name, 0, NULL,
                 &na_ofi_sin_addr);
-            if (ret != NA_SUCCESS || !na_ofi_sin_addr) {
-                NA_LOG_ERROR("Could not check interfaces");
-                goto out;
-            }
+            NA_CHECK_ERROR(ret != NA_SUCCESS || !na_ofi_sin_addr, out, ret,
+                NA_ADDRNOTAVAIL, "Could not check interfaces");
 
             /* Node must match IP resolution */
-            if (!inet_ntop(na_ofi_sin_addr->sin.sin_family,
-                &na_ofi_sin_addr->sin.sin_addr, node, sizeof(node))) {
-                NA_LOG_ERROR("Could not convert IP to string");
-                free(na_ofi_sin_addr);
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            node_ptr = node;
+            ptr = inet_ntop(na_ofi_sin_addr->sin.sin_family,
+                &na_ofi_sin_addr->sin.sin_addr, node, sizeof(node));
             free(na_ofi_sin_addr);
+            NA_CHECK_ERROR(ptr == NULL, out, ret, NA_ADDRNOTAVAIL,
+                "Could not convert IP to string");
+            node_ptr = node;
         } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_PSMX2) {
             /* Nothing to do */
         }
@@ -3228,8 +3071,10 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     /* Get init info */
     if (na_info->na_init_info) {
         /* Progress mode */
-        if (na_info->na_init_info->progress_mode == NA_NO_BLOCK)
+        if (na_info->na_init_info->progress_mode & NA_NO_BLOCK)
             no_wait = NA_TRUE;
+        if (na_info->na_init_info->progress_mode & NA_NO_RETRY)
+            no_retry = NA_TRUE;
         /* Max contexts */
         max_contexts = na_info->na_init_info->max_contexts;
         /* Auth key */
@@ -3239,48 +3084,37 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     /* Create private data */
     na_class->plugin_class = (struct na_ofi_class *) malloc(
         sizeof(struct na_ofi_class));
-    if (!na_class->plugin_class) {
-        NA_LOG_ERROR("Could not allocate NA private data class");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_class->plugin_class == NULL, out, ret, NA_NOMEM,
+        "Could not allocate NA private data class");
     memset(na_class->plugin_class, 0, sizeof(struct na_ofi_class));
     priv = NA_OFI_CLASS(na_class);
     priv->no_wait = no_wait;
-    priv->nop_listen = listen;
-    priv->nop_max_contexts = max_contexts;
-    priv->nop_contexts = 0;
+    priv->no_retry = no_retry;
+    priv->max_contexts = max_contexts;
+    priv->contexts = 0;
 
     /* Initialize queue / mutex */
-    hg_thread_mutex_init(&priv->nop_mutex);
+    hg_thread_mutex_init(&priv->mutex);
 
     /* Initialize buf pool */
-    hg_thread_spin_init(&priv->nop_buf_pool_lock);
-    HG_QUEUE_INIT(&priv->nop_buf_pool);
+    hg_thread_spin_init(&priv->buf_pool_lock);
+    HG_QUEUE_INIT(&priv->buf_pool);
 
     /* Create domain */
-    ret = na_ofi_domain_open(na_class->plugin_class, prov_type, domain_name,
-        auth_key, &priv->nop_domain);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not open domain for %s, %s", na_ofi_prov_name[prov_type],
-            domain_name);
-        goto out;
-    }
+    ret = na_ofi_domain_open(na_class->plugin_class, prov_type, domain_name_ptr,
+        auth_key, &priv->domain);
+    NA_CHECK_NA_ERROR(out, ret, "Could not open domain for %s, %s",
+        na_ofi_prov_name[prov_type], domain_name_ptr);
 
     /* Create endpoint */
-    ret = na_ofi_endpoint_open(priv->nop_domain, node_ptr, src_addr, src_addrlen,
-        priv->no_wait, priv->nop_max_contexts, &priv->nop_endpoint);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not create endpoint for %s", resolve_name);
-        goto out;
-    }
+    ret = na_ofi_endpoint_open(priv->domain, node_ptr, src_addr, src_addrlen,
+        priv->no_wait, priv->max_contexts, &priv->endpoint);
+    NA_CHECK_NA_ERROR(out, ret, "Could not create endpoint for %s",
+        resolve_name);
 
     /* Get address from endpoint */
-    ret = na_ofi_get_ep_addr(na_class, &priv->nop_endpoint->noe_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not get address from endpoint");
-        goto out;
-    }
+    ret = na_ofi_get_ep_addr(na_class, &priv->endpoint->src_addr);
+    NA_CHECK_NA_ERROR(out, ret, "Could not get address from endpoint");
 
 out:
     if (ret != NA_SUCCESS) {
@@ -3290,7 +3124,7 @@ out:
         }
     }
     free(src_addr);
-    free(resolve_name);
+    free(host_name);
     return ret;
 }
 
@@ -3305,38 +3139,32 @@ na_ofi_finalize(na_class_t *na_class)
         goto out;
 
     /* Close endpoint */
-    if (priv->nop_endpoint) {
-        ret = na_ofi_endpoint_close(priv->nop_endpoint);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not close endpoint");
-            goto out;
-        }
-        priv->nop_endpoint = NULL;
+    if (priv->endpoint) {
+        ret = na_ofi_endpoint_close(priv->endpoint);
+        NA_CHECK_NA_ERROR(out, ret, "Could not close endpoint");
+        priv->endpoint = NULL;
     }
 
     /* Free memory pool (must be done before trying to close the domain as
      * the pool is holding memory handles) */
-    while (!HG_QUEUE_IS_EMPTY(&priv->nop_buf_pool)) {
+    while (!HG_QUEUE_IS_EMPTY(&priv->buf_pool)) {
         struct na_ofi_mem_pool *na_ofi_mem_pool =
-            HG_QUEUE_FIRST(&priv->nop_buf_pool);
-        HG_QUEUE_POP_HEAD(&priv->nop_buf_pool, entry);
+            HG_QUEUE_FIRST(&priv->buf_pool);
+        HG_QUEUE_POP_HEAD(&priv->buf_pool, entry);
 
         na_ofi_mem_pool_destroy(na_ofi_mem_pool);
     }
-    hg_thread_spin_destroy(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_destroy(&NA_OFI_CLASS(na_class)->buf_pool_lock);
 
     /* Close domain */
-    if (priv->nop_domain) {
-        ret = na_ofi_domain_close(priv->nop_domain);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not close domain");
-            goto out;
-        }
-        priv->nop_domain = NULL;
+    if (priv->domain) {
+        ret = na_ofi_domain_close(priv->domain);
+        NA_CHECK_NA_ERROR(out, ret, "Could not close domain");
+        priv->domain = NULL;
     }
 
     /* Close mutex / free private data */
-    hg_thread_mutex_destroy(&priv->nop_mutex);
+    hg_thread_mutex_destroy(&priv->mutex);
     free(priv);
     na_class->plugin_class = NULL;
 
@@ -3349,152 +3177,104 @@ static na_return_t
 na_ofi_context_create(na_class_t *na_class, void **context, na_uint8_t id)
 {
     struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_domain *domain = priv->nop_domain;
-    struct na_ofi_endpoint *ep = priv->nop_endpoint;
+    struct na_ofi_domain *domain = priv->domain;
+    struct na_ofi_endpoint *ep = priv->endpoint;
     struct na_ofi_context *ctx = NULL;
     struct fi_cq_attr cq_attr = {0};
     na_return_t ret = NA_SUCCESS;
     int rc = 0;
 
     ctx = (struct na_ofi_context *)calloc(1, sizeof(struct na_ofi_context));
-    if (!ctx) {
-        NA_LOG_ERROR("Could not allocate na_ofi_context.");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    ctx->noc_idx = id;
+    NA_CHECK_ERROR(ctx == NULL, out, ret, NA_NOMEM,
+        "Could not allocate na_ofi_context");
+    ctx->idx = id;
 
     /* If not using SEP, just point to endpoint objects */
-    hg_thread_mutex_lock(&priv->nop_mutex);
+    hg_thread_mutex_lock(&priv->mutex);
+
     if (!na_ofi_with_sep(na_class)) {
-        ctx->noc_tx = ep->noe_ep;
-        ctx->noc_rx = ep->noe_ep;
-        ctx->noc_cq = ep->noe_cq;
-        ctx->noc_wait = ep->noe_wait;
-        ctx->noc_unexpected_op_queue = ep->noe_unexpected_op_queue;
+        ctx->fi_tx = ep->fi_ep;
+        ctx->fi_rx = ep->fi_ep;
+        ctx->fi_cq = ep->fi_cq;
+        ctx->fi_wait = ep->fi_wait;
+        ctx->retry_op_queue = ep->retry_op_queue;
     } else {
+        ctx->retry_op_queue = malloc(sizeof(struct na_ofi_queue));
+        NA_CHECK_ERROR(ctx->retry_op_queue == NULL, error, ret,
+            NA_NOMEM, "Could not allocate retry_op_queue/_lock");
+
         /* Initialize queue / mutex */
-        ctx->noc_unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
-        if (!ctx->noc_unexpected_op_queue) {
-            NA_LOG_ERROR("Could not allocate noc_unexpected_op_queue/_lock");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-        HG_QUEUE_INIT(&ctx->noc_unexpected_op_queue->noq_queue);
-        hg_thread_spin_init(&ctx->noc_unexpected_op_queue->noq_lock);
-
-        if (priv->nop_contexts >= priv->nop_max_contexts ||
-            id >= priv->nop_max_contexts) {
-            NA_LOG_ERROR("nop_contexts %d, context id %d, nop_max_contexts %d "
-                "could not create context.", priv->nop_contexts,
-                id, priv->nop_max_contexts);
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        HG_QUEUE_INIT(&ctx->retry_op_queue->queue);
+        hg_thread_mutex_init(&ctx->retry_op_queue->mutex);
+
+        NA_CHECK_ERROR(priv->contexts >= priv->max_contexts ||
+            id >= priv->max_contexts, error, ret, NA_OPNOTSUPPORTED,
+            "contexts %d, context id %d, max_contexts %d",
+            priv->contexts, id, priv->max_contexts);
 
         if (!priv->no_wait) {
-            if (na_ofi_prov_flags[domain->nod_prov_type] & NA_OFI_WAIT_FD)
+            if (na_ofi_prov_flags[domain->prov_type] & NA_OFI_WAIT_FD)
                 cq_attr.wait_obj = FI_WAIT_FD; /* Wait on fd */
             else {
                 struct fi_wait_attr wait_attr = {0};
 
                 /* Open wait set for other providers. */
                 wait_attr.wait_obj = FI_WAIT_UNSPEC;
-                rc = fi_wait_open(domain->nod_fabric, &wait_attr,
-                    &ctx->noc_wait);
-                if (rc != 0) {
-                    NA_LOG_ERROR("fi_wait_open failed, rc: %d(%s).", rc,
-                        fi_strerror(-rc));
-                    hg_thread_mutex_unlock(&priv->nop_mutex);
-                    ret = NA_PROTOCOL_ERROR;
-                    goto out;
-                }
+                rc = fi_wait_open(domain->fi_fabric, &wait_attr,
+                    &ctx->fi_wait);
+                NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+                    "fi_wait_open() failed, rc: %d (%s)", rc, fi_strerror(-rc));
                 cq_attr.wait_obj = FI_WAIT_SET; /* Wait on wait set */
-                cq_attr.wait_set = ctx->noc_wait;
+                cq_attr.wait_set = ctx->fi_wait;
             }
         }
         cq_attr.wait_cond = FI_CQ_COND_NONE;
         cq_attr.format = FI_CQ_FORMAT_TAGGED;
         cq_attr.size = NA_OFI_CQ_DEPTH;
-        rc = fi_cq_open(domain->nod_domain, &cq_attr, &ctx->noc_cq, NULL);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_cq_open failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_cq_open(domain->fi_domain, &cq_attr, &ctx->fi_cq, NULL);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_cq_open() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-        rc = fi_tx_context(ep->noe_ep, id, NULL, &ctx->noc_tx, NULL);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_tx_context failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_tx_context(ep->fi_ep, id, NULL, &ctx->fi_tx, NULL);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_tx_context() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-        rc = fi_rx_context(ep->noe_ep, id, NULL, &ctx->noc_rx, NULL);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_rx_context failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_rx_context(ep->fi_ep, id, NULL, &ctx->fi_rx, NULL);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_rx_context() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-        rc = fi_ep_bind(ctx->noc_tx, &ctx->noc_cq->fid, FI_TRANSMIT);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_ep_bind noc_tx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_ep_bind(ctx->fi_tx, &ctx->fi_cq->fid, FI_TRANSMIT);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_ep_bind() noc_tx failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-        rc = fi_ep_bind(ctx->noc_rx, &ctx->noc_cq->fid, FI_RECV);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_ep_bind noc_rx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_ep_bind(ctx->fi_rx, &ctx->fi_cq->fid, FI_RECV);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_ep_bind() noc_rx failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-        rc = fi_enable(ctx->noc_tx);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_enable noc_tx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_enable(ctx->fi_tx);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_enable() noc_tx failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-        rc = fi_enable(ctx->noc_rx);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_enable noc_rx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_enable(ctx->fi_rx);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_enable() noc_rx failed, rc: %d (%s)", rc, fi_strerror(-rc));
     }
 
-    priv->nop_contexts++;
-    hg_thread_mutex_unlock(&priv->nop_mutex);
+    priv->contexts++;
+    hg_thread_mutex_unlock(&priv->mutex);
 
     *context = ctx;
 
 out:
-    if (ret != NA_SUCCESS && ctx) {
-        if (na_ofi_with_sep(na_class) && ctx->noc_unexpected_op_queue) {
-            hg_thread_spin_destroy(&ctx->noc_unexpected_op_queue->noq_lock);
-            free(ctx->noc_unexpected_op_queue);
-        }
-        free(ctx);
-    }
+    return ret;
 
+error:
+    hg_thread_mutex_unlock(&priv->mutex);
+    if (na_ofi_with_sep(na_class) && ctx->retry_op_queue) {
+        hg_thread_mutex_destroy(&ctx->retry_op_queue->mutex);
+        free(ctx->retry_op_queue);
+    }
+    free(ctx);
     return ret;
 }
 
@@ -3507,70 +3287,54 @@ na_ofi_context_destroy(na_class_t *na_class, void *context)
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    /* Check that unexpected op queue is empty */
-    if (na_ofi_with_sep(na_class) &&
-        !HG_QUEUE_IS_EMPTY(&ctx->noc_unexpected_op_queue->noq_queue)) {
-        NA_LOG_ERROR("Unexpected op queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-
     if (na_ofi_with_sep(na_class)) {
-        if (ctx->noc_tx) {
-            rc = fi_close(&ctx->noc_tx->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close noc_tx failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_tx = NULL;
+        na_bool_t empty;
+
+        /* Check that retry op queue is empty */
+        empty = HG_QUEUE_IS_EMPTY(&ctx->retry_op_queue->queue);
+        NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_BUSY,
+            "Retry op queue should be empty");
+
+        if (ctx->fi_tx) {
+            rc = fi_close(&ctx->fi_tx->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() noc_tx failed, rc: %d (%s)", rc, fi_strerror(-rc));
+            ctx->fi_tx = NULL;
         }
 
-        if (ctx->noc_rx) {
-            rc = fi_close(&ctx->noc_rx->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close noc_rx failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_rx = NULL;
+        if (ctx->fi_rx) {
+            rc = fi_close(&ctx->fi_rx->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() noc_rx failed, rc: %d (%s)", rc, fi_strerror(-rc));
+            ctx->fi_rx = NULL;
         }
 
         /* Close wait set */
-        if (ctx->noc_wait) {
-            rc = fi_close(&ctx->noc_wait->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close wait failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_wait = NULL;
+        if (ctx->fi_wait) {
+            rc = fi_close(&ctx->fi_wait->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() wait failed, rc: %d (%s)", rc, fi_strerror(-rc));
+            ctx->fi_wait = NULL;
         }
 
         /* Close completion queue */
-        if (ctx->noc_cq) {
-            rc = fi_close(&ctx->noc_cq->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close CQ failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_cq = NULL;
+        if (ctx->fi_cq) {
+            rc = fi_close(&ctx->fi_cq->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() CQ failed, rc: %d (%s)", rc, fi_strerror(-rc));
+            ctx->fi_cq = NULL;
         }
 
-        hg_thread_spin_destroy(&ctx->noc_unexpected_op_queue->noq_lock);
-        free(ctx->noc_unexpected_op_queue);
+        hg_thread_mutex_destroy(&ctx->retry_op_queue->mutex);
+        free(ctx->retry_op_queue);
     }
 
-    hg_thread_mutex_lock(&priv->nop_mutex);
-    priv->nop_contexts--;
-    hg_thread_mutex_unlock(&priv->nop_mutex);
+    hg_thread_mutex_lock(&priv->mutex);
+    priv->contexts--;
+    hg_thread_mutex_unlock(&priv->mutex);
 
     free(ctx);
+
 out:
     return ret;
 }
@@ -3582,21 +3346,15 @@ na_ofi_op_create(na_class_t NA_UNUSED *na_class)
     struct na_ofi_op_id *na_ofi_op_id = NULL;
 
     na_ofi_op_id = (struct na_ofi_op_id *)calloc(1, sizeof(struct na_ofi_op_id));
-    if (!na_ofi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA OFI operation ID");
-        goto out;
-    }
-    hg_atomic_init32(&na_ofi_op_id->noo_refcount, 1);
+    NA_CHECK_ERROR_NORET(na_ofi_op_id == NULL, out,
+        "Could not allocate NA OFI operation ID");
+    hg_atomic_init32(&na_ofi_op_id->refcount, 1);
     /* Completed by default */
-    hg_atomic_init32(&na_ofi_op_id->noo_completed, NA_TRUE);
-
-    /* Set op ID verification magic */
-    na_ofi_op_id->noo_magic_1 = NA_OFI_OP_ID_MAGIC_1;
-    na_ofi_op_id->noo_magic_2 = NA_OFI_OP_ID_MAGIC_2;
+    hg_atomic_init32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
 
     /* Set op ID release callbacks */
-    na_ofi_op_id->noo_completion_data.plugin_callback = na_ofi_release;
-    na_ofi_op_id->noo_completion_data.plugin_callback_args = na_ofi_op_id;
+    na_ofi_op_id->completion_data.plugin_callback = na_ofi_release;
+    na_ofi_op_id->completion_data.plugin_callback_args = na_ofi_op_id;
 
 out:
     return (na_op_id_t) na_ofi_op_id;
@@ -3615,110 +3373,75 @@ na_ofi_op_destroy(na_class_t NA_UNUSED *na_class, na_op_id_t op_id)
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, const char *name, na_op_id_t *op_id)
+na_ofi_addr_lookup(na_class_t *na_class, const char *name, na_addr_t *addr)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_op_id *na_ofi_op_id = NULL;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
 
     /* Check provider from name */
-    if (na_ofi_addr_prov(name) != priv->nop_domain->nod_prov_type) {
-        NA_LOG_ERROR("Unrecognized provider type found from: %s", name);
-        ret = NA_INVALID_PARAM;
-        goto out;
-    }
-
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_LOOKUP;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    /* Take one refcount to be released in na_ofi_complete->na_ofi_release */
-    hg_atomic_set32(&na_ofi_op_id->noo_refcount, 1);
+    NA_CHECK_ERROR(na_ofi_addr_prov(name) != domain->prov_type, out, ret,
+        NA_INVALID_ARG, "Unrecognized provider type found from: %s", name);
 
     /* Allocate addr */
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("na_ofi_addr_alloc failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_addr = na_ofi_addr_alloc(domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM,
+        "na_ofi_addr_alloc() failed");
     na_ofi_addr->uri = strdup(name);
-    if (!na_ofi_addr->uri) {
-        NA_LOG_ERROR("strdup() of URI failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    /* One extra refcount to be decref in na_ofi_complete(). */
-    na_ofi_addr_addref(na_ofi_addr);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    na_ofi_op_id->noo_info.noo_lookup.noi_addr = (na_addr_t) na_ofi_addr;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    NA_CHECK_ERROR(na_ofi_addr->uri == NULL, error, ret, NA_NOMEM,
+        "strdup() of URI failed");
 
     /* Convert name to address */
-    ret = na_ofi_str_to_addr(name,
-        na_ofi_prov_addr_format[priv->nop_domain->nod_prov_type],
+    ret = na_ofi_str_to_addr(name, na_ofi_prov_addr_format[domain->prov_type],
         &na_ofi_addr->addr, &na_ofi_addr->addrlen);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not convert string to address");
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not convert string to address");
 
     /* Lookup address */
-    ret = na_ofi_addr_ht_lookup(na_class,
-        na_ofi_prov_addr_format[priv->nop_domain->nod_prov_type],
-        na_ofi_addr->addr, na_ofi_addr->addrlen, &na_ofi_addr->fi_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_addr_ht_lookup(%s) failed, ret: %d.", name, ret);
-        goto out;
-    }
+    ret = na_ofi_addr_ht_lookup(domain,
+        na_ofi_prov_addr_format[domain->prov_type], na_ofi_addr->addr,
+        na_ofi_addr->addrlen, &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
+    NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup(%s) failed", name);
 
-    /* As the fi_av_insert is blocking, always complete here */
-    ret = na_ofi_complete(na_ofi_op_id, ret);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto out;
-    }
+    *addr = (na_addr_t) na_ofi_addr;
 
 out:
-    if (ret != NA_SUCCESS) {
-        if (na_ofi_addr) {
-            free(na_ofi_addr->addr);
-            free(na_ofi_addr->uri);
-            free(na_ofi_addr);
-        }
-        free(na_ofi_op_id);
+    return ret;
+
+error:
+    if (na_ofi_addr) {
+        free(na_ofi_addr->addr);
+        free(na_ofi_addr->uri);
+        free(na_ofi_addr);
     }
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_return_t
+na_ofi_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t addr)
+{
+    na_ofi_addr_decref((struct na_ofi_addr *) addr);
+
+    return NA_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
+na_ofi_addr_set_remove(na_class_t NA_UNUSED *na_class, na_addr_t addr)
+{
+    ((struct na_ofi_addr *) addr)->remove = NA_TRUE;
+
+    return NA_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
 na_ofi_addr_self(na_class_t *na_class, na_addr_t *addr)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_endpoint *ep = priv->nop_endpoint;
+    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->endpoint;
 
-    na_ofi_addr_addref(ep->noe_addr); /* decref in na_ofi_addr_free() */
-    *addr = ep->noe_addr;
+    na_ofi_addr_addref(ep->src_addr); /* decref in na_ofi_addr_free() */
+    *addr = ep->src_addr;
 
     return NA_SUCCESS;
 }
@@ -3737,19 +3460,56 @@ na_ofi_addr_dup(na_class_t NA_UNUSED *na_class, na_addr_t addr,
 }
 
 /*---------------------------------------------------------------------------*/
-static na_return_t
-na_ofi_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t addr)
+static na_bool_t
+na_ofi_addr_cmp(na_class_t NA_UNUSED *na_class, na_addr_t addr1,
+    na_addr_t addr2)
 {
-    na_ofi_addr_decref((struct na_ofi_addr *) addr);
+    struct na_ofi_addr *na_ofi_addr1 = (struct na_ofi_addr *) addr1;
+    struct na_ofi_addr *na_ofi_addr2 = (struct na_ofi_addr *) addr2;
 
-    return NA_SUCCESS;
+    if ((na_ofi_addr1 == na_ofi_addr2)
+        || (na_ofi_addr1->fi_addr == na_ofi_addr2->fi_addr))
+        return NA_TRUE;
+
+    /* If we don't have the addr, look it up from AV */
+    if (!na_ofi_addr1->addr) {
+        na_return_t na_ret = na_ofi_av_lookup(na_ofi_addr1->domain,
+            na_ofi_addr1->fi_addr, &na_ofi_addr1->addr, &na_ofi_addr1->addrlen);
+        NA_CHECK_NA_ERROR(out, na_ret, "Could not get addr from AV");
+    }
+    if (!na_ofi_addr2->addr) {
+        na_return_t na_ret = na_ofi_av_lookup(na_ofi_addr2->domain,
+            na_ofi_addr2->fi_addr, &na_ofi_addr2->addr, &na_ofi_addr2->addrlen);
+        NA_CHECK_NA_ERROR(out, na_ret, "Could not get addr from AV");
+    }
+
+    if ((na_ofi_addr1->addrlen == na_ofi_addr2->addrlen)
+        && (memcmp(na_ofi_addr1->addr, na_ofi_addr2->addr,
+            na_ofi_addr1->addrlen) == 0))
+        return NA_TRUE;
+
+out:
+    return NA_FALSE;
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
-na_ofi_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
+na_ofi_addr_is_self(na_class_t *na_class, na_addr_t addr)
 {
-    return ((struct na_ofi_addr *) addr)->self;
+    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->endpoint;
+    struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) addr;
+
+    if (ep->src_addr == na_ofi_addr)
+        goto done;
+
+    if (ep->src_addr->addrlen != na_ofi_addr->addrlen)
+        return NA_FALSE;
+
+    if (memcmp(ep->src_addr->addr, na_ofi_addr->addr, na_ofi_addr->addrlen))
+        return NA_FALSE;
+
+done:
+    return NA_TRUE;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3761,20 +3521,27 @@ na_ofi_addr_to_string(na_class_t NA_UNUSED *na_class, char *buf,
     na_size_t str_len;
     na_return_t ret = NA_SUCCESS;
 
-    if (na_ofi_addr->unexpected) {
-        NA_LOG_ERROR("Addr to string is not available on unexpected addresses");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
+    /* If there is no URI for address, attempt to reconstruct one */
+    if (!na_ofi_addr->uri) {
+        NA_CHECK_ERROR(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out, ret,
+            NA_ADDRNOTAVAIL, "Addr is not initialized");
+
+        /* If we don't have the addr either, look it up from AV */
+        if (!na_ofi_addr->addr) {
+            ret = na_ofi_av_lookup(na_ofi_addr->domain, na_ofi_addr->fi_addr,
+                &na_ofi_addr->addr, &na_ofi_addr->addrlen);
+            NA_CHECK_NA_ERROR(out, ret, "Could not get addr from AV");
+        }
+
+        ret = na_ofi_get_uri(na_class, na_ofi_addr->addr, &na_ofi_addr->uri);
+        NA_CHECK_NA_ERROR(out, ret, "Could not get URI for address");
     }
 
     str_len = strlen(na_ofi_addr->uri);
     if (buf) {
-        if (str_len >= *buf_size) {
-            NA_LOG_ERROR("Buffer size too small to copy addr");
-            ret = NA_SIZE_ERROR;
-        } else {
-            strcpy(buf, na_ofi_addr->uri);
-        }
+        NA_CHECK_ERROR(str_len >= *buf_size, out, ret, NA_OVERFLOW,
+            "Buffer size too small to copy addr");
+        strcpy(buf, na_ofi_addr->uri);
     }
     *buf_size = str_len + 1;
 
@@ -3788,8 +3555,25 @@ na_ofi_addr_get_serialize_size(na_class_t NA_UNUSED *na_class,
     na_addr_t addr)
 {
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) addr;
+    na_size_t size = 0;
+
+    if (!na_ofi_addr->addr) {
+        na_return_t ret;
+
+        NA_CHECK_ERROR_NORET(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out,
+            "Addr is not initialized");
+
+        /* If we don't have the addr, look it up from AV */
+        ret = na_ofi_av_lookup(na_ofi_addr->domain, na_ofi_addr->fi_addr,
+            &na_ofi_addr->addr, &na_ofi_addr->addrlen);
+        NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, out,
+            "Could not get addr from AV");
+    }
+
+    size = na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen);
 
-    return (na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen));
+out:
+    return size;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3798,20 +3582,28 @@ na_ofi_addr_serialize(na_class_t NA_UNUSED *na_class, void *buf,
     na_size_t buf_size, na_addr_t addr)
 {
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) addr;
+    na_uint8_t *p = buf;
     na_size_t len;
     na_return_t ret = NA_SUCCESS;
 
-    len = na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen);
-    if (buf_size < len) {
-        NA_LOG_ERROR("Buffer size too small for serializing address");
-        ret = NA_SIZE_ERROR;
-        goto out;
+    if (!na_ofi_addr->addr) {
+        NA_CHECK_ERROR(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out, ret,
+            NA_ADDRNOTAVAIL, "Addr is not initialized");
+
+        /* If we don't have the addr, look it up from AV */
+        ret = na_ofi_av_lookup(na_ofi_addr->domain, na_ofi_addr->fi_addr,
+            &na_ofi_addr->addr, &na_ofi_addr->addrlen);
+        NA_CHECK_NA_ERROR(out, ret, "Could not get addr from AV");
     }
 
+    len = na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen);
+    NA_CHECK_ERROR(buf_size < len, out, ret, NA_OVERFLOW,
+        "Buffer size too small for serializing address");
+
     /* TODO could skip the addrlen but include it for sanity check */
-    memcpy(buf, &na_ofi_addr->addrlen, sizeof(na_ofi_addr->addrlen));
-    memcpy((na_uint8_t *) buf + sizeof(na_ofi_addr->addrlen), na_ofi_addr->addr,
-        na_ofi_addr->addrlen);
+    memcpy(p, &na_ofi_addr->addrlen, sizeof(na_ofi_addr->addrlen));
+    p += sizeof(na_ofi_addr->addrlen);
+    memcpy(p, na_ofi_addr->addr, na_ofi_addr->addrlen);
 
 out:
     return ret;
@@ -3822,46 +3614,39 @@ static na_return_t
 na_ofi_addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
     na_size_t NA_UNUSED buf_size)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     struct na_ofi_addr *na_ofi_addr = NULL;
+    const na_uint8_t *p = buf;
     na_return_t ret = NA_SUCCESS;
 
     /* Allocate addr */
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("na_ofi_addr_alloc failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    memcpy(&na_ofi_addr->addrlen, buf, sizeof(na_ofi_addr->addrlen));
+    na_ofi_addr = na_ofi_addr_alloc(domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM,
+        "na_ofi_addr_alloc() failed");
+    memcpy(&na_ofi_addr->addrlen, p, sizeof(na_ofi_addr->addrlen));
+    p += sizeof(na_ofi_addr->addrlen);
 
     na_ofi_addr->addr = malloc(na_ofi_addr->addrlen);
-    if (!na_ofi_addr->addr) {
-        NA_LOG_ERROR("Could not allocate %zu bytes for address",
-            na_ofi_addr->addrlen);
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    memcpy(na_ofi_addr->addr,
-        (const na_uint8_t *) buf + sizeof(na_ofi_addr->addrlen),
-        na_ofi_addr->addrlen);
+    NA_CHECK_ERROR(na_ofi_addr->addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate %zu bytes for address", na_ofi_addr->addrlen);
+    memcpy(na_ofi_addr->addr, p, na_ofi_addr->addrlen);
 
-    /* TODO Skip URI generation? */
+    /* Skip URI generation, URI will only be generated when needed */
 
     /* Lookup address */
-    ret = na_ofi_addr_ht_lookup(na_class,
-        na_ofi_prov_addr_format[priv->nop_domain->nod_prov_type],
-        na_ofi_addr->addr, na_ofi_addr->addrlen, &na_ofi_addr->fi_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_addr_ht_lookup(%s) failed, ret: %d.", "", ret);
-        goto out;
-    }
+    ret = na_ofi_addr_ht_lookup(domain,
+        na_ofi_prov_addr_format[domain->prov_type], na_ofi_addr->addr,
+        na_ofi_addr->addrlen, &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
+    NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
 
     *addr = na_ofi_addr;
 
 out:
-    if (ret != NA_SUCCESS && na_ofi_addr)
-        free(na_ofi_addr);
+    return ret;
+
+error:
+    free(na_ofi_addr->addr);
+    free(na_ofi_addr);
     return ret;
 }
 
@@ -3871,25 +3656,22 @@ na_ofi_msg_get_max_unexpected_size(const na_class_t NA_UNUSED *na_class)
 {
     na_size_t max_unexpected_size = NA_OFI_UNEXPECTED_SIZE;
 #ifdef NA_OFI_HAS_EXT_GNI_H
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
 
-    if (domain->nod_prov_type == NA_OFI_PROV_GNI) {
+    if (domain->prov_type == NA_OFI_PROV_GNI) {
         struct fi_gni_ops_domain *gni_domain_ops;
         int rc;
 
-        rc = fi_open_ops(&domain->nod_domain->fid, FI_GNI_DOMAIN_OPS_1,
+        rc = fi_open_ops(&domain->fi_domain->fid, FI_GNI_DOMAIN_OPS_1,
             0, (void **) &gni_domain_ops, NULL);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_open_ops failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            goto out;
-        }
+        NA_CHECK_ERROR(rc != 0, out, max_unexpected_size, 0,
+            "fi_open_ops() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
-        rc = gni_domain_ops->get_val(&domain->nod_domain->fid,
+        rc = gni_domain_ops->get_val(&domain->fi_domain->fid,
             GNI_MBOX_MSG_MAX_SIZE, &max_unexpected_size);
-        if (rc != 0) {
-            NA_LOG_ERROR("get_val failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            goto out;
-        }
+        NA_CHECK_ERROR(rc != 0, out, max_unexpected_size, 0,
+            "gni_domain_ops->get_val() failed, rc: %d (%s)", rc,
+            fi_strerror(-rc));
     }
 
 out:
@@ -3930,16 +3712,12 @@ na_ofi_msg_buf_alloc(na_class_t *na_class, na_size_t size, void **plugin_data)
 
 #ifdef NA_OFI_HAS_MEM_POOL
     mem_ptr = na_ofi_mem_pool_alloc(na_class, size, &mr_hdl);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate buffer from pool");
-        goto out;
-    }
+    NA_CHECK_ERROR_NORET(mem_ptr == NULL, out,
+        "Could not allocate buffer from pool");
 #else
     mem_ptr = na_ofi_mem_alloc(na_class, size, &mr_hdl);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate %d bytes", (int) size);
-        goto out;
-    }
+    NA_CHECK_ERROR_NORET(mem_ptr == NULL, out,
+        "Could not allocate %d bytes", (int) size);
 #endif
     *plugin_data = mr_hdl;
 
@@ -3967,6 +3745,8 @@ na_ofi_msg_buf_free(na_class_t *na_class, void *buf, void *plugin_data)
 static na_return_t
 na_ofi_msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
 {
+    na_return_t ret = NA_SUCCESS;
+
     /*
      * For those providers that don't support FI_SOURCE/FI_SOURCE_ERR, insert
      * the msg header to piggyback the source address for unexpected message.
@@ -3974,13 +3754,15 @@ na_ofi_msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
     if (na_ofi_with_msg_hdr(na_class)) {
         struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
         struct na_ofi_sin_addr *na_ofi_sin_addr =
-            (struct na_ofi_sin_addr *) priv->nop_endpoint->noe_addr->addr;
+            (struct na_ofi_sin_addr *) priv->endpoint->src_addr->addr;
 
-        assert(buf_size > sizeof(*na_ofi_sin_addr));
+        NA_CHECK_ERROR(buf_size < sizeof(*na_ofi_sin_addr), out, ret,
+            NA_OVERFLOW, "Buffer size too small to copy addr");
         memcpy(buf, na_ofi_sin_addr, sizeof(*na_ofi_sin_addr));
     }
 
-    return NA_SUCCESS;
+out:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3991,64 +3773,74 @@ na_ofi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) dest_addr;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
-    struct fid_mr *mr_hdl = plugin_data;
-    fi_addr_t fi_addr;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
-    na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    NA_CHECK_ERROR(
+        !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED), out,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_SEND_UNEXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    na_ofi_addr_addref(na_ofi_addr);
+    na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    /* We assume buf remains valid (safe because we pre-allocate buffers) */
+    na_ofi_op_id->info.msg.buf.const_ptr = buf;
+    na_ofi_op_id->info.msg.buf_size = buf_size;
+    na_ofi_op_id->info.msg.actual_buf_size = buf_size;
+    /* Specify target receive context */
+    na_ofi_op_id->info.msg.fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id,
+        NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.msg.fi_mr = plugin_data;
+    na_ofi_op_id->info.msg.tag = tag;
+
+    NA_LOG_DEBUG("Sending unexpected msg with tag=%llu",
+        tag | NA_OFI_UNEXPECTED_TAG);
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
+    /* Post the FI unexpected send request */
+    rc = fi_tsend(ctx->fi_tx, buf, buf_size, na_ofi_op_id->info.msg.fi_mr,
+        na_ofi_op_id->info.msg.fi_addr, tag | NA_OFI_UNEXPECTED_TAG,
+        &na_ofi_op_id->fi_ctx);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
 
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_SEND_UNEXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_tsend() unexpected failed, rc: %d (%s)", rc,
+            fi_strerror((int ) -rc));
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+out:
+    return ret;
 
-    /* Post the FI unexpected send request */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
-    do {
-        rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-                      tag, &na_ofi_op_id->noo_fi_ctx);
-        /* for EAGAIN, progress and do it again */
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_tsend(unexpected) failed, rc: %d(%s)",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    hg_atomic_set32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
+    na_ofi_op_id_decref(na_ofi_op_id);
 
-out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
     return ret;
 }
 
@@ -4059,62 +3851,66 @@ na_ofi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_rx;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
-    struct fid_mr *mr_hdl = plugin_data;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    NA_CHECK_ERROR(
+        !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED), out,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_RECV_UNEXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    na_ofi_op_id->addr = NULL;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    /* We assume buf remains valid (safe because we pre-allocate buffers) */
+    na_ofi_op_id->info.msg.buf.ptr = buf;
+    na_ofi_op_id->info.msg.buf_size = buf_size;
+    na_ofi_op_id->info.msg.actual_buf_size = 0;
+    na_ofi_op_id->info.msg.fi_addr = FI_ADDR_UNSPEC;
+    na_ofi_op_id->info.msg.fi_mr = plugin_data;
+    na_ofi_op_id->info.msg.tag = 0;
 
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_RECV_UNEXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    na_ofi_op_id->noo_addr = NULL; /* Make sure the addr is reset */
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_buf = buf;
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_buf_size = buf_size;
+    /* Post the FI unexpected recv request */
+    rc = fi_trecv(ctx->fi_rx, buf, buf_size, na_ofi_op_id->info.msg.fi_mr,
+        na_ofi_op_id->info.msg.fi_addr, NA_OFI_UNEXPECTED_TAG,
+        NA_OFI_TAG_MASK, &na_ofi_op_id->fi_ctx);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_trecv() unexpected failed, rc: %d (%s)", rc,
+            fi_strerror((int ) -rc));
 
-    na_ofi_msg_unexpected_op_push(context, na_ofi_op_id);
+out:
+    return ret;
 
-    /* Post the FI unexpected recv request */
-    do {
-        rc = fi_trecv(ep_hdl, buf, buf_size, mr_hdl, FI_ADDR_UNSPEC,
-                      1 /* tag */, NA_OFI_UNEXPECTED_TAG_IGNORE,
-                      &na_ofi_op_id->noo_fi_ctx);
-        /* for EAGAIN, progress and do it again */
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_trecv(unexpected) failed, rc: %d(%s)",
-                     rc, fi_strerror((int) -rc));
-        na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
-        ret = NA_PROTOCOL_ERROR;
-    }
+error:
+    hg_atomic_set32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
+    na_ofi_op_id_decref(na_ofi_op_id);
 
-out:
-    if (ret != NA_SUCCESS && na_ofi_op_id != NULL)
-        na_ofi_op_id_decref(na_ofi_op_id);
     return ret;
 }
 
@@ -4126,64 +3922,72 @@ na_ofi_msg_send_expected(na_class_t *na_class, na_context_t *context,
     na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) dest_addr;
-    struct fid_mr *mr_hdl = plugin_data;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
-    fi_addr_t fi_addr;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
-    na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    NA_CHECK_ERROR(
+        !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED), out,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_SEND_EXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    na_ofi_addr_addref(na_ofi_addr);
+    na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    /* We assume buf remains valid (safe because we pre-allocate buffers) */
+    na_ofi_op_id->info.msg.buf.const_ptr = buf;
+    na_ofi_op_id->info.msg.buf_size = buf_size;
+    na_ofi_op_id->info.msg.actual_buf_size = buf_size;
+    /* Specify target receive context */
+     na_ofi_op_id->info.msg.fi_addr =
+         fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.msg.fi_mr = plugin_data;
+    na_ofi_op_id->info.msg.tag = tag;
+
+    NA_LOG_DEBUG("Sending expected msg with tag=%llu", tag);
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
+    /* Post the FI expected send request */
+    rc = fi_tsend(ctx->fi_tx, buf, buf_size, na_ofi_op_id->info.msg.fi_mr,
+        na_ofi_op_id->info.msg.fi_addr, tag, &na_ofi_op_id->fi_ctx);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
 
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_SEND_EXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_tsend() expected failed, rc: %d (%s)", rc,
+            fi_strerror((int ) -rc));
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+out:
+    return ret;
 
-    /* Post the FI expected send request */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
-    do {
-        rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-                NA_OFI_EXPECTED_TAG_FLAG | tag, &na_ofi_op_id->noo_fi_ctx);
-        /* for EAGAIN, progress and do it again */
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_tsend(expected) failed, rc: %d(%s)",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    hg_atomic_set32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
+    na_ofi_op_id_decref(na_ofi_op_id);
 
-out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
     return ret;
 }
 
@@ -4195,68 +3999,69 @@ na_ofi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_rx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) source_addr;
-    struct fid_mr *mr_hdl = plugin_data;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
-    fi_addr_t fi_addr;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
-    na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    NA_CHECK_ERROR(
+        !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED), out,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_RECV_EXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    na_ofi_addr_addref(na_ofi_addr);
+    na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    na_ofi_op_id->info.msg.buf.ptr = buf;
+    na_ofi_op_id->info.msg.buf_size = buf_size;
+    na_ofi_op_id->info.msg.actual_buf_size = 0;
+    /* Specify target source context */
+    na_ofi_op_id->info.msg.fi_addr =
+        fi_rx_addr(na_ofi_addr->fi_addr, source_id, NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.msg.fi_mr = plugin_data;
+    na_ofi_op_id->info.msg.tag = tag;
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
+    /* Post the FI expected recv request */
+    rc = fi_trecv(ctx->fi_rx, buf, buf_size, na_ofi_op_id->info.msg.fi_mr,
+        na_ofi_op_id->info.msg.fi_addr, tag, 0, &na_ofi_op_id->fi_ctx);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
         }
-    }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_trecv() expected failed, rc: %d (%s)", rc,
+            fi_strerror((int ) -rc));
 
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_RECV_EXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_buf = buf;
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_buf_size = buf_size;
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_tag = tag;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+out:
+    return ret;
 
-    /* Post the FI expected recv request */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, source_id, NA_OFI_SEP_RX_CTX_BITS);
-    do {
-        rc = fi_trecv(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-            NA_OFI_EXPECTED_TAG_FLAG | tag, 0 /* ignore */,
-            &na_ofi_op_id->noo_fi_ctx);
-        /* for EAGAIN, progress and do it again */
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_trecv(expected) failed, rc: %d(%s)",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    hg_atomic_set32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
+    na_ofi_op_id_decref(na_ofi_op_id);
 
-out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
     return ret;
 }
 
@@ -4271,11 +4076,8 @@ na_ofi_mem_handle_create(na_class_t NA_UNUSED *na_class, void *buf,
     /* Allocate memory handle */
     na_ofi_mem_handle = (struct na_ofi_mem_handle *) calloc(1,
         sizeof(struct na_ofi_mem_handle));
-    if (!na_ofi_mem_handle) {
-        NA_LOG_ERROR("Could not allocate NA OFI memory handle");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_mem_handle == NULL, out, ret, NA_NOMEM,
+        "Could not allocate NA OFI memory handle");
 
     na_ofi_mem_handle->desc.base = (na_ptr_t)buf;
     na_ofi_mem_handle->desc.size = buf_size;
@@ -4302,7 +4104,7 @@ static na_return_t
 na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     struct na_ofi_mem_handle *na_ofi_mem_handle = mem_handle;
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     const void *base;
     na_uint64_t access;
     int rc = 0;
@@ -4310,11 +4112,11 @@ na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 
     /* Nothing to do for providers that do not need physically backed
      * virtual addresses (FI_MR_SCALABLE) */
-    if (!(domain->nod_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
+    if (!(domain->fi_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
         /* Use global handle and key */
-        na_ofi_mem_handle->mr_hdl = domain->nod_mr;
-        na_ofi_mem_handle->desc.mr_key = domain->nod_mr_key;
-        return NA_SUCCESS;
+        na_ofi_mem_handle->fi_mr = domain->fi_mr;
+        na_ofi_mem_handle->desc.fi_mr_key = domain->fi_mr_key;
+        goto out;
     }
 
     /* Set access mode */
@@ -4329,26 +4131,23 @@ na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
             access = FI_READ | FI_WRITE | FI_REMOTE_READ | FI_REMOTE_WRITE;
             break;
         default:
-            NA_LOG_ERROR("Invalid memory access flag");
-            ret = NA_INVALID_PARAM;
-            goto out;
+            NA_GOTO_ERROR(out, ret, NA_INVALID_ARG,
+                "Invalid memory access flag");
+            break;
     }
 
     /* Register region */
-    base = (domain->nod_prov->domain_attr->mr_mode & FI_MR_VIRT_ADDR) ?
+    base = (domain->fi_prov->domain_attr->mr_mode & FI_MR_VIRT_ADDR) ?
         (const void *) na_ofi_mem_handle->desc.base : NULL;
-    rc = fi_mr_reg(domain->nod_domain, base,
+    rc = fi_mr_reg(domain->fi_domain, base,
         (size_t) na_ofi_mem_handle->desc.size, access, 0 /* offset */,
-        0 /* requested key */, 0 /* flags */, &na_ofi_mem_handle->mr_hdl,
+        0 /* requested key */, 0 /* flags */, &na_ofi_mem_handle->fi_mr,
         NULL /* context */);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_mr_reg failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_mr_reg() failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
     /* Retrieve key */
-    na_ofi_mem_handle->desc.mr_key = fi_mr_key(na_ofi_mem_handle->mr_hdl);
+    na_ofi_mem_handle->desc.fi_mr_key = fi_mr_key(na_ofi_mem_handle->fi_mr);
 
 out:
     return ret;
@@ -4358,22 +4157,19 @@ out:
 static na_return_t
 na_ofi_mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     struct na_ofi_mem_handle *na_ofi_mem_handle = mem_handle;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    if (!(domain->nod_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)
-        || !na_ofi_mem_handle->mr_hdl)
+    if (!(domain->fi_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)
+        || !na_ofi_mem_handle->fi_mr)
         goto out;
 
     /* close MR handle */
-    rc = fi_close(&na_ofi_mem_handle->mr_hdl->fid);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_close mr_hdl failed, rc: %d(%s).",
-                     rc, fi_strerror(-rc));
-        return NA_PROTOCOL_ERROR;
-    }
+    rc = fi_close(&na_ofi_mem_handle->fi_mr->fid);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_close() mr_hdl failed, rc: %d (%s)", rc, fi_strerror(-rc));
 
 out:
     return ret;
@@ -4396,11 +4192,8 @@ na_ofi_mem_handle_serialize(na_class_t NA_UNUSED *na_class, void *buf,
             (struct na_ofi_mem_handle *) mem_handle;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size < sizeof(struct na_ofi_mem_desc)) {
-        NA_LOG_ERROR("Buffer size too small for serializing handle");
-        ret = NA_SIZE_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(buf_size < sizeof(struct na_ofi_mem_desc), out, ret,
+        NA_OVERFLOW, "Buffer size too small for serializing handle");
 
     /* Copy struct */
     memcpy(buf, &na_ofi_mem_handle->desc, sizeof(na_ofi_mem_handle->desc));
@@ -4417,23 +4210,17 @@ na_ofi_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
     struct na_ofi_mem_handle *na_ofi_mem_handle = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size < sizeof(struct na_ofi_mem_desc)) {
-        NA_LOG_ERROR("Buffer size too small for deserializing handle");
-        ret = NA_SIZE_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(buf_size < sizeof(struct na_ofi_mem_desc), out, ret,
+        NA_OVERFLOW, "Buffer size too small for deserializing handle");
 
     na_ofi_mem_handle = (struct na_ofi_mem_handle *)
             malloc(sizeof(struct na_ofi_mem_handle));
-    if (!na_ofi_mem_handle) {
-          NA_LOG_ERROR("Could not allocate NA OFI memory handle");
-          ret = NA_NOMEM_ERROR;
-          goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_mem_handle == NULL, out, ret, NA_NOMEM,
+        "Could not allocate NA OFI memory handle");
 
     /* Copy struct */
     memcpy(&na_ofi_mem_handle->desc, buf, sizeof(na_ofi_mem_handle->desc));
-    na_ofi_mem_handle->mr_hdl = NULL;
+    na_ofi_mem_handle->fi_mr = NULL;
 
     *mem_handle = (na_mem_handle_t) na_ofi_mem_handle;
 
@@ -4450,89 +4237,92 @@ na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
     struct na_ofi_mem_handle *ofi_local_mem_handle =
         (struct na_ofi_mem_handle *) local_mem_handle;
     struct na_ofi_mem_handle *ofi_remote_mem_handle =
         (struct na_ofi_mem_handle *) remote_mem_handle;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) remote_addr;
-    void *local_desc = fi_mr_desc(ofi_local_mem_handle->mr_hdl);
-    struct iovec local_iov = {
-        .iov_base = (char *)ofi_local_mem_handle->desc.base + local_offset,
-        .iov_len = length
-    };
-    struct fi_rma_iov remote_iov = {
-        .addr = (na_uint64_t)ofi_remote_mem_handle->desc.base + remote_offset,
-        .len = length,
-        .key = ofi_remote_mem_handle->desc.mr_key
-    };
-    struct fi_msg_rma msg_rma = {
-        .msg_iov = &local_iov,
-        .desc = &local_desc,
-        .iov_count = 1,
-        .addr = fi_rx_addr(na_ofi_addr->fi_addr, remote_id, NA_OFI_SEP_RX_CTX_BITS),
-        .rma_iov = &remote_iov,
-        .rma_iov_count = 1,
-        .context = NULL,
-        .data = 0
-    };
     struct na_ofi_op_id *na_ofi_op_id = NULL;
+    const struct fi_msg_rma na_ofi_msg_rma_initializer = {.msg_iov = NULL,
+        .desc = NULL, .iov_count = 1, .addr = 0, .rma_iov = NULL,
+        .rma_iov_count = 1, .context = NULL, .data = 0};
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
-    na_ofi_addr_addref(na_ofi_addr); /* for na_ofi_complete() */
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED),
+        out, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_PUT;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    na_ofi_addr_addref(na_ofi_addr);
+    na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
+
+    /* Set local desc */
+    na_ofi_op_id->info.rma.local_desc = fi_mr_desc(ofi_local_mem_handle->fi_mr);
+
+    /* Set local IOV */
+    na_ofi_op_id->info.rma.local_iov.iov_base =
+        (char *) ofi_local_mem_handle->desc.base + local_offset;
+    na_ofi_op_id->info.rma.local_iov.iov_len = length;
+
+    /* Set remote IOV */
+    na_ofi_op_id->info.rma.remote_iov.addr =
+        (na_uint64_t) ofi_remote_mem_handle->desc.base + remote_offset;
+    na_ofi_op_id->info.rma.remote_iov.len = length;
+    na_ofi_op_id->info.rma.remote_iov.key =
+        ofi_remote_mem_handle->desc.fi_mr_key;
+
+    /* Set RMA msg */
+    na_ofi_op_id->info.rma.fi_rma = na_ofi_msg_rma_initializer;
+    na_ofi_op_id->info.rma.fi_rma.msg_iov = &na_ofi_op_id->info.rma.local_iov;
+    na_ofi_op_id->info.rma.fi_rma.desc = &na_ofi_op_id->info.rma.local_desc;
+    na_ofi_op_id->info.rma.fi_rma.addr = fi_rx_addr(na_ofi_addr->fi_addr,
+        remote_id, NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.rma.fi_rma.rma_iov = &na_ofi_op_id->info.rma.remote_iov;
+    na_ofi_op_id->info.rma.fi_rma.context = &na_ofi_op_id->fi_ctx;
+
+    /* Post the OFI RMA write.
+     * For writes, FI_DELIVERY_COMPLETE guarantees that the operation
+     * has been processed by the destination */
+    rc = fi_writemsg(ctx->fi_tx, &na_ofi_op_id->info.rma.fi_rma,
+        NA_OFI_PUT_COMPLETION);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *) na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
         }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_PUT;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_writemsg() failed, rc: %d (%s)", rc, fi_strerror((int ) -rc));
 
-    /* Assign context */
-    msg_rma.context = &na_ofi_op_id->noo_fi_ctx;
+out:
+    return ret;
 
-    /* Post the OFI RMA write */
-    do {
-        /* For writes, FI_DELIVERY_COMPLETE guarantees that the operation
-         * has been processed by the destination */
-        rc = fi_writemsg(ep_hdl, &msg_rma, FI_COMPLETION | FI_DELIVERY_COMPLETE);
-        /* for EAGAIN, progress and do it again */
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_writemsg() failed, rc: %d(%s)", rc,
-            fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    hg_atomic_set32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
+    na_ofi_op_id_decref(na_ofi_op_id);
 
-out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
     return ret;
 }
 
@@ -4545,87 +4335,91 @@ na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
+    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_mem_handle *ofi_local_mem_handle =
         (struct na_ofi_mem_handle *) local_mem_handle;
     struct na_ofi_mem_handle *ofi_remote_mem_handle =
         (struct na_ofi_mem_handle *) remote_mem_handle;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) remote_addr;
-    void *local_desc = fi_mr_desc(ofi_local_mem_handle->mr_hdl);
-    struct iovec local_iov = {
-        .iov_base = (void *)(ofi_local_mem_handle->desc.base + local_offset),
-        .iov_len = length
-    };
-    struct fi_rma_iov remote_iov = {
-        .addr = (uint64_t)(ofi_remote_mem_handle->desc.base + remote_offset),
-        .len = length,
-        .key = ofi_remote_mem_handle->desc.mr_key
-    };
-    struct fi_msg_rma msg_rma = {
-        .msg_iov = &local_iov,
-        .desc = &local_desc,
-        .iov_count = 1,
-        .addr = fi_rx_addr(na_ofi_addr->fi_addr, remote_id, NA_OFI_SEP_RX_CTX_BITS),
-        .rma_iov = &remote_iov,
-        .rma_iov_count = 1,
-        .context = NULL,
-        .data = 0
-    };
     struct na_ofi_op_id *na_ofi_op_id = NULL;
+    const struct fi_msg_rma na_ofi_msg_rma_initializer = {.msg_iov = NULL,
+        .desc = NULL, .iov_count = 1, .addr = 0, .rma_iov = NULL,
+        .rma_iov_count = 1, .context = NULL, .data = 0};
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
-    na_ofi_addr_addref(na_ofi_addr); /* for na_ofi_complete() */
-
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *) na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED),
+        out, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_GET;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    na_ofi_addr_addref(na_ofi_addr);
+    na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
+
+    /* Set local desc */
+    na_ofi_op_id->info.rma.local_desc = fi_mr_desc(ofi_local_mem_handle->fi_mr);
+
+    /* Set local IOV */
+    na_ofi_op_id->info.rma.local_iov.iov_base =
+        (char *) ofi_local_mem_handle->desc.base + local_offset;
+    na_ofi_op_id->info.rma.local_iov.iov_len = length;
+
+    /* Set remote IOV */
+    na_ofi_op_id->info.rma.remote_iov.addr =
+        (na_uint64_t) ofi_remote_mem_handle->desc.base + remote_offset;
+    na_ofi_op_id->info.rma.remote_iov.len = length;
+    na_ofi_op_id->info.rma.remote_iov.key =
+        ofi_remote_mem_handle->desc.fi_mr_key;
+
+    /* Set RMA msg */
+    na_ofi_op_id->info.rma.fi_rma = na_ofi_msg_rma_initializer;
+    na_ofi_op_id->info.rma.fi_rma.msg_iov = &na_ofi_op_id->info.rma.local_iov;
+    na_ofi_op_id->info.rma.fi_rma.desc = &na_ofi_op_id->info.rma.local_desc;
+    na_ofi_op_id->info.rma.fi_rma.addr = fi_rx_addr(na_ofi_addr->fi_addr,
+        remote_id, NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.rma.fi_rma.rma_iov = &na_ofi_op_id->info.rma.remote_iov;
+    na_ofi_op_id->info.rma.fi_rma.context = &na_ofi_op_id->fi_ctx;
 
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_GET;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
+    /* Post the OFI RMA read */
+    rc = fi_readmsg(ep_hdl, &na_ofi_op_id->info.rma.fi_rma,
+        NA_OFI_GET_COMPLETION);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_readmsg() failed, rc: %d (%s)", rc, fi_strerror((int ) -rc));
 
-    /* Assign context */
-    msg_rma.context = &na_ofi_op_id->noo_fi_ctx;
+out:
+    return ret;
 
-    /* Post the OFI RMA read */
-    do {
-        rc = fi_readmsg(ep_hdl, &msg_rma, FI_COMPLETION);
-        /* for EAGAIN, progress and do it again */
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_readmsg() failed, rc: %d(%s)", rc,
-            fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    hg_atomic_set32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
+    na_ofi_op_id_decref(na_ofi_op_id);
 
-out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
     return ret;
 }
 
@@ -4638,17 +4432,14 @@ na_ofi_poll_get_fd(na_class_t *na_class, na_context_t *context)
     int fd = -1, rc;
 
     if (priv->no_wait ||
-        (na_ofi_prov_flags[priv->nop_domain->nod_prov_type] & NA_OFI_WAIT_SET))
+        (na_ofi_prov_flags[priv->domain->prov_type] & NA_OFI_WAIT_SET))
         goto out;
 
-    rc = fi_control(&ctx->noc_cq->fid, FI_GETWAIT, &fd);
-    if (rc < 0 && rc != -FI_ENOSYS)
-        NA_LOG_ERROR("fi_control() failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-    if (fd < 0) {
-        NA_LOG_ERROR("Returned fd is not valid (%d), will not block", fd);
-        goto out;
-    }
+    rc = fi_control(&ctx->fi_cq->fid, FI_GETWAIT, &fd);
+    NA_CHECK_ERROR_NORET(rc != 0 && rc != -FI_ENOSYS, out,
+        "fi_control() failed, rc: %d (%s)", rc, fi_strerror((int) -rc));
+    NA_CHECK_ERROR_NORET(fd < 0, out,
+        "Returned fd is not valid (%d), will not block", fd);
 
 out:
     return fd;
@@ -4663,24 +4454,29 @@ na_ofi_poll_try_wait(na_class_t *na_class, na_context_t *context)
     struct fid *fids[1];
     int rc;
 
-    if (priv->no_wait)
+    /* Keep making progress if retry queue is not empty */
+    hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+    if (!HG_QUEUE_IS_EMPTY(&ctx->retry_op_queue->queue)) {
+        hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
         return NA_FALSE;
+    }
+    hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
 
     /* Assume it is safe to block if provider is using wait set */
-    if ((na_ofi_prov_flags[priv->nop_domain->nod_prov_type] & NA_OFI_WAIT_SET)
+    if ((na_ofi_prov_flags[priv->domain->prov_type] & NA_OFI_WAIT_SET)
         /* PSM2 shows very slow performance with fi_trywait() */
-        || priv->nop_domain->nod_prov_type == NA_OFI_PROV_PSM2)
+        || priv->domain->prov_type == NA_OFI_PROV_PSM2)
            return NA_TRUE;
 
-    fids[0] = &ctx->noc_cq->fid;
+    fids[0] = &ctx->fi_cq->fid;
     /* Check whether it is safe to block on that fd */
-    rc = fi_trywait(priv->nop_domain->nod_fabric, fids, 1);
+    rc = fi_trywait(priv->domain->fi_fabric, fids, 1);
     if (rc == FI_SUCCESS)
         return NA_TRUE;
     else if (rc == -FI_EAGAIN)
         return NA_FALSE;
     else {
-        NA_LOG_ERROR("fi_trywait() failed, rc: %d(%s).",
+        NA_LOG_ERROR("fi_trywait() failed, rc: %d (%s)",
             rc, fi_strerror((int) -rc));
         return NA_FALSE;
     }
@@ -4698,59 +4494,58 @@ na_ofi_progress(na_class_t *na_class, na_context_t *context,
     do {
         struct fi_cq_tagged_entry cq_events[NA_OFI_CQ_EVENT_NUM];
         fi_addr_t src_addrs[NA_OFI_CQ_EVENT_NUM] = {FI_ADDR_UNSPEC};
-        void *src_err_addr = NULL;
-        size_t src_err_addrlen = 0;
+        char src_err_addr[NA_OFI_CQ_MAX_ERR_DATA_SIZE] = {0};
+        void *src_err_addr_ptr = src_err_addr;
+        size_t src_err_addrlen = NA_OFI_CQ_MAX_ERR_DATA_SIZE;
         size_t i, actual_count = 0;
         hg_time_t t1, t2;
 
         if (timeout) {
-            struct fid_wait *wait_hdl = NA_OFI_CONTEXT(context)->noc_wait;
+            struct fid_wait *wait_hdl = NA_OFI_CONTEXT(context)->fi_wait;
 
             hg_time_get_current(&t1);
 
             if (wait_hdl) {
                 /* Wait in wait set if provider does not support wait on FDs */
-                int rc = fi_wait(wait_hdl, (int) (remaining * 1000.0));
+                int rc = 0, retry_cnt = 0;
+                do {
+                    rc = fi_wait(wait_hdl, (int) (remaining * 1000.0));
+                } while (rc == -FI_EINTR && retry_cnt++ < NA_OFI_MAX_EINTR_RETRY);
+
                 if (rc == -FI_ETIMEDOUT)
                     break;
-                else if (rc != FI_SUCCESS) {
-                    NA_LOG_ERROR("fi_wait() failed, rc: %d(%s).",
-                        rc, fi_strerror((int) -rc));
-                    ret = NA_PROTOCOL_ERROR;
-                    goto out;
-                }
+
+                NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                    "fi_wait() failed, rc: %d (%s)", rc, fi_strerror((int) -rc));
             }
         }
 
         /* Read from CQ */
-        ret = na_ofi_cq_read(na_class, context, NA_OFI_CQ_EVENT_NUM, cq_events,
-            src_addrs, &src_err_addr, &src_err_addrlen, &actual_count);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not read events from context CQ");
-            goto out;
-        } else {
-            if (timeout) {
-                hg_time_get_current(&t2);
-                remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
-            }
-            if (actual_count == 0) {
-                ret = NA_TIMEOUT; /* Return NA_TIMEOUT if no events */
-                if (remaining <= 0)
-                    break;
-                continue;
-            }
+        ret = na_ofi_cq_read(context, NA_OFI_CQ_EVENT_NUM, cq_events, src_addrs,
+            &src_err_addr_ptr, &src_err_addrlen, &actual_count);
+        NA_CHECK_NA_ERROR(out, ret,
+            "Could not read events from context CQ");
+
+        /* Attempt to process retries */
+        ret = na_ofi_cq_process_retries(context);
+        NA_CHECK_NA_ERROR(out, ret, "Could not process retries");
+
+        if (timeout) {
+            hg_time_get_current(&t2);
+            remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
         }
 
-        /* Got at least one completion event */
-        assert(actual_count > 0);
+        if (actual_count == 0) {
+            ret = NA_TIMEOUT; /* Return NA_TIMEOUT if no events */
+            if (remaining <= 0)
+                break;
+            continue;
+        }
 
         for (i = 0; i < actual_count; i++) {
-           ret = na_ofi_cq_process_event(na_class, context, &cq_events[i],
-               src_addrs[i], src_err_addr, src_err_addrlen);
-           if (ret != NA_SUCCESS) {
-               NA_LOG_ERROR("Could not process event");
-               goto out;
-           }
+            ret = na_ofi_cq_process_event(na_class, &cq_events[i], src_addrs[i],
+                src_err_addr_ptr, src_err_addrlen);
+            NA_CHECK_NA_ERROR(out, ret, "Could not process event");
         }
     } while (remaining > 0 && ret != NA_SUCCESS);
 
@@ -4764,103 +4559,70 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context,
     na_op_id_t op_id)
 {
     struct na_ofi_op_id *na_ofi_op_id = (struct na_ofi_op_id *) op_id;
-    struct na_ofi_op_id *tmp = NULL, *first = NULL;
-    ssize_t rc;
+    struct fid_ep *fi_ep = NULL;
     na_return_t ret = NA_SUCCESS;
+    na_bool_t canceled = NA_FALSE;
+    ssize_t rc;
 
-    if (!na_ofi_op_id_valid(na_ofi_op_id)) {
-        NA_LOG_ERROR("bad na_ofi_op_id, ignore the cancel request.");
-        goto out;
-    }
-    if (hg_atomic_get32(&na_ofi_op_id->noo_completed))
-        goto out;
-    if (!hg_atomic_cas32(&na_ofi_op_id->noo_canceled, NA_FALSE, NA_TRUE)) {
-        NA_LOG_WARNING("ignore canceling for a canceled op.");
+    /* Exit if op has already completed */
+    if (hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_CANCELED)
+        & NA_OFI_OP_COMPLETED)
         goto out;
-    }
 
-    hg_atomic_incr32(&na_ofi_op_id->noo_canceled);
-
-    switch (na_ofi_op_id->noo_completion_data.callback_info.type) {
-    case NA_CB_LOOKUP:
-        break;
-    case NA_CB_RECV_UNEXPECTED:
-        rc = fi_cancel(&NA_OFI_CONTEXT(context)->noc_rx->fid,
-            &na_ofi_op_id->noo_fi_ctx);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_cancel unexpected recv failed, rc: %d(%s).",
-                         rc, fi_strerror((int) -rc));
-            ret = NA_CANCEL_ERROR;
-            goto out;
-        }
+    NA_LOG_DEBUG("Canceling operation ID %p", na_ofi_op_id);
 
-        tmp = first = na_ofi_msg_unexpected_op_pop(context);
-        do {
-            if (!tmp) {
-                NA_LOG_ERROR("got NULL head of unexpected op queue.");
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            if (tmp == na_ofi_op_id) {
-                break;
-            }
-            na_ofi_msg_unexpected_op_push(context, tmp);
+    switch (na_ofi_op_id->completion_data.callback_info.type) {
+        case NA_CB_RECV_UNEXPECTED:
+        case NA_CB_RECV_EXPECTED:
+            fi_ep = NA_OFI_CONTEXT(context)->fi_rx;
+            break;
+        case NA_CB_SEND_UNEXPECTED:
+        case NA_CB_SEND_EXPECTED:
+        case NA_CB_PUT:
+        case NA_CB_GET:
+            fi_ep = NA_OFI_CONTEXT(context)->fi_tx;
+            break;
+        case NA_CB_LOOKUP:
+        default:
+            NA_GOTO_ERROR(out, ret, NA_INVALID_ARG,
+                "Operation type %d not supported",
+                na_ofi_op_id->completion_data.callback_info.type);
+            break;
+    }
 
-            tmp = na_ofi_msg_unexpected_op_pop(context);
-            if (tmp == first) {
-                NA_LOG_ERROR("tmp == first");
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-        } while (tmp != na_ofi_op_id);
-
-        ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
-        break;
-    case NA_CB_RECV_EXPECTED:
-        rc = fi_cancel(&NA_OFI_CONTEXT(context)->noc_rx->fid,
-            &na_ofi_op_id->noo_fi_ctx);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_cancel expected recv failed, rc: %d(%s).",
-                         rc, fi_strerror((int) -rc));
-            ret = NA_CANCEL_ERROR;
-            goto out;
-        }
+    /* Check if op_id is in retry queue */
+    hg_thread_mutex_lock(&NA_OFI_CONTEXT(context)->retry_op_queue->mutex);
+    if (hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_QUEUED) {
+        HG_QUEUE_REMOVE(&NA_OFI_CONTEXT(context)->retry_op_queue->queue,
+            na_ofi_op_id, na_ofi_op_id, entry);
+        hg_atomic_and32(&na_ofi_op_id->status, ~NA_OFI_OP_QUEUED);
+        canceled = NA_TRUE;
+    }
+    hg_thread_mutex_unlock(&NA_OFI_CONTEXT(context)->retry_op_queue->mutex);
 
-        ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
-        break;
-    case NA_CB_SEND_UNEXPECTED:
-    case NA_CB_SEND_EXPECTED:
-    case NA_CB_PUT:
-    case NA_CB_GET:
-        /* May or may not be canceled in that case */
-        rc = fi_cancel(&NA_OFI_CONTEXT(context)->noc_tx->fid,
-            &na_ofi_op_id->noo_fi_ctx);
-        if (rc != 0) {
-            NA_LOG_WARNING("fi_cancel failed, rc: %d(%s).",
-                         rc, fi_strerror((int) -rc));
-        }
-        /* fi_cancel() is not guaranteed to return proper return code for now */
-//        if (rc == 0) {
-            /* Complete only if successfully canceled */
-        ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
-//        } else
-//            ret = NA_CANCEL_ERROR;
-        break;
-    default:
-        break;
+    if (canceled) {
+        ret = na_ofi_complete(na_ofi_op_id);
+        NA_CHECK_NA_ERROR(out, ret, "Could not complete operation");
+    } else {
+        /* fi_cancel() is an asynchronous operation, either the operation
+         * will be canceled and an FI_ECANCELED event will be generated
+         * or it will show up in the regular completion queue.
+         */
+        rc = fi_cancel(&fi_ep->fid, &na_ofi_op_id->fi_ctx);
+        NA_LOG_DEBUG("fi_cancel() rc: %d (%s)", (int) rc,
+            fi_strerror((int) -rc));
+        (void)rc;
     }
 
     /* Work around segfault on fi_cq_signal() in some providers */
-    if (!(na_ofi_prov_flags[NA_OFI_CLASS(na_class)->nop_domain->nod_prov_type]
+    if (!(na_ofi_prov_flags[NA_OFI_CLASS(na_class)->domain->prov_type]
         & NA_OFI_SKIP_SIGNAL)) {
         /* Signal CQ to wake up and no longer wait on FD */
-        rc = fi_cq_signal(NA_OFI_CONTEXT(context)->noc_cq);
-        if (rc != 0 && rc != -ENOSYS) {
-            NA_LOG_ERROR("fi_cq_signal (op type %d) failed, rc: %d(%s).",
-                na_ofi_op_id->noo_completion_data.callback_info.type, rc,
-                fi_strerror((int) -rc));
-            ret = NA_PROTOCOL_ERROR;
-        }
+        int rc_signal = fi_cq_signal(NA_OFI_CONTEXT(context)->fi_cq);
+        NA_CHECK_ERROR(rc_signal != 0 && rc_signal != -ENOSYS, out, ret,
+            NA_PROTOCOL_ERROR, "fi_cq_signal (op type %d) failed, rc: %d (%s)",
+            na_ofi_op_id->completion_data.callback_info.type, rc_signal,
+            fi_strerror((int) -rc_signal));
     }
 
 out:
diff --git a/src/na/na_plugin.h b/src/na/na_plugin.h
index 2db9207..05a6076 100644
--- a/src/na/na_plugin.h
+++ b/src/na/na_plugin.h
@@ -12,6 +12,7 @@
 #define NA_PLUGIN_H
 
 #include "na.h"
+#include "na_error.h"
 
 #include "mercury_atomic_queue.h"
 #include "mercury_queue.h"
@@ -27,8 +28,8 @@ typedef void (*na_plugin_cb_t)(void *arg);
 
 /* Completion data stored in completion queue */
 struct na_cb_completion_data {
-    na_cb_t callback;                   /* Pointer to function */
     struct na_cb_info callback_info;    /* Callback info struct */
+    na_cb_t callback;                   /* Pointer to function */
     na_plugin_cb_t plugin_callback;     /* Callback which will be called after
                                          * the user callback returns. */
     void *plugin_callback_args;         /* Argument to plugin_callback */
@@ -73,8 +74,7 @@ struct na_cb_completion_data {
 /**
  * Plugin ops definition
  */
-#define NA_PLUGIN_OPS(plugin_name) \
-    const struct na_class_ops na_ ##plugin_name ##_class_ops_g
+#define NA_PLUGIN_OPS(plugin_name) na_ ##plugin_name ##_class_ops_g
 
 /*********************/
 /* Public Prototypes */
@@ -94,7 +94,7 @@ extern "C" {
  *
  * \return NA_SUCCESS or corresponding NA error code (failure is not an option)
  */
-NA_EXPORT na_return_t
+NA_PRIVATE na_return_t
 na_cb_completion_add(
         na_context_t                 *context,
         struct na_cb_completion_data *na_cb_completion_data
@@ -103,20 +103,21 @@ na_cb_completion_add(
 /*********************/
 /* Public Variables */
 /*********************/
+
 #ifdef NA_HAS_SM
-NA_EXPORT NA_PLUGIN_OPS(sm);
+extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(sm);
 #endif
 #ifdef NA_HAS_BMI
-NA_EXPORT NA_PLUGIN_OPS(bmi);
+extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(bmi);
 #endif
 #ifdef NA_HAS_MPI
-NA_EXPORT NA_PLUGIN_OPS(mpi);
+extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(mpi);
 #endif
 #ifdef NA_HAS_CCI
-NA_EXPORT NA_PLUGIN_OPS(cci);
+extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(cci);
 #endif
 #ifdef NA_HAS_OFI
-NA_EXPORT NA_PLUGIN_OPS(ofi);
+extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(ofi);
 #endif
 
 #ifdef __cplusplus
diff --git a/src/na/na_sm.c b/src/na/na_sm.c
index 58e2a19..71333d9 100644
--- a/src/na/na_sm.c
+++ b/src/na/na_sm.c
@@ -24,22 +24,24 @@
 #include <stdio.h>
 
 #ifdef _WIN32
-#include <process.h>
+# include <process.h>
 #else
-#include <ftw.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#if defined(NA_SM_HAS_CMA)
-#include <sys/uio.h>
-#elif defined(__APPLE__)
-#include <mach/mach.h>
-#include <mach/mach_vm.h>
-#endif
+# include <pwd.h>
+# include <ftw.h>
+# include <unistd.h>
+# include <sys/types.h>
+# include <sys/mman.h>
+# include <sys/stat.h>
+# include <fcntl.h>
+# include <sys/socket.h>
+# include <sys/un.h>
+# if defined(NA_SM_HAS_CMA)
+#  include <sys/uio.h>
+#  include <limits.h>
+# elif defined(__APPLE__)
+#  include <mach/mach.h>
+#  include <mach/mach_vm.h>
+# endif
 #endif
 
 /****************/
@@ -65,6 +67,11 @@
 /* Max tag */
 #define NA_SM_MAX_TAG           NA_TAG_UB
 
+/* Op ID status bits */
+#define NA_SM_OP_COMPLETED      (1 << 0)
+#define NA_SM_OP_CANCELED       (1 << 1)
+#define NA_SM_OP_QUEUED         (1 << 2)
+
 /* Private data access */
 #define NA_SM_CLASS(na_class) \
     ((struct na_sm_class *)(na_class->plugin_class))
@@ -77,35 +84,34 @@
 #define NA_SM_MSGHDR_INITIALIZER {NULL, 0, NULL, 0, NULL, 0, 0}
 
 /* Default filenames/paths */
-#define NA_SM_SOCK_PATH NA_SM_TMP_DIRECTORY "/" NA_SM_SHM_PREFIX
-#define NA_SM_SHM_PATH "/dev/shm"
+#define NA_SM_SHM_PATH          "/dev/shm"
 
-#define NA_SM_GEN_SHM_NAME(filename, na_sm_addr)        \
-    do {                                                \
-        sprintf(filename, "%s-%d-%u", NA_SM_SHM_PREFIX, \
-            na_sm_addr->pid, na_sm_addr->id);           \
+#define NA_SM_GEN_SHM_NAME(filename, username, na_sm_addr)      \
+    do {                                                        \
+        sprintf(filename, "%s_%s-%d-%u", NA_SM_SHM_PREFIX,      \
+            username, na_sm_addr->pid, na_sm_addr->id);         \
     } while (0)
 
-#define NA_SM_GEN_SOCK_PATH(pathname, na_sm_addr)               \
-    do {                                                        \
-        sprintf(pathname, "%s/%s/%d/%u", NA_SM_TMP_DIRECTORY,   \
-            NA_SM_SHM_PREFIX, na_sm_addr->pid, na_sm_addr->id); \
+#define NA_SM_GEN_SOCK_PATH(pathname, username, na_sm_addr)                 \
+    do {                                                                    \
+        sprintf(pathname, "%s/%s_%s/%d/%u", NA_SM_TMP_DIRECTORY,            \
+            NA_SM_SHM_PREFIX, username, na_sm_addr->pid, na_sm_addr->id);   \
     } while (0)
 
 #define NA_SM_SEND_NAME "s" /* used for pair_name */
 #define NA_SM_RECV_NAME "r" /* used for pair_name */
-#define NA_SM_GEN_RING_NAME(filename, pair_name, na_sm_addr)            \
-    do {                                                                \
-        sprintf(filename, "%s-%d-%u-%u-" pair_name, NA_SM_SHM_PREFIX,   \
-            na_sm_addr->pid, na_sm_addr->id, na_sm_addr->conn_id);      \
+#define NA_SM_GEN_RING_NAME(filename, pair_name, username, na_sm_addr)      \
+    do {                                                                    \
+        sprintf(filename, "%s_%s-%d-%u-%u-" pair_name, NA_SM_SHM_PREFIX,    \
+            username, na_sm_addr->pid, na_sm_addr->id, na_sm_addr->conn_id);\
     } while (0)
 
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
-#define NA_SM_GEN_FIFO_NAME(filename, pair_name, na_sm_addr)            \
+#define NA_SM_GEN_FIFO_NAME(filename, pair_name, username, na_sm_addr)  \
     do {                                                                \
-        sprintf(filename, "%s/%s/%d/%u/fifo-%u-" pair_name,             \
-            NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX, na_sm_addr->pid,     \
-            na_sm_addr->id, na_sm_addr->conn_id);                       \
+        sprintf(filename, "%s/%s_%s/%d/%u/fifo-%u-" pair_name,          \
+            NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX, username,            \
+            na_sm_addr->pid, na_sm_addr->id, na_sm_addr->conn_id);      \
     } while (0)
 #endif
 
@@ -158,8 +164,8 @@ typedef enum na_sm_poll_type {
 /* Poll data */
 struct na_sm_poll_data {
     na_class_t *na_class;
-    na_sm_poll_type_t type;  /* Type of operation */
     struct na_sm_addr *addr; /* Address */
+    na_sm_poll_type_t type;  /* Type of operation */
 };
 
 /* Sock progress type */
@@ -171,30 +177,23 @@ typedef enum {
 
 /* Address */
 struct na_sm_addr {
-    pid_t pid;                              /* PID */
-    unsigned int id;                        /* SM ID */
-    unsigned int conn_id;                   /* Connection ID */
+    HG_QUEUE_ENTRY(na_sm_addr) entry;       /* Next queue entry */
+    HG_QUEUE_ENTRY(na_sm_addr) poll_entry;  /* Next poll queue entry */
     struct na_sm_ring_buf *na_sm_send_ring_buf; /* Shared send ring buffer */
     struct na_sm_ring_buf *na_sm_recv_ring_buf; /* Shared recv ring buffer */
     struct na_sm_copy_buf *na_sm_copy_buf;  /* Shared copy buffer */
-    na_bool_t accepted;                     /* Created on accept */
-    na_bool_t self;                         /* Self address */
-    int sock;                               /* Sock fd */
-    na_sm_sock_progress_t sock_progress;    /* Current sock progress state */
     struct na_sm_poll_data *sock_poll_data; /* Sock poll data */
-    int local_notify;                       /* Local notify fd */
     struct na_sm_poll_data *local_notify_poll_data; /* Notify poll data */
+    pid_t pid;                              /* PID */
+    na_sm_sock_progress_t sock_progress;    /* Current sock progress state */
+    unsigned int id;                        /* SM ID */
+    unsigned int conn_id;                   /* Connection ID */
+    int sock;                               /* Sock fd */
+    int local_notify;                       /* Local notify fd */
     int remote_notify;                      /* Remote notify fd */
     hg_atomic_int32_t ref_count;            /* Ref count */
-    HG_QUEUE_ENTRY(na_sm_addr) entry;       /* Next queue entry */
-    HG_QUEUE_ENTRY(na_sm_addr) poll_entry;  /* Next poll queue entry */
-};
-
-/* Unexpected message info */
-struct na_sm_unexpected_info {
-    struct na_sm_addr *na_sm_addr;
-    na_sm_cacheline_hdr_t na_sm_hdr;
-    HG_QUEUE_ENTRY(na_sm_unexpected_info) entry;
+    na_bool_t accepted;                     /* Created on accept */
+    na_bool_t self;                         /* Self address */
 };
 
 /* Memory handle */
@@ -205,70 +204,64 @@ struct na_sm_mem_handle {
     size_t len;
 };
 
-/* Lookup info */
-struct na_sm_info_lookup {
-    struct na_sm_addr *na_sm_addr;
-};
 
-/* Send unexpected and expected */
-struct na_sm_info_send {
-    void *buf;
-    size_t buf_size;
+/* Unexpected message info */
+struct na_sm_unexpected_info {
+    HG_QUEUE_ENTRY(na_sm_unexpected_info) entry;
     struct na_sm_addr *na_sm_addr;
-    na_tag_t tag;
-};
-
-/* Unexpected recv info */
-struct na_sm_info_recv_unexpected {
     void *buf;
-    size_t buf_size;
-    struct na_sm_unexpected_info unexpected_info;
+    na_size_t buf_size;
+    na_tag_t tag;
 };
 
-/* Expected recv info */
-struct na_sm_info_recv_expected {
-    void *buf;
+/* Msg info */
+struct na_sm_msg_info {
+    union {
+        const void *const_ptr;
+        void *ptr;
+    } buf;
     size_t buf_size;
-    struct na_sm_addr *na_sm_addr;
+    na_size_t actual_buf_size;
     na_tag_t tag;
 };
 
 /* Operation ID */
 struct na_sm_op_id {
-    na_class_t *na_class;
-    na_context_t *context;
-    struct na_cb_completion_data completion_data;
-    hg_atomic_int32_t completed;    /* Operation completed */
-    hg_atomic_int32_t canceled;     /* Operation canceled */
+    struct na_cb_completion_data completion_data; /* Completion data */
     union {
-        struct na_sm_info_lookup lookup;
-        struct na_sm_info_send send;
-        struct na_sm_info_recv_unexpected recv_unexpected;
-        struct na_sm_info_recv_expected recv_expected;
-    } info;
-    hg_atomic_int32_t ref_count;    /* Ref count */
-    HG_QUEUE_ENTRY(na_sm_op_id) entry;
+        struct na_sm_msg_info msg;
+    } info;                             /* Op info                  */
+    HG_QUEUE_ENTRY(na_sm_op_id) entry;  /* Entry in queue           */
+    na_class_t *na_class;               /* NA class associated      */
+    na_context_t *context;              /* NA context associated    */
+    struct na_sm_addr *na_sm_addr;      /* Address associated       */
+    hg_atomic_int32_t status;           /* Operation status         */
+    hg_atomic_int32_t ref_count;        /* Refcount                 */
 };
 
 /* Private data */
 struct na_sm_class {
-    struct na_sm_addr *self_addr;
-    hg_poll_set_t *poll_set;
     HG_QUEUE_HEAD(na_sm_addr) accepted_addr_queue;
     HG_QUEUE_HEAD(na_sm_addr) poll_addr_queue;
     HG_QUEUE_HEAD(na_sm_unexpected_info) unexpected_msg_queue;
     HG_QUEUE_HEAD(na_sm_op_id) lookup_op_queue;
     HG_QUEUE_HEAD(na_sm_op_id) unexpected_op_queue;
     HG_QUEUE_HEAD(na_sm_op_id) expected_op_queue;
+    HG_QUEUE_HEAD(na_sm_op_id) retry_op_queue;
+    hg_time_t last_accept_time;
+    char *username;
+    struct na_sm_addr *self_addr;
+    hg_poll_set_t *poll_set;
     hg_thread_spin_t accepted_addr_queue_lock;
     hg_thread_spin_t poll_addr_queue_lock;
     hg_thread_spin_t unexpected_msg_queue_lock;
     hg_thread_spin_t lookup_op_queue_lock;
     hg_thread_spin_t unexpected_op_queue_lock;
     hg_thread_spin_t expected_op_queue_lock;
+    hg_thread_spin_t retry_op_queue_lock;
     hg_thread_spin_t copy_buf_lock;
-    hg_time_t last_accept_time;
     na_bool_t no_wait;
+    na_bool_t no_retry;
 };
 
 /********************/
@@ -276,6 +269,14 @@ struct na_sm_class {
 /********************/
 
 /**
+ * utility function: wrapper around getlogin().
+ * Allows graceful handling of directory name generation.
+ */
+static char *
+getlogin_safe(void);
+
+
+/**
  * Open shared buf.
  */
 static void *
@@ -483,7 +484,7 @@ na_sm_reserve_and_copy_buf(
     );
 
 /**
- * Free shared copy buf.
+ * Free and copy buf.
  */
 static NA_INLINE void
 na_sm_copy_and_free_buf(
@@ -495,6 +496,25 @@ na_sm_copy_and_free_buf(
     );
 
 /**
+ * Release shared copy buf.
+ */
+static NA_INLINE void
+na_sm_release_buf(
+    struct na_sm_copy_buf *na_sm_copy_buf,
+    unsigned int idx_reserved
+    );
+
+/**
+ * Insert message header into ring buffer.
+ */
+static na_return_t
+na_sm_msg_insert(
+    na_class_t *na_class,
+    struct na_sm_op_id *na_sm_op_id,
+    unsigned int idx_reserved
+    );
+
+/**
  * Translate offset from mem_handle into usable iovec.
  */
 static void
@@ -522,8 +542,7 @@ na_sm_progress_cb(
 static na_return_t
 na_sm_progress_error(
     na_class_t *na_class,
-    struct na_sm_addr *poll_addr,
-    int error
+    struct na_sm_addr *poll_addr
     );
 
 /**
@@ -577,6 +596,14 @@ na_sm_progress_expected(
     );
 
 /**
+ * Progress retries.
+ */
+static na_return_t
+na_sm_progress_retries(
+    na_class_t *na_class
+    );
+
+/**
  * Complete operation.
  */
 static na_return_t
@@ -664,6 +691,14 @@ na_sm_addr_dup(
     na_addr_t  *new_addr
     );
 
+/* addr_cmp */
+static na_bool_t
+na_sm_addr_cmp(
+    na_class_t *na_class,
+    na_addr_t   addr1,
+    na_addr_t   addr2
+    );
+
 /* addr_is_self */
 static NA_INLINE na_bool_t
 na_sm_addr_is_self(
@@ -881,7 +916,7 @@ na_sm_cancel(
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN_OPS(sm) = {
+const struct na_class_ops NA_PLUGIN_OPS(sm) = {
     "na",                                   /* name */
     na_sm_check_protocol,                   /* check_protocol */
     na_sm_initialize,                       /* initialize */
@@ -892,9 +927,12 @@ NA_PLUGIN_OPS(sm) = {
     na_sm_op_create,                        /* op_create */
     na_sm_op_destroy,                       /* op_destroy */
     na_sm_addr_lookup,                      /* addr_lookup */
+    NULL,                                   /* addr_lookup2 */
     na_sm_addr_free,                        /* addr_free */
+    NULL,                                   /* addr_set_remove */
     na_sm_addr_self,                        /* addr_self */
     na_sm_addr_dup,                         /* addr_dup */
+    na_sm_addr_cmp,                         /* addr_cmp */
     na_sm_addr_is_self,                     /* addr_is_self */
     na_sm_addr_to_string,                   /* addr_to_string */
     NULL,                                   /* addr_get_serialize_size */
@@ -939,49 +977,47 @@ NA_PLUGIN_OPS(sm) = {
 /* Plugin callbacks */
 /********************/
 
-/*
-static char*
+/* Debug information */
+#ifdef NA_HAS_DEBUG
+static char *
 itoa(uint64_t val, int base)
 {
     static char buf[64] = {0};
     int i = 62;
 
-    for (; val && i; --i, val /= base)
-        buf[i] = "0123456789abcdef"[val % base];
+    for (; val && i; --i, val /= (uint64_t) base)
+        buf[i] = "0123456789abcdef"[val % (uint64_t) base];
 
     return &buf[i + 1];
 }
-*/
+#endif
 
-/*
-static void
-na_sm_print_addr(struct na_sm_addr *na_sm_addr)
+/*---------------------------------------------------------------------------*/
+static char *
+getlogin_safe(void)
 {
-    NA_LOG_DEBUG("pid=%d, id=%d, copy_buf=0x%lX, sock=%d, local_notify=%d, "
-        "remote_notify=%d", na_sm_addr->pid, na_sm_addr->id,
-        (uint64_t)na_sm_addr->na_sm_copy_buf, na_sm_addr->sock,
-        na_sm_addr->local_notify, na_sm_addr->remote_notify);
+    struct passwd *passwd;
+
+    /* statically allocated */
+    passwd = getpwuid(getuid());
+
+    return passwd ? passwd->pw_name : "unknown";
 }
-*/
 
 /*---------------------------------------------------------------------------*/
 static void *
 na_sm_open_shared_buf(const char *name, size_t buf_size, na_bool_t create)
 {
-//    na_size_t page_size = (na_size_t) hg_mem_get_page_size();
+    na_size_t page_size = (na_size_t) hg_mem_get_page_size();
     void *ret = NULL;
 
     /* Check alignment */
-//    if (buf_size / page_size * page_size != buf_size) {
-//        NA_LOG_ERROR(
-//            "Not aligned properly, page size=%zu bytes, buf size=%zu bytes",
-//            page_size, buf_size);
-//        goto done;
-//    }
+    NA_CHECK_WARNING(buf_size / page_size * page_size != buf_size,
+        "Not aligned properly, page size=%zu bytes, buf size=%zu bytes",
+        page_size, buf_size);
 
     ret = hg_mem_shm_map(name, buf_size, create);
 
-//done:
     return ret;
 }
 
@@ -997,8 +1033,9 @@ static na_return_t
 na_sm_create_sock(const char *pathname, na_bool_t na_listen, int *sock)
 {
     struct sockaddr_un addr;
+    char *dup_path = NULL;
     na_return_t ret = NA_SUCCESS;
-    int fd;
+    int fd = -1, rc;
 
     /* Create a non-blocking socket so that we can poll for incoming connections */
 #ifdef SOCK_NONBLOCK
@@ -1006,33 +1043,30 @@ na_sm_create_sock(const char *pathname, na_bool_t na_listen, int *sock)
 #else
     fd = socket(AF_UNIX, SOCK_STREAM, 0);
 #endif
-    if (fd == -1) {
-        NA_LOG_ERROR("socket() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(fd == -1, error, ret, NA_PROTOCOL_ERROR,
+        "socket() failed (%s)", strerror(errno));
+
 #ifndef SOCK_NONBLOCK
-    if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {
-        NA_LOG_ERROR("fcntl() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    };
+    rc = fcntl(fd, F_SETFL, O_NONBLOCK);
+    NA_CHECK_ERROR(rc == -1, error, ret, NA_PROTOCOL_ERROR,
+        "fcntl() failed (%s)", strerror(errno));
 #endif
 
     memset(&addr, 0, sizeof(struct sockaddr_un));
     addr.sun_family = AF_UNIX;
-    if (strlen(pathname) + strlen("/sock") > sizeof(addr.sun_path) - 1) {
-        NA_LOG_ERROR("Exceeds maximum AF UNIX socket path length");
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(strlen(pathname) + strlen("/sock") > sizeof(addr.sun_path) - 1,
+        error, ret, NA_OVERFLOW, "Exceeds maximum AF UNIX socket path length");
     strcpy(addr.sun_path, pathname);
     strcat(addr.sun_path, "/sock");
 
     if (na_listen) {
-        char *dup_path = strdup(pathname);
         char stat_path[NA_SM_MAX_FILENAME];
-        char *path_ptr = dup_path;
+        char *path_ptr;
+
+        dup_path = strdup(pathname);
+        NA_CHECK_ERROR(dup_path == NULL, error, ret, NA_NOMEM,
+            "Could not dup pathname");
+        path_ptr = dup_path;
 
         memset(stat_path, '\0', NA_SM_MAX_FILENAME);
         if (dup_path[0] == '/') {
@@ -1044,47 +1078,47 @@ na_sm_create_sock(const char *pathname, na_bool_t na_listen, int *sock)
         while (path_ptr) {
             struct stat sb;
             char *current = strtok_r(path_ptr, "/", &path_ptr);
-            if (!current) break;
+            if (!current)
+                break;
 
             strcat(stat_path, current);
             if (stat(stat_path, &sb) == -1) {
-                if (mkdir(stat_path, 0775) == -1 && errno != EEXIST) {
-                    NA_LOG_ERROR("Could not create directory: %s (%s)",
-                        stat_path, strerror(errno));
-                    ret = NA_PROTOCOL_ERROR;
-                    free(dup_path);
-                    goto done;
-                }
+                rc = mkdir(stat_path, 0775);
+                NA_CHECK_ERROR(rc == -1 && errno != EEXIST, error, ret,
+                    NA_PROTOCOL_ERROR, "Could not create directory: %s (%s)",
+                    stat_path, strerror(errno));
             }
             strcat(stat_path, "/");
         }
-        free(dup_path);
 
         /* Bind */
-        if (bind(fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1) {
-            NA_LOG_ERROR("bind() socket (%s)", strerror(errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = bind(fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un));
+        NA_CHECK_ERROR(rc == -1, error, ret, NA_PROTOCOL_ERROR,
+            "bind() failed (%s)", strerror(errno));
 
         /* Listen */
-        if (listen(fd, NA_SM_LISTEN_BACKLOG) == -1) {
-            NA_LOG_ERROR("listen() failed (%s)", strerror(errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = listen(fd, NA_SM_LISTEN_BACKLOG);
+        NA_CHECK_ERROR(rc == -1, error, ret, NA_PROTOCOL_ERROR,
+            "listen() failed (%s)", strerror(errno));
     } else {
         /* Connect */
-        if (connect(fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1) {
-            NA_LOG_ERROR("connect() failed (%s)", strerror(errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = connect(fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un));
+        NA_CHECK_ERROR(rc == -1, error, ret, NA_PROTOCOL_ERROR,
+            "connect() failed (%s)", strerror(errno));
     }
 
     *sock = fd;
 
-done:
+    free(dup_path);
+    return ret;
+
+error:
+    if (fd != -1) {
+        rc = close(fd);
+        NA_CHECK_ERROR_DONE(rc == -1, "close() failed (%s)", strerror(errno));
+    }
+    free(dup_path);
+
     return ret;
 }
 
@@ -1093,12 +1127,11 @@ static na_return_t
 na_sm_close_sock(int sock, const char *pathname)
 {
     na_return_t ret = NA_SUCCESS;
+    int rc;
 
-    if (close(sock) == -1) {
-        NA_LOG_ERROR("close() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = close(sock);
+    NA_CHECK_ERROR(rc == -1, done, ret, NA_PROTOCOL_ERROR,
+        "close() failed (%s)", strerror(errno));
 
     if (pathname) {
         char dup_path[NA_SM_MAX_FILENAME];
@@ -1107,11 +1140,9 @@ na_sm_close_sock(int sock, const char *pathname)
         strcpy(dup_path, pathname);
         strcat(dup_path, "/sock");
 
-        if (unlink(dup_path) == -1) {
-            NA_LOG_ERROR("unlink() failed (%s)", strerror(errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = unlink(dup_path);
+        NA_CHECK_ERROR(rc == -1, done, ret, NA_PROTOCOL_ERROR,
+            "unlink() failed (%s)", strerror(errno));
 
         /* Delete path */
         path_ptr = strrchr(dup_path, '/');
@@ -1141,12 +1172,16 @@ static int
 na_sm_cleanup_shm(const char *fpath, const struct stat NA_UNUSED *sb,
     int NA_UNUSED typeflag, struct FTW NA_UNUSED *ftwbuf)
 {
-    const char *prefix = NA_SM_SHM_PATH "/" NA_SM_SHM_PREFIX;
+    const char *prefix = NA_SM_SHM_PATH "/" NA_SM_SHM_PREFIX "_";
     int ret = 0;
 
     if (strncmp(fpath, prefix, strlen(prefix)) == 0) {
         const char *file = fpath + strlen(NA_SM_SHM_PATH "/");
-        ret = hg_mem_shm_unmap(file, NULL, 0);
+        char *username = getlogin_safe();
+
+        if (strncmp(file + strlen(NA_SM_SHM_PREFIX "_"),
+            username, strlen(username)) == 0)
+            ret = hg_mem_shm_unmap(file, NULL, 0);
     }
 
     return ret;
@@ -1159,30 +1194,31 @@ static int
 na_sm_event_create(const char *filename)
 {
     int fd = -1;
+    int rc;
 
     /* Create FIFO */
-    if (mkfifo(filename, S_IRUSR | S_IWUSR) == - 1) {
-        NA_LOG_ERROR("mkfifo() failed (%s)", strerror(errno));
-        goto done;
-    }
+    rc = mkfifo(filename, S_IRUSR | S_IWUSR);
+    NA_CHECK_ERROR_NORET(rc == -1, error, "mkfifo() failed (%s)",
+        strerror(errno));
 
     /* Open FIFO (RDWR for convenience) */
     fd = open(filename, O_RDWR);
-    if (fd == -1) {
-        NA_LOG_ERROR("open() failed (%s)", strerror(errno));
-        goto done;
-    }
+    NA_CHECK_ERROR_NORET(fd == -1, error, "open() failed (%s)", strerror(errno));
 
     /* Set FIFO to be non-blocking */
-    if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {
-        NA_LOG_ERROR("fcntl() failed (%s)", strerror(errno));
-        close(fd);
-        fd = -1;
-        goto done;
-    };
+    rc = fcntl(fd, F_SETFL, O_NONBLOCK);
+    NA_CHECK_ERROR_NORET(rc == -1, error, "fcntl() failed (%s)",
+        strerror(errno));
 
-done:
     return fd;
+
+error:
+    if (fd != -1) {
+        rc = close(fd);
+        NA_CHECK_ERROR_DONE(rc == -1, "close() failed (%s)", strerror(errno));
+    }
+
+    return -1;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1190,18 +1226,18 @@ na_return_t
 na_sm_event_destroy(const char *filename, int fd)
 {
     na_return_t ret = NA_SUCCESS;
+    int rc;
 
-    if (close(fd) == -1) {
-        NA_LOG_ERROR("close() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = close(fd);
+    NA_CHECK_ERROR(rc == -1, done, ret, NA_PROTOCOL_ERROR,
+        "close() failed (%s)", strerror(errno));
 
-    if (filename && unlink(filename) == -1) {
-        NA_LOG_ERROR("unlink() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+    if (filename) {
+        rc = unlink(filename);
+        NA_CHECK_ERROR(rc == -1, done, ret, NA_PROTOCOL_ERROR,
+            "unlink() failed (%s)", strerror(errno));
     }
+
 done:
     return ret;
 }
@@ -1215,11 +1251,8 @@ na_sm_event_set(int fd)
     ssize_t s;
 
     s = write(fd, &count, sizeof(uint64_t));
-    if (s != sizeof(uint64_t)) {
-        NA_LOG_ERROR("write() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(s != sizeof(uint64_t), done, ret, NA_PROTOCOL_ERROR,
+        "write() failed (%s)", strerror(errno));
 
 done:
     return ret;
@@ -1230,21 +1263,20 @@ na_return_t
 na_sm_event_get(int fd, na_bool_t *signaled)
 {
     na_return_t ret = NA_SUCCESS;
-    na_bool_t event_signal = NA_FALSE;
     uint64_t count = 1;
     ssize_t s;
 
     s = read(fd, &count, sizeof(uint64_t));
     if (s != sizeof(uint64_t)) {
-        if (errno == EAGAIN)
+        if (likely(errno == EAGAIN)) {
+            *signaled = NA_FALSE;
             goto done;
-        NA_LOG_ERROR("read() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+        } else
+            NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR, "read() failed (%s)",
+                strerror(errno));
     }
-    event_signal = NA_TRUE;
 
-    if (signaled) *signaled = event_signal;
+    *signaled = NA_TRUE;
 
 done:
     return ret;
@@ -1260,7 +1292,7 @@ na_sm_poll_register(na_class_t *na_class, na_sm_poll_type_t poll_type,
     struct na_sm_poll_data *na_sm_poll_data = NULL;
     struct na_sm_poll_data **na_sm_poll_data_ptr = NULL;
     unsigned int flags = HG_POLLIN;
-    int fd;
+    int fd, rc;
     na_return_t ret = NA_SUCCESS;
 
     switch (poll_type) {
@@ -1277,30 +1309,30 @@ na_sm_poll_register(na_class_t *na_class, na_sm_poll_type_t poll_type,
             na_sm_poll_data_ptr = &na_sm_addr->local_notify_poll_data;
             break;
         default:
-            NA_LOG_ERROR("Invalid poll type");
-            ret = NA_INVALID_PARAM;
-            goto done;
+            NA_GOTO_ERROR(error, ret, NA_INVALID_ARG, "Invalid poll type");
     }
 
-    na_sm_poll_data = (struct na_sm_poll_data *) malloc(sizeof(struct na_sm_poll_data));
-    if (!na_sm_poll_data) {
-        NA_LOG_ERROR("Could not allocate NA SM poll data");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_sm_poll_data =
+        (struct na_sm_poll_data *) malloc(sizeof(struct na_sm_poll_data));
+    NA_CHECK_ERROR(na_sm_poll_data == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA SM poll data");
     na_sm_poll_data->na_class = na_class;
     na_sm_poll_data->type = poll_type;
     na_sm_poll_data->addr = na_sm_addr;
     *na_sm_poll_data_ptr = na_sm_poll_data;
 
-    if (hg_poll_add(NA_SM_CLASS(na_class)->poll_set, fd, flags,
-        na_sm_progress_cb, na_sm_poll_data) != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_poll_add failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_poll_add(NA_SM_CLASS(na_class)->poll_set, fd, flags,
+        na_sm_progress_cb, na_sm_poll_data);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_PROTOCOL_ERROR,
+        "hg_poll_add() failed");
+
+    return ret;
+
+error:
+    free(na_sm_poll_data);
+    if (na_sm_poll_data_ptr)
+        *na_sm_poll_data_ptr = NULL;
 
-done:
     return ret;
 }
 
@@ -1309,7 +1341,7 @@ static na_return_t
 na_sm_poll_deregister(na_class_t *na_class, na_sm_poll_type_t poll_type,
     struct na_sm_addr *na_sm_addr)
 {
-    int fd;
+    int fd, rc;
     struct na_sm_poll_data *na_sm_poll_data = NULL;
     na_return_t ret = NA_SUCCESS;
 
@@ -1327,17 +1359,12 @@ na_sm_poll_deregister(na_class_t *na_class, na_sm_poll_type_t poll_type,
             fd = na_sm_addr->local_notify;
             break;
         default:
-            NA_LOG_ERROR("Invalid poll type");
-            ret = NA_INVALID_PARAM;
-            goto done;
+            NA_GOTO_ERROR(done, ret, NA_INVALID_ARG, "Invalid poll type");
     }
 
-    if (hg_poll_remove(NA_SM_CLASS(na_class)->poll_set,
-        fd) != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_poll_remove failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_poll_remove(NA_SM_CLASS(na_class)->poll_set, fd);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+        "hg_poll_remove() failed");
     free(na_sm_poll_data);
 
 done:
@@ -1350,39 +1377,42 @@ na_sm_setup_shm(na_class_t *na_class, struct na_sm_addr *na_sm_addr)
 {
     char filename[NA_SM_MAX_FILENAME], pathname[NA_SM_MAX_FILENAME];
     struct na_sm_copy_buf *na_sm_copy_buf = NULL;
-    int listen_sock;
+    int listen_sock = -1;
     na_return_t ret = NA_SUCCESS;
 
     /* Create SHM buffer */
-    NA_SM_GEN_SHM_NAME(filename, na_sm_addr);
+    NA_SM_GEN_SHM_NAME(filename, NA_SM_CLASS(na_class)->username, na_sm_addr);
     na_sm_copy_buf = (struct na_sm_copy_buf *) na_sm_open_shared_buf(
         filename, sizeof(struct na_sm_copy_buf), NA_TRUE);
-    if (!na_sm_copy_buf) {
-        NA_LOG_ERROR("Could not create copy buffer");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_copy_buf == NULL, error, ret, NA_PROTOCOL_ERROR,
+        "Could not create copy buffer");
+
     /* Initialize copy buf, store 1111111111...1111 */
     hg_atomic_init64(&na_sm_copy_buf->available.val, ~((hg_util_int64_t)0));
     na_sm_addr->na_sm_copy_buf = na_sm_copy_buf;
 
     /* Create SHM sock */
-    NA_SM_GEN_SOCK_PATH(pathname, na_sm_addr);
+    NA_SM_GEN_SOCK_PATH(pathname, NA_SM_CLASS(na_class)->username, na_sm_addr);
     ret = na_sm_create_sock(pathname, NA_TRUE, &listen_sock);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not create sock");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not create sock");
     na_sm_addr->sock = listen_sock;
 
     /* Add listen_sock to poll set */
     ret = na_sm_poll_register(na_class, NA_SM_ACCEPT, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add listen_sock to poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not add listen_sock to poll set");
 
-done:
+    return ret;
+
+error:
+    if (listen_sock != -1) {
+        na_sm_close_sock(listen_sock, pathname);
+        na_sm_addr->sock = -1;
+    }
+    if (na_sm_copy_buf) {
+        na_sm_close_shared_buf(filename, na_sm_copy_buf,
+            sizeof(struct na_sm_copy_buf));
+        na_sm_addr->na_sm_copy_buf = NULL;
+    }
     return ret;
 }
 
@@ -1404,11 +1434,8 @@ na_sm_send_addr_info(na_class_t *na_class, struct na_sm_addr *na_sm_addr)
     msg.msg_iovlen = 2;
 
     nsend = sendmsg(na_sm_addr->sock, &msg, 0);
-    if (nsend == -1) {
-        NA_LOG_ERROR("sendmsg() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(nsend == -1, done, ret, NA_PROTOCOL_ERROR,
+        "sendmsg() failed (%s)", strerror(errno));
 
 done:
     return ret;
@@ -1433,14 +1460,14 @@ na_sm_recv_addr_info(struct na_sm_addr *na_sm_addr, na_bool_t *received)
 
     nrecv = recvmsg(na_sm_addr->sock, &msg, 0);
     if (nrecv == -1) {
-        if (errno == EAGAIN) {
+        if (likely(errno == EAGAIN)) {
             *received = NA_FALSE;
             goto done;
-        }
-        NA_LOG_ERROR("recvmsg() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+        } else
+            NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR, "recvmsg() failed (%s)",
+                strerror(errno));
     }
+
     *received = NA_TRUE;
 
 done:
@@ -1485,11 +1512,8 @@ na_sm_send_conn_id(struct na_sm_addr *na_sm_addr)
     memcpy(fdptr, fds, sizeof(fds));
 
     nsend = sendmsg(na_sm_addr->sock, &msg, 0);
-    if (nsend == -1) {
-        NA_LOG_ERROR("sendmsg() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(nsend == -1, done, ret, NA_PROTOCOL_ERROR,
+        "sendmsg() failed (%s)", strerror(errno));
 
 done:
     return ret;
@@ -1525,23 +1549,20 @@ na_sm_recv_conn_id(struct na_sm_addr *na_sm_addr, na_bool_t *received)
 
     nrecv = recvmsg(na_sm_addr->sock, &msg, 0);
     if (nrecv == -1) {
-        if (errno == EAGAIN) {
+        if (likely(errno == EAGAIN)) {
             *received = NA_FALSE;
             goto done;
-        }
-        NA_LOG_ERROR("recvmsg() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+        } else
+            NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR, "recvmsg() failed (%s)",
+                strerror(errno));
     }
+
     *received = NA_TRUE;
 
     /* Retrieve ancillary data */
     cmsg = CMSG_FIRSTHDR(&msg);
-    if (cmsg == NULL) {
-        NA_LOG_ERROR("NULL cmsg");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(cmsg == NULL, done, ret, NA_PROTOCOL_ERROR, "NULL cmsg");
+
     fdptr = (int *) CMSG_DATA(cmsg);
     memcpy(fds, fdptr ,sizeof(fds));
     /* Invert descriptors so that local is remote and remote is local */
@@ -1572,13 +1593,10 @@ static NA_INLINE na_bool_t
 na_sm_ring_buf_push(struct na_sm_ring_buf *na_sm_ring_buf,
     na_sm_cacheline_hdr_t na_sm_hdr)
 {
-    na_bool_t ret = NA_TRUE;
+    int rc = hg_atomic_queue_push(&na_sm_ring_buf->queue,
+        (void *) na_sm_hdr.val);
 
-    if (hg_atomic_queue_push(&na_sm_ring_buf->queue,
-        (void *) na_sm_hdr.val) == HG_UTIL_FAIL)
-        ret = NA_FALSE;
-
-    return ret;
+    return (likely(rc == HG_UTIL_SUCCESS)) ? NA_TRUE : NA_FALSE;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1586,20 +1604,10 @@ static NA_INLINE na_bool_t
 na_sm_ring_buf_pop(struct na_sm_ring_buf *na_sm_ring_buf,
     na_sm_cacheline_hdr_t *na_sm_hdr_ptr)
 {
-    na_sm_cacheline_hdr_t na_sm_hdr;
-    na_bool_t ret = NA_TRUE;
-
-    na_sm_hdr.val = (na_uint64_t) hg_atomic_queue_pop_mc(&na_sm_ring_buf->queue);
-    if (!na_sm_hdr.val) {
-        /* Empty */
-        ret = NA_FALSE;
-        goto done;
-    }
-
-    *na_sm_hdr_ptr = na_sm_hdr;
+    na_sm_hdr_ptr->val = (na_uint64_t) hg_atomic_queue_pop_mc(
+        &na_sm_ring_buf->queue);
 
-done:
-    return ret;
+    return (likely(na_sm_hdr_ptr->val)) ? NA_TRUE : NA_FALSE;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1616,7 +1624,7 @@ na_sm_reserve_and_copy_buf(na_class_t *na_class,
     unsigned int *idx_reserved)
 {
     hg_util_int64_t bits = 1LL;
-    na_return_t ret = NA_SIZE_ERROR;
+    na_return_t ret = NA_AGAIN;
     unsigned int i = 0;
 
     hg_thread_spin_lock(&NA_SM_CLASS(na_class)->copy_buf_lock);
@@ -1624,9 +1632,10 @@ na_sm_reserve_and_copy_buf(na_class_t *na_class,
     do {
         hg_util_int64_t available = hg_atomic_get64(
             &na_sm_copy_buf->available.val);
-        if (!available)
+        if (!available) {
             /* Nothing available */
             break;
+        }
         if ((available & bits) != bits) {
             /* Already reserved */
             hg_atomic_fence();
@@ -1640,8 +1649,8 @@ na_sm_reserve_and_copy_buf(na_class_t *na_class,
             /* Reservation succeeded, copy buffer */
             memcpy(na_sm_copy_buf->buf[i], buf, buf_size);
             *idx_reserved = i;
-//            NA_LOG_DEBUG("Reserved %u is:\n%s", i,
-//                itoa(hg_atomic_get64(&na_sm_copy_buf->available.val), 2));
+            NA_LOG_DEBUG("Reserved bit index %u:\n%s", i, itoa((hg_util_uint64_t)
+                hg_atomic_get64(&na_sm_copy_buf->available.val), 2));
             ret = NA_SUCCESS;
             break;
         }
@@ -1650,6 +1659,7 @@ na_sm_reserve_and_copy_buf(na_class_t *na_class,
     } while (i < (NA_SM_NUM_BUFS - 1));
 
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->copy_buf_lock);
+
     return ret;
 }
 
@@ -1659,78 +1669,60 @@ na_sm_copy_and_free_buf(na_class_t *na_class,
     struct na_sm_copy_buf *na_sm_copy_buf, void *buf, size_t buf_size,
     unsigned int idx_reserved)
 {
-    hg_util_int64_t bits = 1LL << idx_reserved;
-#if defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
-    hg_util_int64_t available;
-#endif
-
     hg_thread_spin_lock(&NA_SM_CLASS(na_class)->copy_buf_lock);
-
     memcpy(buf, na_sm_copy_buf->buf[idx_reserved], buf_size);
-
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
-    hg_atomic_or64(&na_sm_copy_buf->available.val, bits);
-#else
-    do {
-        available = hg_atomic_get64(&na_sm_copy_buf->available.val);
-    } while (!hg_atomic_cas64(&na_sm_copy_buf->available.val, available,
-        (available | bits)));
-#endif
-
+    hg_atomic_or64(&na_sm_copy_buf->available.val, 1LL << idx_reserved);
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->copy_buf_lock);
 }
 
 /*---------------------------------------------------------------------------*/
+static NA_INLINE void
+na_sm_release_buf(struct na_sm_copy_buf *na_sm_copy_buf,
+    unsigned int idx_reserved)
+{
+    hg_atomic_or64(&na_sm_copy_buf->available.val, 1LL << idx_reserved);
+}
+
+/*---------------------------------------------------------------------------*/
 static na_return_t
 na_sm_msg_insert(na_class_t *na_class, struct na_sm_op_id *na_sm_op_id,
-    na_cb_type_t cb_type, struct na_sm_addr *na_sm_addr,
-    unsigned int idx_reserved, na_size_t buf_size, na_tag_t tag)
+    unsigned int idx_reserved)
 {
     na_sm_cacheline_hdr_t na_sm_hdr;
     na_return_t ret = NA_SUCCESS;
+    int rc;
 
     /* Post the SM send request */
-    na_sm_hdr.hdr.type = cb_type;
+    na_sm_hdr.hdr.type = na_sm_op_id->completion_data.callback_info.type;
     na_sm_hdr.hdr.buf_idx = idx_reserved & 0xff;
-    na_sm_hdr.hdr.buf_size = buf_size & 0xffff;
-    na_sm_hdr.hdr.tag = tag;
-    if (!na_sm_ring_buf_push(na_sm_addr->na_sm_send_ring_buf, na_sm_hdr)) {
-        NA_LOG_ERROR("Full ring buffer");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    /* Immediate completion, add directly to completion queue. */
-    ret = na_sm_complete(na_sm_op_id);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    na_sm_hdr.hdr.buf_size = na_sm_op_id->info.msg.buf_size & 0xffff;
+    na_sm_hdr.hdr.tag = na_sm_op_id->info.msg.tag;
+    rc = (int) na_sm_ring_buf_push(na_sm_op_id->na_sm_addr->na_sm_send_ring_buf,
+        na_sm_hdr);
+    NA_CHECK_ERROR(rc == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Full ring buffer");
 
-    /* Notify remote */
     if (!NA_SM_CLASS(na_class)->no_wait) {
+        /* Notify remote */
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
-        if (hg_event_set(na_sm_addr->remote_notify) != HG_UTIL_SUCCESS) {
-            NA_LOG_ERROR("Could not send completion notification");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_event_set(na_sm_op_id->na_sm_addr->remote_notify);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "Could not send completion notification");
 #else
-        if (na_sm_event_set(na_sm_addr->remote_notify) != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not send completion notification");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        ret = na_sm_event_set(na_sm_op_id->na_sm_addr->remote_notify);
+        NA_CHECK_NA_ERROR(done, ret, "Could not send completion notification");
 #endif
     }
 
-    /* Notify local completion */
-    if (!NA_SM_CLASS(na_class)->no_wait
-        && (hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify)
-        != HG_UTIL_SUCCESS)) {
-        NA_LOG_ERROR("Could not signal local completion");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+    /* Immediate completion, add directly to completion queue. */
+    ret = na_sm_complete(na_sm_op_id);
+    NA_CHECK_NA_ERROR(done, ret, "Could not complete operation");
+
+    if (!NA_SM_CLASS(na_class)->no_wait) {
+        /* Notify local completion */
+        rc = hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "Could not signal local completion");
     }
 
 done:
@@ -1781,74 +1773,59 @@ na_sm_progress_cb(void *arg, int error, hg_util_bool_t *progressed)
 {
     na_class_t *na_class;
     struct na_sm_poll_data *na_sm_poll_data = (struct na_sm_poll_data *) arg;
-    na_return_t na_ret;
+    na_return_t ret;
+
+    NA_CHECK_ERROR_NORET(na_sm_poll_data == NULL, error, "NULL SM poll data");
 
-    if (!na_sm_poll_data) {
-        NA_LOG_ERROR("NULL SM poll data");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
     na_class = na_sm_poll_data->na_class;
 
     if (error) {
-        na_ret = na_sm_progress_error(na_class, na_sm_poll_data->addr, error);
-        if (na_ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not process error");
-            goto done;
-        }
+        ret = na_sm_progress_error(na_class, na_sm_poll_data->addr);
+        NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, error,
+            "Could not process error");
     } else switch (na_sm_poll_data->type) {
         case NA_SM_ACCEPT:
-            na_ret = na_sm_progress_accept(na_class, na_sm_poll_data->addr,
+            ret = na_sm_progress_accept(na_class, na_sm_poll_data->addr,
                 (hg_util_bool_t *) progressed);
-            if (na_ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not make progress on accept");
-                goto done;
-            }
+            NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, error,
+                "Could not make progress on accept");
             break;
         case NA_SM_SOCK:
-            na_ret = na_sm_progress_sock(na_class, na_sm_poll_data->addr,
-                (hg_util_bool_t *) progressed);
-            if (na_ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not make progress on sock");
-                goto done;
+            if (na_sm_poll_data->addr != NA_SM_CLASS(na_class)->self_addr) {
+                ret = na_sm_progress_sock(na_class, na_sm_poll_data->addr,
+                    (hg_util_bool_t *) progressed);
+                NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, error,
+                    "Could not make progress on sock");
             }
             break;
         case NA_SM_NOTIFY:
-            na_ret = na_sm_progress_notify(na_class, na_sm_poll_data->addr,
+            ret = na_sm_progress_notify(na_class, na_sm_poll_data->addr,
                 (hg_util_bool_t *) progressed);
-            if (na_ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not make progress on notify");
-                goto done;
-            }
+            NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, error,
+                "Could not make progress on notify");
             break;
         default:
             NA_LOG_ERROR("Unknown poll data type");
-            na_ret = NA_PROTOCOL_ERROR;
-            goto done;
-            break;
+            goto error;
     }
 
-done:
-    return (na_ret == NA_SUCCESS) ? HG_UTIL_SUCCESS : HG_UTIL_FAIL;
+    return HG_UTIL_SUCCESS;
+
+error:
+    return HG_UTIL_FAIL;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_sm_progress_error(na_class_t *na_class, struct na_sm_addr *poll_addr,
-    int error)
+na_sm_progress_error(na_class_t *na_class, struct na_sm_addr *poll_addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (poll_addr == NA_SM_CLASS(na_class)->self_addr) {
-        NA_LOG_ERROR("Unsupported error occurred");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(poll_addr == NA_SM_CLASS(na_class)->self_addr,
+        done, ret, NA_PROTOCOL_ERROR, "Unsupported error occurred");
 
     /* Handle case of peer disconnection */
-    if (error) {
-        ret = na_sm_addr_free(na_class, poll_addr);
-    }
+    ret = na_sm_addr_free(na_class, poll_addr);
 
 done:
     return ret;
@@ -1866,12 +1843,12 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     hg_time_t now;
     double elapsed_ms;
     na_return_t ret = NA_SUCCESS;
+#ifndef SOCK_NONBLOCK
+    int rc;
+#endif
 
-    if (poll_addr != NA_SM_CLASS(na_class)->self_addr) {
-        NA_LOG_ERROR("Unrecognized poll addr");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(poll_addr != NA_SM_CLASS(na_class)->self_addr,
+        done, ret, NA_PROTOCOL_ERROR, "Unrecognized poll addr");
 
     /* Prevent from entering accept too often */
     hg_time_get_current(&now);
@@ -1889,29 +1866,24 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     conn_sock = accept(poll_addr->sock, NULL, NULL);
 #endif
     if (conn_sock == -1) {
-        if (errno == EAGAIN) {
+        if (likely(errno == EAGAIN)) {
             *progressed = NA_FALSE;
             goto done;
-        }
-        NA_LOG_ERROR("accept() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+        } else
+            NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR, "accept() failed (%s)",
+                strerror(errno));
     }
 #ifndef SOCK_NONBLOCK
-    if (fcntl(conn_sock, F_SETFL, O_NONBLOCK) == -1) {
-        NA_LOG_ERROR("fcntl() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    };
+    rc = fcntl(conn_sock, F_SETFL, O_NONBLOCK);
+    NA_CHECK_ERROR(rc == -1, done, ret, NA_PROTOCOL_ERROR,
+        "fcntl() failed (%s)", strerror(errno));
 #endif
 
     /* Allocate new addr and pass it to poll set */
     na_sm_addr = (struct na_sm_addr *) malloc(sizeof(struct na_sm_addr));
-    if (!na_sm_addr) {
-        NA_LOG_ERROR("Could not allocate NA SM addr");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_addr == NULL, done, ret, NA_NOMEM,
+        "Could not allocate NA SM addr");
+
     memset(na_sm_addr, 0, sizeof(struct na_sm_addr));
     hg_atomic_init32(&na_sm_addr->ref_count, 1);
     na_sm_addr->accepted = NA_TRUE;
@@ -1922,35 +1894,28 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
     /* Add conn_sock to poll set */
     ret = na_sm_poll_register(na_class, NA_SM_SOCK, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add conn_sock to poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not add conn_sock to poll set");
 
     /* Set up ring buffer pair (send/recv) for connection IDs */
     na_sm_addr->conn_id = NA_SM_CLASS(na_class)->self_addr->conn_id;
     NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(filename,
         NA_SM_RING_BUF_SIZE, NA_TRUE);
-    if (!na_sm_ring_buf) {
-        NA_LOG_ERROR("Could not open ring buf");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_ring_buf == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "Could not open ring buf");
+
     /* Initialize ring buffer */
     na_sm_ring_buf_init(na_sm_ring_buf);
     na_sm_addr->na_sm_send_ring_buf = na_sm_ring_buf;
 
     NA_SM_GEN_RING_NAME(filename, NA_SM_RECV_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(filename,
         NA_SM_RING_BUF_SIZE, NA_TRUE);
-    if (!na_sm_ring_buf) {
-        NA_LOG_ERROR("Could not open ring buf");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_ring_buf == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "Could not open ring buf");
+
     /* Initialize ring buffer */
     na_sm_ring_buf_init(na_sm_ring_buf);
     na_sm_addr->na_sm_recv_ring_buf = na_sm_ring_buf;
@@ -1958,11 +1923,8 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     /* Create local signal event */
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
     local_notify = hg_event_create();
-    if (local_notify == HG_UTIL_FAIL) {
-        NA_LOG_ERROR("hg_event_create() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(local_notify == -1, done, ret, NA_PROTOCOL_ERROR,
+        "hg_event_create() failed");
 #else
     /**
      * If eventfd is not supported, we need to explicitly use named pipes in
@@ -1970,24 +1932,18 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
      * ancillary data
      */
     NA_SM_GEN_FIFO_NAME(filename, NA_SM_RECV_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     local_notify = na_sm_event_create(filename);
-    if (local_notify == -1) {
-        NA_LOG_ERROR("na_sm_event_create() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(local_notify == -1, done, ret, NA_PROTOCOL_ERROR,
+        "na_sm_event_create() failed");
 #endif
     na_sm_addr->local_notify = local_notify;
 
     /* Create remote signal event */
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
     remote_notify = hg_event_create();
-    if (remote_notify == HG_UTIL_FAIL) {
-        NA_LOG_ERROR("hg_event_create() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(remote_notify == -1, done, ret, NA_PROTOCOL_ERROR,
+        "hg_event_create() failed");
 #else
     /**
      * If eventfd is not supported, we need to explicitly use named pipes in
@@ -1995,29 +1951,20 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
      * ancillary data
      */
     NA_SM_GEN_FIFO_NAME(filename, NA_SM_SEND_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     remote_notify = na_sm_event_create(filename);
-    if (remote_notify == -1) {
-        NA_LOG_ERROR("na_sm_event_create() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(remote_notify == -1, done, ret, NA_PROTOCOL_ERROR,
+        "na_sm_event_create() failed");
 #endif
     na_sm_addr->remote_notify = remote_notify;
 
     /* Add local notify to poll set */
     ret = na_sm_poll_register(na_class, NA_SM_NOTIFY, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add notify to poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not add notify to poll set");
 
     /* Send connection ID / event IDs */
     ret = na_sm_send_conn_id(na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not send connection ID");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not send connection ID");
 
     /* Increment connection ID */
     NA_SM_CLASS(na_class)->self_addr->conn_id++;
@@ -2032,6 +1979,10 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
 done:
     return ret;
+
+//error:
+// TODO
+//    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2041,10 +1992,8 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (poll_addr == NA_SM_CLASS(na_class)->self_addr) {
-        *progressed = NA_FALSE;
-        goto done;
-    }
+    NA_CHECK_ERROR(poll_addr == NA_SM_CLASS(na_class)->self_addr,
+        done, ret, NA_PROTOCOL_ERROR, "Unrecognized poll addr");
 
     switch (poll_addr->sock_progress) {
         case NA_SM_ADDR_INFO: {
@@ -2052,11 +2001,7 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
             /* Receive addr info (PID / ID) */
             ret = na_sm_recv_addr_info(poll_addr, &received);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not recv addr info");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_NA_ERROR(done, ret, "Could not recv addr info");
             if (!received) {
                 *progressed = NA_FALSE;
                 goto done;
@@ -2082,11 +2027,7 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
             /* Receive connection ID / event IDs */
             ret = na_sm_recv_conn_id(poll_addr, &received);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not recv connection ID");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_NA_ERROR(done, ret, "Could not recv connection ID");
             if (!received) {
                 *progressed = NA_FALSE;
                 goto done;
@@ -2097,7 +2038,7 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
             hg_thread_spin_lock(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
             HG_QUEUE_FOREACH(na_sm_op_id,
                 &NA_SM_CLASS(na_class)->lookup_op_queue, entry) {
-                if (na_sm_op_id->info.lookup.na_sm_addr == poll_addr) {
+                if (na_sm_op_id->na_sm_addr == poll_addr) {
                     HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->lookup_op_queue,
                         na_sm_op_id, na_sm_op_id, entry);
                     break;
@@ -2105,41 +2046,31 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
             }
             hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
 
-            if (!na_sm_op_id) {
-                NA_LOG_ERROR("Could not find lookup op ID, conn ID=%u, PID=%u",
-                    poll_addr->conn_id, (unsigned int) poll_addr->pid);
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_ERROR(na_sm_op_id == NULL, done, ret, NA_PROTOCOL_ERROR,
+                "Could not find lookup op ID, conn ID=%u, PID=%u",
+                poll_addr->conn_id, (unsigned int) poll_addr->pid);
 
             /* Open remote ring buf pair (send and recv names correspond to
              * remote ring buffer pair) */
-            NA_SM_GEN_RING_NAME(filename, NA_SM_RECV_NAME, poll_addr);
+            NA_SM_GEN_RING_NAME(filename, NA_SM_RECV_NAME,
+                NA_SM_CLASS(na_class)->username, poll_addr);
             na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(
                 filename, NA_SM_RING_BUF_SIZE, NA_FALSE);
-            if (!na_sm_ring_buf) {
-                NA_LOG_ERROR("Could not open ring buf");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_ERROR(na_sm_ring_buf == NULL, done, ret, NA_PROTOCOL_ERROR,
+                "Could not open ring buf");
             poll_addr->na_sm_send_ring_buf = na_sm_ring_buf;
 
-            NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME, poll_addr);
+            NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME,
+                NA_SM_CLASS(na_class)->username, poll_addr);
             na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(
                 filename, NA_SM_RING_BUF_SIZE, NA_FALSE);
-            if (!na_sm_ring_buf) {
-                NA_LOG_ERROR("Could not open ring buf");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_ERROR(na_sm_ring_buf == NULL, done, ret, NA_PROTOCOL_ERROR,
+                "Could not open ring buf");
             poll_addr->na_sm_recv_ring_buf = na_sm_ring_buf;
 
             /* Add received local notify to poll set */
             ret = na_sm_poll_register(na_class, NA_SM_NOTIFY, poll_addr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not add notify to poll set");
-                goto done;
-            }
+            NA_CHECK_NA_ERROR(done, ret, "Could not add notify to poll set");
 
             /* Add addr to poll addr queue */
             hg_thread_spin_lock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
@@ -2149,10 +2080,7 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
             /* Completion */
             ret = na_sm_complete(na_sm_op_id);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not complete operation");
-                goto done;
-            }
+            NA_CHECK_NA_ERROR(done, ret, "Could not complete operation");
 
             /* Progressed */
             *progressed = NA_TRUE;
@@ -2166,6 +2094,10 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
 done:
     return ret;
+
+//error:
+// TODO
+//    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2174,42 +2106,33 @@ na_sm_progress_notify(na_class_t *na_class, struct na_sm_addr *poll_addr,
     na_bool_t *progressed)
 {
     na_sm_cacheline_hdr_t na_sm_hdr;
-    na_bool_t notified = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
+    int rc;
 
     if (poll_addr == NA_SM_CLASS(na_class)->self_addr) {
         /* Local notification */
-        if (!NA_SM_CLASS(na_class)->no_wait
-            && (hg_event_get(poll_addr->local_notify, (hg_util_bool_t *) &notified)
-            != HG_UTIL_SUCCESS)) {
-            NA_LOG_ERROR("Could not get completion notification");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
-
-        if (!notified) {
+        if (!NA_SM_CLASS(na_class)->no_wait) {
+            rc = hg_event_get(poll_addr->local_notify,
+                (hg_util_bool_t *) progressed);
+            NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+                "Could not get completion notification");
+        } else
             *progressed = NA_FALSE;
-            goto done;
-        }
-        *progressed = NA_TRUE;
         goto done;
     }
 
     /* Remote notification */
     if (!NA_SM_CLASS(na_class)->no_wait) {
+        na_bool_t notified = NA_FALSE;
+
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
-        if (hg_event_get(poll_addr->local_notify, (hg_util_bool_t *) &notified)
-            != HG_UTIL_SUCCESS) {
-            NA_LOG_ERROR("Could not get completion notification");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_event_get(poll_addr->local_notify,
+            (hg_util_bool_t *) &notified);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "Could not get completion notification");
 #else
-        if (na_sm_event_get(poll_addr->local_notify, &notified) != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not get completion notification");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        ret = na_sm_event_get(poll_addr->local_notify, &notified);
+        NA_CHECK_NA_ERROR(done, ret, "Could not get completion notification");
 #endif
         if (!notified) {
             *progressed = NA_FALSE;
@@ -2222,24 +2145,29 @@ na_sm_progress_notify(na_class_t *na_class, struct na_sm_addr *poll_addr,
         goto done;
     }
 
+    /* Progress expected and unexpected messages */
     switch (na_sm_hdr.hdr.type) {
-        case NA_CB_RECV_UNEXPECTED:
+        case NA_CB_SEND_UNEXPECTED:
             ret = na_sm_progress_unexpected(na_class, poll_addr, na_sm_hdr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not make progress on unexpected msg");
-            }
+            NA_CHECK_NA_ERROR(done, ret,
+                "Could not make progress on unexpected msg");
             break;
-        case NA_CB_RECV_EXPECTED:
+        case NA_CB_SEND_EXPECTED:
             ret = na_sm_progress_expected(na_class, poll_addr, na_sm_hdr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not make progress on expected msg");
-            }
+            NA_CHECK_NA_ERROR(done, ret,
+                "Could not make progress on expected msg");
             break;
         default:
-            NA_LOG_ERROR("Unknown type of operation");
-            ret = NA_PROTOCOL_ERROR;
-            break;
+            NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR,
+                "Unknown type of operation");
+    }
+
+    /* Progress retries */
+    if (!NA_SM_CLASS(na_class)->no_retry) {
+        ret = na_sm_progress_retries(na_class);
+        NA_CHECK_NA_ERROR(done, ret, "Could not make progress on retried msgs");
     }
+
     *progressed = NA_TRUE;
 
 done:
@@ -2251,7 +2179,6 @@ static na_return_t
 na_sm_progress_unexpected(na_class_t *na_class, struct na_sm_addr *poll_addr,
     na_sm_cacheline_hdr_t na_sm_hdr)
 {
-    struct na_sm_unexpected_info *na_sm_unexpected_info = NULL;
     struct na_sm_op_id *na_sm_op_id = NULL;
     na_return_t ret = NA_SUCCESS;
 
@@ -2259,31 +2186,48 @@ na_sm_progress_unexpected(na_class_t *na_class, struct na_sm_addr *poll_addr,
     hg_thread_spin_lock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
     na_sm_op_id = HG_QUEUE_FIRST(&NA_SM_CLASS(na_class)->unexpected_op_queue);
     HG_QUEUE_POP_HEAD(&NA_SM_CLASS(na_class)->unexpected_op_queue, entry);
+    hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
 
-    if (na_sm_op_id) {
-        /* If an op id was pushed, associate unexpected info to this
-         * operation ID and complete operation */
-        na_sm_op_id->info.recv_unexpected.unexpected_info.na_sm_addr = poll_addr;
-        na_sm_op_id->info.recv_unexpected.unexpected_info.na_sm_hdr = na_sm_hdr;
+    if (likely(na_sm_op_id)) {
+        /* Fill info */
+        na_sm_op_id->na_sm_addr = poll_addr;
+        hg_atomic_incr32(&na_sm_op_id->na_sm_addr->ref_count);
+        na_sm_op_id->info.msg.actual_buf_size =
+            (na_size_t) na_sm_hdr.hdr.buf_size;
+        na_sm_op_id->info.msg.tag = (na_tag_t) na_sm_hdr.hdr.tag;
 
+        /* Copy and free buffer atomically */
+        na_sm_copy_and_free_buf(na_class, poll_addr->na_sm_copy_buf,
+            na_sm_op_id->info.msg.buf.ptr, na_sm_hdr.hdr.buf_size,
+            na_sm_hdr.hdr.buf_idx);
+
+        /* Complete operation */
         ret = na_sm_complete(na_sm_op_id);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not complete operation");
     } else {
+        struct na_sm_unexpected_info *na_sm_unexpected_info = NULL;
+
         /* If no error and message arrived, keep a copy of the struct in
          * the unexpected message queue (should rarely happen) */
         na_sm_unexpected_info = (struct na_sm_unexpected_info *) malloc(
             sizeof(struct na_sm_unexpected_info));
-        if (!na_sm_unexpected_info) {
-            NA_LOG_ERROR("Could not allocate unexpected info");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_sm_unexpected_info == NULL, done, ret, NA_NOMEM,
+            "Could not allocate unexpected info");
+
         na_sm_unexpected_info->na_sm_addr = poll_addr;
-        na_sm_unexpected_info->na_sm_hdr = na_sm_hdr;
+        na_sm_unexpected_info->buf_size = (na_size_t) na_sm_hdr.hdr.buf_size;
+        na_sm_unexpected_info->tag = (na_tag_t) na_sm_hdr.hdr.tag;
+
+        /* Allocate buf */
+        na_sm_unexpected_info->buf = malloc(na_sm_unexpected_info->buf_size);
+        NA_CHECK_ERROR(na_sm_unexpected_info->buf == NULL, done, ret, NA_NOMEM,
+            "Could not allocate na_sm_unexpected_info buf");
+
+        /* Copy and free buffer atomically */
+        na_sm_copy_and_free_buf(na_class, poll_addr->na_sm_copy_buf,
+            na_sm_unexpected_info->buf, na_sm_hdr.hdr.buf_size,
+            na_sm_hdr.hdr.buf_idx);
 
         /* Otherwise push the unexpected message into our unexpected queue so
          * that we can treat it later when a recv_unexpected is posted */
@@ -2310,34 +2254,31 @@ na_sm_progress_expected(na_class_t *na_class, struct na_sm_addr *poll_addr,
         &NA_SM_CLASS(na_class)->expected_op_queue_lock);
     HG_QUEUE_FOREACH(na_sm_op_id,
         &NA_SM_CLASS(na_class)->expected_op_queue, entry) {
-        if (na_sm_op_id->info.recv_expected.na_sm_addr == poll_addr &&
-            na_sm_op_id->info.recv_expected.tag == na_sm_hdr.hdr.tag) {
+        if (na_sm_op_id->na_sm_addr == poll_addr
+            && na_sm_op_id->info.msg.tag == na_sm_hdr.hdr.tag) {
             HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->expected_op_queue,
                 na_sm_op_id, na_sm_op_id, entry);
+            hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
             break;
         }
     }
     hg_thread_spin_unlock(
         &NA_SM_CLASS(na_class)->expected_op_queue_lock);
 
-    if (!na_sm_op_id) {
-        /* No match if either the message was not pre-posted or it was canceled */
-        NA_LOG_WARNING("Ignored expected message received (canceled?)");
-//        NA_LOG_DEBUG("Expected: pid=%d, tag=%d", poll_addr->pid,
-//            na_sm_hdr.hdr.tag);
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_op_id == NULL, done, ret, NA_INVALID_ARG,
+        "Invalid operation ID");
+    /* Cannot have an already completed operation ID, TODO add sanity check */
+
+    na_sm_op_id->info.msg.actual_buf_size = na_sm_hdr.hdr.buf_size;
 
     /* Copy and free buffer atomically */
     na_sm_copy_and_free_buf(na_class, poll_addr->na_sm_copy_buf,
-        na_sm_op_id->info.recv_expected.buf, na_sm_hdr.hdr.buf_size,
+        na_sm_op_id->info.msg.buf.ptr, na_sm_hdr.hdr.buf_size,
         na_sm_hdr.hdr.buf_idx);
 
+    /* Complete operation */
     ret = na_sm_complete(na_sm_op_id);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not complete operation");
 
 done:
     return ret;
@@ -2345,12 +2286,77 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
+na_sm_progress_retries(na_class_t *na_class)
+{
+    struct na_sm_op_id *na_sm_op_id = NULL;
+    unsigned int idx_reserved;
+    na_return_t ret = NA_SUCCESS;
+
+    do {
+        na_bool_t canceled = NA_FALSE;
+
+        hg_thread_spin_lock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+        na_sm_op_id = HG_QUEUE_FIRST(&NA_SM_CLASS(na_class)->retry_op_queue);
+        hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+
+        if (!na_sm_op_id)
+            break;
+
+        NA_LOG_DEBUG("Attempting to retry %p", na_sm_op_id);
+
+        /* Try to reserve buffer atomically */
+        if (na_sm_reserve_and_copy_buf(na_class,
+            na_sm_op_id->na_sm_addr->na_sm_copy_buf,
+            na_sm_op_id->info.msg.buf.const_ptr,
+            na_sm_op_id->info.msg.buf_size, &idx_reserved) == NA_AGAIN)
+            break;
+
+        /* Successfully reserved a buffer */
+        hg_thread_spin_lock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+        if ((hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_CANCELED)) {
+            canceled = NA_TRUE;
+            na_sm_release_buf(na_sm_op_id->na_sm_addr->na_sm_copy_buf,
+                idx_reserved);
+        } else {
+            HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->retry_op_queue,
+                na_sm_op_id, na_sm_op_id, entry);
+            hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
+        }
+        hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+
+        if (!canceled) {
+            /* Insert message into ring buffer (complete OP ID) */
+            ret = na_sm_msg_insert(na_class, na_sm_op_id, idx_reserved);
+            NA_CHECK_NA_ERROR(error, ret, "Could not insert message");
+        }
+    } while (1);
+
+    return ret;
+
+error:
+    na_sm_release_buf(na_sm_op_id->na_sm_addr->na_sm_copy_buf, idx_reserved);
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
 na_sm_complete(struct na_sm_op_id *na_sm_op_id)
 {
     struct na_cb_info *callback_info = NULL;
-    na_bool_t canceled = (na_bool_t) hg_atomic_get32(&na_sm_op_id->canceled);
+    na_bool_t canceled = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
 
+    /* Mark op id as completed before checking for cancelation */
+    if (hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_COMPLETED)
+        & NA_SM_OP_CANCELED) {
+        /* If it was canceled while being processed, set callback ret accordingly */
+        NA_LOG_DEBUG("Operation ID %p was canceled", na_sm_op_id);
+        canceled = NA_TRUE;
+    }
+
     /* Init callback info */
     callback_info = &na_sm_op_id->completion_data.callback_info;
     callback_info->ret = (canceled) ? NA_CANCELED : ret;
@@ -2358,42 +2364,29 @@ na_sm_complete(struct na_sm_op_id *na_sm_op_id)
     switch (callback_info->type) {
         case NA_CB_LOOKUP:
             callback_info->info.lookup.addr =
-                (na_addr_t) na_sm_op_id->info.lookup.na_sm_addr;
+                (na_addr_t) na_sm_op_id->na_sm_addr;
             break;
         case NA_CB_SEND_UNEXPECTED:
             break;
-        case NA_CB_RECV_UNEXPECTED: {
-            struct na_sm_unexpected_info *na_sm_unexpected_info =
-                &na_sm_op_id->info.recv_unexpected.unexpected_info;
-            struct na_sm_copy_buf *na_sm_copy_buf;
-
+        case NA_CB_RECV_UNEXPECTED:
             if (canceled) {
                 /* In case of cancellation where no recv'd data */
                 callback_info->info.recv_unexpected.actual_buf_size = 0;
                 callback_info->info.recv_unexpected.source = NA_ADDR_NULL;
                 callback_info->info.recv_unexpected.tag = 0;
-                break;
+            } else {
+                /* Increment addr ref count */
+                hg_atomic_incr32(&na_sm_op_id->na_sm_addr->ref_count);
+
+                /* Fill callback info */
+                callback_info->info.recv_unexpected.actual_buf_size =
+                    na_sm_op_id->info.msg.actual_buf_size;
+                callback_info->info.recv_unexpected.source =
+                    (na_addr_t) na_sm_op_id->na_sm_addr;
+                callback_info->info.recv_unexpected.tag =
+                    na_sm_op_id->info.msg.tag;
             }
-
-            /* Increment addr ref count */
-            hg_atomic_incr32(&na_sm_unexpected_info->na_sm_addr->ref_count);
-
-            /* Fill callback info */
-            callback_info->info.recv_unexpected.actual_buf_size =
-                (na_size_t) na_sm_unexpected_info->na_sm_hdr.hdr.buf_size;
-            callback_info->info.recv_unexpected.source =
-                (na_addr_t) na_sm_unexpected_info->na_sm_addr;
-            callback_info->info.recv_unexpected.tag =
-                (na_tag_t) na_sm_unexpected_info->na_sm_hdr.hdr.tag;
-
-            /* Copy and free buffer atomically */
-            na_sm_copy_buf = na_sm_unexpected_info->na_sm_addr->na_sm_copy_buf;
-            na_sm_copy_and_free_buf(na_sm_op_id->na_class, na_sm_copy_buf,
-                na_sm_op_id->info.recv_unexpected.buf,
-                na_sm_unexpected_info->na_sm_hdr.hdr.buf_size,
-                na_sm_unexpected_info->na_sm_hdr.hdr.buf_idx);
             break;
-        }
         case NA_CB_SEND_EXPECTED:
             break;
         case NA_CB_RECV_EXPECTED:
@@ -2403,20 +2396,14 @@ na_sm_complete(struct na_sm_op_id *na_sm_op_id)
         case NA_CB_GET:
             break;
         default:
-            NA_LOG_ERROR("Operation not supported");
-            ret = NA_INVALID_PARAM;
-            break;
+            NA_GOTO_ERROR(done, ret, NA_INVALID_ARG,
+                "Operation type %d not supported", callback_info->type);
     }
 
-    /* Mark op id as completed */
-    hg_atomic_set32(&na_sm_op_id->completed, NA_TRUE);
-
+    /* Add OP to NA completion queue */
     ret = na_cb_completion_add(na_sm_op_id->context,
         &na_sm_op_id->completion_data);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add callback to completion queue");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not add callback to completion queue");
 
 done:
     return ret;
@@ -2428,13 +2415,21 @@ na_sm_release(void *arg)
 {
     struct na_sm_op_id *na_sm_op_id = (struct na_sm_op_id *) arg;
 
-    if (na_sm_op_id && !hg_atomic_get32(&na_sm_op_id->completed)) {
-        NA_LOG_ERROR("Releasing resources from an uncompleted operation");
+    NA_CHECK_WARNING(na_sm_op_id
+        && (!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED)),
+        "Releasing resources from an uncompleted operation");
+
+    if (na_sm_op_id->na_sm_addr) {
+        na_sm_addr_free(na_sm_op_id->na_class, na_sm_op_id->na_sm_addr);
+        na_sm_op_id->na_sm_addr = NULL;
     }
-    na_sm_op_destroy(NULL, na_sm_op_id);
+    na_sm_op_destroy(na_sm_op_id->na_class, na_sm_op_id);
 }
 
-/*---------------------------------------------------------------------------*/
+/********************/
+/* Plugin callbacks */
+/********************/
+
 static na_bool_t
 na_sm_check_protocol(const char *protocol_name)
 {
@@ -2454,8 +2449,9 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     static hg_atomic_int32_t id = HG_ATOMIC_VAR_INIT(0);
     struct na_sm_addr *na_sm_addr = NULL;
     pid_t pid;
+    char *username = NULL;
     hg_poll_set_t *poll_set;
-    na_bool_t no_wait = NA_FALSE;
+    na_bool_t no_wait = NA_FALSE, no_retry = NA_FALSE;
     int local_notify;
     na_return_t ret = NA_SUCCESS;
 
@@ -2464,42 +2460,46 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     /* Get init info */
     if (na_info->na_init_info) {
         /* Progress mode */
-        if (na_info->na_init_info->progress_mode == NA_NO_BLOCK)
+        if (na_info->na_init_info->progress_mode & NA_NO_BLOCK)
             no_wait = NA_TRUE;
+        if (na_info->na_init_info->progress_mode & NA_NO_RETRY)
+            no_retry = NA_TRUE;
     }
 
     /* Get PID */
     pid = getpid();
 
+    /* Get username */
+    username = getlogin_safe();
+    NA_CHECK_ERROR(username == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "Could not query login name");
+
     /* Initialize errno */
     errno = 0;
 
     /* Initialize private data */
     na_class->plugin_class = malloc(sizeof(struct na_sm_class));
-    if (!na_class->plugin_class) {
-        NA_LOG_ERROR("Could not allocate NA private data class");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class->plugin_class == NULL, done, ret, NA_NOMEM,
+        "Could not allocate NA private data class");
     memset(na_class->plugin_class, 0, sizeof(struct na_sm_class));
     NA_SM_CLASS(na_class)->no_wait = no_wait;
+    NA_SM_CLASS(na_class)->no_retry = no_retry;
+
+    /* Copy username */
+    NA_SM_CLASS(na_class)->username = strdup(username);
+    NA_CHECK_ERROR(NA_SM_CLASS(na_class)->username == NULL, done, ret, NA_NOMEM,
+        "Could not dup username");
 
     /* Create poll set to wait for events */
     poll_set = hg_poll_create();
-    if (!poll_set) {
-        NA_LOG_ERROR("cannot create poll set");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(poll_set == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "Cannot create poll set");
     NA_SM_CLASS(na_class)->poll_set = poll_set;
 
     /* Create self addr */
     na_sm_addr = (struct na_sm_addr *) malloc(sizeof(struct na_sm_addr));
-    if (!na_sm_addr) {
-        NA_LOG_ERROR("Could not allocate NA SM addr");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_addr == NULL, done, ret, NA_NOMEM,
+        "Could not allocate NA SM addr");
     memset(na_sm_addr, 0, sizeof(struct na_sm_addr));
     na_sm_addr->pid = pid;
     na_sm_addr->id = (unsigned int) hg_atomic_incr32(&id) - 1;
@@ -2508,26 +2508,17 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     /* If we're listening, create a new shm region */
     if (listen) {
         ret = na_sm_setup_shm(na_class, na_sm_addr);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not setup shm");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not setup shm");
     }
     /* Create local signal event on self address */
     local_notify = hg_event_create();
-    if (local_notify == HG_UTIL_FAIL) {
-        NA_LOG_ERROR("hg_event_create() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(local_notify == -1, done, ret, NA_PROTOCOL_ERROR,
+        "hg_event_create() failed");
     na_sm_addr->local_notify = local_notify;
 
     /* Add local notify to poll set */
     ret = na_sm_poll_register(na_class, NA_SM_NOTIFY, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add notify to poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not add notify to poll set");
     NA_SM_CLASS(na_class)->self_addr = na_sm_addr;
 
     /* Initialize queues */
@@ -2537,6 +2528,7 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->lookup_op_queue);
     HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->unexpected_op_queue);
     HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->expected_op_queue);
+    HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->retry_op_queue);
 
     /* Initialize mutexes */
     hg_thread_spin_init(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
@@ -2545,10 +2537,15 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     hg_thread_spin_init(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
     hg_thread_spin_init(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
     hg_thread_spin_init(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
+    hg_thread_spin_init(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
     hg_thread_spin_init(&NA_SM_CLASS(na_class)->copy_buf_lock);
 
 done:
     return ret;
+
+//error:
+// TODO
+//    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2556,63 +2553,53 @@ static na_return_t
 na_sm_finalize(na_class_t *na_class)
 {
     na_return_t ret = NA_SUCCESS;
+    na_bool_t empty;
+    int rc;
 
-    if (!na_class->plugin_class) {
+    if (!na_class->plugin_class)
         goto done;
-    }
 
     /* Check that lookup op queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->lookup_op_queue)) {
-        NA_LOG_ERROR("Lookup op queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->lookup_op_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Lookup op queue should be empty");
 
     /* Check that unexpected op queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->unexpected_op_queue)) {
-        NA_LOG_ERROR("Unexpected op queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->unexpected_op_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Unexpected op queue should be empty");
 
     /* Check that unexpected message queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->unexpected_msg_queue)) {
-        NA_LOG_ERROR("Unexpected msg queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->unexpected_msg_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Unexpected msg queue should be empty");
 
     /* Check that expected op queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->expected_op_queue)) {
-        NA_LOG_ERROR("Expected op queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->expected_op_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Expected op queue should be empty");
+
+    /* Check that retry op queue is empty */
+    empty = HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->retry_op_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Retry op queue should be empty");
 
     /* Check that accepted addr queue is empty */
     while (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->accepted_addr_queue)) {
         struct na_sm_addr *na_sm_addr = HG_QUEUE_FIRST(
             &NA_SM_CLASS(na_class)->accepted_addr_queue);
         ret = na_sm_addr_free(na_class, na_sm_addr);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not free accepted addr");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not free accepted addr");
     }
 
     /* Free self addr */
     ret = na_sm_addr_free(na_class, NA_SM_CLASS(na_class)->self_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not free self addr");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not free self addr");
 
     /* Close poll set */
-    if (hg_poll_destroy(NA_SM_CLASS(na_class)->poll_set) != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_poll_destroy() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_poll_destroy(NA_SM_CLASS(na_class)->poll_set);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+        "hg_poll_destroy() failed");
 
     /* Destroy mutexes */
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
@@ -2621,8 +2608,10 @@ na_sm_finalize(na_class_t *na_class)
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
+    hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->copy_buf_lock);
 
+    free(NA_SM_CLASS(na_class)->username);
     free(na_class->plugin_class);
 
 done:
@@ -2633,21 +2622,24 @@ done:
 static void
 na_sm_cleanup(void)
 {
+    char pathname[NA_SM_MAX_FILENAME] = {'\0'};
+    char *username = getlogin_safe();
     int ret;
 
+    sprintf(pathname, "%s/%s_%s", NA_SM_TMP_DIRECTORY,
+        NA_SM_SHM_PREFIX, username);
+
     /* We need to remove all files first before being able to remove the
      * directories */
-    ret = nftw(NA_SM_SOCK_PATH, na_sm_cleanup_file, NA_SM_CLEANUP_NFDS,
+    ret = nftw(pathname, na_sm_cleanup_file, NA_SM_CLEANUP_NFDS,
         FTW_PHYS | FTW_DEPTH);
-    if (ret != 0 && errno != ENOENT) {
-        NA_LOG_WARNING("nftw() failed (%s)", strerror(errno));
-    }
+    NA_CHECK_WARNING(ret != 0 && errno != ENOENT, "nftw() failed (%s)",
+        strerror(errno));
 
     ret = nftw(NA_SM_SHM_PATH, na_sm_cleanup_shm, NA_SM_CLEANUP_NFDS,
         FTW_PHYS);
-    if (ret != 0 && errno != ENOENT) {
-        NA_LOG_WARNING("nftw() failed (%s)", strerror(errno));
-    }
+    NA_CHECK_WARNING(ret != 0 && errno != ENOENT, "nftw() failed (%s)",
+        strerror(errno));
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2657,14 +2649,13 @@ na_sm_op_create(na_class_t *na_class)
     struct na_sm_op_id *na_sm_op_id = NULL;
 
     na_sm_op_id = (struct na_sm_op_id *) malloc(sizeof(struct na_sm_op_id));
-    if (!na_sm_op_id) {
-        NA_LOG_ERROR("Could not allocate NA SM operation ID");
-        goto done;
-    }
+    NA_CHECK_ERROR_NORET(na_sm_op_id == NULL, done,
+        "Could not allocate NA SM operation ID");
     memset(na_sm_op_id, 0, sizeof(struct na_sm_op_id));
     na_sm_op_id->na_class = na_class;
     hg_atomic_init32(&na_sm_op_id->ref_count, 1);
-    hg_atomic_init32(&na_sm_op_id->completed, NA_TRUE); /* Completed by default */
+    /* Completed by default */
+    hg_atomic_init32(&na_sm_op_id->status, NA_SM_OP_COMPLETED);
 
     /* Set op ID release callbacks */
     na_sm_op_id->completion_data.plugin_callback = na_sm_release;
@@ -2705,48 +2696,42 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
     char *name_string = NULL, *short_name = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_LOOKUP;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
+    na_sm_op_id->na_sm_addr = NULL;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
 
     /* Allocate addr */
     na_sm_addr = (struct na_sm_addr *) malloc(sizeof(struct na_sm_addr));
-    if (!na_sm_addr) {
-        NA_LOG_ERROR("Could not allocate NA SM addr");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_addr == NULL, done, ret, NA_NOMEM,
+        "Could not allocate NA SM addr");
     memset(na_sm_addr, 0, sizeof(struct na_sm_addr));
-    hg_atomic_init32(&na_sm_addr->ref_count, 1);
-    na_sm_op_id->info.lookup.na_sm_addr = na_sm_addr;
+    hg_atomic_init32(&na_sm_addr->ref_count, 2); /* Extra refcount */
+
+    na_sm_op_id->na_sm_addr = na_sm_addr;
 
     /**
      * Clean up name, strings can be of the format:
      *   <protocol>://<host string>
      */
     name_string = strdup(name);
-    if (!name_string) {
-        NA_LOG_ERROR("Could not duplicate string");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM,
+        "Could not duplicate string");
+
     if (strstr(name_string, ":") != NULL) {
          strtok_r(name_string, ":", &short_name);
          short_name += 2;
@@ -2757,23 +2742,17 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
     sscanf(short_name, "%d/%u", &na_sm_addr->pid, &na_sm_addr->id);
 
     /* Open shared copy buf */
-    NA_SM_GEN_SHM_NAME(filename, na_sm_addr);
+    NA_SM_GEN_SHM_NAME(filename, NA_SM_CLASS(na_class)->username, na_sm_addr);
     na_sm_copy_buf = (struct na_sm_copy_buf *) na_sm_open_shared_buf(
         filename, sizeof(struct na_sm_copy_buf), NA_FALSE);
-    if (!na_sm_copy_buf) {
-        NA_LOG_ERROR("Could not open copy buf");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_copy_buf == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "Could not open copy buffer");
     na_sm_addr->na_sm_copy_buf = na_sm_copy_buf;
 
     /* Open SHM sock */
-    NA_SM_GEN_SOCK_PATH(pathname, na_sm_addr);
+    NA_SM_GEN_SOCK_PATH(pathname, NA_SM_CLASS(na_class)->username, na_sm_addr);
     ret = na_sm_create_sock(pathname, NA_FALSE, &conn_sock);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not create sock");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not create sock");
     na_sm_addr->sock = conn_sock;
     /* We only need to receive conn ID in sock progress */
     na_sm_addr->sock_progress = NA_SM_CONN_ID;
@@ -2784,30 +2763,17 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
         entry);
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
-
     /* Add conn_sock to poll set */
     ret = na_sm_poll_register(na_class, NA_SM_SOCK, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add conn_sock to poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not add conn_sock to poll set");
 
     /* Send addr info (PID / ID) */
     ret = na_sm_send_addr_info(na_class, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not send addr info");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not send addr info");
 
 done:
-    if (ret != NA_SUCCESS) {
-        free(na_sm_addr);
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
     free(name_string);
+
     return ret;
 }
 
@@ -2823,17 +2789,14 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
         na_sm_recv_ring_buf_name[NA_SM_MAX_FILENAME],
         na_sock_name[NA_SM_MAX_FILENAME];
     na_return_t ret = NA_SUCCESS;
+    int rc;
 
-    if (!na_sm_addr) {
-        NA_LOG_ERROR("NULL SM addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL SM addr");
 
-    if (hg_atomic_decr32(&na_sm_addr->ref_count)) {
+    if (hg_atomic_decr32(&na_sm_addr->ref_count))
         /* Cannot free yet */
         goto done;
-    }
 
     if (na_sm_addr->accepted) { /* Created by accept */
         hg_thread_spin_lock(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
@@ -2845,20 +2808,16 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 
     /* Deregister event file descriptors from poll set */
     ret = na_sm_poll_deregister(na_class, NA_SM_NOTIFY, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not delete notify from poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not delete notify from poll set");
 
     /* Destroy local event */
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
-    if (hg_event_destroy(na_sm_addr->local_notify) == HG_UTIL_FAIL) {
-        NA_LOG_ERROR("hg_event_destroy() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_event_destroy(na_sm_addr->local_notify);
+    NA_CHECK_ERROR(rc == HG_UTIL_FAIL, done, ret, NA_PROTOCOL_ERROR,
+        "hg_event_destroy() failed");
 #endif
 
+    // TODO cleanup
     if (!na_sm_addr->self) { /* Created by lookup/connect or accept */
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
         char na_sm_local_event_name[NA_SM_MAX_FILENAME],
@@ -2868,10 +2827,7 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 
         /* Deregister sock file descriptor */
         ret = na_sm_poll_deregister(na_class, NA_SM_SOCK, na_sm_addr);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not delete sock from poll set");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not delete sock from poll set");
 
         /* Remove addr from poll addr queue */
         hg_thread_spin_lock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
@@ -2881,25 +2837,29 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 
         if (na_sm_addr->accepted) { /* Created by accept */
             /* Get file names from ring bufs / events to delete files */
-            sprintf(na_sm_send_ring_buf_name, "%s-%d-%d-%d-%s",
-                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->self_addr->pid,
+            sprintf(na_sm_send_ring_buf_name, "%s_%s-%d-%d-%d-" NA_SM_SEND_NAME,
+                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->username,
+                NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
-                na_sm_addr->conn_id, NA_SM_SEND_NAME);
-            sprintf(na_sm_recv_ring_buf_name, "%s-%d-%d-%d-%s",
-                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->self_addr->pid,
+                na_sm_addr->conn_id);
+            sprintf(na_sm_recv_ring_buf_name, "%s_%s-%d-%d-%d-" NA_SM_RECV_NAME,
+                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->username,
+                NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
-                na_sm_addr->conn_id, NA_SM_RECV_NAME);
+                na_sm_addr->conn_id);
             send_ring_buf_name = na_sm_send_ring_buf_name;
             recv_ring_buf_name = na_sm_recv_ring_buf_name;
 
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
-            sprintf(na_sm_local_event_name, "%s/%s/%d/%u/fifo-%u-%s",
+            sprintf(na_sm_local_event_name, "%s/%s_%s/%d/%u/fifo-%u-%s",
                 NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX,
+                NA_SM_CLASS(na_class)->username,
                 NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
                 na_sm_addr->conn_id, NA_SM_RECV_NAME);
-            sprintf(na_sm_remote_event_name, "%s/%s/%d/%u/fifo-%u-%s",
+            sprintf(na_sm_remote_event_name, "%s/%s_%s/%d/%u/fifo-%u-%s",
                 NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX,
+                NA_SM_CLASS(na_class)->username,
                 NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
                 na_sm_addr->conn_id, NA_SM_SEND_NAME);
@@ -2910,80 +2870,56 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 
         /* Destroy events */
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
-        if (hg_event_destroy(na_sm_addr->remote_notify) == HG_UTIL_FAIL) {
-            NA_LOG_ERROR("hg_event_destroy() failed");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_event_destroy(na_sm_addr->remote_notify);
+        NA_CHECK_ERROR(rc == HG_UTIL_FAIL, done, ret, NA_PROTOCOL_ERROR,
+            "hg_event_destroy() failed");
 #else
-        if (na_sm_event_destroy(local_event_name, na_sm_addr->local_notify)
-            != NA_SUCCESS) {
-            NA_LOG_ERROR("na_sm_event_destroy() failed");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        ret = na_sm_event_destroy(local_event_name, na_sm_addr->local_notify);
+        NA_CHECK_NA_ERROR(done, ret, "na_sm_event_destroy() failed");
 
-        if (na_sm_event_destroy(remote_event_name, na_sm_addr->remote_notify)
-            != NA_SUCCESS) {
-            NA_LOG_ERROR("na_sm_event_destroy() failed");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        ret = na_sm_event_destroy(remote_event_name, na_sm_addr->remote_notify);
+        NA_CHECK_NA_ERROR(done, ret, "na_sm_event_destroy() failed");
 #endif
     } else {
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
         /* Destroy local event */
-        if (hg_event_destroy(na_sm_addr->local_notify) == HG_UTIL_FAIL) {
-            NA_LOG_ERROR("hg_event_destroy() failed");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_event_destroy(na_sm_addr->local_notify);
+        NA_CHECK_ERROR(rc == HG_UTIL_FAIL, done, ret, NA_PROTOCOL_ERROR,
+            "hg_event_destroy() failed");
 #endif
         if (na_sm_addr->na_sm_copy_buf) { /* Self addr and listen */
             ret = na_sm_poll_deregister(na_class, NA_SM_ACCEPT, na_sm_addr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not delete listen from poll set");
-                goto done;
-            }
+            NA_CHECK_NA_ERROR(done, ret,
+                "Could not delete listen from poll set");
 
-            NA_SM_GEN_SHM_NAME(na_sm_copy_buf_name, na_sm_addr);
+            NA_SM_GEN_SHM_NAME(na_sm_copy_buf_name,
+                NA_SM_CLASS(na_class)->username, na_sm_addr);
             copy_buf_name = na_sm_copy_buf_name;
-            NA_SM_GEN_SOCK_PATH(na_sock_name, na_sm_addr);
+            NA_SM_GEN_SOCK_PATH(na_sock_name,
+                NA_SM_CLASS(na_class)->username, na_sm_addr);
             pathname = na_sock_name;
         }
     }
 
     /* Close sock (delete also tmp dir if pathname is set) */
     ret = na_sm_close_sock(na_sm_addr->sock, pathname);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not close sock");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not close sock");
 
     /* Close ring buf (send) */
     ret = na_sm_close_shared_buf(send_ring_buf_name,
         na_sm_addr->na_sm_send_ring_buf, sizeof(struct na_sm_ring_buf));
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not close send ring buffer");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not close send ring buffer");
 
     /* Close ring buf (recv) */
     ret = na_sm_close_shared_buf(recv_ring_buf_name,
         na_sm_addr->na_sm_recv_ring_buf, sizeof(struct na_sm_ring_buf));
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not close recv ring buffer");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not close recv ring buffer");
 
     /* Close copy buf */
     if (!na_sm_addr->accepted) { /* Created by accept */
         ret = na_sm_close_shared_buf(copy_buf_name, na_sm_addr->na_sm_copy_buf,
             sizeof(struct na_sm_copy_buf));
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not close copy buffer");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not close copy buffer");
     }
 
     free(na_sm_addr);
@@ -3024,6 +2960,17 @@ na_sm_addr_dup(na_class_t NA_UNUSED *na_class, na_addr_t addr,
 }
 
 /*---------------------------------------------------------------------------*/
+static na_bool_t
+na_sm_addr_cmp(na_class_t NA_UNUSED *na_class, na_addr_t addr1, na_addr_t addr2)
+{
+    struct na_sm_addr *na_sm_addr1 = (struct na_sm_addr *) addr1;
+    struct na_sm_addr *na_sm_addr2 = (struct na_sm_addr *) addr2;
+
+    return (na_sm_addr1->pid == na_sm_addr2->pid)
+        && (na_sm_addr1->id == na_sm_addr2->id);
+}
+
+/*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
 na_sm_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
@@ -3043,17 +2990,13 @@ na_sm_addr_to_string(na_class_t NA_UNUSED *na_class, char *buf,
     na_return_t ret = NA_SUCCESS;
 
     sprintf(addr_string, "sm://%d/%u", na_sm_addr->pid, na_sm_addr->id);
+
     string_len = strlen(addr_string);
     if (buf) {
-        if (string_len >= *buf_size) {
-            NA_LOG_ERROR("Buffer size too small to copy addr");
-            ret = NA_SIZE_ERROR;
-            goto done;
-        } else {
-            strcpy(buf, addr_string);
-        }
+        NA_CHECK_ERROR(string_len >= *buf_size, done, ret, NA_OVERFLOW,
+            "Buffer size too small to copy addr");
+        strcpy(buf, addr_string);
     }
-
     *buf_size = string_len + 1;
 
 done:
@@ -3091,68 +3034,75 @@ na_sm_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     struct na_sm_op_id *na_sm_op_id = NULL;
     struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) dest_addr;
     unsigned int idx_reserved;
+    na_bool_t reserved = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size > NA_SM_UNEXPECTED_SIZE) {
-        NA_LOG_ERROR("Exceeds unexpected size");
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size > NA_SM_UNEXPECTED_SIZE, done, ret, NA_OVERFLOW,
+        "Exceeds unexpected size, %d", buf_size);
+
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_SEND_UNEXPECTED;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    hg_atomic_incr32(&na_sm_addr->ref_count);
+    na_sm_op_id->na_sm_addr = na_sm_addr;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
+    /* TODO we assume that buf remains valid (safe because we pre-allocate buffers) */
+    na_sm_op_id->info.msg.buf.const_ptr = buf;
+    na_sm_op_id->info.msg.buf_size = buf_size;
+    na_sm_op_id->info.msg.actual_buf_size = buf_size;
+    na_sm_op_id->info.msg.tag = tag;
 
     /* Try to reserve buffer atomically */
-    do {
-        ret = na_sm_reserve_and_copy_buf(na_class, na_sm_addr->na_sm_copy_buf,
-            buf, buf_size, &idx_reserved);
-        if (ret != NA_SUCCESS) {
-            na_return_t progress_ret = na_sm_progress(na_class, context, 0);
-
-            if (progress_ret != NA_SUCCESS && progress_ret != NA_TIMEOUT) {
-                NA_LOG_ERROR("Could not make progress");
-                ret = progress_ret;
-                goto done;
-            }
-            continue;
+    ret = na_sm_reserve_and_copy_buf(na_class, na_sm_addr->na_sm_copy_buf,
+        buf, buf_size, &idx_reserved);
+    if (unlikely(ret == NA_AGAIN)) {
+        if (NA_SM_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_sm_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_spin_lock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+            HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->retry_op_queue,
+                na_sm_op_id, entry);
+            hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_QUEUED);
+            hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+
+            ret = NA_SUCCESS;
         }
-        break;
-    } while (1);
+    } else {
+        /* Successfully reserved a buffer */
+        reserved = NA_TRUE;
 
-    /* Insert message into ring buffer (complete OP ID) */
-    ret = na_sm_msg_insert(na_class, na_sm_op_id, NA_CB_RECV_UNEXPECTED,
-        na_sm_addr, idx_reserved, buf_size, tag);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not insert message");
-        goto done;
+        /* Insert message into ring buffer (complete OP ID) */
+        ret = na_sm_msg_insert(na_class, na_sm_op_id, idx_reserved);
+        NA_CHECK_NA_ERROR(error, ret, "Could not insert message");
     }
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
+    return ret;
+
+error:
+    if (reserved)
+        na_sm_release_buf(na_sm_op_id->na_sm_addr->na_sm_copy_buf,
+            idx_reserved);
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
     return ret;
 }
 
@@ -3166,40 +3116,29 @@ na_sm_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
     struct na_sm_op_id *na_sm_op_id = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size > NA_SM_UNEXPECTED_SIZE) {
-        NA_LOG_ERROR("Exceeds unexpected size, %d", buf_size);
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size > NA_SM_UNEXPECTED_SIZE, done, ret, NA_OVERFLOW,
+        "Exceeds unexpected size, %d", buf_size);
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
 
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_RECV_UNEXPECTED;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-    na_sm_op_id->info.recv_unexpected.buf = buf;
-    na_sm_op_id->info.recv_unexpected.buf_size = buf_size;
-    na_sm_op_id->info.recv_unexpected.unexpected_info.na_sm_addr = NULL;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    na_sm_op_id->na_sm_addr = NULL;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
+    na_sm_op_id->info.msg.buf.ptr = buf;
+    na_sm_op_id->info.msg.buf_size = buf_size;
 
     /* Look for an unexpected message already received */
     hg_thread_spin_lock(&NA_SM_CLASS(na_class)->unexpected_msg_queue_lock);
@@ -3207,28 +3146,40 @@ na_sm_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
         &NA_SM_CLASS(na_class)->unexpected_msg_queue);
     HG_QUEUE_POP_HEAD(&NA_SM_CLASS(na_class)->unexpected_msg_queue, entry);
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->unexpected_msg_queue_lock);
-    if (na_sm_unexpected_info) {
-        na_sm_op_id->info.recv_unexpected.unexpected_info =
-            *na_sm_unexpected_info;
+    if (unlikely(na_sm_unexpected_info)) {
+        na_sm_op_id->na_sm_addr = na_sm_unexpected_info->na_sm_addr;
+        hg_atomic_incr32(&na_sm_op_id->na_sm_addr->ref_count);
+        na_sm_op_id->info.msg.actual_buf_size = na_sm_unexpected_info->buf_size;
+        na_sm_op_id->info.msg.tag = na_sm_unexpected_info->tag;
+
+        /* Copy buffers */
+        memcpy(na_sm_op_id->info.msg.buf.ptr, na_sm_unexpected_info->buf,
+            na_sm_unexpected_info->buf_size);
+
+        free(na_sm_unexpected_info->buf);
         free(na_sm_unexpected_info);
 
         ret = na_sm_complete(na_sm_op_id);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(error, ret, "Could not complete operation");
     } else {
+        na_sm_op_id->info.msg.actual_buf_size = 0;
+        na_sm_op_id->info.msg.tag = 0;
+
         /* Nothing has been received yet so add op_id to progress queue */
         hg_thread_spin_lock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
         HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->unexpected_op_queue,
             na_sm_op_id, entry);
+        hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_QUEUED);
         hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
     }
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
+    return ret;
+
+error:
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
     return ret;
 }
 
@@ -3242,68 +3193,75 @@ na_sm_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
     struct na_sm_op_id *na_sm_op_id = NULL;
     struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) dest_addr;
     unsigned int idx_reserved;
+    na_bool_t reserved = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size > NA_SM_EXPECTED_SIZE) {
-        NA_LOG_ERROR("Exceeds expected size");
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size > NA_SM_EXPECTED_SIZE, done, ret, NA_OVERFLOW,
+        "Exceeds expected size, %d", buf_size);
+
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_SEND_EXPECTED;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    hg_atomic_incr32(&na_sm_addr->ref_count);
+    na_sm_op_id->na_sm_addr = na_sm_addr;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
+    /* TODO we assume that buf remains valid (safe because we pre-allocate buffers) */
+    na_sm_op_id->info.msg.buf.const_ptr = buf;
+    na_sm_op_id->info.msg.buf_size = buf_size;
+    na_sm_op_id->info.msg.actual_buf_size = buf_size;
+    na_sm_op_id->info.msg.tag = tag;
 
     /* Try to reserve buffer atomically */
-    do {
-        ret = na_sm_reserve_and_copy_buf(na_class, na_sm_addr->na_sm_copy_buf,
-            buf, buf_size, &idx_reserved);
-        if (ret != NA_SUCCESS) {
-            na_return_t progress_ret = na_sm_progress(na_class, context, 0);
-
-            if (progress_ret != NA_SUCCESS && progress_ret != NA_TIMEOUT) {
-                NA_LOG_ERROR("Could not make progress");
-                ret = progress_ret;
-                goto done;
-            }
-            continue;
+    ret = na_sm_reserve_and_copy_buf(na_class, na_sm_addr->na_sm_copy_buf,
+        buf, buf_size, &idx_reserved);
+    if (unlikely(ret == NA_AGAIN)) {
+        if (NA_SM_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_sm_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_spin_lock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+            HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->retry_op_queue,
+                na_sm_op_id, entry);
+            hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_QUEUED);
+            hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+
+            ret = NA_SUCCESS;
         }
-        break;
-    } while (1);
+    } else {
+        /* Successfully reserved a buffer */
+        reserved = NA_TRUE;
 
-    /* Insert message into ring buffer (complete OP ID) */
-    ret = na_sm_msg_insert(na_class, na_sm_op_id, NA_CB_RECV_EXPECTED,
-        na_sm_addr, idx_reserved, buf_size, tag);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not insert message");
-        goto done;
+        /* Insert message into ring buffer (complete OP ID) */
+        ret = na_sm_msg_insert(na_class, na_sm_op_id, idx_reserved);
+        NA_CHECK_NA_ERROR(error, ret, "Could not insert message");
     }
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
+    return ret;
+
+error:
+    if (reserved)
+        na_sm_release_buf(na_sm_op_id->na_sm_addr->na_sm_copy_buf,
+            idx_reserved);
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
     return ret;
 }
 
@@ -3315,42 +3273,35 @@ na_sm_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     na_uint8_t NA_UNUSED source_id, na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_sm_op_id *na_sm_op_id = NULL;
+    struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) source_addr;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size > NA_SM_EXPECTED_SIZE) {
-        NA_LOG_ERROR("Exceeds expected size");
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size > NA_SM_EXPECTED_SIZE, done, ret, NA_OVERFLOW,
+        "Exceeds expected size, %d", buf_size);
+
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_RECV_EXPECTED;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-    na_sm_op_id->info.recv_expected.buf = buf;
-    na_sm_op_id->info.recv_expected.buf_size = buf_size;
-    na_sm_op_id->info.recv_expected.na_sm_addr = (struct na_sm_addr *) source_addr;
-    na_sm_op_id->info.recv_expected.tag = tag;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    hg_atomic_incr32(&na_sm_addr->ref_count);
+    na_sm_op_id->na_sm_addr = na_sm_addr;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
+    na_sm_op_id->info.msg.buf.ptr = buf;
+    na_sm_op_id->info.msg.buf_size = buf_size;
+    na_sm_op_id->info.msg.actual_buf_size = 0;
+    na_sm_op_id->info.msg.tag = tag;
 
     /* Expected messages must always be pre-posted, therefore a message should
      * never arrive before that call returns (not completes), simply add
@@ -3358,12 +3309,10 @@ na_sm_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     hg_thread_spin_lock(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
     HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->expected_op_queue, na_sm_op_id,
         entry);
+    hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_QUEUED);
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
     return ret;
 }
 
@@ -3377,18 +3326,13 @@ na_sm_mem_handle_create(na_class_t NA_UNUSED *na_class, void *buf,
 
     na_sm_mem_handle = (struct na_sm_mem_handle *) malloc(
         sizeof(struct na_sm_mem_handle));
-    if (!na_sm_mem_handle) {
-        NA_LOG_ERROR("Could not allocate NA SM memory handle");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA SM memory handle");
+
     na_sm_mem_handle->iov = (struct iovec *) malloc(sizeof(struct iovec));
-    if (!na_sm_mem_handle->iov) {
-        NA_LOG_ERROR("Could not allocate iovec");
-        ret = NA_NOMEM_ERROR;
-        free(na_sm_mem_handle);
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle->iov == NULL, error, ret, NA_NOMEM,
+        "Could not allocate iovec");
+
     na_sm_mem_handle->iov->iov_base = buf;
     na_sm_mem_handle->iov->iov_len = buf_size;
     na_sm_mem_handle->iovcnt = 1;
@@ -3397,7 +3341,13 @@ na_sm_mem_handle_create(na_class_t NA_UNUSED *na_class, void *buf,
 
     *mem_handle = (na_mem_handle_t) na_sm_mem_handle;
 
-done:
+    return ret;
+
+error:
+    if (na_sm_mem_handle) {
+        free(na_sm_mem_handle->iov);
+        free(na_sm_mem_handle);
+    }
     return ret;
 }
 
@@ -3414,26 +3364,19 @@ na_sm_mem_handle_create_segments(na_class_t NA_UNUSED *na_class,
 
     /* Check that we do not exceed IOV_MAX */
     iov_max = (na_size_t) sysconf(_SC_IOV_MAX);
-    if (segment_count > iov_max) {
-        NA_LOG_ERROR("Segment count exceeds IOV_MAX limit");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(segment_count > iov_max, error, ret, NA_INVALID_ARG,
+        "Segment count exceeds IOV_MAX limit");
 
     na_sm_mem_handle = (struct na_sm_mem_handle *) malloc(
         sizeof(struct na_sm_mem_handle));
-    if (!na_sm_mem_handle) {
-        NA_LOG_ERROR("Could not allocate NA SM memory handle");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA SM memory handle");
+
     na_sm_mem_handle->iov = (struct iovec *) malloc(
         segment_count * sizeof(struct iovec));
-    if (!na_sm_mem_handle->iov) {
-        NA_LOG_ERROR("Could not allocate iovec");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle->iov == NULL, error, ret, NA_NOMEM,
+        "Could not allocate iovec");
+
     na_sm_mem_handle->len = 0;
     for (i = 0; i < segment_count; i++) {
         na_sm_mem_handle->iov[i].iov_base = (void *) segments[i].address;
@@ -3445,7 +3388,13 @@ na_sm_mem_handle_create_segments(na_class_t NA_UNUSED *na_class,
 
     *mem_handle = (na_mem_handle_t) na_sm_mem_handle;
 
-done:
+    return ret;
+
+error:
+    if (na_sm_mem_handle) {
+        free(na_sm_mem_handle->iov);
+        free(na_sm_mem_handle);
+    }
     return ret;
 }
 #endif
@@ -3475,9 +3424,8 @@ na_sm_mem_handle_get_serialize_size(na_class_t NA_UNUSED *na_class,
     unsigned long i;
     na_size_t ret = 2 * sizeof(unsigned long) + sizeof(size_t);
 
-    for (i = 0; i < na_sm_mem_handle->iovcnt; i++) {
+    for (i = 0; i < na_sm_mem_handle->iovcnt; i++)
         ret += sizeof(void *) + sizeof(size_t);
-    }
 
     return ret;
 }
@@ -3528,21 +3476,15 @@ na_sm_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
 
     na_sm_mem_handle = (struct na_sm_mem_handle *) malloc(
         sizeof(struct na_sm_mem_handle));
-    if (!na_sm_mem_handle) {
-          NA_LOG_ERROR("Could not allocate NA SM memory handle");
-          ret = NA_NOMEM_ERROR;
-          goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA SM memory handle");
+    na_sm_mem_handle->iov = NULL;
 
     /* Number of segments */
     memcpy(&na_sm_mem_handle->iovcnt, buf_ptr, sizeof(unsigned long));
     buf_ptr += sizeof(unsigned long);
-    if (!na_sm_mem_handle->iovcnt) {
-        NA_LOG_ERROR("NULL segment count");
-        ret = NA_SIZE_ERROR;
-        free(na_sm_mem_handle);
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle->iovcnt == 0, error, ret, NA_FAULT,
+        "NULL segment count");
 
     /* Flags */
     memcpy(&na_sm_mem_handle->flags, buf_ptr, sizeof(unsigned long));
@@ -3555,12 +3497,9 @@ na_sm_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
     /* Segments */
     na_sm_mem_handle->iov = (struct iovec *) malloc(na_sm_mem_handle->iovcnt *
         sizeof(struct iovec));
-    if (!na_sm_mem_handle->iov) {
-        NA_LOG_ERROR("Could not allocate iovec");
-        ret = NA_NOMEM_ERROR;
-        free(na_sm_mem_handle);
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle->iov == NULL, error, ret, NA_NOMEM,
+        "Could not allocate iovec");
+
     for (i = 0; i < na_sm_mem_handle->iovcnt; i++) {
         memcpy(&na_sm_mem_handle->iov[i].iov_base, buf_ptr, sizeof(void *));
         buf_ptr += sizeof(void *);
@@ -3570,7 +3509,13 @@ na_sm_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
 
     *mem_handle = (na_mem_handle_t) na_sm_mem_handle;
 
-done:
+    return ret;
+
+error:
+    if (na_sm_mem_handle) {
+        free(na_sm_mem_handle->iov);
+        free(na_sm_mem_handle);
+    }
     return ret;
 }
 
@@ -3589,6 +3534,8 @@ na_sm_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
         (struct na_sm_mem_handle *) remote_mem_handle;
     struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) remote_addr;
     struct iovec *local_iov, *remote_iov;
+    struct iovec *local_iovs[IOV_MAX] = {NULL, 0};
+    struct iovec *remote_iovs[IOV_MAX] = {NULL, 0};
     unsigned long liovcnt, riovcnt;
     na_return_t ret = NA_SUCCESS;
 #if defined(NA_SM_HAS_CMA)
@@ -3599,58 +3546,49 @@ na_sm_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 #endif
 
 #if !defined(NA_SM_HAS_CMA) && !defined(__APPLE__)
-    (void) na_sm_addr;
-    NA_LOG_ERROR("Not implemented for this platform");
-    ret = NA_PROTOCOL_ERROR;
-    goto done;
+    NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR,
+        "Not implemented for this platform");
 #endif
 
     switch (na_sm_mem_handle_remote->flags) {
         case NA_MEM_READ_ONLY:
-            NA_LOG_ERROR("Registered memory requires write permission");
-            ret = NA_PERMISSION_ERROR;
-            goto done;
+            NA_GOTO_ERROR(done, ret, NA_PERMISSION,
+                "Registered memory requires write permission");
+            break;
         case NA_MEM_WRITE_ONLY:
         case NA_MEM_READWRITE:
             break;
         default:
-            NA_LOG_ERROR("Invalid memory access flag");
-            ret = NA_INVALID_PARAM;
-            goto done;
+            NA_GOTO_ERROR(done, ret, NA_INVALID_ARG,
+                "Invalid memory access flag");
     }
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_PUT;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    hg_atomic_incr32(&na_sm_addr->ref_count);
+    na_sm_op_id->na_sm_addr = na_sm_addr;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
 
     /* Translate local offset, skip this step if not necessary */
     if (local_offset || length != na_sm_mem_handle_local->len) {
-        /* TODO fix allocation */
-        local_iov = (struct iovec *) alloca(
-            na_sm_mem_handle_local->iovcnt * sizeof(struct iovec));
+        local_iov = (struct iovec *) local_iovs;
         na_sm_offset_translate(na_sm_mem_handle_local, local_offset, length,
             local_iov, &liovcnt);
+        NA_LOG_DEBUG("Translated local offsets into %lu segment(s)", liovcnt);
     } else {
         local_iov = na_sm_mem_handle_local->iov;
         liovcnt = na_sm_mem_handle_local->iovcnt;
@@ -3658,11 +3596,10 @@ na_sm_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
     /* Translate remote offset, skip this step if not necessary */
     if (remote_offset || length != na_sm_mem_handle_remote->len) {
-        /* TODO fix allocation */
-        remote_iov = (struct iovec *) alloca(
-            na_sm_mem_handle_remote->iovcnt * sizeof(struct iovec));
+        remote_iov = (struct iovec *) remote_iovs;
         na_sm_offset_translate(na_sm_mem_handle_remote, remote_offset, length,
             remote_iov, &riovcnt);
+        NA_LOG_DEBUG("Translated remote offsets into %lu segment(s)", riovcnt);
     } else {
         remote_iov = na_sm_mem_handle_remote->iov;
         riovcnt = na_sm_mem_handle_remote->iovcnt;
@@ -3671,62 +3608,45 @@ na_sm_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 #if defined(NA_SM_HAS_CMA)
     nwrite = process_vm_writev(na_sm_addr->pid, local_iov, liovcnt, remote_iov,
         riovcnt, /* unused */0);
-    if (nwrite < 0) {
-        NA_LOG_ERROR("process_vm_writev() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-    if ((na_size_t)nwrite != length) {
-        NA_LOG_ERROR("Wrote %ld bytes, was expecting %lu bytes", nwrite, length);
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(nwrite < 0, error, ret, NA_PROTOCOL_ERROR,
+        "process_vm_writev() failed (%s)", strerror(errno));
+    NA_CHECK_ERROR((na_size_t)nwrite != length, error, ret, NA_MSGSIZE,
+        "Wrote %ld bytes, was expecting %lu bytes", nwrite, length);
 #elif defined(__APPLE__)
     kret = task_for_pid(mach_task_self(), na_sm_addr->pid, &remote_task);
-    if (kret != KERN_SUCCESS) {
-        NA_LOG_ERROR("task_for_pid() failed (%s)\n"
-                     "Permission must be set to access remote memory, please refer to the documentation for instructions.", mach_error_string(kret));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    if (liovcnt > 1 || riovcnt > 1) {
-        NA_LOG_ERROR("Non-contiguous transfers are not supported");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(kret != KERN_SUCCESS, error, ret, NA_PROTOCOL_ERROR,
+        "task_for_pid() failed (%s)\n"
+        "Permission must be set to access remote memory, please refer to the "
+        "documentation for instructions.", mach_error_string(kret));
+    NA_CHECK_ERROR(liovcnt > 1 || riovcnt > 1, error, ret, NA_PROTOCOL_ERROR,
+        "Non-contiguous transfers are not supported");
 
     kret = mach_vm_write(remote_task,
         (mach_vm_address_t) remote_iov->iov_base,
         (mach_vm_address_t) local_iov->iov_base,
         (mach_msg_type_number_t) length);
-    if (kret != KERN_SUCCESS) {
-        NA_LOG_ERROR("mach_vm_write() failed (%s)", mach_error_string(kret));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(kret != KERN_SUCCESS, error, ret, NA_PROTOCOL_ERROR,
+        "mach_vm_write() failed (%s)", mach_error_string(kret));
 #endif
 
     /* Immediate completion */
     ret = na_sm_complete(na_sm_op_id);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not complete operation");
 
     /* Notify local completion */
-    if (!NA_SM_CLASS(na_class)->no_wait
-        && (hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify)
-        != HG_UTIL_SUCCESS)) {
-        NA_LOG_ERROR("Could not signal local completion");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+    if (!NA_SM_CLASS(na_class)->no_wait) {
+        int rc = hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "Could not signal local completion");
     }
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
+    return ret;
+
+error:
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
     return ret;
 }
 
@@ -3745,6 +3665,8 @@ na_sm_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
         (struct na_sm_mem_handle *) remote_mem_handle;
     struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) remote_addr;
     struct iovec *local_iov, *remote_iov;
+    struct iovec *local_iovs[IOV_MAX] = {NULL, 0};
+    struct iovec *remote_iovs[IOV_MAX] = {NULL, 0};
     unsigned long liovcnt, riovcnt;
     na_return_t ret = NA_SUCCESS;
 #if defined(NA_SM_HAS_CMA)
@@ -3756,58 +3678,44 @@ na_sm_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 #endif
 
 #if !defined(NA_SM_HAS_CMA) && !defined(__APPLE__)
-    (void) na_sm_addr;
-    NA_LOG_ERROR("Not implemented for this platform");
-    ret = NA_PROTOCOL_ERROR;
-    goto done;
+    NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR,
+        "Not implemented for this platform");
 #endif
 
     switch (na_sm_mem_handle_remote->flags) {
         case NA_MEM_WRITE_ONLY:
-            NA_LOG_ERROR("Registered memory requires read permission");
-            ret = NA_PERMISSION_ERROR;
-            goto done;
+            NA_GOTO_ERROR(done, ret, NA_PERMISSION,
+                "Registered memory requires write permission");
+            break;
         case NA_MEM_READ_ONLY:
         case NA_MEM_READWRITE:
             break;
         default:
-            NA_LOG_ERROR("Invalid memory access flag");
-            ret = NA_INVALID_PARAM;
-            goto done;
+            NA_GOTO_ERROR(done, ret, NA_INVALID_ARG,
+                "Invalid memory access flag");
     }
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_GET;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    hg_atomic_incr32(&na_sm_addr->ref_count);
+    na_sm_op_id->na_sm_addr = na_sm_addr;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
 
     /* Translate local offset, skip this step if not necessary */
     if (local_offset || length != na_sm_mem_handle_local->len) {
-        /* TODO fix allocation */
-        local_iov = (struct iovec *) alloca(
-            na_sm_mem_handle_local->iovcnt * sizeof(struct iovec));
+        local_iov = (struct iovec *) local_iovs;
         na_sm_offset_translate(na_sm_mem_handle_local, local_offset, length,
             local_iov, &liovcnt);
+        NA_LOG_DEBUG("Translated local offsets into %lu segment(s)", liovcnt);
     } else {
         local_iov = na_sm_mem_handle_local->iov;
         liovcnt = na_sm_mem_handle_local->iovcnt;
@@ -3815,11 +3723,10 @@ na_sm_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
     /* Translate remote offset, skip this step if not necessary */
     if (remote_offset || length != na_sm_mem_handle_remote->len) {
-        /* TODO fix allocation */
-        remote_iov = (struct iovec *) alloca(
-            na_sm_mem_handle_remote->iovcnt * sizeof(struct iovec));
+        remote_iov = (struct iovec *) remote_iovs;
         na_sm_offset_translate(na_sm_mem_handle_remote, remote_offset, length,
             remote_iov, &riovcnt);
+        NA_LOG_DEBUG("Translated remote offsets into %lu segment(s)", riovcnt);
     } else {
         remote_iov = na_sm_mem_handle_remote->iov;
         riovcnt = na_sm_mem_handle_remote->iovcnt;
@@ -3828,63 +3735,46 @@ na_sm_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 #if defined(NA_SM_HAS_CMA)
     nread = process_vm_readv(na_sm_addr->pid, local_iov, liovcnt, remote_iov,
         riovcnt, /* unused */0);
-    if (nread < 0) {
-        NA_LOG_ERROR("process_vm_readv() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(nread < 0, error, ret, NA_PROTOCOL_ERROR,
+        "process_vm_readv() failed (%s)", strerror(errno));
 #elif defined(__APPLE__)
     kret = task_for_pid(mach_task_self(), na_sm_addr->pid, &remote_task);
-    if (kret != KERN_SUCCESS) {
-        NA_LOG_ERROR("task_for_pid() failed (%s)\n"
-                     "Permission must be set to access remote memory, please refer to the documentation for instructions.", mach_error_string(kret));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    if (liovcnt > 1 || riovcnt > 1) {
-        NA_LOG_ERROR("Non-contiguous transfers are not supported");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(kret != KERN_SUCCESS, error, ret, NA_PROTOCOL_ERROR,
+        "task_for_pid() failed (%s)\n"
+        "Permission must be set to access remote memory, please refer to the "
+        "documentation for instructions.", mach_error_string(kret));
+    NA_CHECK_ERROR(liovcnt > 1 || riovcnt > 1, error, ret, NA_PROTOCOL_ERROR,
+        "Non-contiguous transfers are not supported");
 
     kret = mach_vm_read_overwrite(remote_task,
         (mach_vm_address_t) remote_iov->iov_base, length,
         (mach_vm_address_t) local_iov->iov_base, &nread);
-    if (kret != KERN_SUCCESS) {
-        NA_LOG_ERROR("mach_vm_read_overwrite() failed (%s)", mach_error_string(kret));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(kret != KERN_SUCCESS, error, ret, NA_PROTOCOL_ERROR,
+        "mach_vm_read_overwrite() failed (%s)", mach_error_string(kret));
 #endif
 #if defined(NA_SM_HAS_CMA) || defined(__APPLE__)
-    if ((na_size_t)nread != length) {
-        NA_LOG_ERROR("Read %ld bytes, was expecting %lu bytes", nread, length);
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR((na_size_t)nread != length, error, ret, NA_MSGSIZE,
+        "Read %ld bytes, was expecting %lu bytes", nread, length);
 #endif
 
     /* Immediate completion */
     ret = na_sm_complete(na_sm_op_id);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not complete operation");
 
     /* Notify local completion */
-    if (!NA_SM_CLASS(na_class)->no_wait
-        && (hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify)
-        != HG_UTIL_SUCCESS)) {
-        NA_LOG_ERROR("Could not signal local completion");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+    if (!NA_SM_CLASS(na_class)->no_wait) {
+        int rc = hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "Could not signal local completion");
     }
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
+    return ret;
+
+error:
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
     return ret;
 }
 
@@ -3892,13 +3782,12 @@ done:
 static NA_INLINE int
 na_sm_poll_get_fd(na_class_t *na_class, na_context_t NA_UNUSED *context)
 {
-    int fd;
+    int fd = -1;
 
     fd = hg_poll_get_fd(NA_SM_CLASS(na_class)->poll_set);
-    if (fd == HG_UTIL_FAIL) {
-        NA_LOG_ERROR("Could not get poll fd from poll set");
-    }
+    NA_CHECK_ERROR_NORET(fd == -1, done, "Could not get poll fd from poll set");
 
+ done:
     return fd;
 }
 
@@ -3934,16 +3823,17 @@ na_sm_progress(na_class_t *na_class, na_context_t NA_UNUSED *context,
     do {
         hg_time_t t1, t2;
         hg_util_bool_t progressed;
+        unsigned int poll_timeout = (NA_SM_CLASS(na_class)->no_wait) ? 0 :
+            (unsigned int) (remaining * 1000.0);
+        int rc;
 
         if (timeout)
             hg_time_get_current(&t1);
 
-        if (hg_poll_wait(NA_SM_CLASS(na_class)->poll_set,
-            (unsigned int) (remaining * 1000.0), &progressed) != HG_UTIL_SUCCESS) {
-            NA_LOG_ERROR("hg_poll_wait() failed");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_poll_wait(NA_SM_CLASS(na_class)->poll_set, poll_timeout,
+            &progressed);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "hg_poll_wait() failed");
 
         /* We progressed, return success */
         if (progressed) {
@@ -3968,74 +3858,55 @@ na_sm_cancel(na_class_t *na_class, na_context_t NA_UNUSED *context,
 {
     struct na_sm_op_id *na_sm_op_id = (struct na_sm_op_id *) op_id;
     na_return_t ret = NA_SUCCESS;
+    na_bool_t canceled = NA_FALSE;
 
-    if (hg_atomic_get32(&na_sm_op_id->completed))
+    /* Exit if op has already completed */
+    if (hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_CANCELED)
+        & NA_SM_OP_COMPLETED)
         goto done;
 
+    NA_LOG_DEBUG("Canceling operation ID %p", na_sm_op_id);
+
     switch (na_sm_op_id->completion_data.callback_info.type) {
         case NA_CB_LOOKUP:
             /* Nothing */
             break;
-        case NA_CB_SEND_UNEXPECTED:
-            /* Nothing */
-            break;
-        case NA_CB_RECV_UNEXPECTED: {
-            struct na_sm_op_id *na_sm_var_op_id = NULL;
-
+        case NA_CB_RECV_UNEXPECTED:
             /* Must remove op_id from unexpected op_id queue */
             hg_thread_spin_lock(
                 &NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
-            HG_QUEUE_FOREACH(na_sm_var_op_id,
-                &NA_SM_CLASS(na_class)->unexpected_op_queue, entry) {
-                if (na_sm_var_op_id == na_sm_op_id) {
-                    HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->unexpected_op_queue,
-                        na_sm_var_op_id, na_sm_op_id, entry);
-                    break;
-                }
+            if (hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_QUEUED) {
+                HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->unexpected_op_queue,
+                    na_sm_op_id, na_sm_op_id, entry);
+                hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
+                canceled = NA_TRUE;
             }
             hg_thread_spin_unlock(
                 &NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
-
-            /* Cancel op id */
-            if (na_sm_var_op_id == na_sm_op_id) {
-                hg_atomic_set32(&na_sm_op_id->canceled, NA_TRUE);
-                ret = na_sm_complete(na_sm_op_id);
-                if (ret != NA_SUCCESS) {
-                    NA_LOG_ERROR("Could not complete operation");
-                    goto done;
-                }
-            }
-        }
-            break;
-        case NA_CB_SEND_EXPECTED:
-            /* Nothing */
             break;
-        case NA_CB_RECV_EXPECTED: {
-            struct na_sm_op_id *na_sm_var_op_id = NULL;
-
+        case NA_CB_RECV_EXPECTED:
             /* Must remove op_id from unexpected op_id queue */
             hg_thread_spin_lock(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
-            HG_QUEUE_FOREACH(na_sm_var_op_id,
-                &NA_SM_CLASS(na_class)->expected_op_queue, entry) {
-                if (na_sm_var_op_id == na_sm_op_id) {
-                    HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->expected_op_queue,
-                        na_sm_var_op_id, na_sm_op_id, entry);
-                    break;
-                }
+            if (hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_QUEUED) {
+                HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->expected_op_queue,
+                    na_sm_op_id, na_sm_op_id, entry);
+                hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
+                canceled = NA_TRUE;
             }
             hg_thread_spin_unlock(
                 &NA_SM_CLASS(na_class)->expected_op_queue_lock);
-
-            /* Cancel op id */
-            if (na_sm_var_op_id == na_sm_op_id) {
-                hg_atomic_set32(&na_sm_op_id->canceled, NA_TRUE);
-                ret = na_sm_complete(na_sm_op_id);
-                if (ret != NA_SUCCESS) {
-                    NA_LOG_ERROR("Could not complete operation");
-                    goto done;
-                }
+            break;
+        case NA_CB_SEND_UNEXPECTED:
+        case NA_CB_SEND_EXPECTED:
+            /* Must remove op_id from retry op_id queue */
+            hg_thread_spin_lock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+            if (hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_QUEUED) {
+                HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->retry_op_queue,
+                    na_sm_op_id, na_sm_op_id, entry);
+                hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
+                canceled = NA_TRUE;
             }
-        }
+            hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
             break;
         case NA_CB_PUT:
             /* Nothing */
@@ -4044,9 +3915,15 @@ na_sm_cancel(na_class_t *na_class, na_context_t NA_UNUSED *context,
             /* Nothing */
             break;
         default:
-            NA_LOG_ERROR("Operation not supported");
-            ret = NA_INVALID_PARAM;
-            break;
+            NA_GOTO_ERROR(done, ret, NA_INVALID_ARG,
+                "Operation type %d not supported",
+                na_sm_op_id->completion_data.callback_info.type);
+    }
+
+    /* Cancel op id */
+    if (canceled) {
+        ret = na_sm_complete(na_sm_op_id);
+        NA_CHECK_NA_ERROR(done, ret, "Could not complete operation");
     }
 
 done:
diff --git a/src/na/na_types.h b/src/na/na_types.h
index fd18929..7032bd0 100644
--- a/src/na/na_types.h
+++ b/src/na/na_types.h
@@ -29,17 +29,12 @@ typedef void *na_op_id_t;               /* Abstract operation id */
 typedef void *na_mem_handle_t;          /* Abstract memory handle */
 typedef na_uint64_t na_offset_t;        /* Offset */
 
-/* Progress mode */
-typedef enum na_progress_mode {
-    NA_DEFAULT,     /*!< blocking progress, depending on timeout value */
-    NA_NO_BLOCK     /*!< no blocking progress, independent of timeout value */
-} na_progress_mode_t;
-
 /* Init info */
 struct na_init_info {
-    na_progress_mode_t progress_mode;   /* Progress mode */
-    na_uint8_t max_contexts;            /* Max contexts */
+    const char *ip_subnet;              /* Preferred IP subnet */
     const char *auth_key;               /* Authorization key */
+    na_uint32_t progress_mode;          /* Progress mode */
+    na_uint8_t max_contexts;            /* Max contexts */
 };
 
 /* Segment */
@@ -48,21 +43,34 @@ struct na_segment {
     na_size_t size;     /* Size of the segment in bytes */
 };
 
-/* Error return codes:
- * Functions return 0 for success or NA_XXX_ERROR for failure */
-typedef enum na_return {
-    NA_SUCCESS,             /*!< operation succeeded */
-    NA_TIMEOUT,             /*!< reached timeout */
-    NA_INVALID_PARAM,       /*!< invalid parameter */
-    NA_SIZE_ERROR,          /*!< message size error */
-    NA_ALIGNMENT_ERROR,     /*!< alignment error */
-    NA_PERMISSION_ERROR,    /*!< read/write permission error */
-    NA_NOMEM_ERROR,         /*!< no memory error */
-    NA_PROTOCOL_ERROR,      /*!< unknown error reported from the protocol layer */
-    NA_CANCELED,            /*!< operation was canceled */
-    NA_CANCEL_ERROR,        /*!< operation could not be canceled */
-    NA_ADDRINUSE_ERROR      /*!< address already in use */
-} na_return_t;
+/* Return codes:
+ * Functions return 0 for success or corresponding return code */
+#define NA_RETURN_VALUES                                                    \
+    X(NA_SUCCESS)           /*!< operation succeeded */                     \
+    X(NA_PERMISSION)        /*!< operation not permitted */                 \
+    X(NA_NOENTRY)           /*!< no such file or directory */               \
+    X(NA_INTERRUPT)         /*!< operation interrupted */                   \
+    X(NA_AGAIN)             /*!< operation must be retried */               \
+    X(NA_NOMEM)             /*!< out of memory */                           \
+    X(NA_ACCESS)            /*!< permission denied */                       \
+    X(NA_FAULT)             /*!< bad address */                             \
+    X(NA_BUSY)              /*!< device or resource busy */                 \
+    X(NA_NODEV)             /*!< no such device */                          \
+    X(NA_INVALID_ARG)       /*!< invalid argument */                        \
+    X(NA_PROTOCOL_ERROR)    /*!< protocol error */                          \
+    X(NA_OVERFLOW)          /*!< value too large */                         \
+    X(NA_MSGSIZE)           /*!< message size too long */                   \
+    X(NA_PROTONOSUPPORT)    /*!< protocol not supported */                  \
+    X(NA_OPNOTSUPPORTED)    /*!< operation not supported on endpoint */     \
+    X(NA_ADDRINUSE)         /*!< address already in use */                  \
+    X(NA_ADDRNOTAVAIL)      /*!< cannot assign requested address */         \
+    X(NA_TIMEOUT)           /*!< operation reached timeout */               \
+    X(NA_CANCELED)          /*!< operation canceled */                      \
+    X(NA_RETURN_MAX)
+
+#define X(a) a,
+typedef enum na_return { NA_RETURN_VALUES } na_return_t;
+#undef X
 
 /* Callback operation type */
 typedef enum na_cb_type {
@@ -88,13 +96,13 @@ struct na_cb_info_recv_unexpected {
 
 /* Callback info struct */
 struct na_cb_info {
-    void *arg;          /* User data */
-    na_return_t ret;    /* Return value */
-    na_cb_type_t type;  /* Callback type */
     union {             /* Union of callback info structures */
         struct na_cb_info_lookup lookup;
         struct na_cb_info_recv_unexpected recv_unexpected;
     } info;
+    void *arg;          /* User data */
+    na_cb_type_t type;  /* Callback type */
+    na_return_t ret;    /* Return value */
 };
 
 /* Callback type */
@@ -123,4 +131,12 @@ typedef int (*na_cb_t)(const struct na_cb_info *callback_info);
 #define NA_MEM_WRITE_ONLY   0x02
 #define NA_MEM_READWRITE    0x03
 
+/* Progress modes */
+#define NA_NO_BLOCK         0x01    /*!< no blocking progress, independent of timeout value */
+#define NA_NO_RETRY         0x02    /*!< no retry of operations in progress */
+
+/* NA init info initializer */
+#define NA_INIT_INFO_INITIALIZER \
+    { NULL, NULL, 0, 1 }
+
 #endif /* NA_TYPES_H */
diff --git a/src/proc_extra/mercury_proc_string.h b/src/proc_extra/mercury_proc_string.h
index 918dce6..e1bc9ab 100644
--- a/src/proc_extra/mercury_proc_string.h
+++ b/src/proc_extra/mercury_proc_string.h
@@ -16,8 +16,8 @@
 
 #include <string.h>
 
-typedef const char * hg_const_string_t;
-typedef char * hg_string_t;
+typedef const char *hg_const_string_t;
+typedef char *hg_string_t;
 
 #ifdef __cplusplus
 extern "C" {
@@ -45,35 +45,29 @@ static HG_INLINE hg_return_t
 hg_proc_hg_const_string_t(hg_proc_t proc, void *data)
 {
     hg_string_object_t string;
-    hg_const_string_t *strdata = (hg_const_string_t*)data;
+    hg_const_string_t *strdata = (hg_const_string_t *) data;
     hg_return_t ret = HG_SUCCESS;
 
     switch (hg_proc_get_op(proc)) {
         case HG_ENCODE:
             hg_string_object_init_const_char(&string, *strdata, 0);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             hg_string_object_free(&string);
             break;
         case HG_DECODE:
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             *strdata = hg_string_object_swap(&string, 0);
             hg_string_object_free(&string);
             break;
         case HG_FREE:
             hg_string_object_init_const_char(&string, *strdata, 1);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             break;
         default:
             break;
@@ -95,35 +89,29 @@ static HG_INLINE hg_return_t
 hg_proc_hg_string_t(hg_proc_t proc, void *data)
 {
     hg_string_object_t string;
-    hg_string_t *strdata = (hg_string_t*)data;
+    hg_string_t *strdata = (hg_string_t *) data;
     hg_return_t ret = HG_SUCCESS;
 
     switch (hg_proc_get_op(proc)) {
         case HG_ENCODE:
             hg_string_object_init_char(&string, *strdata, 0);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             hg_string_object_free(&string);
             break;
         case HG_DECODE:
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             *strdata = hg_string_object_swap(&string, 0);
             hg_string_object_free(&string);
             break;
         case HG_FREE:
             hg_string_object_init_char(&string, *strdata, 1);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             break;
         default:
             break;
@@ -146,67 +134,61 @@ hg_proc_hg_string_object_t(hg_proc_t proc, void *string)
 {
     hg_uint64_t string_len = 0;
     hg_return_t ret = HG_SUCCESS;
-    hg_string_object_t *strobj = (hg_string_object_t*)string;
+    hg_string_object_t *strobj = (hg_string_object_t *) string;
 
     switch (hg_proc_get_op(proc)) {
         case HG_ENCODE:
             string_len = (strobj->data) ? strlen(strobj->data) + 1 : 0;
             ret = hg_proc_uint64_t(proc, &string_len);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             if (string_len) {
                 ret = hg_proc_raw(proc, strobj->data, string_len);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                if (ret != HG_SUCCESS)
                     goto done;
-                }
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_const);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_const);
+                if (ret != HG_SUCCESS)
                     goto done;
-                }
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_owned);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_owned);
+                if (ret != HG_SUCCESS)
                     goto done;
-                }
             }
             break;
         case HG_DECODE:
             ret = hg_proc_uint64_t(proc, &string_len);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             if (string_len) {
-                strobj->data = (char*) malloc(string_len);
+                strobj->data = (char *) malloc(string_len);
+                if (strobj->data == NULL) {
+                    ret = HG_NOMEM;
+                    goto done;
+                }
                 ret = hg_proc_raw(proc, strobj->data, string_len);
                 if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                    free(strobj->data);
+                    strobj->data = NULL;
                     goto done;
                 }
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_const);
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_const);
                 if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                    free(strobj->data);
+                    strobj->data = NULL;
                     goto done;
                 }
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_owned);
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_owned);
                 if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                    free(strobj->data);
+                    strobj->data = NULL;
                     goto done;
                 }
-            } else {
+            } else
                 strobj->data = NULL;
-            }
             break;
         case HG_FREE:
             ret = hg_string_object_free(strobj);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not free string object");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             break;
         default:
             break;
diff --git a/src/proc_extra/mercury_string_object.c b/src/proc_extra/mercury_string_object.c
index 76863c2..b7c7832 100644
--- a/src/proc_extra/mercury_string_object.c
+++ b/src/proc_extra/mercury_string_object.c
@@ -9,6 +9,7 @@
  */
 
 #include "mercury_string_object.h"
+#include "mercury_error.h"
 
 #include <string.h>
 #include <stdlib.h>
@@ -55,7 +56,7 @@ hg_string_object_init_const_char(hg_string_object_t *string, const char *s,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    string->data = (char*) s;
+    string->data = (char *) s;
     string->is_owned = is_owned;
     string->is_const = 1;
 
@@ -87,9 +88,12 @@ hg_string_object_dup(hg_string_object_t string, hg_string_object_t *new_string)
     hg_return_t ret = HG_SUCCESS;
 
     new_string->data = strdup(string.data);
+    HG_CHECK_ERROR(new_string->data == NULL, done, ret, HG_NOMEM,
+        "Could not dup string data");
     new_string->is_owned = 1;
     new_string->is_const = 0;
 
+done:
     return ret;
 }
 
diff --git a/src/proc_extra/mercury_string_object.h b/src/proc_extra/mercury_string_object.h
index ab5ae01..7d29e26 100644
--- a/src/proc_extra/mercury_string_object.h
+++ b/src/proc_extra/mercury_string_object.h
@@ -30,7 +30,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_string_object_init(hg_string_object_t *string);
 
 /**
@@ -42,8 +42,9 @@ hg_string_object_init(hg_string_object_t *string);
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
-hg_string_object_init_char(hg_string_object_t *string, char *s, hg_bool_t is_owned);
+HG_PUBLIC hg_return_t
+hg_string_object_init_char(hg_string_object_t *string, char *s,
+    hg_bool_t is_owned);
 
 /**
  * Initialize a string object from the const string pointed to by s.
@@ -54,8 +55,9 @@ hg_string_object_init_char(hg_string_object_t *string, char *s, hg_bool_t is_own
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
-hg_string_object_init_const_char(hg_string_object_t *string, const char *s, hg_bool_t is_owned);
+HG_PUBLIC hg_return_t
+hg_string_object_init_const_char(hg_string_object_t *string, const char *s,
+    hg_bool_t is_owned);
 
 /**
  * Free a string object.
@@ -64,7 +66,7 @@ hg_string_object_init_const_char(hg_string_object_t *string, const char *s, hg_b
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_string_object_free(hg_string_object_t *string);
 
 /**
@@ -75,7 +77,7 @@ hg_string_object_free(hg_string_object_t *string);
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_string_object_dup(hg_string_object_t string, hg_string_object_t *new_string);
 
 /**
@@ -85,7 +87,7 @@ hg_string_object_dup(hg_string_object_t string, hg_string_object_t *new_string);
  *
  * \return Pointer to string contained by string before the swap
  */
-HG_EXPORT char *
+HG_PUBLIC char *
 hg_string_object_swap(hg_string_object_t *string, char *s);
 
 #ifdef __cplusplus
diff --git a/src/util/mercury_atomic.h b/src/util/mercury_atomic.h
index 4533532..6ece1d7 100644
--- a/src/util/mercury_atomic.h
+++ b/src/util/mercury_atomic.h
@@ -25,13 +25,8 @@ typedef OPA_ptr_t hg_atomic_int64_t; /* OPA has only limited 64-bit support */
 # define HG_ATOMIC_VAR_INIT(x) OPA_PTR_T_INITIALIZER(x)
 #elif defined(HG_UTIL_HAS_STDATOMIC_H)
 # include <stdatomic.h>
-# ifdef __INTEL_COMPILER
 typedef atomic_int hg_atomic_int32_t;
 typedef atomic_llong hg_atomic_int64_t;
-# else
-typedef _Atomic hg_util_int32_t hg_atomic_int32_t;
-typedef _Atomic hg_util_int64_t hg_atomic_int64_t;
-# endif
 # define HG_ATOMIC_VAR_INIT(x) ATOMIC_VAR_INIT(x)
 #elif defined(__APPLE__)
 # include <libkern/OSAtomic.h>
@@ -94,7 +89,6 @@ hg_atomic_incr32(hg_atomic_int32_t *ptr);
 static HG_UTIL_INLINE hg_util_int32_t
 hg_atomic_decr32(hg_atomic_int32_t *ptr);
 
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
 /**
  * OR atomic value (32-bit integer).
  *
@@ -127,7 +121,6 @@ hg_atomic_xor32(hg_atomic_int32_t *ptr, hg_util_int32_t value);
  */
 static HG_UTIL_INLINE hg_util_int32_t
 hg_atomic_and32(hg_atomic_int32_t *ptr, hg_util_int32_t value);
-#endif
 
 /**
  * Compare and swap values (32-bit integer).
@@ -171,7 +164,6 @@ hg_atomic_set64(hg_atomic_int64_t *ptr, hg_util_int64_t value);
 static HG_UTIL_INLINE hg_util_int64_t
 hg_atomic_get64(hg_atomic_int64_t *ptr);
 
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
 /**
  * Increment atomic value (64-bit integer).
  *
@@ -192,7 +184,6 @@ hg_atomic_incr64(hg_atomic_int64_t *ptr);
 static HG_UTIL_INLINE hg_util_int64_t
 hg_atomic_decr64(hg_atomic_int64_t *ptr);
 
-#if defined(_WIN32) || defined(HG_UTIL_HAS_STDATOMIC_H)
 /**
  * OR atomic value (64-bit integer).
  *
@@ -226,9 +217,6 @@ hg_atomic_xor64(hg_atomic_int64_t *ptr, hg_util_int64_t value);
 static HG_UTIL_INLINE hg_util_int64_t
 hg_atomic_and64(hg_atomic_int64_t *ptr, hg_util_int64_t value);
 
-#endif /* defined(_WIN32) || defined(HG_UTIL_HAS_STDATOMIC_H) */
-#endif /* !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H) */
-
 /**
  * Compare and swap values (64-bit integer).
  *
@@ -341,7 +329,6 @@ hg_atomic_decr32(hg_atomic_int32_t *ptr)
     return ret;
 }
 
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_int32_t
 hg_atomic_or32(hg_atomic_int32_t *ptr, hg_util_int32_t value)
@@ -350,12 +337,14 @@ hg_atomic_or32(hg_atomic_int32_t *ptr, hg_util_int32_t value)
 
 #if defined(_WIN32)
     ret = InterlockedOrNoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_or_explicit(ptr, value, memory_order_acq_rel);
 #elif defined(__APPLE__)
     ret = OSAtomicOr32Orig((uint32_t) value, (volatile uint32_t *) &ptr->value);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get32(ptr);
+    } while (!hg_atomic_cas32(ptr, ret, (ret | value)));
 #endif
 
     return ret;
@@ -369,12 +358,14 @@ hg_atomic_xor32(hg_atomic_int32_t *ptr, hg_util_int32_t value)
 
 #if defined(_WIN32)
     ret = InterlockedXorNoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_xor_explicit(ptr, value, memory_order_acq_rel);
 #elif defined(__APPLE__)
     ret = OSAtomicXor32Orig((uint32_t) value, (volatile uint32_t *) &ptr->value);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get32(ptr);
+    } while (!hg_atomic_cas32(ptr, ret, (ret ^ value)));
 #endif
 
     return ret;
@@ -388,17 +379,18 @@ hg_atomic_and32(hg_atomic_int32_t *ptr, hg_util_int32_t value)
 
 #if defined(_WIN32)
     ret = InterlockedAndNoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_and_explicit(ptr, value, memory_order_acq_rel);
 #elif defined(__APPLE__)
     ret = OSAtomicAnd32Orig((uint32_t) value, (volatile uint32_t *) &ptr->value);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get32(ptr);
+    } while (!hg_atomic_cas32(ptr, ret, (ret & value)));
 #endif
 
     return ret;
 }
-#endif /* !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H) */
 
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_bool_t
@@ -473,7 +465,6 @@ hg_atomic_get64(hg_atomic_int64_t *ptr)
     return ret;
 }
 
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_int64_t
 hg_atomic_incr64(hg_atomic_int64_t *ptr)
@@ -482,12 +473,15 @@ hg_atomic_incr64(hg_atomic_int64_t *ptr)
 
 #if defined(_WIN32)
     ret = InterlockedIncrementNoFence64(&ptr->value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_add_explicit(ptr, 1, memory_order_acq_rel) + 1;
 #elif defined(__APPLE__)
     ret = OSAtomicIncrement64(&ptr->value);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get64(ptr);
+    } while (!hg_atomic_cas64(ptr, ret, ret + 1));
+    ret++;
 #endif
 
     return ret;
@@ -501,18 +495,20 @@ hg_atomic_decr64(hg_atomic_int64_t *ptr)
 
 #if defined(_WIN32)
     ret = InterlockedDecrementNoFence64(&ptr->value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_sub_explicit(ptr, 1, memory_order_acq_rel) - 1;
 #elif defined(__APPLE__)
     ret = OSAtomicDecrement64(&ptr->value);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get64(ptr);
+    } while (!hg_atomic_cas64(ptr, ret, ret - 1));
+    ret--;
 #endif
 
     return ret;
 }
 
-#if defined(_WIN32) || defined(HG_UTIL_HAS_STDATOMIC_H)
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_int64_t
 hg_atomic_or64(hg_atomic_int64_t *ptr, hg_util_int64_t value)
@@ -521,10 +517,12 @@ hg_atomic_or64(hg_atomic_int64_t *ptr, hg_util_int64_t value)
 
 #if defined(_WIN32)
     ret = InterlockedOr64NoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_or_explicit(ptr, value, memory_order_acq_rel);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get64(ptr);
+    } while (!hg_atomic_cas64(ptr, ret, (ret | value)));
 #endif
 
     return ret;
@@ -538,10 +536,12 @@ hg_atomic_xor64(hg_atomic_int64_t *ptr, hg_util_int64_t value)
 
 #if defined(_WIN32)
     ret = InterlockedXor64NoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_xor_explicit(ptr, value, memory_order_acq_rel);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get64(ptr);
+    } while (!hg_atomic_cas64(ptr, ret, (ret ^ value)));
 #endif
 
     return ret;
@@ -555,16 +555,16 @@ hg_atomic_and64(hg_atomic_int64_t *ptr, hg_util_int64_t value)
 
 #if defined(_WIN32)
     ret = InterlockedAnd64NoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_and_explicit(ptr, value, memory_order_acq_rel);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get64(ptr);
+    } while (!hg_atomic_cas64(ptr, ret, (ret & value)));
 #endif
 
     return ret;
 }
-#endif /* defined(_WIN32) || defined(HG_UTIL_HAS_STDATOMIC_H) */
-#endif /* !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H) */
 
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_bool_t
diff --git a/src/util/mercury_log.c b/src/util/mercury_log.c
index 7e18319..e17e973 100644
--- a/src/util/mercury_log.c
+++ b/src/util/mercury_log.c
@@ -57,7 +57,7 @@ hg_log_set_stream_error(FILE *stream)
 
 /*---------------------------------------------------------------------------*/
 void
-hg_log_write(hg_log_type_t log_type, const char *module, const char *file,
+hg_log_write(unsigned int log_type, const char *module, const char *file,
     unsigned int line, const char *func, const char *format, ...)
 {
     char buf[HG_UTIL_LOG_MAX_BUF];
diff --git a/src/util/mercury_log.h b/src/util/mercury_log.h
index bec44c3..d6eb11e 100644
--- a/src/util/mercury_log.h
+++ b/src/util/mercury_log.h
@@ -15,11 +15,10 @@
 
 #include <stdio.h>
 
-typedef enum {
-    HG_LOG_TYPE_DEBUG,
-    HG_LOG_TYPE_WARNING,
-    HG_LOG_TYPE_ERROR
-} hg_log_type_t;
+#define HG_LOG_TYPE_NONE    0
+#define HG_LOG_TYPE_DEBUG   0x01
+#define HG_LOG_TYPE_WARNING 0x02
+#define HG_LOG_TYPE_ERROR   0x04
 
 /* For compatibility */
 #if defined(__STDC_VERSION__) &&  (__STDC_VERSION__ < 199901L)
@@ -92,7 +91,7 @@ hg_log_set_stream_error(FILE *stream);
  * \param format [IN]           string format
  */
 HG_UTIL_EXPORT void
-hg_log_write(hg_log_type_t log_type, const char *module, const char *file,
+hg_log_write(unsigned int log_type, const char *module, const char *file,
     unsigned int line, const char *func, const char *format, ...);
 
 #ifdef __cplusplus
diff --git a/src/util/mercury_thread.h b/src/util/mercury_thread.h
index 596c7e3..a90855c 100644
--- a/src/util/mercury_thread.h
+++ b/src/util/mercury_thread.h
@@ -109,6 +109,22 @@ HG_UTIL_EXPORT int
 hg_thread_yield(void);
 
 /**
+ * Obtain handle of the calling thread.
+ *
+ * \return
+ */
+static HG_UTIL_INLINE hg_thread_t
+hg_thread_self(void);
+
+/**
+ * Compare thread IDs.
+ *
+ * \return Non-zero if equal, zero if not equal
+ */
+static HG_UTIL_INLINE int
+hg_thread_equal(hg_thread_t t1, hg_thread_t t2);
+
+/**
  * Create a thread-specific data key visible to all threads in the process.
  *
  * \param key [OUT]             pointer to thread key object
@@ -173,6 +189,28 @@ HG_UTIL_EXPORT int
 hg_thread_setaffinity(hg_thread_t thread, const hg_cpu_set_t *cpu_mask);
 
 /*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE hg_thread_t
+hg_thread_self(void)
+{
+#ifdef _WIN32
+    return GetCurrentThread();
+#else
+    return pthread_self();
+#endif
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE int
+hg_thread_equal(hg_thread_t t1, hg_thread_t t2)
+{
+#ifdef _WIN32
+    return GetThreadId(t1) == GetThreadId(t2);
+#else
+    return pthread_equal(t1, t2);
+#endif
+}
+
+/*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE void *
 hg_thread_getspecific(hg_thread_key_t key)
 {
