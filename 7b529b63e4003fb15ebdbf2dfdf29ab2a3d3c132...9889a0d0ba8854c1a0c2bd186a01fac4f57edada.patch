diff --git a/Testing/na/na_test.c b/Testing/na/na_test.c
index 0a48600..1eb1398 100644
--- a/Testing/na/na_test.c
+++ b/Testing/na/na_test.c
@@ -80,6 +80,7 @@ na_test_usage(const char *execname)
     printf("    -h, --help          Print a usage message and exit\n");
     printf("    -c, --comm          Select NA plugin\n"
            "                        NA plugins: bmi, mpi, cci, etc\n");
+    printf("    -d, --domain        Select NA OFI domain\n");
     printf("    -p, --protocol      Select plugin protocol\n"
            "                        Available protocols: tcp, ib, etc\n");
     printf("    -H, --hostname      Select hostname / IP address to use\n"
@@ -116,6 +117,9 @@ na_test_parse_options(int argc, char *argv[],
                 if (!na_test_info->comm)
                     na_test_info->comm = strdup(na_test_opt_arg_g);
                 break;
+            case 'd': /* Domain */
+                na_test_info->domain = strdup(na_test_opt_arg_g);
+                break;
             case 'p': /* Protocol */
                 /* Prevent from overriding protocol */
                 if (!na_test_info->protocol)
@@ -161,7 +165,7 @@ na_test_parse_options(int argc, char *argv[],
     }
     na_test_opt_ind_g = 1;
 
-    if (!na_test_info->comm || ! na_test_info->protocol) {
+    if (!na_test_info->protocol) {
         na_test_usage(argv[0]);
         exit(1);
     }
@@ -267,8 +271,11 @@ na_test_gen_config(struct na_test_info *na_test_info)
     }
     memset(info_string, '\0', NA_TEST_MAX_ADDR_NAME);
     info_string_ptr = info_string;
-    info_string_ptr += sprintf(info_string_ptr, "%s+%s", na_test_info->comm,
-        na_test_info->protocol);
+    if (na_test_info->comm)
+        info_string_ptr += sprintf(info_string_ptr, "%s+", na_test_info->comm);
+    info_string_ptr += sprintf(info_string_ptr, "%s://", na_test_info->protocol);
+    if (na_test_info->domain)
+        info_string_ptr += sprintf(info_string_ptr, "%s/", na_test_info->domain);
 
     if (strcmp("sm", na_test_info->protocol) == 0) {
 #if defined(PR_SET_PTRACER) && defined(PR_SET_PTRACER_ANY)
@@ -291,7 +298,7 @@ na_test_gen_config(struct na_test_info *na_test_info)
 #endif
         if (na_test_info->listen) {
             /* special-case SM (pid:id) */
-            sprintf(info_string_ptr, "://%d/%d", (int) getpid(), port_incr);
+            sprintf(info_string_ptr, "%d/%d", (int) getpid(), port_incr);
         }
     } else if ((strcmp("tcp", na_test_info->protocol) == 0)
         || (strcmp("verbs;ofi_rxm", na_test_info->protocol) == 0)
@@ -302,17 +309,17 @@ na_test_gen_config(struct na_test_info *na_test_info)
             /* Nothing */
         } else if (na_test_info->listen) {
             base_port += (unsigned int) na_test_info->mpi_comm_rank;
-            sprintf(info_string_ptr, "://%s:%d", na_test_info->hostname,
+            sprintf(info_string_ptr, "%s:%d", na_test_info->hostname,
                 base_port + port_incr);
         } else
-            sprintf(info_string_ptr, "://%s", na_test_info->hostname);
+            sprintf(info_string_ptr, "%s", na_test_info->hostname);
     } else if (strcmp("static", na_test_info->protocol) == 0) {
         /* Nothing */
     } else if (strcmp("dynamic", na_test_info->protocol) == 0) {
         /* Nothing */
     } else if (strcmp("gni", na_test_info->protocol) == 0) {
         base_port += (unsigned int) na_test_info->mpi_comm_rank;
-        sprintf(info_string_ptr, "://%s:%d", na_test_info->hostname,
+        sprintf(info_string_ptr, "%s:%d", na_test_info->hostname,
             base_port + port_incr);
     } else {
         NA_LOG_ERROR("Unknown protocol: %s", na_test_info->protocol);
diff --git a/Testing/na/na_test.h b/Testing/na/na_test.h
index 62c1b61..8290198 100644
--- a/Testing/na/na_test.h
+++ b/Testing/na/na_test.h
@@ -27,6 +27,7 @@ struct na_test_info {
     na_class_t *na_class;       /* NA class */
     char *target_name;          /* Target name */
     char *comm;                 /* Comm/Plugin name */
+    char *domain;               /* Domain name */
     char *protocol;             /* Protocol name */
     char *hostname;             /* Hostname */
     na_bool_t listen;           /* Listen */
diff --git a/Testing/na/na_test_getopt.c b/Testing/na/na_test_getopt.c
index 3f2005d..54f9c8d 100644
--- a/Testing/na/na_test_getopt.c
+++ b/Testing/na/na_test_getopt.c
@@ -17,10 +17,11 @@
 
 int na_test_opt_ind_g = 1; /* token pointer */
 const char *na_test_opt_arg_g = NULL; /* flag argument (or value) */
-const char *na_test_short_opt_g = "hc:p:H:LsSak:l:t:bmC:V";
+const char *na_test_short_opt_g = "hc:d:p:H:LsSak:l:t:bmC:V";
 const struct na_test_opt na_test_opt_g[] = {
     { "help", no_arg, 'h'},
     { "comm", require_arg, 'c' },
+    { "domain", require_arg, 'd' },
     { "protocol", require_arg, 'p' },
     { "hostname", require_arg, 'H' },
     { "listen", no_arg, 'L' },
diff --git a/Testing/script/travis_build.sh b/Testing/script/travis_build.sh
index 69001c8..0955e7d 100755
--- a/Testing/script/travis_build.sh
+++ b/Testing/script/travis_build.sh
@@ -2,10 +2,10 @@
 
 BMI_VERSION=master
 CMAKE_VERSION_MAJOR=3.15
-CMAKE_VERSION_MINOR=3
+CMAKE_VERSION_MINOR=5
 MPI_VERSION=3.3.1
 CCI_VERSION=2.1
-OFI_VERSION=1.8.1
+OFI_VERSION=1.9.0rc2
 PREFIX=$HOME/install
 
 set -e
diff --git a/Testing/test_rpc.c b/Testing/test_rpc.c
index 67834dd..789ca88 100644
--- a/Testing/test_rpc.c
+++ b/Testing/test_rpc.c
@@ -9,6 +9,7 @@
  */
 
 #include "mercury_test.h"
+#include "mercury_hl.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -178,6 +179,75 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
+hg_test_rpc_lookup(hg_context_t *context, hg_request_class_t *request_class,
+    const char *target_name, hg_id_t rpc_id, hg_cb_t callback)
+{
+    hg_request_t *request = NULL;
+    hg_handle_t handle;
+    hg_return_t hg_ret = HG_SUCCESS;
+    struct forward_cb_args forward_cb_args;
+    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    rpc_handle_t rpc_open_handle;
+    rpc_open_in_t  rpc_open_in_struct;
+    hg_addr_t target_addr = HG_ADDR_NULL;
+    int i;
+
+    for (i = 0; i < 32; i++) {
+        request = hg_request_create(request_class);
+
+        /* Look up target addr using target name info */
+        hg_ret = HG_Hl_addr_lookup_wait(context, request_class, target_name,
+            &target_addr, HG_MAX_IDLE_TIME);
+        if (hg_ret != HG_SUCCESS)
+            goto done;
+
+        /* Create RPC request */
+        hg_ret = HG_Create(context, target_addr, rpc_id, &handle);
+        if (hg_ret != HG_SUCCESS) {
+            if (hg_ret != HG_NO_MATCH)
+                HG_TEST_LOG_ERROR("Could not create handle");
+            goto done;
+        }
+
+        /* Fill input structure */
+        rpc_open_handle.cookie = 100;
+        rpc_open_in_struct.path = rpc_open_path;
+        rpc_open_in_struct.handle = rpc_open_handle;
+
+        /* Forward call to remote addr and get a new request */
+        HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
+        forward_cb_args.request = request;
+        forward_cb_args.rpc_handle = &rpc_open_handle;
+        hg_ret = HG_Forward(handle, callback, &forward_cb_args,
+            &rpc_open_in_struct);
+        if (hg_ret != HG_SUCCESS) {
+            HG_TEST_LOG_ERROR("Could not forward call");
+            goto done;
+        }
+
+        hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+        /* Complete */
+        hg_ret = HG_Destroy(handle);
+        if (hg_ret != HG_SUCCESS) {
+            HG_TEST_LOG_ERROR("Could not destroy handle");
+            goto done;
+        }
+
+        HG_Addr_set_remove(context->hg_class, target_addr);
+        HG_Addr_free(context->hg_class, target_addr);
+        target_addr = HG_ADDR_NULL;
+        hg_request_destroy(request);
+        request = NULL;
+    }
+
+done:
+    hg_request_destroy(request);
+    return hg_ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
 hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
@@ -458,6 +528,30 @@ main(int argc, char *argv[])
     }
     HG_PASSED();
 
+    /* RPC test with lookup/free */
+    if (!hg_test_info.na_test_info.self_send &&
+        strcmp(HG_Class_get_name(hg_test_info.hg_class), "mpi")) {
+        HG_TEST("lookup RPC");
+        HG_Addr_free(hg_test_info.hg_class, hg_test_info.target_addr);
+        hg_test_info.target_addr = HG_ADDR_NULL;
+        hg_ret = hg_test_rpc_lookup(hg_test_info.context, hg_test_info.request_class,
+            hg_test_info.na_test_info.target_name, hg_test_rpc_open_id_g,
+            hg_test_rpc_forward_cb);
+        if (hg_ret != HG_SUCCESS) {
+            ret = EXIT_FAILURE;
+            goto done;
+        }
+        /* Look up target addr using target name info */
+        hg_ret = HG_Hl_addr_lookup_wait(hg_test_info.context,
+            hg_test_info.request_class, hg_test_info.na_test_info.target_name,
+            &hg_test_info.target_addr, HG_MAX_IDLE_TIME);
+        if (ret != HG_SUCCESS) {
+            ret = EXIT_FAILURE;
+            goto done;
+        }
+        HG_PASSED();
+    }
+
     /* RPC reset test */
     HG_TEST("RPC reset");
     hg_ret = hg_test_rpc_reset(hg_test_info.context, hg_test_info.request_class,
diff --git a/Testing/util/test_thread.c b/Testing/util/test_thread.c
index 1888b33..0312b5d 100644
--- a/Testing/util/test_thread.c
+++ b/Testing/util/test_thread.c
@@ -56,6 +56,20 @@ done:
     return thread_ret;
 }
 
+static HG_THREAD_RETURN_TYPE
+thread_cb_equal(void *arg)
+{
+    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
+    hg_thread_t *t1_ptr = (hg_thread_t *) arg;
+    hg_thread_t t2 = hg_thread_self();
+
+    if (hg_thread_equal(*t1_ptr, t2) == 0)
+        fprintf(stderr, "Error: t1 is not equal to t2\n");
+
+    hg_thread_exit(thread_ret);
+    return thread_ret;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -86,6 +100,9 @@ main(int argc, char *argv[])
     hg_thread_join(thread);
     hg_thread_key_delete(thread_key);
 
+    hg_thread_create(&thread, thread_cb_equal, &thread);
+    hg_thread_join(thread);
+
 done:
     return ret;
 }
diff --git a/src/mercury.c b/src/mercury.c
index d9ad358..d45c9d0 100644
--- a/src/mercury.c
+++ b/src/mercury.c
@@ -1670,6 +1670,24 @@ done:
 
 /*---------------------------------------------------------------------------*/
 hg_return_t
+HG_Addr_set_remove(hg_class_t *hg_class, hg_addr_t addr)
+{
+    hg_return_t ret = HG_SUCCESS;
+
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    ret = HG_Core_addr_set_remove(hg_class->core_class, (hg_core_addr_t) addr);
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
 HG_Addr_self(hg_class_t *hg_class, hg_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
diff --git a/src/mercury.h b/src/mercury.h
index de4705a..397ed22 100644
--- a/src/mercury.h
+++ b/src/mercury.h
@@ -589,7 +589,7 @@ HG_Addr_lookup(
         );
 
 /**
- * Free the addr from the list of peers.
+ * Free the addr.
  *
  * \param hg_class [IN]         pointer to HG class
  * \param addr [IN]             abstract address
@@ -603,6 +603,23 @@ HG_Addr_free(
         );
 
 /**
+ * Hint that the address is no longer valid. This may happen if the peer is
+ * no longer responding. This can be used to force removal of the
+ * peer address from the list of the peers, before freeing it and reclaim
+ * resources.
+ *
+ * \param hg_class [IN]         pointer to HG class
+ * \param addr [IN]             abstract address
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_EXPORT hg_return_t
+HG_Addr_set_remove(
+        hg_class_t *hg_class,
+        hg_addr_t   addr
+        );
+
+/**
  * Access self address. Address must be freed with HG_Addr_free().
  *
  * \param hg_class [IN]         pointer to HG class
diff --git a/src/mercury_core.c b/src/mercury_core.c
index f426497..053a7c0 100644
--- a/src/mercury_core.c
+++ b/src/mercury_core.c
@@ -4372,6 +4372,33 @@ done:
 
 /*---------------------------------------------------------------------------*/
 hg_return_t
+HG_Core_addr_set_remove(hg_core_class_t *hg_core_class, hg_core_addr_t addr)
+{
+    struct hg_core_private_addr *hg_core_addr =
+        (struct hg_core_private_addr *) addr;
+    hg_return_t ret = HG_SUCCESS;
+    na_return_t na_ret;
+
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    na_ret = NA_Addr_set_remove(hg_core_addr->core_addr.na_class,
+        hg_core_addr->core_addr.na_addr);
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not set address to be removed");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
 HG_Core_addr_self(hg_core_class_t *hg_core_class, hg_core_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
diff --git a/src/mercury_core.h b/src/mercury_core.h
index 072a865..27eaa27 100644
--- a/src/mercury_core.h
+++ b/src/mercury_core.h
@@ -580,6 +580,23 @@ HG_Core_addr_free(
         );
 
 /**
+ * Hint that the address is no longer valid. This may happen if the peer is
+ * no longer responding. This can be used to force removal of the
+ * peer address from the list of the peers, before freeing it and reclaim
+ * resources.
+ *
+ * \param hg_core_class [IN]    pointer to HG core class
+ * \param addr [IN]             abstract address
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_EXPORT hg_return_t
+HG_Core_addr_set_remove(
+        hg_core_class_t *hg_core_class,
+        hg_core_addr_t addr
+        );
+
+/**
  * Set the underlying NA address to a HG address.
  *
  * \param core_addr [IN]        abstract address that not set NA address before
diff --git a/src/na/na.c b/src/na/na.c
index 08373e3..869cdb0 100644
--- a/src/na/na.c
+++ b/src/na/na.c
@@ -226,8 +226,9 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
 {
     struct na_private_class *na_private_class = NULL;
     struct na_info *na_info = NULL;
-    unsigned int plugin_index = 0;
-    unsigned int plugin_count = 0;
+    unsigned int plugin_index;
+    const unsigned int plugin_count =
+        sizeof(na_class_table) / sizeof(na_class_table[0]) - 1;
     na_bool_t plugin_found = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
 
@@ -240,8 +241,6 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
         "Could not allocate class");
     memset(na_private_class, 0, sizeof(struct na_private_class));
 
-    plugin_count = sizeof(na_class_table) / sizeof(na_class_table[0]) - 1;
-
     ret = na_info_parse(info_string, &na_info);
     NA_CHECK_NA_ERROR(error, ret, "Could not parse host string");
 
@@ -253,7 +252,7 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
     na_info_print(na_info);
 #endif
 
-    while (plugin_index < plugin_count) {
+    for (plugin_index = 0; plugin_index < plugin_count; plugin_index++) {
         na_bool_t verified = NA_FALSE;
 
         NA_CHECK_ERROR(na_class_table[plugin_index]->class_name == NULL, error,
@@ -266,20 +265,17 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
         /* Skip check protocol if class name does not match */
         if (na_info->class_name) {
             if (strcmp(na_class_table[plugin_index]->class_name,
-                na_info->class_name) != 0) {
-                plugin_index++;
+                na_info->class_name) != 0)
                 continue;
-            }
         }
 
         /* Check that protocol is supported */
         verified = na_class_table[plugin_index]->check_protocol(
             na_info->protocol_name);
         if (!verified) {
-            NA_CHECK_ERROR(na_info->class_name == NULL, error, ret,
+            NA_CHECK_ERROR(na_info->class_name, error, ret,
                 NA_PROTOCOL_ERROR,
                 "Specified class name does not support requested protocol");
-            plugin_index++;
             continue;
         }
 
@@ -681,6 +677,27 @@ done:
 
 /*---------------------------------------------------------------------------*/
 na_return_t
+NA_Addr_set_remove(na_class_t *na_class, na_addr_t addr)
+{
+    na_return_t ret = NA_SUCCESS;
+
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    if (addr == NA_ADDR_NULL)
+        /* Nothing to do */
+        goto done;
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    if (na_class->ops->addr_set_remove)
+        ret = na_class->ops->addr_set_remove(na_class, addr);
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+na_return_t
 NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
     na_addr_t addr)
 {
diff --git a/src/na/na.h b/src/na/na.h
index 8d0874e..eba537b 100644
--- a/src/na/na.h
+++ b/src/na/na.h
@@ -264,6 +264,23 @@ NA_Addr_free(
         );
 
 /**
+ * Hint that the address is no longer valid. This may happen if the peer is
+ * no longer responding. This can be used to force removal of the
+ * peer address from the list of the peers, before freeing it and reclaim
+ * resources.
+ *
+ * \param na_class [IN/OUT]     pointer to NA class
+ * \param addr [IN]             abstract address
+ *
+ * \return NA_SUCCESS or corresponding NA error code
+ */
+NA_EXPORT na_return_t
+NA_Addr_set_remove(
+        na_class_t *na_class,
+        na_addr_t   addr
+        );
+
+/**
  * Access self address.
  *
  * \param na_class [IN/OUT]     pointer to NA class
@@ -1150,6 +1167,11 @@ struct na_class_ops {
             na_addr_t   addr
             );
     na_return_t
+    (*addr_set_remove)(
+            na_class_t *na_class,
+            na_addr_t   addr
+            );
+    na_return_t
     (*addr_self)(
             na_class_t *na_class,
             na_addr_t  *addr
diff --git a/src/na/na_bmi.c b/src/na/na_bmi.c
index 7902e43..40eab78 100644
--- a/src/na/na_bmi.c
+++ b/src/na/na_bmi.c
@@ -515,6 +515,7 @@ NA_PLUGIN_OPS(bmi) = {
         na_bmi_addr_lookup,                   /* addr_lookup */
         NULL,                                 /* addr_lookup2 */
         na_bmi_addr_free,                     /* addr_free */
+        NULL,                                 /* addr_set_remove */
         na_bmi_addr_self,                     /* addr_self */
         na_bmi_addr_dup,                      /* addr_dup */
         na_bmi_addr_is_self,                  /* addr_is_self */
diff --git a/src/na/na_cci.c b/src/na/na_cci.c
index dbc21fb..a105133 100644
--- a/src/na/na_cci.c
+++ b/src/na/na_cci.c
@@ -373,6 +373,7 @@ NA_PLUGIN_OPS(cci) = {
     na_cci_addr_lookup,                     /* addr_lookup */
     NULL,                                   /* addr_lookup2 */
     na_cci_addr_free,                       /* addr_free */
+    NULL,                                   /* addr_set_remove */
     na_cci_addr_self,                       /* addr_self */
     na_cci_addr_dup,                        /* addr_dup */
     na_cci_addr_is_self,                    /* addr_is_self */
diff --git a/src/na/na_mpi.c b/src/na/na_mpi.c
index a070e6c..637a97e 100644
--- a/src/na/na_mpi.c
+++ b/src/na/na_mpi.c
@@ -544,6 +544,7 @@ NA_PLUGIN_OPS(mpi) = {
         na_mpi_addr_lookup,                   /* addr_lookup */
         NULL,                                 /* addr_lookup2 */
         na_mpi_addr_free,                     /* addr_free */
+        NULL,                                 /* addr_set_remove */
         na_mpi_addr_self,                     /* addr_self */
         NULL,                                 /* addr_dup */
         na_mpi_addr_is_self,                  /* addr_is_self */
diff --git a/src/na/na_ofi.c b/src/na/na_ofi.c
index 1cd6556..5a2540e 100644
--- a/src/na/na_ofi.c
+++ b/src/na/na_ofi.c
@@ -130,7 +130,7 @@
         "",                                                             \
         FI_SOCKADDR_IN,                                                 \
         FI_PROGRESS_AUTO,                                               \
-        FI_DIRECTED_RECV,                                               \
+        (FI_SOURCE | FI_DIRECTED_RECV),                                 \
         (NA_OFI_VERIFY_PROV_DOM | NA_OFI_WAIT_FD)                       \
     )                                                                   \
     X(NA_OFI_PROV_TCP,                                                  \
@@ -138,7 +138,7 @@
         "tcp",                                                          \
         FI_SOCKADDR_IN,                                                 \
         FI_PROGRESS_MANUAL,                                             \
-        FI_DIRECTED_RECV,                                               \
+        (FI_SOURCE | FI_DIRECTED_RECV),                                 \
         (NA_OFI_WAIT_FD | NA_OFI_NO_SEP | NA_OFI_SKIP_SIGNAL)           \
     )                                                                   \
     X(NA_OFI_PROV_PSM2,                                                 \
@@ -154,7 +154,7 @@
         "verbs",                                                        \
         FI_SOCKADDR_IN,                                                 \
         FI_PROGRESS_MANUAL,                                             \
-        (FI_DIRECTED_RECV),                                             \
+        (FI_SOURCE | FI_DIRECTED_RECV),                                 \
         (NA_OFI_VERIFY_PROV_DOM | NA_OFI_WAIT_FD | NA_OFI_NO_SEP | NA_OFI_SKIP_SIGNAL)   \
     )                                                                   \
     X(NA_OFI_PROV_GNI,                                                  \
@@ -239,9 +239,10 @@ struct na_ofi_addr {
     na_size_t addrlen;                      /* Native address len       */
     char *uri;                              /* Generated URI            */
     fi_addr_t fi_addr;                      /* FI address               */
+    na_uint64_t ht_key;                     /* Key in hash-table        */
     hg_atomic_int32_t refcount;             /* Reference counter        */
     na_bool_t self;                         /* Boolean for self         */
-    na_bool_t unexpected;                   /* Boolean for unexpected   */
+    na_bool_t remove;                       /* Remove from AV on free   */
 };
 
 /* SIN address */
@@ -371,7 +372,6 @@ struct na_ofi_domain {
     char *prov_name;                        /* Provider name            */
     enum na_ofi_prov_type prov_type;        /* Provider type            */
     hg_atomic_int32_t refcount;             /* Refcount of this domain  */
-
 };
 
 /**
@@ -491,8 +491,23 @@ na_ofi_addr_ht_key_equal(hg_hash_table_key_t vlocation1,
  * already exist.
  */
 static na_return_t
-na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
-    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr);
+na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
+    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key);
+
+/**
+ * Remove an addr from the AV and the hash-table.
+ */
+static na_return_t
+na_ofi_addr_ht_remove(struct na_ofi_domain *domain, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key);
+
+/**
+ * Lookup an FI addr from the AV.
+ */
+static na_return_t
+na_ofi_av_lookup(struct na_ofi_domain *na_ofi_domain, fi_addr_t fi_addr,
+    void **addr_ptr, size_t *addrlen_ptr);
 
 /**
  * Get info caps from providers and return matching providers.
@@ -682,10 +697,9 @@ na_ofi_msg_unexpected_op_pop(na_context_t *context);
  * Read from CQ.
  */
 static na_return_t
-na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
-    size_t max_count, struct fi_cq_tagged_entry cq_events[],
-    fi_addr_t src_addrs[], void **src_err_addr, size_t *src_err_addrlen,
-    size_t *actual_count);
+na_ofi_cq_read(na_context_t *context, size_t max_count,
+    struct fi_cq_tagged_entry cq_events[], fi_addr_t src_addrs[],
+    void **src_err_addr, size_t *src_err_addrlen, size_t *actual_count);
 
 /**
  * Process event from CQ.
@@ -789,6 +803,10 @@ na_ofi_addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr);
 static NA_INLINE na_return_t
 na_ofi_addr_free(na_class_t *na_class, na_addr_t addr);
 
+/* addr_set_remove */
+static NA_INLINE na_return_t
+na_ofi_addr_set_remove(na_class_t *na_class, na_addr_t addr);
+
 /* addr_is_self */
 static NA_INLINE na_bool_t
 na_ofi_addr_is_self(na_class_t *na_class, na_addr_t addr);
@@ -944,6 +962,7 @@ NA_PLUGIN_OPS(ofi) = {
     na_ofi_addr_lookup,                     /* addr_lookup */
     na_ofi_addr_lookup2,                    /* addr_lookup2 */
     na_ofi_addr_free,                       /* addr_free */
+    na_ofi_addr_set_remove,                 /* addr_set_remove */
     na_ofi_addr_self,                       /* addr_self */
     na_ofi_addr_dup,                        /* addr_dup */
     na_ofi_addr_is_self,                    /* addr_is_self */
@@ -1249,47 +1268,47 @@ na_ofi_addr_ht_key_equal(hg_hash_table_key_t vlocation1,
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
-    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr)
+na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
+    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
-    na_uint64_t addr_key;
-    hg_hash_table_key_t ht_key = NULL;
+    hg_hash_table_key_t ht_key = addr_key;
     hg_hash_table_value_t ht_value = NULL;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
     /* Generate key */
-    addr_key = na_ofi_addr_to_key(addr_format, addr, addrlen);
-    NA_CHECK_ERROR(addr_key == 0, out, ret, NA_PROTOCOL_ERROR,
+    *addr_key = na_ofi_addr_to_key(addr_format, addr, addrlen);
+    NA_CHECK_ERROR(*addr_key == 0, out, ret, NA_PROTOCOL_ERROR,
         "Could not generate key from addr");
 
     /* Lookup key */
     hg_thread_rwlock_rdlock(&domain->rwlock);
-    ht_value = hg_hash_table_lookup(domain->addr_ht, &addr_key);
+    ht_value = hg_hash_table_lookup(domain->addr_ht, ht_key);
     hg_thread_rwlock_release_rdlock(&domain->rwlock);
     if (ht_value != HG_HASH_TABLE_NULL) {
+        /* Found */
         *fi_addr = *(fi_addr_t *) ht_value;
-        return ret;
+        goto out;
     }
 
     /* Insert addr into AV if key not found */
     na_ofi_domain_lock(domain);
-    rc = fi_av_insert(domain->fi_av, addr, 1, fi_addr, 0 /* flags */,
-        NULL /* context */);
+    rc = fi_av_insert(domain->fi_av, addr, 1, fi_addr, 0 /* flags */, NULL);
     na_ofi_domain_unlock(domain);
     NA_CHECK_ERROR(rc < 1, out, ret, NA_PROTOCOL_ERROR,
         "fi_av_insert() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
     hg_thread_rwlock_wrlock(&domain->rwlock);
 
-    ht_value = hg_hash_table_lookup(domain->addr_ht, &addr_key);
+    ht_value = hg_hash_table_lookup(domain->addr_ht, ht_key);
     if (ht_value != HG_HASH_TABLE_NULL) {
         /* in race condition, use addr in HT and remove the new addr from AV */
-        fi_av_remove(domain->fi_av, fi_addr, 1, 0);
+        rc = fi_av_remove(domain->fi_av, fi_addr, 1, 0 /* flags */);
+        NA_CHECK_ERROR(rc != 0, unlock, ret, NA_PROTOCOL_ERROR,
+            "fi_av_remove() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
         *fi_addr = *(fi_addr_t *) ht_value;
-        hg_thread_rwlock_release_wrlock(&domain->rwlock);
-        return ret;
+        goto unlock;
     }
 
     /* Allocate new key */
@@ -1302,7 +1321,7 @@ na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
     NA_CHECK_ERROR(ht_value == NULL, error, ret, NA_NOMEM_ERROR,
         "cannot allocate memory for ht_key");
 
-    *((na_uint64_t *) ht_key) = addr_key;
+    *((na_uint64_t *) ht_key) = *addr_key;
     *((na_uint64_t *) ht_value) = *fi_addr;
 
     /* Insert new value */
@@ -1310,6 +1329,7 @@ na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
     NA_CHECK_ERROR(rc == 0, error, ret, NA_NOMEM_ERROR,
         "hg_hash_table_insert() failed");
 
+unlock:
     hg_thread_rwlock_release_wrlock(&domain->rwlock);
 
 out:
@@ -1319,7 +1339,67 @@ error:
     hg_thread_rwlock_release_wrlock(&domain->rwlock);
     free(ht_key);
     free(ht_value);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ofi_addr_ht_remove(struct na_ofi_domain *domain, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key)
+{
+    na_return_t ret = NA_SUCCESS;
+    int rc;
 
+    hg_thread_rwlock_wrlock(&domain->rwlock);
+    rc = hg_hash_table_remove(domain->addr_ht, (hg_hash_table_key_t) addr_key);
+    NA_CHECK_ERROR(rc != 1, unlock, ret, NA_PROTOCOL_ERROR,
+        "hg_hash_table_remove() failed");
+
+    rc = fi_av_remove(domain->fi_av, fi_addr, 1, 0 /* flags */);
+    NA_CHECK_ERROR(rc != 0, unlock, ret, NA_PROTOCOL_ERROR,
+        "fi_av_remove() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+
+unlock:
+    hg_thread_rwlock_release_wrlock(&domain->rwlock);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ofi_av_lookup(struct na_ofi_domain *na_ofi_domain, fi_addr_t fi_addr,
+    void **addr_ptr, size_t *addrlen_ptr)
+{
+    void *addr = NULL;
+    size_t addrlen = na_ofi_domain->fi_prov->src_addrlen;
+    na_bool_t retried = NA_FALSE;
+    na_return_t ret = NA_SUCCESS;
+    int rc;
+
+retry:
+    addr = malloc(addrlen);
+    NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate %zu bytes for address", addrlen);
+
+    /* Lookup address from AV */
+    na_ofi_domain_lock(na_ofi_domain);
+    rc = fi_av_lookup(na_ofi_domain->fi_av, fi_addr, addr, &addrlen);
+    na_ofi_domain_unlock(na_ofi_domain);
+    if (rc == -FI_ETOOSMALL && retried == NA_FALSE) {
+        retried = NA_TRUE;
+        free(addr);
+        goto retry;
+    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_av_lookup() failed, rc: %d(%s)", rc,
+        fi_strerror((int ) -rc));
+
+    *addr_ptr = addr;
+    *addrlen_ptr = addrlen;
+
+    return ret;
+
+error:
+    free(addr);
     return ret;
 }
 
@@ -1613,7 +1693,7 @@ na_ofi_domain_open(struct na_ofi_class *priv, enum na_ofi_prov_type prov_type,
     NA_CHECK_ERROR(na_ofi_domain == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate na_ofi_domain");
     memset(na_ofi_domain, 0, sizeof(struct na_ofi_domain));
-    hg_atomic_set32(&na_ofi_domain->refcount, 1);
+    hg_atomic_init32(&na_ofi_domain->refcount, 1);
 
     /* Init mutex */
     rc = hg_thread_mutex_init(&na_ofi_domain->mutex);
@@ -1790,10 +1870,9 @@ na_ofi_domain_close(struct na_ofi_domain *na_ofi_domain)
         /* Cannot free yet */
         goto out;
 
-    /* inserted to na_ofi_domain_list_g after nod_addr_ht created */
+    /* Remove from domain list (won't remove if not inserted) */
     hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
-    if (na_ofi_domain->addr_ht != NULL)
-        HG_LIST_REMOVE(na_ofi_domain, entry);
+    HG_LIST_REMOVE(na_ofi_domain, entry);
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
 
     /* Close MR */
@@ -2096,23 +2175,20 @@ na_ofi_get_ep_addr(na_class_t *na_class, struct na_ofi_addr **na_ofi_addr_ptr)
     NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate NA OFI addr");
 
-retry_getname:
-    if (retried)
-        free(addr);
+retry:
     addr = malloc(addrlen);
     NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate addr");
 
     rc = fi_getname(&na_ofi_endpoint->fi_ep->fid, addr, &addrlen);
-    if (rc != 0) {
-        if (rc == -FI_ETOOSMALL && retried == NA_FALSE) {
-            retried = NA_TRUE;
-            goto retry_getname;
-        }
-        NA_GOTO_ERROR(error, ret, NA_PROTOCOL_ERROR,
-            "fi_getname() failed, rc: %d(%s), addrlen: %zu", rc,
-            fi_strerror(-rc), addrlen);
+    if (rc == -FI_ETOOSMALL && retried == NA_FALSE) {
+        retried = NA_TRUE;
+        free(addr);
+        goto retry;
     }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_getname() failed, rc: %d(%s), addrlen: %zu", rc, fi_strerror(-rc),
+        addrlen);
 
     na_ofi_addr->addr = addr;
     na_ofi_addr->addrlen = addrlen;
@@ -2138,8 +2214,7 @@ error:
 static na_return_t
 na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_domain *na_ofi_domain = priv->domain;
+    struct na_ofi_domain *na_ofi_domain = NA_OFI_CLASS(na_class)->domain;
     char addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         fi_addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         *fi_addr_str_ptr, *uri = NULL;
@@ -2195,7 +2270,7 @@ na_ofi_addr_alloc(struct na_ofi_domain *na_ofi_domain)
     hg_atomic_incr32(&na_ofi_domain->refcount);
 
     /* One refcount for the caller to hold until addr_free */
-    hg_atomic_set32(&na_ofi_addr->refcount, 1);
+    hg_atomic_init32(&na_ofi_addr->refcount, 1);
 
 out:
     return na_ofi_addr;
@@ -2219,7 +2294,14 @@ na_ofi_addr_decref(struct na_ofi_addr *na_ofi_addr)
     if (hg_atomic_decr32(&na_ofi_addr->refcount))
         return;
 
-    /* TODO need to fi_av_remove? */
+    /* Do not call fi_av_remove() here to prevent multiple insert/remove calls
+     * into AV */
+    if (na_ofi_addr->remove) {
+//        NA_LOG_DEBUG("fi_addr=%" SCNx64 " ht_key=%" SCNx64,
+//            na_ofi_addr->fi_addr, na_ofi_addr->ht_key);
+        na_ofi_addr_ht_remove(na_ofi_addr->domain, &na_ofi_addr->fi_addr,
+            &na_ofi_addr->ht_key);
+    }
     na_ofi_domain_close(na_ofi_addr->domain);
     free(na_ofi_addr->addr);
     free(na_ofi_addr->uri);
@@ -2478,23 +2560,23 @@ na_ofi_msg_unexpected_op_pop(na_context_t *context)
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
-    size_t max_count, struct fi_cq_tagged_entry cq_events[],
-    fi_addr_t src_addrs[], void **src_err_addr, size_t *src_err_addrlen,
-    size_t *actual_count)
+na_ofi_cq_read(na_context_t *context, size_t max_count,
+    struct fi_cq_tagged_entry cq_events[], fi_addr_t src_addrs[],
+    void **src_err_addr, size_t *src_err_addrlen, size_t *actual_count)
 {
     struct fid_cq *cq_hdl = NA_OFI_CONTEXT(context)->fi_cq;
-    char err_data[NA_OFI_CQ_MAX_ERR_DATA_SIZE];
     struct fi_cq_err_entry cq_err;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
     rc = fi_cq_readfrom(cq_hdl, cq_events, max_count, src_addrs);
     if (rc > 0) { /* events available */
+        *src_err_addrlen = 0;
         *actual_count = (size_t) rc;
         goto out;
     }
     if (rc == -FI_EAGAIN) { /* no event available */
+        *src_err_addrlen = 0;
         *actual_count = 0;
         goto out;
     }
@@ -2502,10 +2584,10 @@ na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
         "fi_cq_readfrom() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
     memset(&cq_err, 0, sizeof(cq_err));
-    memset(&err_data, 0, sizeof(err_data));
+
     /* Prevent provider from internally allocating resources */
-    cq_err.err_data = err_data;
-    cq_err.err_data_size = NA_OFI_CQ_MAX_ERR_DATA_SIZE;
+    cq_err.err_data = *src_err_addr;
+    cq_err.err_data_size = *src_err_addrlen;
 
     /* Read error entry */
     rc = fi_cq_readerr(cq_hdl, &cq_err, 0 /* flags */);
@@ -2518,37 +2600,13 @@ na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
 //                         cq_err.flags);
             goto out;
 
-        case FI_EADDRNOTAVAIL: {
-            struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-            struct fid_av *av_hdl = priv->domain->fi_av;
-            void *err_addr = NULL;
-            size_t err_addrlen;
-
-            /* Copy addr information */
-            err_addr = malloc(cq_err.err_data_size);
-            NA_CHECK_ERROR(err_addr == NULL, out, ret, NA_NOMEM_ERROR,
-                "Could not allocate err_addr");
-            err_addrlen = cq_err.err_data_size;
-            memcpy(err_addr, cq_err.err_data, err_addrlen);
-
-            na_ofi_domain_lock(priv->domain);
-            /* Insert new source addr into AV if address was not found */
-            rc = fi_av_insert(av_hdl, err_addr, 1, &src_addrs[0],
-                0 /* flags */, NULL /* context */);
-            na_ofi_domain_unlock(priv->domain);
-            if (unlikely(rc < 1)) {
-                free(err_addr);
-                NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
-                    "fi_av_insert() failed, rc: %d(%s)",
-                    rc, fi_strerror((int) -rc));
-            }
+        case FI_EADDRNOTAVAIL:
             /* Only one error event processed in that case */
             memcpy(&cq_events[0], &cq_err, sizeof(cq_events[0]));
+            *src_err_addr = cq_err.err_data;
+            *src_err_addrlen = cq_err.err_data_size;
             *actual_count = 1;
-            *src_err_addr = err_addr;
-            *src_err_addrlen = err_addrlen;
             break;
-        }
         case FI_EIO:
             NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
                 "fi_cq_readerr() got err: %d(%s), prov_errno: %d(%s)",
@@ -2642,7 +2700,7 @@ na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
     fi_addr_t src_addr, void *src_err_addr, size_t src_err_addrlen,
     uint64_t tag, size_t len)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
@@ -2650,29 +2708,38 @@ na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
     NA_CHECK_ERROR(cb_type != NA_CB_RECV_UNEXPECTED, out, ret,
         NA_PROTOCOL_ERROR, "Invalid cb_type %d, expected NA_CB_RECV_UNEXPECTED",
         cb_type);
+    NA_CHECK_ERROR(tag > NA_OFI_MAX_TAG, out, ret, NA_PROTOCOL_ERROR,
+        "Invalid tag value");
 
     /* Allocate new address */
-    na_ofi_addr = na_ofi_addr_alloc(priv->domain);
+    na_ofi_addr = na_ofi_addr_alloc(domain);
     NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM_ERROR,
         "na_ofi_addr_alloc() failed");
-    na_ofi_addr->addr = src_err_addr; /* may be NULL */
-    na_ofi_addr->addrlen = src_err_addrlen;
-    /* Unexpected address may not have addr/addrlen info */
-    na_ofi_addr->unexpected = NA_TRUE;
-
-    /* Process address info from msg header */
-    if (na_ofi_with_msg_hdr(na_class)) {
-        ret = na_ofi_addr_ht_lookup(na_class, FI_SOCKADDR_IN,
+    /* Unexpected addresses do not need to set addr/addrlen info, fi_av_lookup()
+     * can be used when needed. */
+
+    /* Use src_addr when available */
+    if (src_addr != FI_ADDR_UNSPEC)
+        na_ofi_addr->fi_addr = src_addr;
+    else if (src_err_addr && src_err_addrlen) { /* addr from error info */
+        /* We do not need to keep a copy of src_err_addr */
+        ret = na_ofi_addr_ht_lookup(domain,
+            na_ofi_prov_addr_format[domain->prov_type], src_err_addr,
+            src_err_addrlen, &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
+        NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
+    } else if (na_ofi_with_msg_hdr(na_class)) { /* addr from msg header */
+        /* We do not need to keep a copy of msg header */
+        ret = na_ofi_addr_ht_lookup(domain, FI_SOCKADDR_IN,
             na_ofi_op_id->info.recv_unexpected.buf,
-            sizeof(struct na_ofi_sin_addr), &src_addr);
+            sizeof(struct na_ofi_sin_addr), &na_ofi_addr->fi_addr,
+            &na_ofi_addr->ht_key);
         NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
-    }
-    na_ofi_addr->fi_addr = src_addr;
-    /* For unexpected msg, take one extra ref to be released by addr_free() */
-    na_ofi_addr_addref(na_ofi_addr);
+    } else
+        NA_GOTO_ERROR(error, ret, NA_PROTOCOL_ERROR,
+            "Insufficient address information");
 
+    na_ofi_addr_addref(na_ofi_addr); /* decref in addr_free() */
     na_ofi_op_id->addr = na_ofi_addr;
-    /* TODO check max tag */
     na_ofi_op_id->info.recv_unexpected.tag = (na_tag_t) tag;
     na_ofi_op_id->info.recv_unexpected.msg_size = len;
     na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
@@ -2844,9 +2911,11 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     void *src_addr = NULL;
     na_size_t src_addrlen = 0;
     char *resolve_name = NULL;
+    char *host_name = NULL;
     unsigned int port = 0;
     const char *node_ptr = NULL;
     char node[NA_OFI_MAX_URI_LEN] = {'\0'};
+    char *domain_name_ptr = NULL;
     char domain_name[NA_OFI_MAX_URI_LEN] = {'\0'};
     na_bool_t no_wait = NA_FALSE;
     na_uint8_t max_contexts = 1; /* Default */
@@ -2855,7 +2924,7 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     enum na_ofi_prov_type prov_type;
 
 //    NA_LOG_DEBUG("Entering na_ofi_initialize class_name %s, protocol_name %s, "
-//                 "host_name %s.\n", na_info->class_name, na_info->protocol_name,
+//                 "host_name %s\n", na_info->class_name, na_info->protocol_name,
 //                 na_info->host_name);
 
     prov_type = na_ofi_prov_name_to_type(na_info->protocol_name);
@@ -2877,22 +2946,25 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
 
     /* Use default interface name if no hostname was passed */
     if (na_info->host_name) {
-        resolve_name = strdup(na_info->host_name);
-        NA_CHECK_ERROR(resolve_name == NULL, out, ret, NA_NOMEM_ERROR,
+        host_name = strdup(na_info->host_name);
+        NA_CHECK_ERROR(host_name == NULL, out, ret, NA_NOMEM_ERROR,
             "strdup() of host_name failed");
 
         /* Extract hostname */
-        if (strstr(resolve_name, ":")) {
+        if (strstr(host_name, ":")) {
             char *port_str = NULL;
-
-            strtok_r(resolve_name, ":", &port_str);
+            strtok_r(host_name, ":", &port_str);
             port = (unsigned int) strtoul(port_str, NULL, 10);
         }
-    } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI) {
-        resolve_name = strdup(NA_OFI_GNI_IFACE_DEFAULT);
-        NA_CHECK_ERROR(resolve_name == NULL, out, ret, NA_NOMEM_ERROR,
-            "strdup() of NA_OFI_GNI_IFACE_DEFAULT failed");
-    }
+
+        /* Extract domain (if specified) */
+        if (strstr(host_name, "/")) {
+            strtok_r(host_name, "/", &resolve_name);
+            domain_name_ptr = host_name;
+        } else
+            resolve_name = host_name;
+    } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI)
+        resolve_name = NA_OFI_GNI_IFACE_DEFAULT;
 
     /* Get hostname/port info if available */
     if (resolve_name) {
@@ -2909,12 +2981,16 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
             if (na_ofi_sin_addr && ifa_name) {
                 src_addr = na_ofi_sin_addr;
                 src_addrlen = sizeof(*na_ofi_sin_addr);
-                /* Make sure we are using the right domain */
-                strncpy(domain_name, ifa_name, NA_OFI_MAX_URI_LEN - 1);
+                if (!domain_name_ptr) {
+                    /* Attempt to pass domain name as ifa_name if not set */
+                    strncpy(domain_name, ifa_name, NA_OFI_MAX_URI_LEN - 1);
+                    domain_name_ptr = domain_name;
+                }
                 free(ifa_name);
-            } else {
-                /* Allow for passing domain name directly */
+            } else if (!domain_name_ptr) {
+                /* Pass domain name as hostname if not set */
                 strncpy(domain_name, resolve_name, NA_OFI_MAX_URI_LEN - 1);
+                domain_name_ptr = domain_name;
             }
         } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI) {
             struct na_ofi_sin_addr *na_ofi_sin_addr = NULL;
@@ -2969,10 +3045,10 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     HG_QUEUE_INIT(&priv->buf_pool);
 
     /* Create domain */
-    ret = na_ofi_domain_open(na_class->plugin_class, prov_type, domain_name,
+    ret = na_ofi_domain_open(na_class->plugin_class, prov_type, domain_name_ptr,
         auth_key, &priv->domain);
     NA_CHECK_NA_ERROR(out, ret, "Could not open domain for %s, %s",
-        na_ofi_prov_name[prov_type], domain_name);
+        na_ofi_prov_name[prov_type], domain_name_ptr);
 
     /* Create endpoint */
     ret = na_ofi_endpoint_open(priv->domain, node_ptr, src_addr, src_addrlen,
@@ -2992,7 +3068,7 @@ out:
         }
     }
     free(src_addr);
-    free(resolve_name);
+    free(host_name);
     return ret;
 }
 
@@ -3291,17 +3367,16 @@ error:
 static na_return_t
 na_ofi_addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
 
     /* Check provider from name */
-    NA_CHECK_ERROR(
-        na_ofi_addr_prov(name) != priv->domain->prov_type, out, ret,
+    NA_CHECK_ERROR(na_ofi_addr_prov(name) != domain->prov_type, out, ret,
         NA_INVALID_PARAM, "Unrecognized provider type found from: %s", name);
 
     /* Allocate addr */
-    na_ofi_addr = na_ofi_addr_alloc(priv->domain);
+    na_ofi_addr = na_ofi_addr_alloc(domain);
     NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM_ERROR,
         "na_ofi_addr_alloc() failed");
     na_ofi_addr->uri = strdup(name);
@@ -3309,15 +3384,14 @@ na_ofi_addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr)
         "strdup() of URI failed");
 
     /* Convert name to address */
-    ret = na_ofi_str_to_addr(name,
-        na_ofi_prov_addr_format[priv->domain->prov_type],
+    ret = na_ofi_str_to_addr(name, na_ofi_prov_addr_format[domain->prov_type],
         &na_ofi_addr->addr, &na_ofi_addr->addrlen);
     NA_CHECK_NA_ERROR(error, ret, "Could not convert string to address");
 
     /* Lookup address */
-    ret = na_ofi_addr_ht_lookup(na_class,
-        na_ofi_prov_addr_format[priv->domain->prov_type],
-        na_ofi_addr->addr, na_ofi_addr->addrlen, &na_ofi_addr->fi_addr);
+    ret = na_ofi_addr_ht_lookup(domain,
+        na_ofi_prov_addr_format[domain->prov_type], na_ofi_addr->addr,
+        na_ofi_addr->addrlen, &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
     NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup(%s) failed", name);
 
     *addr = (na_addr_t) na_ofi_addr;
@@ -3361,7 +3435,7 @@ na_ofi_addr_dup(na_class_t NA_UNUSED *na_class, na_addr_t addr,
 }
 
 /*---------------------------------------------------------------------------*/
-static na_return_t
+static NA_INLINE na_return_t
 na_ofi_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
     na_ofi_addr_decref((struct na_ofi_addr *) addr);
@@ -3370,6 +3444,15 @@ na_ofi_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 }
 
 /*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
+na_ofi_addr_set_remove(na_class_t NA_UNUSED *na_class, na_addr_t addr)
+{
+    ((struct na_ofi_addr *) addr)->remove = NA_TRUE;
+
+    return NA_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
 na_ofi_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
@@ -3385,8 +3468,21 @@ na_ofi_addr_to_string(na_class_t NA_UNUSED *na_class, char *buf,
     na_size_t str_len;
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_ofi_addr->unexpected, out, ret, NA_PROTOCOL_ERROR,
-        "Addr to string is not available on unexpected addresses");
+    /* If there is no URI for address, attempt to reconstruct one */
+    if (!na_ofi_addr->uri) {
+        NA_CHECK_ERROR(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out, ret,
+            NA_PROTOCOL_ERROR, "Addr is not initialized");
+
+        /* If we don't have the addr either, look it up from AV */
+        if (!na_ofi_addr->addr) {
+            ret = na_ofi_av_lookup(na_ofi_addr->domain, na_ofi_addr->fi_addr,
+                &na_ofi_addr->addr, &na_ofi_addr->addrlen);
+            NA_CHECK_NA_ERROR(out, ret, "Could not get addr from AV");
+        }
+
+        ret = na_ofi_get_uri(na_class, na_ofi_addr->addr, &na_ofi_addr->uri);
+        NA_CHECK_NA_ERROR(out, ret, "Could not get URI for address");
+    }
 
     str_len = strlen(na_ofi_addr->uri);
     if (buf) {
@@ -3406,8 +3502,25 @@ na_ofi_addr_get_serialize_size(na_class_t NA_UNUSED *na_class,
     na_addr_t addr)
 {
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) addr;
+    na_size_t size = 0;
 
-    return (na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen));
+    if (!na_ofi_addr->addr) {
+        na_return_t ret;
+
+        NA_CHECK_ERROR_NORET(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out,
+            "Addr is not initialized");
+
+        /* If we don't have the addr, look it up from AV */
+        ret = na_ofi_av_lookup(na_ofi_addr->domain, na_ofi_addr->fi_addr,
+            &na_ofi_addr->addr, &na_ofi_addr->addrlen);
+        NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, out,
+            "Could not get addr from AV");
+    }
+
+    size = na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen);
+
+out:
+    return size;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3419,6 +3532,16 @@ na_ofi_addr_serialize(na_class_t NA_UNUSED *na_class, void *buf,
     na_size_t len;
     na_return_t ret = NA_SUCCESS;
 
+    if (!na_ofi_addr->addr) {
+        NA_CHECK_ERROR(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out, ret,
+            NA_PROTOCOL_ERROR, "Addr is not initialized");
+
+        /* If we don't have the addr, look it up from AV */
+        ret = na_ofi_av_lookup(na_ofi_addr->domain, na_ofi_addr->fi_addr,
+            &na_ofi_addr->addr, &na_ofi_addr->addrlen);
+        NA_CHECK_NA_ERROR(out, ret, "Could not get addr from AV");
+    }
+
     len = na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen);
     NA_CHECK_ERROR(buf_size < len, out, ret, NA_SIZE_ERROR,
         "Buffer size too small for serializing address");
@@ -3437,12 +3560,12 @@ static na_return_t
 na_ofi_addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
     na_size_t NA_UNUSED buf_size)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
 
     /* Allocate addr */
-    na_ofi_addr = na_ofi_addr_alloc(priv->domain);
+    na_ofi_addr = na_ofi_addr_alloc(domain);
     NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM_ERROR,
         "na_ofi_addr_alloc() failed");
     memcpy(&na_ofi_addr->addrlen, buf, sizeof(na_ofi_addr->addrlen));
@@ -3454,12 +3577,12 @@ na_ofi_addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
         (const na_uint8_t *) buf + sizeof(na_ofi_addr->addrlen),
         na_ofi_addr->addrlen);
 
-    /* TODO Skip URI generation? */
+    /* Skip URI generation, URI will only be generated when needed */
 
     /* Lookup address */
-    ret = na_ofi_addr_ht_lookup(na_class,
-        na_ofi_prov_addr_format[priv->domain->prov_type],
-        na_ofi_addr->addr, na_ofi_addr->addrlen, &na_ofi_addr->fi_addr);
+    ret = na_ofi_addr_ht_lookup(domain,
+        na_ofi_prov_addr_format[domain->prov_type], na_ofi_addr->addr,
+        na_ofi_addr->addrlen, &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
     NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
 
     *addr = na_ofi_addr;
@@ -4202,8 +4325,9 @@ na_ofi_progress(na_class_t *na_class, na_context_t *context,
     do {
         struct fi_cq_tagged_entry cq_events[NA_OFI_CQ_EVENT_NUM];
         fi_addr_t src_addrs[NA_OFI_CQ_EVENT_NUM] = {FI_ADDR_UNSPEC};
-        void *src_err_addr = NULL;
-        size_t src_err_addrlen = 0;
+        char src_err_addr[NA_OFI_CQ_MAX_ERR_DATA_SIZE] = {0};
+        void *src_err_addr_ptr = src_err_addr;
+        size_t src_err_addrlen = NA_OFI_CQ_MAX_ERR_DATA_SIZE;
         size_t i, actual_count = 0;
         hg_time_t t1, t2;
 
@@ -4228,8 +4352,8 @@ na_ofi_progress(na_class_t *na_class, na_context_t *context,
         }
 
         /* Read from CQ */
-        ret = na_ofi_cq_read(na_class, context, NA_OFI_CQ_EVENT_NUM, cq_events,
-            src_addrs, &src_err_addr, &src_err_addrlen, &actual_count);
+        ret = na_ofi_cq_read(context, NA_OFI_CQ_EVENT_NUM, cq_events, src_addrs,
+            &src_err_addr_ptr, &src_err_addrlen, &actual_count);
         NA_CHECK_NA_ERROR(out, ret,
             "Could not read events from context CQ");
 
@@ -4249,9 +4373,10 @@ na_ofi_progress(na_class_t *na_class, na_context_t *context,
 
         for (i = 0; i < actual_count; i++) {
            ret = na_ofi_cq_process_event(na_class, context, &cq_events[i],
-               src_addrs[i], src_err_addr, src_err_addrlen);
+               src_addrs[i], src_err_addr_ptr, src_err_addrlen);
            NA_CHECK_NA_ERROR(out, ret, "Could not process event");
         }
+
     } while (remaining > 0 && ret != NA_SUCCESS);
 
 out:
diff --git a/src/na/na_sm.c b/src/na/na_sm.c
index de10eb9..63494eb 100644
--- a/src/na/na_sm.c
+++ b/src/na/na_sm.c
@@ -902,6 +902,7 @@ NA_PLUGIN_OPS(sm) = {
     na_sm_addr_lookup,                      /* addr_lookup */
     NULL,                                   /* addr_lookup2 */
     na_sm_addr_free,                        /* addr_free */
+    NULL,                                   /* addr_set_remove */
     na_sm_addr_self,                        /* addr_self */
     na_sm_addr_dup,                         /* addr_dup */
     na_sm_addr_is_self,                     /* addr_is_self */
diff --git a/src/util/mercury_thread.h b/src/util/mercury_thread.h
index 596c7e3..a90855c 100644
--- a/src/util/mercury_thread.h
+++ b/src/util/mercury_thread.h
@@ -109,6 +109,22 @@ HG_UTIL_EXPORT int
 hg_thread_yield(void);
 
 /**
+ * Obtain handle of the calling thread.
+ *
+ * \return
+ */
+static HG_UTIL_INLINE hg_thread_t
+hg_thread_self(void);
+
+/**
+ * Compare thread IDs.
+ *
+ * \return Non-zero if equal, zero if not equal
+ */
+static HG_UTIL_INLINE int
+hg_thread_equal(hg_thread_t t1, hg_thread_t t2);
+
+/**
  * Create a thread-specific data key visible to all threads in the process.
  *
  * \param key [OUT]             pointer to thread key object
@@ -173,6 +189,28 @@ HG_UTIL_EXPORT int
 hg_thread_setaffinity(hg_thread_t thread, const hg_cpu_set_t *cpu_mask);
 
 /*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE hg_thread_t
+hg_thread_self(void)
+{
+#ifdef _WIN32
+    return GetCurrentThread();
+#else
+    return pthread_self();
+#endif
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE int
+hg_thread_equal(hg_thread_t t1, hg_thread_t t2)
+{
+#ifdef _WIN32
+    return GetThreadId(t1) == GetThreadId(t2);
+#else
+    return pthread_equal(t1, t2);
+#endif
+}
+
+/*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE void *
 hg_thread_getspecific(hg_thread_key_t key)
 {
