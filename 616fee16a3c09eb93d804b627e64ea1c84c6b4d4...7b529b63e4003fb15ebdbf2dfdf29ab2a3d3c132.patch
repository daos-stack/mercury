diff --git a/Testing/na/test_lat_client.c b/Testing/na/test_lat_client.c
index e0d2c16..ff80698 100644
--- a/Testing/na/test_lat_client.c
+++ b/Testing/na/test_lat_client.c
@@ -120,16 +120,19 @@ na_test_target_lookup(struct na_test_lat_info *na_test_lat_info)
 {
     struct na_test_target_lookup_arg request_args = { 0 };
     hg_request_t *request = NULL;
+    na_op_id_t op_id = NA_OP_ID_NULL;
     na_return_t ret = NA_SUCCESS;
 
     request = hg_request_create(na_test_lat_info->request_class);
     request_args.addr_ptr = &na_test_lat_info->target_addr;
     request_args.request = request;
 
+    op_id = NA_Op_create(na_test_lat_info->na_class);
+
     /* Forward call to remote addr and get a new request */
     ret = NA_Addr_lookup(na_test_lat_info->na_class, na_test_lat_info->context,
         na_test_target_lookup_cb, &request_args,
-        na_test_lat_info->na_test_info.target_name, NA_OP_ID_IGNORE);
+        na_test_lat_info->na_test_info.target_name, &op_id);
     if (ret != NA_SUCCESS) {
         NA_LOG_ERROR("Could not lookup address");
         goto done;
@@ -139,6 +142,7 @@ na_test_target_lookup(struct na_test_lat_info *na_test_lat_info)
     hg_request_wait(request, NA_MAX_IDLE_TIME, NULL);
 
 done:
+    NA_Op_destroy(na_test_lat_info->na_class, op_id);
     hg_request_destroy(request);
     return ret;
 }
@@ -326,6 +330,8 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
         NA_Msg_get_unexpected_header_size(na_test_lat_info->na_class);
     na_size_t buf_size =
         (unexpected_header_size) ? unexpected_header_size + 1 : 1;
+    na_op_id_t send_op_id;
+    na_op_id_t recv_op_id;
     na_return_t ret = NA_SUCCESS;
 
     /* Prepare send_buf */
@@ -338,13 +344,16 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
         &recv_buf_data);
     memset(recv_buf, 0, buf_size);
 
+    send_op_id = NA_Op_create(na_test_lat_info->na_class);
+    recv_op_id = NA_Op_create(na_test_lat_info->na_class);
+
     recv_request = hg_request_create(na_test_lat_info->request_class);
 
     /* Post recv */
     ret = NA_Msg_recv_expected(na_test_lat_info->na_class,
         na_test_lat_info->context, na_test_recv_expected_cb, recv_request,
         recv_buf, buf_size, recv_buf_data, na_test_lat_info->target_addr, 0,
-        NA_TEST_TAG_DONE, NA_OP_ID_IGNORE);
+        NA_TEST_TAG_DONE, &recv_op_id);
     if (ret != NA_SUCCESS) {
         NA_LOG_ERROR("NA_Msg_recv_expected() failed");
         goto done;
@@ -354,7 +363,7 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
     ret = NA_Msg_send_unexpected(na_test_lat_info->na_class,
         na_test_lat_info->context, NULL, NULL, send_buf, buf_size,
         send_buf_data, na_test_lat_info->target_addr, 0, NA_TEST_TAG_DONE,
-        NA_OP_ID_IGNORE);
+        &send_op_id);
     if (ret != NA_SUCCESS) {
         NA_LOG_ERROR("NA_Msg_send_unexpected() failed");
         goto done;
@@ -365,6 +374,8 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
 done:
     /* Clean up resources */
     hg_request_destroy(recv_request);
+    NA_Op_destroy(na_test_lat_info->na_class, send_op_id);
+    NA_Op_destroy(na_test_lat_info->na_class, recv_op_id);
     NA_Msg_buf_free(na_test_lat_info->na_class, send_buf, send_buf_data);
     NA_Msg_buf_free(na_test_lat_info->na_class, recv_buf, recv_buf_data);
     return ret;
diff --git a/src/mercury.c b/src/mercury.c
index ca4079b..d9ad358 100644
--- a/src/mercury.c
+++ b/src/mercury.c
@@ -383,7 +383,7 @@ hg_more_data_cb(hg_core_handle_t core_handle, hg_op_t op,
         /* We need to do a bulk transfer to get the extra data */
         ret = hg_get_extra_payload(hg_handle, op, done_cb);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get extra input");
+            HG_LOG_ERROR("Could not get extra payload");
             goto done;
         }
     }
@@ -1639,13 +1639,13 @@ HG_Addr_lookup(hg_context_t *context, hg_cb_t callback, void *arg,
     hg_op_id->arg = arg;
     hg_op_id->info.lookup.hg_addr = HG_ADDR_NULL;
 
+    ret = HG_Core_addr_lookup(context->core_context, hg_core_addr_lookup_cb,
+        hg_op_id, name, &hg_op_id->info.lookup.core_op_id);
+
     /* Assign op_id */
     if (op_id && op_id != HG_OP_ID_IGNORE)
         *op_id = (hg_op_id_t) hg_op_id;
 
-    ret = HG_Core_addr_lookup(context->core_context, hg_core_addr_lookup_cb,
-        hg_op_id, name, &hg_op_id->info.lookup.core_op_id);
-
 done:
     return ret;
 }
diff --git a/src/mercury_bulk.c b/src/mercury_bulk.c
index ba0040c..6ce331d 100644
--- a/src/mercury_bulk.c
+++ b/src/mercury_bulk.c
@@ -957,10 +957,7 @@ hg_bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
         goto done;
     }
     for (i = 0; i < hg_bulk_op_id->op_count; i++)
-        hg_bulk_op_id->na_op_ids[i] = NA_OP_ID_NULL;
-
-    /* Assign op_id */
-    if (op_id && op_id != HG_OP_ID_IGNORE) *op_id = (hg_op_id_t) hg_bulk_op_id;
+        hg_bulk_op_id->na_op_ids[i] = NA_Op_create(hg_bulk_op_id->na_class);
 
     /* Do actual transfer */
     ret = hg_bulk_transfer_pieces(na_bulk_op, na_origin_addr, origin_id, use_sm,
@@ -972,6 +969,10 @@ hg_bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
         goto done;
     }
 
+    /* Assign op_id */
+    if (op_id && op_id != HG_OP_ID_IGNORE)
+        *op_id = (hg_op_id_t) hg_bulk_op_id;
+
 done:
     if (ret != HG_SUCCESS && hg_bulk_op_id) {
         free(hg_bulk_op_id->na_op_ids);
@@ -1022,6 +1023,7 @@ hg_return_t
 hg_bulk_trigger_entry(struct hg_bulk_op_id *hg_bulk_op_id)
 {
     hg_return_t ret = HG_SUCCESS;
+    unsigned int i;
 
     /* Execute callback */
     if (hg_bulk_op_id->callback) {
@@ -1054,6 +1056,8 @@ hg_bulk_trigger_entry(struct hg_bulk_op_id *hg_bulk_op_id)
     }
 
     /* Free op */
+    for (i = 0; i < hg_bulk_op_id->op_count; i++)
+        NA_Op_destroy(hg_bulk_op_id->na_class, hg_bulk_op_id->na_op_ids[i]);
     free(hg_bulk_op_id->na_op_ids);
     free(hg_bulk_op_id);
 
diff --git a/src/mercury_core.c b/src/mercury_core.c
index f114699..f426497 100644
--- a/src/mercury_core.c
+++ b/src/mercury_core.c
@@ -1317,6 +1317,7 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
     na_context_t *na_context = context->core_context.na_context;
     struct hg_core_op_id *hg_core_op_id = NULL;
     struct hg_core_private_addr *hg_core_addr = NULL;
+    na_addr_t na_addr = NA_ADDR_NULL;
     na_return_t na_ret;
 #ifdef HG_HAS_SM_ROUTING
     char lookup_name[HG_CORE_ADDR_MAX_SIZE] = {'\0'};
@@ -1337,7 +1338,6 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
     hg_core_op_id->arg = arg;
     hg_atomic_init32(&hg_core_op_id->completed, 0);
     hg_core_op_id->info.lookup.hg_core_addr = NULL;
-    hg_core_op_id->info.lookup.na_lookup_op_id = NA_OP_ID_NULL;
 
     /* Allocate addr */
     hg_core_addr = hg_core_addr_create(HG_CORE_CONTEXT_CLASS(context), NULL);
@@ -1388,17 +1388,34 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
     /* Assign corresponding NA class */
     hg_core_addr->core_addr.na_class = na_class;
 
-    /* Assign op_id */
-    if (op_id && op_id != HG_CORE_OP_ID_IGNORE)
-        *op_id = (hg_core_op_id_t) hg_core_op_id;
-
-    na_ret = NA_Addr_lookup(na_class, na_context, hg_core_addr_lookup_cb,
-        hg_core_op_id, name_str, &hg_core_op_id->info.lookup.na_lookup_op_id);
+    /* Try to use immediate lookup */
+    na_ret = NA_Addr_lookup2(na_class, name_str, &na_addr);
     if (na_ret != NA_SUCCESS) {
         HG_LOG_ERROR("Could not start lookup for address %s", name_str);
         ret = HG_NA_ERROR;
         goto done;
     }
+    if (na_addr != NA_ADDR_NULL) {
+        struct na_cb_info callback_info;
+        callback_info.arg = hg_core_op_id;
+        callback_info.ret = NA_SUCCESS;
+        callback_info.type = NA_CB_LOOKUP;
+        callback_info.info.lookup.addr = na_addr;
+        hg_core_op_id->info.lookup.na_lookup_op_id = NA_OP_ID_NULL;
+
+        hg_core_addr_lookup_cb(&callback_info);
+    } else {
+        /* Create operation ID */
+        hg_core_op_id->info.lookup.na_lookup_op_id = NA_Op_create(na_class);
+
+        na_ret = NA_Addr_lookup(na_class, na_context, hg_core_addr_lookup_cb,
+            hg_core_op_id, name_str, &hg_core_op_id->info.lookup.na_lookup_op_id);
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not start lookup for address %s", name_str);
+            ret = HG_NA_ERROR;
+            goto done;
+        }
+    }
 
     /* TODO to avoid blocking after lookup make progress on the HG layer with
      * timeout of 0 */
@@ -1409,6 +1426,10 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
         goto done;
     }
 
+    /* Assign op_id */
+    if (op_id && op_id != HG_CORE_OP_ID_IGNORE)
+        *op_id = (hg_core_op_id_t) hg_core_op_id;
+
 done:
     if (ret != HG_SUCCESS) {
         free(hg_core_op_id);
@@ -1726,7 +1747,7 @@ hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
     /* Alloc/init NA resources */
     ret = hg_core_alloc_na(hg_core_handle, use_sm);
     if (ret != HG_SUCCESS) {
-        NA_LOG_ERROR("Could not allocate NA handle ops");
+        HG_LOG_ERROR("Could not allocate NA handle ops");
         ret = NA_NOMEM_ERROR;
         goto done;
     }
@@ -1838,9 +1859,12 @@ hg_core_alloc_na(struct hg_core_private_handle *hg_core_handle,
     /* Create NA operation IDs */
     hg_core_handle->na_send_op_id = NA_Op_create(hg_core_handle->na_class);
     hg_core_handle->na_recv_op_id = NA_Op_create(hg_core_handle->na_class);
-    if (hg_core_handle->na_recv_op_id || hg_core_handle->na_send_op_id) {
+    hg_core_handle->na_ack_op_id = NA_Op_create(hg_core_handle->na_class);
+    if (hg_core_handle->na_recv_op_id || hg_core_handle->na_send_op_id
+        || hg_core_handle->na_ack_op_id) {
         if ((hg_core_handle->na_recv_op_id == NA_OP_ID_NULL)
-            || (hg_core_handle->na_send_op_id == NA_OP_ID_NULL)) {
+            || (hg_core_handle->na_send_op_id == NA_OP_ID_NULL)
+            || (hg_core_handle->na_ack_op_id == NA_OP_ID_NULL)) {
             HG_LOG_ERROR("NULL operation ID");
             ret = HG_NOMEM_ERROR;
             goto done;
@@ -1874,6 +1898,9 @@ hg_core_free_na(struct hg_core_private_handle *hg_core_handle)
     na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_recv_op_id);
     if (na_ret != NA_SUCCESS)
         HG_LOG_ERROR("Could not destroy NA op ID");
+    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_ack_op_id);
+    if (na_ret != NA_SUCCESS)
+        HG_LOG_ERROR("Could not destroy NA op ID");
 
     /* Free buffers */
     na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
@@ -3398,6 +3425,12 @@ hg_core_trigger_lookup_entry(struct hg_core_op_id *hg_core_op_id)
 {
     hg_return_t ret = HG_SUCCESS;
 
+    /* Free op */
+    if (hg_core_op_id->info.lookup.na_lookup_op_id != NA_OP_ID_NULL)
+        NA_Op_destroy(
+            hg_core_op_id->info.lookup.hg_core_addr->core_addr.na_class,
+            hg_core_op_id->info.lookup.na_lookup_op_id);
+
     /* Execute callback */
     if (hg_core_op_id->callback) {
         struct hg_core_cb_info hg_core_cb_info;
@@ -3411,7 +3444,6 @@ hg_core_trigger_lookup_entry(struct hg_core_op_id *hg_core_op_id)
         hg_core_op_id->callback(&hg_core_cb_info);
     }
 
-    /* Free op */
     free(hg_core_op_id);
     return ret;
 }
diff --git a/src/na/CMakeLists.txt b/src/na/CMakeLists.txt
index c2ee09c..0b3e0e1 100644
--- a/src/na/CMakeLists.txt
+++ b/src/na/CMakeLists.txt
@@ -327,7 +327,6 @@ install(
 set(NA_HEADERS
   ${CMAKE_CURRENT_BINARY_DIR}/na_config.h
   ${CMAKE_CURRENT_SOURCE_DIR}/na.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/na_error.h
   ${CMAKE_CURRENT_SOURCE_DIR}/na_types.h
 )
 
diff --git a/src/na/na.c b/src/na/na.c
index 3c33da2..08373e3 100644
--- a/src/na/na.c
+++ b/src/na/na.c
@@ -111,18 +111,13 @@ static na_return_t
 na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 {
     struct na_info *na_info = NULL;
+    char *input_string = NULL, *token = NULL, *locator = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    char *input_string = NULL;
-    char *token = NULL;
-    char *locator = NULL;
-
     na_info = (struct na_info *) malloc(sizeof(struct na_info));
-    if (!na_info) {
-        NA_LOG_ERROR("Could not allocate NA info struct");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_info == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate NA info struct");
+
     /* Initialize NA info */
     na_info->class_name = NULL;
     na_info->protocol_name = NULL;
@@ -130,11 +125,8 @@ na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 
     /* Copy info string and work from that */
     input_string = strdup(info_string);
-    if (!input_string) {
-        NA_LOG_ERROR("Could not duplicate host string");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(input_string == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not duplicate host string");
 
     /**
      * Strings can be of the format:
@@ -152,58 +144,44 @@ na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 
         /* Get NA class name */
         na_info->class_name = strdup(token);
-        if (!na_info->class_name) {
-            NA_LOG_ERROR("Could not duplicate NA info class name");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_info->class_name == NULL, error, ret, NA_NOMEM_ERROR,
+            "Could not duplicate NA info class name");
 
         /* Get protocol name */
         na_info->protocol_name = strdup(_locator);
-        if (!na_info->protocol_name) {
-            NA_LOG_ERROR("Could not duplicate NA info protocol name");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_info->protocol_name == NULL, error, ret,
+            NA_NOMEM_ERROR, "Could not duplicate NA info protocol name");
     } else {
         /* Get protocol name */
         na_info->protocol_name = strdup(token);
-        if (!na_info->protocol_name) {
-            NA_LOG_ERROR("Could not duplicate NA info protocol name");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_info->protocol_name == NULL, error, ret,
+            NA_NOMEM_ERROR, "Could not duplicate NA info protocol name");
     }
 
     /* Is the host string empty? */
-    if (!locator || locator[0] == '\0') {
+    if (!locator || locator[0] == '\0')
         goto done;
-    }
+
     /* Format sanity check ("://") */
-    else if (strncmp(locator, "//", 2) != 0) {
-        NA_LOG_ERROR("Bad address string format");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(strncmp(locator, "//", 2) != 0, error, ret,
+        NA_PROTOCOL_ERROR, "Bad address string format");
+
     /* :// followed by empty hostname is allowed, explicitly check here */
-    else if (locator[2] == '\0') {
+    if (locator[2] == '\0')
         goto done;
-    }
-    else {
-        na_info->host_name = strdup(locator + 2);
-        if (!na_info->host_name) {
-            NA_LOG_ERROR("Could not duplicate NA info host name");
-            ret = NA_NOMEM_ERROR;
-        }
-    }
+
+    na_info->host_name = strdup(locator + 2);
+    NA_CHECK_ERROR(na_info->host_name == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not duplicate NA info host name");
 
 done:
-    if (ret == NA_SUCCESS) {
-        *na_info_ptr = na_info;
-    }
-    else {
-        na_info_free(na_info);
-    }
+    *na_info_ptr = na_info;
+    free(input_string);
+
+    return ret;
+
+error:
+    na_info_free(na_info);
     free(input_string);
 
     return ret;
@@ -253,28 +231,20 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
     na_bool_t plugin_found = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
 
-    if (!info_string) {
-        NA_LOG_ERROR("NULL info string");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(info_string == NULL, error, ret, NA_INVALID_PARAM,
+        "NULL info string");
 
     na_private_class = (struct na_private_class *) malloc(
         sizeof(struct na_private_class));
-    if (!na_private_class) {
-        NA_LOG_ERROR("Could not allocate class");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_class == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate class");
     memset(na_private_class, 0, sizeof(struct na_private_class));
 
     plugin_count = sizeof(na_class_table) / sizeof(na_class_table[0]) - 1;
 
     ret = na_info_parse(info_string, &na_info);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not parse host string");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not parse host string");
+
     na_info->na_init_info = na_init_info;
     if (na_init_info)
         na_private_class->na_class.progress_mode = na_init_info->progress_mode;
@@ -286,17 +256,12 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
     while (plugin_index < plugin_count) {
         na_bool_t verified = NA_FALSE;
 
-        if (!na_class_table[plugin_index]->class_name) {
-            NA_LOG_ERROR("class name is not defined");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_class_table[plugin_index]->class_name == NULL, error,
+            ret, NA_PROTOCOL_ERROR, "class name is not defined");
 
-        if (!na_class_table[plugin_index]->check_protocol) {
-            NA_LOG_ERROR("check_protocol plugin callback is not defined");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_class_table[plugin_index]->check_protocol == NULL,
+            error, ret, NA_PROTOCOL_ERROR,
+            "check_protocol plugin callback is not defined");
 
         /* Skip check protocol if class name does not match */
         if (na_info->class_name) {
@@ -311,11 +276,9 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
         verified = na_class_table[plugin_index]->check_protocol(
             na_info->protocol_name);
         if (!verified) {
-            if (na_info->class_name) {
-                NA_LOG_ERROR("Specified class name does not support requested protocol");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_ERROR(na_info->class_name == NULL, error, ret,
+                NA_PROTOCOL_ERROR,
+                "Specified class name does not support requested protocol");
             plugin_index++;
             continue;
         }
@@ -326,11 +289,8 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
             /* While we're here, dup the class_name */
             na_info->class_name = strdup(
                 na_class_table[plugin_index]->class_name);
-            if (!na_info->class_name) {
-                NA_LOG_ERROR("unable to dup class name string");
-                ret = NA_NOMEM_ERROR;
-                goto done;
-            }
+            NA_CHECK_ERROR(na_info->class_name == NULL, error, ret,
+                NA_NOMEM_ERROR, "Unable to dup class name string");
         }
 
         /* All checks have passed */
@@ -338,42 +298,37 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
         break;
     }
 
-    if (!plugin_found) {
-        NA_LOG_ERROR("No suitable plugin found that matches %s", info_string);
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(!plugin_found, error, ret, NA_PROTOCOL_ERROR,
+        "No suitable plugin found that matches %s", info_string);
 
     na_private_class->na_class.ops = na_class_table[plugin_index];
-    if (!na_private_class->na_class.ops->initialize) {
-        NA_LOG_ERROR("initialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_class->na_class.ops == NULL, error, ret,
+        NA_PROTOCOL_ERROR, "NULL NA class ops");
+
+    NA_CHECK_ERROR(na_private_class->na_class.ops->initialize == NULL, error,
+        ret, NA_PROTOCOL_ERROR, "initialize plugin callback is not defined");
+
     ret = na_private_class->na_class.ops->initialize(
         &na_private_class->na_class, na_info, listen);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not initialize plugin");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not initialize plugin");
+
     na_private_class->na_class.protocol_name = strdup(na_info->protocol_name);
-    if (!na_private_class->na_class.protocol_name) {
-        NA_LOG_ERROR("Could not duplicate protocol name");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_class->na_class.protocol_name == NULL, error, ret,
+        NA_NOMEM_ERROR, "Could not duplicate protocol name");
+
     na_private_class->na_class.listen = listen;
 
-done:
-    if (ret != NA_SUCCESS) {
-        if (na_private_class) {
-            free(na_private_class->na_class.protocol_name);
-        }
-        free(na_private_class);
-        na_private_class = NULL;
-    }
     na_info_free(na_info);
+
     return (na_class_t *) na_private_class;
+
+error:
+    na_info_free(na_info);
+    if (na_private_class) {
+        free(na_private_class->na_class.protocol_name);
+        free(na_private_class);
+    }
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -384,12 +339,13 @@ NA_Finalize(na_class_t *na_class)
         (struct na_private_class *) na_class;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_private_class) goto done;
-    if (!na_class->ops->finalize) {
-        NA_LOG_ERROR("finalize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
+    if (!na_private_class)
         goto done;
-    }
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->finalize == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "finalize plugin callback is not defined");
 
     ret = na_class->ops->finalize(&na_private_class->na_class);
 
@@ -430,37 +386,28 @@ NA_Context_create_id(na_class_t *na_class, na_uint8_t id)
     na_return_t ret = NA_SUCCESS;
     struct na_private_context *na_private_context = NULL;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, error, ret, NA_INVALID_PARAM,
+        "NULL NA class");
 
     na_private_context = (struct na_private_context *) malloc(
         sizeof(struct na_private_context));
-    if (!na_private_context) {
-        NA_LOG_ERROR("Could not allocate context");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_context == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate context");
     na_private_context->na_class = na_class;
 
+    NA_CHECK_ERROR(na_class->ops == NULL, error, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
     if (na_class->ops->context_create) {
         ret = na_class->ops->context_create(na_class,
             &na_private_context->context.plugin_context, id);
-        if (ret != NA_SUCCESS) {
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(error, ret, "Could not create plugin context");
     }
 
     /* Initialize completion queue */
     na_private_context->completion_queue =
         hg_atomic_queue_alloc(NA_ATOMIC_QUEUE_SIZE);
-    if (!na_private_context->completion_queue) {
-        NA_LOG_ERROR("Could not allocate queue");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_context->completion_queue == NULL, error, ret,
+        NA_NOMEM_ERROR, "Could not allocate queue");
     HG_QUEUE_INIT(&na_private_context->backfill_queue);
     hg_atomic_init32(&na_private_context->backfill_queue_count, 0);
 
@@ -476,12 +423,11 @@ NA_Context_create_id(na_class_t *na_class, na_uint8_t id)
     hg_atomic_init32(&na_private_context->progressing, 0);
 #endif
 
-done:
-    if (ret != NA_SUCCESS) {
-        free(na_private_context);
-        na_private_context = NULL;
-    }
     return (na_context_t *) na_private_context;
+
+error:
+    free(na_private_context);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -490,44 +436,38 @@ NA_Context_destroy(na_class_t *na_class, na_context_t *context)
 {
     struct na_private_context *na_private_context =
         (struct na_private_context *) context;
+    na_bool_t empty;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    if (!context)
         goto done;
-    }
-    if (!context) goto done;
 
     /* Check that completion queue is empty now */
-    if (!hg_atomic_queue_is_empty(na_private_context->completion_queue)) {
-        NA_LOG_ERROR("Completion queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = hg_atomic_queue_is_empty(na_private_context->completion_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Completion queue should be empty");
     hg_atomic_queue_free(na_private_context->completion_queue);
 
     /* Check that backfill completion queue is empty now */
     hg_thread_mutex_lock(&na_private_context->completion_queue_mutex);
-    if (!HG_QUEUE_IS_EMPTY(&na_private_context->backfill_queue)) {
-        NA_LOG_ERROR("Completion queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        hg_thread_mutex_unlock(&na_private_context->completion_queue_mutex);
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&na_private_context->backfill_queue);
     hg_thread_mutex_unlock(&na_private_context->completion_queue_mutex);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Completion queue should be empty");
 
     /* Destroy completion queue mutex/cond */
     hg_thread_mutex_destroy(&na_private_context->completion_queue_mutex);
     hg_thread_cond_destroy(&na_private_context->completion_queue_cond);
 
     /* Destroy NA plugin context */
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
     if (na_class->ops->context_destroy) {
         ret = na_class->ops->context_destroy(na_class,
             na_private_context->context.plugin_context);
-        if (ret != NA_SUCCESS) {
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not destroy plugin context");
     }
 
 #ifdef NA_HAS_MULTI_PROGRESS
@@ -548,14 +488,12 @@ NA_Op_create(na_class_t *na_class)
 {
     na_op_id_t ret = NA_OP_ID_NULL;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!na_class->ops->op_create) {
+    NA_CHECK_ERROR_NORET(na_class == NULL, done, "NULL NA class");
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, done, "NULL NA class ops");
+
+    if (!na_class->ops->op_create)
         /* Not provided */
         goto done;
-    }
 
     ret = na_class->ops->op_create(na_class);
 
@@ -569,19 +507,19 @@ NA_Op_destroy(na_class_t *na_class, na_op_id_t op_id)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (op_id == NA_OP_ID_NULL) {
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+
+    if (op_id == NA_OP_ID_NULL)
         /* Nothing to do */
         goto done;
-    }
-    if (!na_class->ops->op_destroy) {
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+
+    if (!na_class->ops->op_destroy)
         /* Not provided */
         goto done;
-    }
 
     ret = na_class->ops->op_destroy(na_class, op_id);
 
@@ -598,34 +536,22 @@ NA_Addr_lookup(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     char *short_name = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!name) {
-        NA_LOG_ERROR("Lookup name is NULL");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_lookup) {
-        NA_LOG_ERROR("addr_lookup plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL context");
+    NA_CHECK_ERROR(name == NULL, done, ret, NA_INVALID_PARAM,
+        "Lookup name is NULL");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_lookup == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "addr_lookup plugin callback is not defined");
 
     /* Copy name and work from that */
     name_string = strdup(name);
-    if (!name_string) {
-        NA_LOG_ERROR("Could not duplicate string");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM_ERROR,
+        "Could not duplicate string");
 
     /* If NA class name was specified, we can remove the name here:
      * ie. bmi+tcp://hostname:port -> tcp://hostname:port */
@@ -636,9 +562,48 @@ NA_Addr_lookup(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
     ret = na_class->ops->addr_lookup(na_class, context, callback, arg,
         short_name, op_id);
-    if (ret != NA_SUCCESS) {
+
+done:
+    free(name_string);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+na_return_t
+NA_Addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr)
+{
+    char *name_string = NULL;
+    char *short_name = NULL;
+    na_return_t ret = NA_SUCCESS;
+
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(name == NULL, done, ret, NA_INVALID_PARAM,
+        "Lookup name is NULL");
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL pointer to na_addr_t");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    if (!na_class->ops->addr_lookup2)
+        /* Until we switch to new lookup, exit if no callback */
         goto done;
-    }
+//    NA_CHECK_ERROR(na_class->ops->addr_lookup2 == NULL, done, ret,
+//        NA_PROTOCOL_ERROR, "addr_lookup2 plugin callback is not defined");
+
+    /* Copy name and work from that */
+    name_string = strdup(name);
+    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM_ERROR,
+        "Could not duplicate string");
+
+    /* If NA class name was specified, we can remove the name here:
+     * ie. bmi+tcp://hostname:port -> tcp://hostname:port */
+    if (strstr(name_string, NA_CLASS_DELIMITER) != NULL)
+        strtok_r(name_string, NA_CLASS_DELIMITER, &short_name);
+    else
+        short_name = name_string;
+
+    ret = na_class->ops->addr_lookup2(na_class, short_name, addr);
 
 done:
     free(name_string);
@@ -651,21 +616,15 @@ NA_Addr_self(na_class_t *na_class, na_addr_t *addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!addr) {
-        NA_LOG_ERROR("NULL pointer to na_addr_t");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_self) {
-        NA_LOG_ERROR("addr_self plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL pointer to na_addr_t");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_self == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "addr_self plugin callback is not defined");
 
     ret = na_class->ops->addr_self(na_class, addr);
 
@@ -679,26 +638,17 @@ NA_Addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!new_addr) {
-        NA_LOG_ERROR("NULL pointer to NA addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_dup) {
-        NA_LOG_ERROR("addr_dup plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_PARAM,
+        "NULL addr");
+    NA_CHECK_ERROR(new_addr == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL pointer to NA addr");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_dup == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "addr_dup plugin callback is not defined");
 
     ret = na_class->ops->addr_dup(na_class, addr, new_addr);
 
@@ -712,19 +662,16 @@ NA_Addr_free(na_class_t *na_class, na_addr_t addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
     if (addr == NA_ADDR_NULL)
         /* Nothing to do */
         goto done;
-    if (!na_class->ops->addr_free) {
-        NA_LOG_ERROR("addr_free plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_free == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "addr_free plugin callback is not defined");
 
     ret = na_class->ops->addr_free(na_class, addr);
 
@@ -741,27 +688,18 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
     na_size_t buf_size_used = 0, plugin_buf_size = 0;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
     /* buf can be NULL */
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_to_string) {
-        NA_LOG_ERROR("addr_to_string plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
+        "NULL buffer size");
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_PARAM,
+        "NULL addr");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_to_string == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "addr_to_string plugin callback is not defined");
 
     /* Automatically prepend string by plugin name with class delimiter,
      * except for MPI plugin (special case, because of generated string) */
@@ -769,21 +707,17 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
         buf_size_used = 0;
         plugin_buf_size = *buf_size;
     } else {
-        buf_size_used = strlen(na_class->ops->class_name) + 1;
+        buf_size_used = strlen(na_class->ops->class_name)
+            + strlen(NA_CLASS_DELIMITER);
         if (buf_ptr) {
-            if (*buf_size > buf_size_used) {
-                strcpy(buf_ptr, na_class->ops->class_name);
-                strcat(buf_ptr, NA_CLASS_DELIMITER);
-                buf_ptr += buf_size_used;
-                plugin_buf_size = *buf_size - buf_size_used;
-            } else {
-                NA_LOG_ERROR("Buffer size too small to copy addr");
-                ret = NA_SIZE_ERROR;
-                goto done;
-            }
-        } else {
+            NA_CHECK_ERROR(buf_size_used >= *buf_size, done, ret, NA_SIZE_ERROR,
+                "Buffer size too small to copy addr");
+            strcpy(buf_ptr, na_class->ops->class_name);
+            strcat(buf_ptr, NA_CLASS_DELIMITER);
+            buf_ptr += buf_size_used;
+            plugin_buf_size = *buf_size - buf_size_used;
+        } else
             plugin_buf_size = 0;
-        }
     }
 
     ret = na_class->ops->addr_to_string(na_class, buf_ptr, &plugin_buf_size,
@@ -802,31 +736,19 @@ NA_Addr_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_serialize) {
-        NA_LOG_ERROR("addr_serialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
+        "NULL buffer size");
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_PARAM,
+        "NULL addr");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_serialize == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "addr_serialize plugin callback is not defined");
 
     ret = na_class->ops->addr_serialize(na_class, buf, buf_size, addr);
 
@@ -841,31 +763,19 @@ NA_Addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!addr) {
-        NA_LOG_ERROR("NULL pointer to addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_deserialize) {
-        NA_LOG_ERROR("addr_deserialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL pointer to addr");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
+        "NULL buffer size");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_deserialize == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "addr_deserialize plugin callback is not defined");
 
     ret = na_class->ops->addr_deserialize(na_class, addr, buf, buf_size);
 
@@ -879,29 +789,20 @@ NA_Msg_buf_alloc(na_class_t *na_class, na_size_t buf_size, void **plugin_data)
 {
     void *ret = NULL;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        goto done;
-    }
-    if (!plugin_data) {
-        NA_LOG_ERROR("NULL pointer to plugin data");
-        goto done;
-    }
+    NA_CHECK_ERROR_NORET(na_class == NULL, done, "NULL NA class");
+    NA_CHECK_ERROR_NORET(buf_size == 0, done, "NULL buffer size");
+    NA_CHECK_ERROR_NORET(plugin_data == NULL, done,
+        "NULL pointer to plugin data");
 
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, done, "NULL NA class ops");
     if (na_class->ops->msg_buf_alloc)
         ret = na_class->ops->msg_buf_alloc(na_class, buf_size, plugin_data);
     else {
         na_size_t page_size = (na_size_t) hg_mem_get_page_size();
 
         ret = hg_mem_aligned_alloc(page_size, buf_size);
-        if (!ret) {
-            NA_LOG_ERROR("Could not allocate %d bytes", (int) buf_size);
-            goto done;
-        }
+        NA_CHECK_ERROR_NORET(ret == NULL, done,
+            "Could not allocate %d bytes", (int) buf_size);
         memset(ret, 0, buf_size);
         *plugin_data = (void *)1; /* Sanity check on free */
     }
@@ -916,25 +817,18 @@ NA_Msg_buf_free(na_class_t *na_class, void *buf, void *plugin_data)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL buffer");
 
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
     if (na_class->ops->msg_buf_free)
         ret = na_class->ops->msg_buf_free(na_class, buf, plugin_data);
     else {
-        if (plugin_data != (void *)1) {
-            NA_LOG_ERROR("Invalid plugin data value");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(plugin_data != (void *)1, done, ret, NA_PROTOCOL_ERROR,
+            "Invalid plugin data value");
         hg_mem_aligned_free(buf);
     }
 
@@ -948,22 +842,15 @@ NA_Msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
+        "NULL buffer size");
 
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
     if (na_class->ops->msg_init_unexpected)
         ret = na_class->ops->msg_init_unexpected(na_class, buf, buf_size);
 
@@ -977,22 +864,15 @@ NA_Msg_init_expected(na_class_t *na_class, void *buf, na_size_t buf_size)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
+        "NULL buffer size");
 
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
     if (na_class->ops->msg_init_expected)
         ret = na_class->ops->msg_init_expected(na_class, buf, buf_size);
 
@@ -1007,26 +887,17 @@ NA_Mem_handle_create(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_create) {
-        NA_LOG_ERROR("mem_handle_create plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
+        "NULL buffer size");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_create == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "mem_handle_create plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_create(na_class, buf, buf_size, flags,
         mem_handle);
@@ -1043,26 +914,18 @@ NA_Mem_handle_create_segments(na_class_t *na_class, struct na_segment *segments,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!segments) {
-        NA_LOG_ERROR("NULL pointer to segments");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!segment_count) {
-        NA_LOG_ERROR("NULL segment count");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_create_segments) {
-        NA_LOG_ERROR("mem_handle_create_segments plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(segments == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL pointer to segments");
+    NA_CHECK_ERROR(segment_count == 0, done, ret, NA_INVALID_PARAM,
+        "NULL segment count");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_create_segments == NULL, done, ret,
+        NA_PROTOCOL_ERROR,
+        "mem_handle_create_segments plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_create_segments(na_class, segments,
         segment_count, flags, mem_handle);
@@ -1077,21 +940,15 @@ NA_Mem_handle_free(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_free) {
-        NA_LOG_ERROR("mem_handle_free plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_PARAM, "NULL memory handle");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_free == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "mem_handle_free plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_free(na_class, mem_handle);
 
@@ -1105,21 +962,16 @@ NA_Mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_PARAM, "NULL memory handle");
 
-    if (na_class->ops->mem_register) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    if (na_class->ops->mem_register)
         /* Optional */
         ret = na_class->ops->mem_register(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1131,21 +983,16 @@ NA_Mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_PARAM, "NULL memory handle");
 
-    if (na_class->ops->mem_deregister) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    if (na_class->ops->mem_deregister)
         /* Optional */
         ret = na_class->ops->mem_deregister(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1157,21 +1004,16 @@ NA_Mem_publish(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_PARAM, "NULL memory handle");
 
-    if (na_class->ops->mem_publish) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    if (na_class->ops->mem_publish)
         /* Optional */
         ret = na_class->ops->mem_publish(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1183,21 +1025,16 @@ NA_Mem_unpublish(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_PARAM, "NULL memory handle");
 
-    if (na_class->ops->mem_unpublish) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    if (na_class->ops->mem_unpublish)
         /* Optional */
         ret = na_class->ops->mem_unpublish(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1210,31 +1047,20 @@ NA_Mem_handle_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_serialize) {
-        NA_LOG_ERROR("mem_handle_serialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
+        "NULL buffer size");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_PARAM, "NULL memory handle");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_serialize == NULL, done, ret,
+        NA_PROTOCOL_ERROR,
+        "mem_handle_serialize plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_serialize(na_class, buf, buf_size,
         mem_handle);
@@ -1250,31 +1076,20 @@ NA_Mem_handle_deserialize(na_class_t *na_class, na_mem_handle_t *mem_handle,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!mem_handle) {
-        NA_LOG_ERROR("NULL pointer to memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_deserialize) {
-        NA_LOG_ERROR("mem_handle_deserialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NULL, done, ret,
+        NA_INVALID_PARAM, "NULL pointer to memory handle");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
+        "NULL buffer size");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_deserialize == NULL, done, ret,
+        NA_PROTOCOL_ERROR,
+        "mem_handle_deserialize plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_deserialize(na_class, mem_handle, buf,
         buf_size);
@@ -1289,31 +1104,29 @@ NA_Poll_try_wait(na_class_t *na_class, na_context_t *context)
 {
     struct na_private_context *na_private_context =
         (struct na_private_context *) context;
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_FALSE;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_FALSE;
-    }
-#endif
+    na_bool_t ret = NA_FALSE;
+
+    NA_CHECK_ERROR_NORET(na_class == NULL, error, "NULL NA class");
+    NA_CHECK_ERROR_NORET(context == NULL, error, "NULL context");
+
     /* Do not try to wait if NA_NO_BLOCK is set */
     if (na_class->progress_mode == NA_NO_BLOCK)
         return NA_FALSE;
 
     /* Something is in one of the completion queues */
     if (!hg_atomic_queue_is_empty(na_private_context->completion_queue) ||
-        hg_atomic_get32(&na_private_context->backfill_queue_count)) {
+        hg_atomic_get32(&na_private_context->backfill_queue_count))
         return NA_FALSE;
-    }
 
     /* Check plugin try wait */
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, error, "NULL NA class ops");
     if (na_class->ops->na_poll_try_wait)
         return na_class->ops->na_poll_try_wait(na_class, context);
 
     return NA_TRUE;
+
+error:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1330,28 +1143,21 @@ NA_Progress(na_class_t *na_class, na_context_t *context, unsigned int timeout)
 #endif
     na_return_t ret = NA_TIMEOUT;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_private_context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->progress) {
-        NA_LOG_ERROR("progress plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(na_private_context == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL context");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->progress == NULL, done, ret,
+        NA_PROTOCOL_ERROR, "progress plugin callback is not defined");
 
     /* Do not block if NA_NO_BLOCK option is passed */
-    if (na_private_class->na_class.progress_mode == NA_NO_BLOCK) {
+    if (na_private_class->na_class.progress_mode == NA_NO_BLOCK)
         remaining = 0;
-    } else {
+    else
         remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
-    }
 
 #ifdef NA_HAS_MULTI_PROGRESS
     hg_atomic_incr32(&na_private_context->progressing);
@@ -1444,20 +1250,16 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
     na_return_t ret = NA_SUCCESS;
     unsigned int count = 0;
 
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL context");
 
     /* Do not block if NA_NO_BLOCK option is passed */
     na_private_class = (struct na_private_class *) na_private_context->na_class;
     if (na_private_class->na_class.progress_mode == NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
-    } else {
+    } else
         remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
-    }
 
     while (count < max_count) {
         struct na_cb_completion_data *completion_data = NULL;
@@ -1523,11 +1325,8 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
         }
 
         /* Completion queue should not be empty now */
-        if (!completion_data) {
-            NA_LOG_ERROR("NULL completion data");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(completion_data == NULL, done, ret, NA_PROTOCOL_ERROR,
+            "NULL completion data");
 
         /* Execute callback */
         if (completion_data->callback) {
@@ -1562,26 +1361,17 @@ NA_Cancel(na_class_t *na_class, na_context_t *context, na_op_id_t op_id)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (op_id == NA_OP_ID_NULL) {
-        NA_LOG_ERROR("NULL operation ID");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->cancel) {
-        NA_LOG_ERROR("cancel plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL NA class");
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_PARAM,
+        "NULL context");
+    NA_CHECK_ERROR(op_id == NA_OP_ID_NULL, done, ret, NA_INVALID_PARAM,
+        "NULL operation ID");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->cancel == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "cancel plugin callback is not defined");
 
     ret = na_class->ops->cancel(na_class, context, op_id);
 
diff --git a/src/na/na.h b/src/na/na.h
index ada6784..8d0874e 100644
--- a/src/na/na.h
+++ b/src/na/na.h
@@ -12,7 +12,6 @@
 #define NA_H
 
 #include "na_types.h"
-#include "na_error.h"
 
 /*************************************/
 /* Public Type and Struct Definition */
@@ -232,6 +231,25 @@ NA_Addr_lookup(
         );
 
 /**
+ * Lookup an addr from a peer address/name. Addresses need to be
+ * freed by calling NA_Addr_free().
+ *
+ * \remark This is the immediate version of NA_Addr_lookup().
+ *
+ * \param na_class [IN/OUT]     pointer to NA class
+ * \param name [IN]             lookup name
+ * \param addr [OUT]            pointer to abstract address
+ *
+ * \return NA_SUCCESS or corresponding NA error code
+ */
+NA_EXPORT na_return_t
+NA_Addr_lookup2(
+        na_class_t *na_class,
+        const char *name,
+        na_addr_t  *addr
+        );
+
+/**
  * Free the addr from the list of peers.
  *
  * \param na_class [IN/OUT]     pointer to NA class
@@ -1121,6 +1139,12 @@ struct na_class_ops {
             na_op_id_t   *op_id
             );
     na_return_t
+    (*addr_lookup2)(
+            na_class_t *na_class,
+            const char *name,
+            na_addr_t  *addr
+            );
+    na_return_t
     (*addr_free)(
             na_class_t *na_class,
             na_addr_t   addr
@@ -1382,12 +1406,6 @@ struct na_class_ops {
 static NA_INLINE const char *
 NA_Get_class_name(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NULL;
-    }
-#endif
     return na_class->ops->class_name;
 }
 
@@ -1395,12 +1413,6 @@ NA_Get_class_name(const na_class_t *na_class)
 static NA_INLINE const char *
 NA_Get_class_protocol(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NULL;
-    }
-#endif
     return na_class->protocol_name;
 }
 
@@ -1408,12 +1420,6 @@ NA_Get_class_protocol(const na_class_t *na_class)
 static NA_INLINE na_bool_t
 NA_Is_listening(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_FALSE;
-    }
-#endif
     return na_class->listen;
 }
 
@@ -1421,16 +1427,6 @@ NA_Is_listening(const na_class_t *na_class)
 static NA_INLINE na_bool_t
 NA_Addr_is_self(na_class_t *na_class, na_addr_t addr)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_FALSE;
-    }
-    if (!na_class->ops->addr_is_self) {
-        NA_LOG_ERROR("addr_is_self plugin callback is not defined");
-        return NA_FALSE;
-    }
-#endif
     return na_class->ops->addr_is_self(na_class, addr);
 }
 
@@ -1438,20 +1434,6 @@ NA_Addr_is_self(na_class_t *na_class, na_addr_t addr)
 static NA_INLINE na_size_t
 NA_Addr_get_serialize_size(na_class_t *na_class, na_addr_t addr)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        return 0;
-    }
-    if (!na_class->ops->addr_get_serialize_size) {
-        NA_LOG_ERROR("addr_get_serialize_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->addr_get_serialize_size(na_class, addr);
 }
 
@@ -1459,16 +1441,6 @@ NA_Addr_get_serialize_size(na_class_t *na_class, na_addr_t addr)
 static NA_INLINE na_size_t
 NA_Msg_get_max_unexpected_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (!na_class->ops->msg_get_max_unexpected_size) {
-        NA_LOG_ERROR("msg_get_max_unexpected_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->msg_get_max_unexpected_size(na_class);
 }
 
@@ -1476,16 +1448,6 @@ NA_Msg_get_max_unexpected_size(const na_class_t *na_class)
 static NA_INLINE na_size_t
 NA_Msg_get_max_expected_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (!na_class->ops->msg_get_max_expected_size) {
-        NA_LOG_ERROR("msg_get_max_expected_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->msg_get_max_expected_size(na_class);
 }
 
@@ -1493,12 +1455,6 @@ NA_Msg_get_max_expected_size(const na_class_t *na_class)
 static NA_INLINE na_size_t
 NA_Msg_get_unexpected_header_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-#endif
     return (na_class->ops->msg_get_unexpected_header_size) ?
         na_class->ops->msg_get_unexpected_header_size(na_class) : 0;
 }
@@ -1507,12 +1463,6 @@ NA_Msg_get_unexpected_header_size(const na_class_t *na_class)
 static NA_INLINE na_size_t
 NA_Msg_get_expected_header_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-#endif
     return (na_class->ops->msg_get_expected_header_size) ?
         na_class->ops->msg_get_expected_header_size(na_class) : 0;
 }
@@ -1521,16 +1471,6 @@ NA_Msg_get_expected_header_size(const na_class_t *na_class)
 static NA_INLINE na_tag_t
 NA_Msg_get_max_tag(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (!na_class->ops->msg_get_max_tag) {
-        NA_LOG_ERROR("msg_get_max_tag plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->msg_get_max_tag(na_class);
 }
 
@@ -1541,32 +1481,6 @@ NA_Msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (dest_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_send_unexpected) {
-        NA_LOG_ERROR("msg_send_unexpected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_send_unexpected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, dest_addr, dest_id, tag, op_id);
 }
@@ -1577,28 +1491,6 @@ NA_Msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
     void *plugin_data, na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_recv_unexpected) {
-        NA_LOG_ERROR("msg_recv_unexpected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_recv_unexpected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, op_id);
 }
@@ -1610,32 +1502,6 @@ NA_Msg_send_expected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (dest_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_send_expected) {
-        NA_LOG_ERROR("msg_send_expected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_send_expected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, dest_addr, dest_id, tag, op_id);
 }
@@ -1647,32 +1513,6 @@ NA_Msg_recv_expected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_addr_t source_addr, na_uint8_t source_id,
     na_tag_t tag, na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (source_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_recv_expected) {
-        NA_LOG_ERROR("msg_recv_expected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_recv_expected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, source_addr, source_id, tag, op_id);
 }
@@ -1682,20 +1522,6 @@ static NA_INLINE na_size_t
 NA_Mem_handle_get_serialize_size(na_class_t *na_class,
     na_mem_handle_t mem_handle)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return 0;
-    }
-    if (!na_class->ops->mem_handle_get_serialize_size) {
-        NA_LOG_ERROR("mem_handle_get_serialize_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->mem_handle_get_serialize_size(na_class, mem_handle);
 }
 
@@ -1707,36 +1533,6 @@ NA_Put(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
     na_size_t data_size, na_addr_t remote_addr, na_uint8_t remote_id,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (local_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (!data_size) {
-        NA_LOG_ERROR("NULL data size");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->put) {
-        NA_LOG_ERROR("put plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->put(na_class, context, callback, arg,
         local_mem_handle, local_offset, remote_mem_handle, remote_offset,
         data_size, remote_addr, remote_id, op_id);
@@ -1750,36 +1546,6 @@ NA_Get(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
     na_size_t data_size, na_addr_t remote_addr, na_uint8_t remote_id,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (local_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (!data_size) {
-        NA_LOG_ERROR("NULL data size");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->get) {
-        NA_LOG_ERROR("get plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->get(na_class, context, callback, arg,
         local_mem_handle, local_offset, remote_mem_handle, remote_offset,
         data_size, remote_addr, remote_id, op_id);
@@ -1789,16 +1555,6 @@ NA_Get(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
 static NA_INLINE int
 NA_Poll_get_fd(na_class_t *na_class, na_context_t *context)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return -1;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return -1;
-    }
-#endif
     return (na_class->ops->na_poll_get_fd) ?
         na_class->ops->na_poll_get_fd(na_class, context) : -1;
 }
diff --git a/src/na/na_bmi.c b/src/na/na_bmi.c
index 84daf0f..7902e43 100644
--- a/src/na/na_bmi.c
+++ b/src/na/na_bmi.c
@@ -513,6 +513,7 @@ NA_PLUGIN_OPS(bmi) = {
         na_bmi_op_create,                     /* op_create */
         na_bmi_op_destroy,                    /* op_destroy */
         na_bmi_addr_lookup,                   /* addr_lookup */
+        NULL,                                 /* addr_lookup2 */
         na_bmi_addr_free,                     /* addr_free */
         na_bmi_addr_self,                     /* addr_self */
         na_bmi_addr_dup,                      /* addr_dup */
diff --git a/src/na/na_cci.c b/src/na/na_cci.c
index 2758ad8..dbc21fb 100644
--- a/src/na/na_cci.c
+++ b/src/na/na_cci.c
@@ -371,6 +371,7 @@ NA_PLUGIN_OPS(cci) = {
     na_cci_op_create,                       /* op_create */
     na_cci_op_destroy,                      /* op_destroy */
     na_cci_addr_lookup,                     /* addr_lookup */
+    NULL,                                   /* addr_lookup2 */
     na_cci_addr_free,                       /* addr_free */
     na_cci_addr_self,                       /* addr_self */
     na_cci_addr_dup,                        /* addr_dup */
diff --git a/src/na/na_error.h b/src/na/na_error.h
index f04adb0..2f0ed26 100644
--- a/src/na/na_error.h
+++ b/src/na/na_error.h
@@ -15,18 +15,58 @@
 
 /* Default error macro */
 #ifdef NA_HAS_VERBOSE_ERROR
-  #include <mercury_log.h>
-  #define NA_LOG_MODULE_NAME "NA"
-  #define NA_LOG_ERROR(...)                                 \
-      HG_LOG_WRITE_ERROR(NA_LOG_MODULE_NAME, __VA_ARGS__)
-  #define NA_LOG_DEBUG(...)                                 \
-      HG_LOG_WRITE_DEBUG(NA_LOG_MODULE_NAME, __VA_ARGS__)
-  #define NA_LOG_WARNING(...)                               \
-      HG_LOG_WRITE_WARNING(NA_LOG_MODULE_NAME, __VA_ARGS__)
+# include <mercury_log.h>
+# define NA_LOG_MODULE_NAME "NA"
+# define NA_LOG_ERROR(...)                                      \
+    HG_LOG_WRITE_ERROR(NA_LOG_MODULE_NAME, __VA_ARGS__)
+# define NA_LOG_DEBUG(...)                                      \
+    HG_LOG_WRITE_DEBUG(NA_LOG_MODULE_NAME, __VA_ARGS__)
+# define NA_LOG_WARNING(...)                                    \
+    HG_LOG_WRITE_WARNING(NA_LOG_MODULE_NAME, __VA_ARGS__)
 #else
-  #define NA_LOG_ERROR(...) (void)0
-  #define NA_LOG_DEBUG(...) (void)0
-  #define NA_LOG_WARNING(...) (void)0
+# define NA_LOG_ERROR(...)      (void)0
+# define NA_LOG_DEBUG(...)      (void)0
+# define NA_LOG_WARNING(...)    (void)0
 #endif
 
+/* Branch predictor hints */
+#ifndef _WIN32
+# define likely(x)       __builtin_expect(!!(x), 1)
+# define unlikely(x)     __builtin_expect(!!(x), 0)
+#else
+# define likely(x)       (x)
+# define unlikely(x)     (x)
+#endif
+
+/* Error macros */
+#define NA_GOTO_ERROR(label, ret, error, ...) do {              \
+    NA_LOG_ERROR(__VA_ARGS__);                                  \
+    ret = error;                                                \
+    goto label;                                                 \
+} while (0)
+
+/* Check for na_ret value and goto label */
+#define NA_CHECK_NA_ERROR(label, na_ret, ...) do {              \
+    if (unlikely(na_ret != NA_SUCCESS)) {                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+/* Check for cond, set ret to err_val and goto label */
+#define NA_CHECK_ERROR(cond, label, ret, err_val, ...) do {     \
+    if (unlikely(cond)) {                                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+        ret = err_val;                                          \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define NA_CHECK_ERROR_NORET(cond, label, ...) do {             \
+    if (unlikely(cond)) {                                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
 #endif /* NA_ERROR_H */
diff --git a/src/na/na_mpi.c b/src/na/na_mpi.c
index 2ad315a..a070e6c 100644
--- a/src/na/na_mpi.c
+++ b/src/na/na_mpi.c
@@ -542,6 +542,7 @@ NA_PLUGIN_OPS(mpi) = {
         NULL,                                 /* op_create */
         NULL,                                 /* op_destroy */
         na_mpi_addr_lookup,                   /* addr_lookup */
+        NULL,                                 /* addr_lookup2 */
         na_mpi_addr_free,                     /* addr_free */
         na_mpi_addr_self,                     /* addr_self */
         NULL,                                 /* addr_dup */
diff --git a/src/na/na_ofi.c b/src/na/na_ofi.c
index 1c541d0..1cd6556 100644
--- a/src/na/na_ofi.c
+++ b/src/na/na_ofi.c
@@ -99,17 +99,17 @@
  * provider) 
  */
 /* requires domain verification in addition to provider match */
-#define NA_OFI_VERIFY_PROV_DOM (1<<0) 
+#define NA_OFI_VERIFY_PROV_DOM          (1 << 0)
 /* supports FI_WAIT_SET */
-#define NA_OFI_WAIT_SET        (1<<1)
+#define NA_OFI_WAIT_SET                 (1 << 1)
 /* supports FI_WAIT_FD */
-#define NA_OFI_WAIT_FD         (1<<2)
+#define NA_OFI_WAIT_FD                  (1 << 2)
 /* workaround to prevent calling fi_signal() for this provider */
-#define NA_OFI_SKIP_SIGNAL     (1<<4)
+#define NA_OFI_SKIP_SIGNAL              (1 << 4)
 /* workaround to serialize access to ofi domain */
-#define NA_OFI_DOMAIN_LOCK     (1<<5)
+#define NA_OFI_DOMAIN_LOCK              (1 << 5)
 /* disable scalable endpoint support */
-#define NA_OFI_NO_SEP          (1<<6)
+#define NA_OFI_NO_SEP                   (1 << 6)
 
 /* X-macro to define the following for each supported provider:
  * - enum type
@@ -191,42 +191,41 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 
 /* Address / URI max len */
 #define NA_OFI_MAX_URI_LEN              (128)
-#define NA_OFI_GNI_AV_STR_ADDR_VERSION  1
+#define NA_OFI_GNI_AV_STR_ADDR_VERSION  (1)
 #define NA_OFI_GNI_IFACE_DEFAULT        "ipogif0"
 
 /* Memory pool (enabled by default, comment out to disable) */
 #define NA_OFI_HAS_MEM_POOL
-#define NA_OFI_MEM_BLOCK_COUNT  (256)
+#define NA_OFI_MEM_BLOCK_COUNT          (256)
 
 /* Max tag */
-#define NA_OFI_MAX_TAG          ((1 << 30) -1)
+#define NA_OFI_MAX_TAG                  ((1 << 30) -1)
 
 /* Unexpected size */
-#define NA_OFI_UNEXPECTED_SIZE          4096
+#define NA_OFI_UNEXPECTED_SIZE          (4096)
 #define NA_OFI_EXPECTED_TAG_FLAG        (0x100000000ULL)
 #define NA_OFI_UNEXPECTED_TAG_IGNORE    (0x0FFFFFFFFULL)
 
 /* Number of CQ event provided for fi_cq_read() */
-#define NA_OFI_CQ_EVENT_NUM     (16)
+#define NA_OFI_CQ_EVENT_NUM             (16)
 /* CQ depth (the socket provider's default value is 256 */
-#define NA_OFI_CQ_DEPTH         (8192)
+#define NA_OFI_CQ_DEPTH                 (8192)
 /* CQ max err data size (fix to 48 to work around bug in gni provider code) */
-#define NA_OFI_CQ_MAX_ERR_DATA_SIZE (48)
+#define NA_OFI_CQ_MAX_ERR_DATA_SIZE     (48)
 
-/* The magic number for na_ofi_op_id verification */
-#define NA_OFI_OP_ID_MAGIC_1    (0x1928374655627384ULL)
-#define NA_OFI_OP_ID_MAGIC_2    (0x8171615141312111ULL)
+/* Number of retries when receiving FI_EINTR error */
+#define NA_OFI_MAX_EINTR_RETRY          (1000)
 
 /* The predefined RMA KEY for MR_SCALABLE */
-#define NA_OFI_RMA_KEY          (0x0F1B0F1BULL)
+#define NA_OFI_RMA_KEY                  (0x0F1B0F1BULL)
 
 /* Receive context bits for SEP */
-#define NA_OFI_SEP_RX_CTX_BITS  (8)
+#define NA_OFI_SEP_RX_CTX_BITS          (8)
 
 /* Private data access */
-#define NA_OFI_CLASS(na_class) \
+#define NA_OFI_CLASS(na_class)      \
     ((struct na_ofi_class *)((na_class)->plugin_class))
-#define NA_OFI_CONTEXT(na_context)    \
+#define NA_OFI_CONTEXT(na_context)  \
     ((struct na_ofi_context *)((na_context)->plugin_context))
 
 /************************************/
@@ -235,13 +234,14 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 
 /* Address */
 struct na_ofi_addr {
-    void *addr;                 /* Native address */
-    na_size_t addrlen;          /* Native address len */
-    char *uri;                  /* Generated URI */
-    fi_addr_t fi_addr;          /* FI address */
-    hg_atomic_int32_t refcount; /* Reference counter (dup/free)  */
-    na_bool_t self;             /* Boolean for self */
-    na_bool_t unexpected;       /* Boolean for unexpected (no uri/addr) */
+    struct na_ofi_domain *domain;           /* Domain                   */
+    void *addr;                             /* Native address           */
+    na_size_t addrlen;                      /* Native address len       */
+    char *uri;                              /* Generated URI            */
+    fi_addr_t fi_addr;                      /* FI address               */
+    hg_atomic_int32_t refcount;             /* Reference counter        */
+    na_bool_t self;                         /* Boolean for self         */
+    na_bool_t unexpected;                   /* Boolean for unexpected   */
 };
 
 /* SIN address */
@@ -258,17 +258,17 @@ struct na_ofi_psm2_addr {
 /* GNI address */
 struct na_ofi_gni_addr {
     struct {
-        na_uint32_t device_addr;        /* physical NIC address */
-        na_uint32_t cdm_id;             /* user supplied id */
+        na_uint32_t device_addr;            /* physical NIC address     */
+        na_uint32_t cdm_id;                 /* user supplied id         */
     };
     struct {
-        na_uint32_t name_type : 8;      /* bound, unbound, SEP name types */
-        na_uint32_t cm_nic_cdm_id : 24; /* CM nic ID */
-        na_uint32_t cookie;             /* communication domain identifier */
+        na_uint32_t name_type : 8;          /* bound, unbound           */
+        na_uint32_t cm_nic_cdm_id : 24;     /* CM nic ID                */
+        na_uint32_t cookie;                 /* CDM identifier           */
     };
     struct {
-        na_uint32_t rx_ctx_cnt : 8;     /* number of contexts */
-        na_uint32_t key_offset : 12;    /* auth key offset */
+        na_uint32_t rx_ctx_cnt : 8;         /* number of contexts       */
+        na_uint32_t key_offset : 12;        /* auth key offset          */
         na_uint32_t unused1 : 12;
         na_uint32_t unused2;
     };
@@ -277,121 +277,109 @@ struct na_ofi_gni_addr {
 
 /* Memory handle */
 struct na_ofi_mem_desc {
-    na_uint64_t mr_key;                 /* FI MR key */
-    na_ptr_t    base;                   /* Base address of memory */
-    na_size_t   size;                   /* Size of registered region */
-    na_uint8_t  attr;                   /* Flag of operation access */
+    na_uint64_t fi_mr_key;                  /* FI MR key                */
+    na_ptr_t    base;                       /* Base address of memory   */
+    na_size_t   size;                       /* Size of region           */
+    na_uint8_t  attr;                       /* Flag of operation access */
 };
 
 struct na_ofi_mem_handle {
-    struct na_ofi_mem_desc desc;        /* Memory descriptor */
-    struct fid_mr *mr_hdl;              /* FI MR handle */
+    struct na_ofi_mem_desc desc;            /* Memory descriptor        */
+    struct fid_mr *fi_mr;                   /* FI MR handle             */
 };
 
 /* Lookup info */
 struct na_ofi_info_lookup {
-    na_addr_t noi_addr;
+    na_addr_t addr;
 };
 
 /* Unexpected recv info */
 struct na_ofi_info_recv_unexpected {
-    void *noi_buf;
-    na_size_t noi_buf_size;
-    na_size_t noi_msg_size;
-    na_tag_t noi_tag;
+    void *buf;
+    na_size_t buf_size;
+    na_size_t msg_size;
+    na_tag_t tag;
 };
 
 /* Expected recv info */
 struct na_ofi_info_recv_expected {
-    void *noi_buf;
-    na_size_t noi_buf_size;
-    na_size_t noi_msg_size;
-    na_tag_t noi_tag;
+    void *buf;
+    na_size_t buf_size;
+    na_size_t msg_size;
+    na_tag_t tag;
 };
 
 /* Operation ID */
 struct na_ofi_op_id {
-    /* noo_magic_1 and noo_magic_2 are for data verification */
-    na_uint64_t noo_magic_1;
-    na_context_t *noo_context;
-    struct fi_context noo_fi_ctx;
-    struct na_cb_completion_data noo_completion_data;
-    struct na_ofi_addr *noo_addr;
-    hg_atomic_int32_t noo_completed;/* Operation completed */
-    hg_atomic_int32_t noo_canceled; /* Operation canceled  */
+    struct na_cb_completion_data completion_data; /* Completion data    */
     union {
-        struct na_ofi_info_lookup noo_lookup;
-        struct na_ofi_info_recv_unexpected noo_recv_unexpected;
-        struct na_ofi_info_recv_expected noo_recv_expected;
-    } noo_info;
-    hg_atomic_int32_t noo_refcount; /* Ref count */
-    HG_QUEUE_ENTRY(na_ofi_op_id) noo_entry;
-    na_uint64_t noo_magic_2;
+        struct na_ofi_info_lookup lookup;
+        struct na_ofi_info_recv_unexpected recv_unexpected;
+        struct na_ofi_info_recv_expected recv_expected;
+    } info;                                 /* Op info                  */
+    struct fi_context fi_ctx;               /* Context handle           */
+    na_context_t *context;                  /* NA context associated    */
+    struct na_ofi_addr *addr;               /* Address associated       */
+    HG_QUEUE_ENTRY(na_ofi_op_id) entry;     /* Entry in queue           */
+    hg_atomic_int32_t completed;            /* Operation completed      */
+    hg_atomic_int32_t canceled;             /* Operation canceled       */
+    hg_atomic_int32_t refcount;             /* Refcount                 */
 };
 
 /* Op queue */
 struct na_ofi_queue {
-    hg_thread_spin_t noq_lock;
-    HG_QUEUE_HEAD(na_ofi_op_id) noq_queue;
+    hg_thread_spin_t lock;
+    HG_QUEUE_HEAD(na_ofi_op_id) queue;
 };
 
 /* Context */
 struct na_ofi_context {
-    na_uint8_t      noc_idx; /* context index, [0, nop_max_contexts - 1] */
-    struct fid_ep   *noc_tx; /* Transmit context */
-    struct fid_ep   *noc_rx; /* Receive context */
-    struct fid_cq   *noc_cq; /* CQ for basic ep or tx/rx context for sep */
-    struct fid_wait *noc_wait;  /* Wait set handle */
-    /* Unexpected op queue per context for scalable endpoint, for regular
-     * endpoint just a reference to per class op queue. */
-    struct na_ofi_queue *noc_unexpected_op_queue;
+    struct fid_ep *fi_tx;                    /* Transmit context handle  */
+    struct fid_ep *fi_rx;                    /* Receive context handle   */
+    struct fid_cq *fi_cq;                    /* CQ handle                */
+    struct fid_wait *fi_wait;                /* Wait set handle          */
+    struct na_ofi_queue *unexpected_op_queue;/* Unexpected op queue     */
+    na_uint8_t idx;                         /* Context index            */
 };
 
 /* Endpoint */
 struct na_ofi_endpoint {
-    struct na_ofi_addr *noe_addr;/* Endpoint address */
-    struct fi_info *noe_prov;   /* OFI provider info */
-    struct fid_ep *noe_ep;      /* Endpoint to communicate on */
-    struct fid_cq *noe_cq;      /* Completion queue handle, invalid for sep */
-    struct fid_wait *noe_wait;  /* Wait set handle, invalid for sep */
-    /* Unexpected op queue for regular endpoint */
-    struct na_ofi_queue *noe_unexpected_op_queue;
-    na_bool_t noe_sep;          /* True for SEP, false for basic EP */
+    struct na_ofi_addr *src_addr;           /* Endpoint address         */
+    struct fi_info *fi_prov;                /* Provider info            */
+    struct fid_ep *fi_ep;                   /* Endpoint handle          */
+    struct fid_wait *fi_wait;               /* Wait set handle          */
+    struct fid_cq *fi_cq;                   /* CQ handle                */
+    struct na_ofi_queue *unexpected_op_queue;/* Unexpected op queue     */
+    na_bool_t sep;                          /* Scalable endpoint        */
 };
 
 /* Domain */
 struct na_ofi_domain {
-    enum na_ofi_prov_type nod_prov_type;    /* OFI provider type */
-    char *nod_prov_name;                    /* OFI provider name */
+    hg_thread_mutex_t mutex;                /* Mutex for AV etc         */
+    hg_thread_rwlock_t rwlock;              /* RW lock for addr_ht      */
+    HG_LIST_ENTRY(na_ofi_domain) entry;     /* Entry in domain list     */
 #ifdef NA_OFI_HAS_EXT_GNI_H
-    struct fi_gni_auth_key fi_gni_auth_key; /* GNI auth key */
+    struct fi_gni_auth_key fi_gni_auth_key; /* GNI auth key             */
 #endif
-    struct fi_info *nod_prov;               /* OFI provider info */
-    struct fid_fabric *nod_fabric;          /* Fabric domain handle */
-    struct fid_domain *nod_domain;          /* Access domain handle */
-    /* Memory region handle, only valid for MR_SCALABLE */
-    struct fid_mr *nod_mr;
-    na_uint64_t nod_mr_key;                 /* FI MR key */
-    struct fid_av *nod_av;                  /* Address vector handle */
-    /* mutex to protect per domain resource like av */
-    hg_thread_mutex_t nod_mutex;
-    /*
-     * Address hash-table, to map the source-side address to fi_addr_t.
-     * The key is 64bits value serialized from source-side IP+Port (see
-     * na_ofi_reqhdr_2_key), the value is fi_addr_t.
-     */
-    hg_hash_table_t *nod_addr_ht;
-    hg_thread_rwlock_t nod_rwlock;          /* RW lock to protect nod_addr_ht */
-    hg_atomic_int32_t nod_refcount;         /* Refcount of this domain */
-    HG_LIST_ENTRY(na_ofi_domain) nod_entry; /* Entry in nog_domain_list */
+    struct fid_fabric *fi_fabric;           /* Fabric handle            */
+    struct fid_domain *fi_domain;           /* Domain handle            */
+    struct fi_info *fi_prov;                /* Provider info            */
+    struct fid_mr *fi_mr;                   /* Global MR handle         */
+    na_uint64_t fi_mr_key;                  /* Global MR key            */
+    struct fid_av *fi_av;                   /* Address vector handle    */
+    hg_hash_table_t *addr_ht;               /* Address hash_table       */
+    char *prov_name;                        /* Provider name            */
+    enum na_ofi_prov_type prov_type;        /* Provider type            */
+    hg_atomic_int32_t refcount;             /* Refcount of this domain  */
+
 };
 
 /**
  * Memory node (points to actual data).
  */
 struct na_ofi_mem_node {
-    HG_QUEUE_ENTRY(na_ofi_mem_node) entry;  /* Entry in node_list */
-    char *block;                            /* Must be last */
+    HG_QUEUE_ENTRY(na_ofi_mem_node) entry;  /* Entry in node_list       */
+    char *block;                            /* Must be last             */
 };
 
 /**
@@ -400,25 +388,24 @@ struct na_ofi_mem_node {
  * functions.
  */
 struct na_ofi_mem_pool {
-    HG_QUEUE_ENTRY(na_ofi_mem_pool) entry;      /* Entry in pool list */
-    struct fid_mr *mr_hdl;                      /* MR handle */
-    na_size_t block_size;                       /* Node block size */
-    hg_thread_spin_t node_list_lock;            /* Node list lock */
-    HG_QUEUE_HEAD(na_ofi_mem_node) node_list;   /* Node list */
+    HG_QUEUE_HEAD(na_ofi_mem_node) node_list;   /* Node list            */
+    HG_QUEUE_ENTRY(na_ofi_mem_pool) entry;  /* Entry in pool list       */
+    struct fid_mr *mr_hdl;                  /* MR handle                */
+    na_size_t block_size;                   /* Node block size          */
+    hg_thread_spin_t node_list_lock;        /* Node list lock           */
 };
 
 /* Private data */
 struct na_ofi_class {
-    struct na_ofi_domain *nop_domain; /* Point back to access domain */
-    struct na_ofi_endpoint *nop_endpoint;
-    na_bool_t nop_listen; /* flag of listening, true for server */
-    na_uint8_t nop_contexts; /* number of context */
-    na_uint8_t nop_max_contexts; /* max number of contexts */
-    /* nop_mutex only used for verbs provider as it is not thread safe now */
-    hg_thread_mutex_t nop_mutex;
-    HG_QUEUE_HEAD(na_ofi_mem_pool) nop_buf_pool;    /* Msg buf pool head */
-    hg_thread_spin_t nop_buf_pool_lock;             /* Buf pool lock */
-    na_bool_t no_wait; /* Ignore wait object */
+    hg_thread_mutex_t mutex;                /* Mutex (for verbs prov)   */
+    HG_QUEUE_HEAD(na_ofi_mem_pool) buf_pool;/* Msg buf pool head        */
+    struct na_ofi_domain *domain;           /* Domain pointer           */
+    struct na_ofi_endpoint *endpoint;       /* Endpoint pointer         */
+    hg_thread_spin_t buf_pool_lock;         /* Buf pool lock            */
+    na_uint8_t contexts;                    /* Number of context        */
+    na_uint8_t max_contexts;                /* Max number of contexts   */
+    na_bool_t listen;                       /* Listening flag           */
+    na_bool_t no_wait;                      /* Ignore wait object       */
 };
 
 /********************/
@@ -510,7 +497,7 @@ na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
 /**
  * Get info caps from providers and return matching providers.
  */
-static int
+static na_return_t
 na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers);
 
 /**
@@ -601,7 +588,7 @@ na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr);
  * Allocate address.
  */
 static struct na_ofi_addr *
-na_ofi_addr_alloc(void);
+na_ofi_addr_alloc(struct na_ofi_domain *na_ofi_domain);
 
 /**
  * Increment address refcount.
@@ -786,6 +773,10 @@ static na_return_t
 na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const char *name, na_op_id_t *op_id);
 
+/* addr_lookup2 */
+static na_return_t
+na_ofi_addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr);
+
 /* addr_self */
 static NA_INLINE na_return_t
 na_ofi_addr_self(na_class_t *na_class, na_addr_t *addr);
@@ -951,6 +942,7 @@ NA_PLUGIN_OPS(ofi) = {
     na_ofi_op_create,                       /* op_create */
     na_ofi_op_destroy,                      /* op_destroy */
     na_ofi_addr_lookup,                     /* addr_lookup */
+    na_ofi_addr_lookup2,                    /* addr_lookup2 */
     na_ofi_addr_free,                       /* addr_free */
     na_ofi_addr_self,                       /* addr_self */
     na_ofi_addr_dup,                        /* addr_dup */
@@ -1017,34 +1009,34 @@ na_ofi_prov_name_to_type(const char *prov_name)
 static NA_INLINE void
 na_ofi_domain_lock(struct na_ofi_domain *domain)
 {
-    if (na_ofi_prov_flags[domain->nod_prov_type] & NA_OFI_DOMAIN_LOCK)
-        hg_thread_mutex_lock(&domain->nod_mutex);
+    if (na_ofi_prov_flags[domain->prov_type] & NA_OFI_DOMAIN_LOCK)
+        hg_thread_mutex_lock(&domain->mutex);
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE void
 na_ofi_domain_unlock(struct na_ofi_domain *domain)
 {
-    if (na_ofi_prov_flags[domain->nod_prov_type] & NA_OFI_DOMAIN_LOCK)
-        hg_thread_mutex_unlock(&domain->nod_mutex);
+    if (na_ofi_prov_flags[domain->prov_type] & NA_OFI_DOMAIN_LOCK)
+        hg_thread_mutex_unlock(&domain->mutex);
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
 na_ofi_with_sep(const na_class_t *na_class)
 {
-    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->nop_endpoint;
+    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->endpoint;
 
-    return ep->noe_sep;
+    return ep->sep;
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
 na_ofi_with_msg_hdr(const na_class_t *na_class)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
 
-    return (na_ofi_prov_addr_format[domain->nod_prov_type] == FI_SOCKADDR_IN);
+    return (na_ofi_prov_addr_format[domain->prov_type] == FI_SOCKADDR_IN);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1087,47 +1079,36 @@ na_ofi_str_to_sin(const char *str, void **addr, na_size_t *len)
 {
     struct na_ofi_sin_addr *sin_addr;
     char ip[16];
-    int ret;
+    na_return_t ret = NA_SUCCESS;
 
     *len = sizeof(*sin_addr);
     sin_addr = calloc(1, *len);
-    if (!sin_addr) {
-        NA_LOG_ERROR("Could not allocate sin address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(sin_addr == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate sin address");
 
     sin_addr->sin.sin_family = AF_INET;
-    ret = sscanf(str, "%*[^:]://:%" SCNu16, &sin_addr->sin.sin_port);
-    if (ret == 1)
-        goto match_port;
-
-    ret = sscanf(str, "%*[^:]://%15[^:]:%" SCNu16, ip, &sin_addr->sin.sin_port);
-    if (ret == 2)
-        goto match_ip;
-
-    ret = sscanf(str, "%*[^:]://%15[^:/]", ip);
-    if (ret == 1)
-        goto match_ip;
-
-    NA_LOG_ERROR("Malformed FI_ADDR_STR: %s\n", str);
+    if (sscanf(str, "%*[^:]://:%" SCNu16, &sin_addr->sin.sin_port) == 1) {
+        /* nothing */
+    } else if ((sscanf(str, "%*[^:]://%15[^:]:%" SCNu16, ip, &sin_addr->sin.sin_port) == 2)
+        || (sscanf(str, "%*[^:]://%15[^:/]", ip) == 1)) {
+        int rc;
 
-err:
-    free(sin_addr);
-    return NA_PROTOCOL_ERROR;
-
-match_ip:
-    ip[sizeof(ip) - 1] = '\0';
-    ret = inet_pton(AF_INET, ip, &sin_addr->sin.sin_addr);
-    if (ret != 1) {
-        NA_LOG_ERROR("Unable to convert IPv4 address: %s\n", ip);
-        goto err;
-    }
+        ip[sizeof(ip) - 1] = '\0';
+        rc = inet_pton(AF_INET, ip, &sin_addr->sin.sin_addr);
+        NA_CHECK_ERROR(rc != 1, error, ret, NA_PROTOCOL_ERROR,
+            "Unable to convert IPv4 address: %s\n", ip);
+    } else
+        NA_GOTO_ERROR(error, ret, NA_PROTOCOL_ERROR,
+            "Malformed FI_ADDR_STR: %s\n", str);
 
-match_port:
     sin_addr->sin.sin_port = htons(sin_addr->sin.sin_port);
     *addr = sin_addr;
 
-    return NA_SUCCESS;
+    return ret;
+
+error:
+    free(sin_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1135,26 +1116,26 @@ static na_return_t
 na_ofi_str_to_psm2(const char *str, void **addr, na_size_t *len)
 {
     struct na_ofi_psm2_addr *psm2_addr;
-    int ret;
+    na_return_t ret = NA_SUCCESS;
+    int rc;
 
     *len = sizeof(*psm2_addr);
     psm2_addr = calloc(1, *len);
-    if (!psm2_addr) {
-        NA_LOG_ERROR("Could not allocate psm2 address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(psm2_addr == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate psm2 address");
 
-    ret = sscanf(str, "%*[^:]://%" SCNx64 ":%" SCNx64,
+    rc = sscanf(str, "%*[^:]://%" SCNx64 ":%" SCNx64,
         (uint64_t *) &psm2_addr->addr0, (uint64_t *) &psm2_addr->addr1);
-    if (ret != 2) {
-        NA_LOG_ERROR("Could not convert addr string to PSM2 addr format");
-        free(psm2_addr);
-        return NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 2, error, ret, NA_PROTOCOL_ERROR,
+        "Could not convert addr string to PSM2 addr format");
 
     *addr = psm2_addr;
 
-    return NA_SUCCESS;
+    return ret;
+
+error:
+    free(psm2_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1164,28 +1145,21 @@ na_ofi_str_to_gni(const char *str, void **addr, na_size_t *len)
     struct na_ofi_gni_addr *gni_addr;
     unsigned int version, name_type, rx_ctx_cnt;
     na_uint32_t device_addr, cdm_id, cm_nic_cdm_id, cookie;
-    int ret;
+    na_return_t ret = NA_SUCCESS;
+    int rc;
 
     *len = sizeof(*gni_addr);
     gni_addr = calloc(1, *len);
-    if (!gni_addr) {
-        NA_LOG_ERROR("Could not allocate gni address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(gni_addr == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate gni address");
 
-    ret = sscanf(str, "%*[^:]://%04u:0x%08" PRIx32 ":0x%08" PRIx32 ":%02u:0x%06"
+    rc = sscanf(str, "%*[^:]://%04u:0x%08" PRIx32 ":0x%08" PRIx32 ":%02u:0x%06"
         PRIx32 ":0x%08" PRIx32 ":%02u", &version, &device_addr, &cdm_id,
         &name_type, &cm_nic_cdm_id, &cookie, &rx_ctx_cnt);
-    if (ret != 7) {
-        NA_LOG_ERROR("Could not convert addr string to GNI addr format");
-        free(gni_addr);
-        return NA_PROTOCOL_ERROR;
-    }
-    if (version != NA_OFI_GNI_AV_STR_ADDR_VERSION) {
-        NA_LOG_ERROR("Unsupported GNI string addr format");
-        free(gni_addr);
-        return NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 7, error, ret, NA_PROTOCOL_ERROR,
+            "Could not convert addr string to GNI addr format");
+    NA_CHECK_ERROR(version != NA_OFI_GNI_AV_STR_ADDR_VERSION, error, ret,
+        NA_PROTOCOL_ERROR, "Unsupported GNI string addr format");
 
     gni_addr->device_addr = device_addr;
     gni_addr->cdm_id = cdm_id;
@@ -1202,7 +1176,11 @@ na_ofi_str_to_gni(const char *str, void **addr, na_size_t *len)
 
     *addr = gni_addr;
 
-    return NA_SUCCESS;
+    return ret;
+
+error:
+    free(gni_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1274,7 +1252,7 @@ static na_return_t
 na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
     const void *addr, na_size_t addrlen, fi_addr_t *fi_addr)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     na_uint64_t addr_key;
     hg_hash_table_key_t ht_key = NULL;
     hg_hash_table_value_t ht_value = NULL;
@@ -1283,83 +1261,70 @@ na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
 
     /* Generate key */
     addr_key = na_ofi_addr_to_key(addr_format, addr, addrlen);
-    if (!addr_key) {
-        NA_LOG_ERROR("Could not generate key from addr");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(addr_key == 0, out, ret, NA_PROTOCOL_ERROR,
+        "Could not generate key from addr");
 
     /* Lookup key */
-    hg_thread_rwlock_rdlock(&domain->nod_rwlock);
-    ht_value = hg_hash_table_lookup(domain->nod_addr_ht, &addr_key);
+    hg_thread_rwlock_rdlock(&domain->rwlock);
+    ht_value = hg_hash_table_lookup(domain->addr_ht, &addr_key);
+    hg_thread_rwlock_release_rdlock(&domain->rwlock);
     if (ht_value != HG_HASH_TABLE_NULL) {
         *fi_addr = *(fi_addr_t *) ht_value;
-        hg_thread_rwlock_release_rdlock(&domain->nod_rwlock);
         return ret;
     }
-    hg_thread_rwlock_release_rdlock(&domain->nod_rwlock);
 
     /* Insert addr into AV if key not found */
     na_ofi_domain_lock(domain);
-    rc = fi_av_insert(domain->nod_av, addr, 1, fi_addr, 0 /* flags */,
+    rc = fi_av_insert(domain->fi_av, addr, 1, fi_addr, 0 /* flags */,
         NULL /* context */);
     na_ofi_domain_unlock(domain);
-    if (rc < 1) {
-        NA_LOG_ERROR("fi_av_insert failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc < 1, out, ret, NA_PROTOCOL_ERROR,
+        "fi_av_insert() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+
+    hg_thread_rwlock_wrlock(&domain->rwlock);
 
-    hg_thread_rwlock_wrlock(&domain->nod_rwlock);
-    /* in race condition, use addr in HT and remove the new addr from AV */
-    ht_value = hg_hash_table_lookup(domain->nod_addr_ht, &addr_key);
+    ht_value = hg_hash_table_lookup(domain->addr_ht, &addr_key);
     if (ht_value != HG_HASH_TABLE_NULL) {
-        fi_av_remove(domain->nod_av, fi_addr, 1, 0);
-        hg_thread_rwlock_release_wrlock(&domain->nod_rwlock);
+        /* in race condition, use addr in HT and remove the new addr from AV */
+        fi_av_remove(domain->fi_av, fi_addr, 1, 0);
         *fi_addr = *(fi_addr_t *) ht_value;
+        hg_thread_rwlock_release_wrlock(&domain->rwlock);
         return ret;
     }
 
     /* Allocate new key */
     ht_key = malloc(sizeof(na_uint64_t));
-    if (!ht_key) {
-        NA_LOG_ERROR("cannot allocate memory for ht_key");
-        ret = NA_NOMEM_ERROR;
-        goto unlock;
-    }
+    NA_CHECK_ERROR(ht_key == NULL, error, ret, NA_NOMEM_ERROR,
+        "Cannot allocate memory for ht_key");
 
     /* Allocate new value */
     ht_value = malloc(sizeof(*fi_addr));
-    if (!ht_value) {
-        NA_LOG_ERROR("cannot allocate memory for ht_key");
-        ret = NA_NOMEM_ERROR;
-        goto unlock;
-    }
+    NA_CHECK_ERROR(ht_value == NULL, error, ret, NA_NOMEM_ERROR,
+        "cannot allocate memory for ht_key");
 
     *((na_uint64_t *) ht_key) = addr_key;
     *((na_uint64_t *) ht_value) = *fi_addr;
 
     /* Insert new value */
-    if (!hg_hash_table_insert(domain->nod_addr_ht, ht_key, ht_value)) {
-        NA_LOG_ERROR("hg_hash_table_insert() failed.");
-        ret = NA_NOMEM_ERROR;
-        goto unlock;
-    }
+    rc = hg_hash_table_insert(domain->addr_ht, ht_key, ht_value);
+    NA_CHECK_ERROR(rc == 0, error, ret, NA_NOMEM_ERROR,
+        "hg_hash_table_insert() failed");
 
-unlock:
-    hg_thread_rwlock_release_wrlock(&domain->nod_rwlock);
+    hg_thread_rwlock_release_wrlock(&domain->rwlock);
 
 out:
-    if (ret != NA_SUCCESS) {
-        free(ht_key);
-        free(ht_value);
-    }
+    return ret;
+
+error:
+    hg_thread_rwlock_release_wrlock(&domain->rwlock);
+    free(ht_key);
+    free(ht_value);
+
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
-static int
+static na_return_t
 na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers)
 {
     struct fi_info *hints = NULL;
@@ -1370,19 +1335,13 @@ na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers)
       * Hints to query && filter providers.
       */
     hints = fi_allocinfo();
-    if (!hints) {
-        NA_LOG_ERROR("fi_allocinfo failed.\n");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM_ERROR,
+        "fi_allocinfo() failed");
 
     /* Protocol name is provider name, filter out providers within libfabric */
     hints->fabric_attr->prov_name = strdup(na_ofi_prov_name[prov_type]);
-    if (!hints->fabric_attr->prov_name) {
-        NA_LOG_ERROR("Could not duplicate name");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(hints->fabric_attr->prov_name == NULL, cleanup, ret,
+        NA_NOMEM_ERROR, "Could not duplicate name");
 
     /* mode: operational mode, NA_OFI passes in context for communication calls. */
     /* FI_ASYNC_IOV mode indicates  that  the  application  must  provide  the
@@ -1444,18 +1403,15 @@ na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers)
                     0ULL,  /* Optional flag */
                     hints, /* In: Hints to filter providers */
                     providers); /* Out: List of matching providers */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_getinfo failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, cleanup, ret, NA_PROTOCOL_ERROR,
+        "fi_getinfo() failed, rc: %d(%s)", rc, fi_strerror(-rc));
+
+cleanup:
+    free(hints->fabric_attr->prov_name);
+    hints->fabric_attr->prov_name = NULL;
+    fi_freeinfo(hints);
 
 out:
-    if (hints) {
-        free(hints->fabric_attr->prov_name);
-        hints->fabric_attr->prov_name = NULL;
-        fi_freeinfo(hints);
-    }
     return ret;
 }
 
@@ -1474,10 +1430,8 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
 
     /* Allocate new sin addr to store result */
     na_ofi_sin_addr = calloc(1, sizeof(*na_ofi_sin_addr));
-    if (!na_ofi_sin_addr) {
-        NA_LOG_ERROR("Could not allocate sin address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(na_ofi_sin_addr == NULL, out, ret, NA_NOMEM_ERROR,
+        "Could not allocate sin address");
     na_ofi_sin_addr->sin.sin_family = AF_INET;
     na_ofi_sin_addr->sin.sin_port = htons(port & 0xffff);
 
@@ -1491,27 +1445,25 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
     if (s == 0) {
         struct addrinfo *rp;
 
+        /* Get IP */
         for (rp = hostname_res; rp != NULL; rp = rp->ai_next) {
-            /* Get IP */
-            if (!inet_ntop(rp->ai_addr->sa_family,
+            const char *ptr = inet_ntop(rp->ai_addr->sa_family,
                 &((struct sockaddr_in *) rp->ai_addr)->sin_addr, ip_res,
-                INET_ADDRSTRLEN)) {
-                NA_LOG_ERROR("IP could not be resolved");
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
+                INET_ADDRSTRLEN);
+            NA_CHECK_ERROR(ptr == NULL, out, ret, NA_PROTOCOL_ERROR,
+                "IP could not be resolved");
             break;
         }
     }
 
     /* Check and compare interfaces */
-    if (getifaddrs(&ifaddrs) == -1) {
-        NA_LOG_ERROR("getifaddrs() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    s = getifaddrs(&ifaddrs);
+    NA_CHECK_ERROR(s == -1, out, ret, NA_PROTOCOL_ERROR,
+        "getifaddrs() failed");
+
     for (ifaddr = ifaddrs; ifaddr != NULL; ifaddr = ifaddr->ifa_next) {
         char ip[INET_ADDRSTRLEN] = {'\0'}; /* This restricts to ipv4 addresses */
+        const char *ptr;
 
         if (ifaddr->ifa_addr == NULL)
             continue;
@@ -1520,13 +1472,11 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
             continue;
 
         /* Get IP */
-        if (!inet_ntop(ifaddr->ifa_addr->sa_family,
+        ptr = inet_ntop(ifaddr->ifa_addr->sa_family,
             &((struct sockaddr_in *) ifaddr->ifa_addr)->sin_addr, ip,
-            INET_ADDRSTRLEN)) {
-            NA_LOG_ERROR("IP could not be resolved for: %s", ifaddr->ifa_name);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+            INET_ADDRSTRLEN);
+        NA_CHECK_ERROR(ptr == NULL, out, ret, NA_PROTOCOL_ERROR,
+            "IP could not be resolved for: %s", ifaddr->ifa_name);
 
         /* Compare hostnames / device names */
         if (!strcmp(ip, ip_res) || !strcmp(ifaddr->ifa_name, hostname)) {
@@ -1541,10 +1491,8 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
         *na_ofi_sin_addr_ptr = na_ofi_sin_addr;
         if (ifa_name) {
             *ifa_name = strdup(ifaddr->ifa_name);
-            if (!*ifa_name) {
-                NA_LOG_ERROR("Could not dup ifa_name");
-                ret = NA_NOMEM_ERROR;
-            }
+            NA_CHECK_ERROR(*ifa_name == NULL, out, ret, NA_NOMEM_ERROR,
+                "Could not dup ifa_name");
         }
     }
 
@@ -1554,6 +1502,7 @@ out:
     freeifaddrs(ifaddrs);
     if (hostname_res)
         freeaddrinfo(hostname_res);
+
     return ret;
 }
 
@@ -1562,26 +1511,21 @@ static NA_INLINE na_bool_t
 na_ofi_verify_provider(enum na_ofi_prov_type prov_type, const char *domain_name,
     const struct fi_info *fi_info)
 {
-    na_bool_t ret = NA_FALSE;
-
     /* Does not match provider name */
     if (strcmp(na_ofi_prov_name[prov_type], fi_info->fabric_attr->prov_name))
-        goto out;
+        return NA_FALSE;
 
     /* for some providers the provider name is ambiguous and we must check
      * the domain name as well
      */
-    if(na_ofi_prov_flags[prov_type] & NA_OFI_VERIFY_PROV_DOM) {
+    if (na_ofi_prov_flags[prov_type] & NA_OFI_VERIFY_PROV_DOM) {
         /* Does not match domain name */
         if (domain_name && strcmp("\0", domain_name)
             && strcmp(domain_name, fi_info->domain_attr->name))
-            goto out;
+            return NA_FALSE;
     }
 
-    ret = NA_TRUE;
-
-out:
-    return ret;
+    return NA_TRUE;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1594,20 +1538,14 @@ na_ofi_gni_set_domain_op_value(struct na_ofi_domain *na_ofi_domain, int op,
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    rc = fi_open_ops(&na_ofi_domain->nod_domain->fid, FI_GNI_DOMAIN_OPS_1,
+    rc = fi_open_ops(&na_ofi_domain->fi_domain->fid, FI_GNI_DOMAIN_OPS_1,
         0, (void **) &gni_domain_ops, NULL);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_open_ops failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_open_ops() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-    rc = gni_domain_ops->set_val(&na_ofi_domain->nod_domain->fid, op, value);
-    if (rc != 0) {
-        NA_LOG_ERROR("set_val failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = gni_domain_ops->set_val(&na_ofi_domain->fi_domain->fid, op, value);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "gni_domain_ops->set_val() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
 out:
     return ret;
@@ -1616,8 +1554,7 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_domain_open(struct na_ofi_class *priv,
-    enum na_ofi_prov_type prov_type,
+na_ofi_domain_open(struct na_ofi_class *priv, enum na_ofi_prov_type prov_type,
     const char *domain_name, const char *auth_key,
     struct na_ofi_domain **na_ofi_domain_p)
 {
@@ -1634,114 +1571,86 @@ na_ofi_domain_open(struct na_ofi_class *priv,
      * na_ofi_domain.
      */
     hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
-    HG_LIST_FOREACH(na_ofi_domain, &na_ofi_domain_list_g, nod_entry) {
+    HG_LIST_FOREACH(na_ofi_domain, &na_ofi_domain_list_g, entry) {
         if (na_ofi_verify_provider(prov_type, domain_name,
-            na_ofi_domain->nod_prov)) {
-            hg_atomic_incr32(&na_ofi_domain->nod_refcount);
+            na_ofi_domain->fi_prov)) {
+            hg_atomic_incr32(&na_ofi_domain->refcount);
             domain_found = NA_TRUE;
             break;
         }
     }
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
     if (domain_found) {
-        /*
-        NA_LOG_DEBUG("Found existing domain (%s)",
-            na_ofi_domain->nod_prov_name);
-        */
+//        NA_LOG_DEBUG("Found existing domain (%s)",
+//            na_ofi_domain->prov_name);
         *na_ofi_domain_p = na_ofi_domain;
-        goto out;
+        return ret;
     }
 
     /* If no pre-existing domain, get OFI providers info */
     ret = na_ofi_getinfo(prov_type, &providers);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_getinfo failed, ret: %d.", ret);
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "na_ofi_getinfo() failed");
 
     /* Try to find provider that matches protocol and domain/host name */
     prov = providers;
     while (prov != NULL) {
         if (na_ofi_verify_provider(prov_type, domain_name, prov)) {
-            /*
-            NA_LOG_DEBUG("mode 0x%llx, fabric_attr -> prov_name: %s, name: %s; "
-                         "domain_attr -> name: %s, threading: %d.",
-                         prov->mode, prov->fabric_attr->prov_name,
-                         prov->fabric_attr->name, prov->domain_attr->name,
-                         prov->domain_attr->threading);
-            */
+//            NA_LOG_DEBUG("mode 0x%llx, fabric_attr -> prov_name: %s, name: %s; "
+//                "domain_attr -> name: %s, threading: %d.", prov->mode,
+//                prov->fabric_attr->prov_name, prov->fabric_attr->name,
+//                prov->domain_attr->name, prov->domain_attr->threading);
             prov_found = NA_TRUE;
             break;
         }
         prov = prov->next;
     }
-    if (!prov_found) {
-        NA_LOG_ERROR("No provider found for \"%s\" provider on domain \"%s\"",
-                     na_ofi_prov_name[prov_type], domain_name);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(!prov_found, error, ret, NA_PROTOCOL_ERROR,
+        "No provider found for \"%s\" provider on domain \"%s\"",
+        na_ofi_prov_name[prov_type], domain_name);
 
     na_ofi_domain = (struct na_ofi_domain *) malloc(
         sizeof(struct na_ofi_domain));
-    if (na_ofi_domain == NULL) {
-        NA_LOG_ERROR("Could not allocate na_ofi_domain");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_domain == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate na_ofi_domain");
     memset(na_ofi_domain, 0, sizeof(struct na_ofi_domain));
-    hg_atomic_set32(&na_ofi_domain->nod_refcount, 1);
+    hg_atomic_set32(&na_ofi_domain->refcount, 1);
 
     /* Init mutex */
-    rc = hg_thread_mutex_init(&na_ofi_domain->nod_mutex);
-    if (rc != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_thread_mutex_init failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    rc = hg_thread_mutex_init(&na_ofi_domain->mutex);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_NOMEM_ERROR,
+        "hg_thread_mutex_init() failed");
 
     /* Init rw lock */
-    rc = hg_thread_rwlock_init(&na_ofi_domain->nod_rwlock);
-    if (rc != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_thread_rwlock_init failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    rc = hg_thread_rwlock_init(&na_ofi_domain->rwlock);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_NOMEM_ERROR,
+        "hg_thread_rwlock_init() failed");
 
     /* Keep fi_info */
-    na_ofi_domain->nod_prov = fi_dupinfo(prov);
-    if (!na_ofi_domain->nod_prov) {
-        NA_LOG_ERROR("Could not duplicate fi_info");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_domain->fi_prov = fi_dupinfo(prov);
+    NA_CHECK_ERROR(na_ofi_domain->fi_prov == NULL, error, ret,
+        NA_NOMEM_ERROR, "Could not duplicate fi_info");
 
     /* Dup provider name */
-    na_ofi_domain->nod_prov_name = strdup(prov->fabric_attr->prov_name);
-    if (!na_ofi_domain->nod_prov_name) {
-        NA_LOG_ERROR("Could not duplicate name");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_domain->prov_name = strdup(prov->fabric_attr->prov_name);
+    NA_CHECK_ERROR(na_ofi_domain->prov_name == NULL, error, ret,
+        NA_NOMEM_ERROR, "Could not duplicate name");
 
-    na_ofi_domain->nod_prov_type = prov_type;
+    na_ofi_domain->prov_type = prov_type;
 
-    if(prov_type == NA_OFI_PROV_GNI) {
 #if defined(NA_OFI_HAS_EXT_GNI_H)
-        if (auth_key) {
-            na_ofi_domain->fi_gni_auth_key.type = GNIX_AKT_RAW;
-            na_ofi_domain->fi_gni_auth_key.raw.protection_key =
-                (uint32_t) strtoul(auth_key, NULL, 10);
-
-            na_ofi_domain->nod_prov->domain_attr->auth_key =
-                (void *) &na_ofi_domain->fi_gni_auth_key;
-            na_ofi_domain->nod_prov->domain_attr->auth_key_size =
-                sizeof(na_ofi_domain->fi_gni_auth_key);
-        }
+    if (prov_type == NA_OFI_PROV_GNI && auth_key) {
+        na_ofi_domain->fi_gni_auth_key.type = GNIX_AKT_RAW;
+        na_ofi_domain->fi_gni_auth_key.raw.protection_key =
+            (uint32_t) strtoul(auth_key, NULL, 10);
+
+        na_ofi_domain->fi_prov->domain_attr->auth_key =
+            (void *) &na_ofi_domain->fi_gni_auth_key;
+        na_ofi_domain->fi_prov->domain_attr->auth_key_size =
+            sizeof(na_ofi_domain->fi_gni_auth_key);
+    }
 #else
-        (void) auth_key;
+    (void) auth_key;
 #endif
-    }
 
     /* Force no wait if do not support FI_WAIT_FD/FI_WAIT_SET */
     if (!(na_ofi_prov_flags[prov_type] & (NA_OFI_WAIT_SET | NA_OFI_WAIT_FD)))
@@ -1749,129 +1658,120 @@ na_ofi_domain_open(struct na_ofi_class *priv,
 
     /* Force manual progress if no wait is set */
     if (priv->no_wait) {
-        na_ofi_domain->nod_prov->domain_attr->control_progress = FI_PROGRESS_MANUAL;
-        na_ofi_domain->nod_prov->domain_attr->data_progress = FI_PROGRESS_MANUAL;
+        na_ofi_domain->fi_prov->domain_attr->control_progress = FI_PROGRESS_MANUAL;
+        na_ofi_domain->fi_prov->domain_attr->data_progress = FI_PROGRESS_MANUAL;
     }
 
     /* Open fi fabric */
-    rc = fi_fabric(na_ofi_domain->nod_prov->fabric_attr,/* In:  Fabric attributes */
-                   &na_ofi_domain->nod_fabric,          /* Out: Fabric handle */
-                   NULL);                               /* Optional context for fabric events */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_fabric failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_fabric(na_ofi_domain->fi_prov->fabric_attr,/* In:  Fabric attributes */
+                   &na_ofi_domain->fi_fabric,          /* Out: Fabric handle */
+                   NULL);                              /* Optional context for fabric events */
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_fabric() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Create the fi access domain */
-    rc = fi_domain(na_ofi_domain->nod_fabric,   /* In:  Fabric object */
-                   na_ofi_domain->nod_prov,     /* In:  Provider */
-                   &na_ofi_domain->nod_domain,  /* Out: Domain object */
-                   NULL);                       /* Optional context for domain events */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_domain failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-    if (priv->nop_max_contexts > 1) {
+    rc = fi_domain(na_ofi_domain->fi_fabric,  /* In:  Fabric object */
+                   na_ofi_domain->fi_prov,    /* In:  Provider */
+                   &na_ofi_domain->fi_domain, /* Out: Domain object */
+                   NULL);                     /* Optional context for domain events */
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_domain() failed, rc: %d(%s)", rc, fi_strerror(-rc));
+
+    if (priv->max_contexts > 1) {
         size_t min_ctx_cnt =
-            MIN(na_ofi_domain->nod_prov->domain_attr->tx_ctx_cnt,
-                na_ofi_domain->nod_prov->domain_attr->rx_ctx_cnt);
-        if (priv->nop_max_contexts > min_ctx_cnt) {
-            NA_LOG_ERROR("Maximum number of requested contexts (%d) exceeds "
-                "provider limitation (%d).", priv->nop_max_contexts,
-                min_ctx_cnt);
-            ret = NA_INVALID_PARAM;
-            goto out;
-        }
+            MIN(na_ofi_domain->fi_prov->domain_attr->tx_ctx_cnt,
+                na_ofi_domain->fi_prov->domain_attr->rx_ctx_cnt);
+        NA_CHECK_ERROR(priv->max_contexts > min_ctx_cnt, error, ret,
+            NA_INVALID_PARAM, "Maximum number of requested contexts (%d) "
+            "exceeds provider limitation (%d)", priv->max_contexts,
+            min_ctx_cnt);
 //        NA_LOG_DEBUG("fi_domain created, tx_ctx_cnt %d, rx_ctx_cnt %d.",
-//            na_ofi_domain->nod_prov->domain_attr->tx_ctx_cnt,
-//            na_ofi_domain->nod_prov->domain_attr->rx_ctx_cnt);
+//            na_ofi_domain->fi_prov->domain_attr->tx_ctx_cnt,
+//            na_ofi_domain->fi_prov->domain_attr->rx_ctx_cnt);
     }
 
 #ifdef NA_OFI_HAS_EXT_GNI_H
-    if (na_ofi_domain->nod_prov_type == NA_OFI_PROV_GNI) {
-        int enable = 1;
+    if (na_ofi_domain->prov_type == NA_OFI_PROV_GNI) {
+        int32_t enable = 1;
 # ifdef NA_OFI_GNI_HAS_UDREG
         char *other_reg_type = "udreg";
+        int32_t udreg_limit = 1024;
 
         /* Enable use of udreg instead of internal MR cache */
         ret = na_ofi_gni_set_domain_op_value(na_ofi_domain, GNI_MR_CACHE,
             &other_reg_type);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not set domain op value for GNI_MR_CACHE");
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(error, ret,
+            "Could not set domain op value for GNI_MR_CACHE");
+
+        /* Experiments on Theta showed default value of 2048 too high if
+         * launching multiple clients on one node */
+        ret = na_ofi_gni_set_domain_op_value(na_ofi_domain,
+            GNI_MR_UDREG_REG_LIMIT, &udreg_limit);
+        NA_CHECK_NA_ERROR(error, ret,
+            "Could not set domain op value for GNI_MR_UDREG_REG_LIMIT");
 # endif
 
         /* Enable lazy deregistration in MR cache */
         ret = na_ofi_gni_set_domain_op_value(na_ofi_domain,
             GNI_MR_CACHE_LAZY_DEREG, &enable);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not set domain op value for GNI_MR_CACHE_LAZY_DEREG");
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(error, ret,
+            "Could not set domain op value for GNI_MR_CACHE_LAZY_DEREG");
     }
 #endif
 
     /* If memory does not need to be backed up by physical pages at the time of
      * registration, export all memory range for RMA
      * (this is equivalent to FI_MR_SCALABLE) */
-    if (!(na_ofi_domain->nod_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
+    if (!(na_ofi_domain->fi_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
         uint64_t requested_key =
-            (!(na_ofi_domain->nod_prov->domain_attr->mr_mode & FI_MR_PROV_KEY))
+            (!(na_ofi_domain->fi_prov->domain_attr->mr_mode & FI_MR_PROV_KEY))
             ? NA_OFI_RMA_KEY : 0;
 
-        rc = fi_mr_reg(na_ofi_domain->nod_domain, NULL, UINT64_MAX,
+        rc = fi_mr_reg(na_ofi_domain->fi_domain, NULL, UINT64_MAX,
             FI_REMOTE_READ | FI_REMOTE_WRITE | FI_SEND | FI_RECV
             | FI_READ | FI_WRITE, 0 /* offset */, requested_key, 0 /* flags */,
-            &na_ofi_domain->nod_mr, NULL /* context */);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_mr_reg failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+            &na_ofi_domain->fi_mr, NULL /* context */);
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_mr_reg failed(), rc: %d(%s)", rc, fi_strerror(-rc));
+
         /* Requested key may not be the same, currently RxM provider forces
          * the underlying provider to provide keys and ignores user-provided
          * key.
          */
-        na_ofi_domain->nod_mr_key = fi_mr_key(na_ofi_domain->nod_mr);
+        na_ofi_domain->fi_mr_key = fi_mr_key(na_ofi_domain->fi_mr);
     }
 
     /* Open fi address vector */
     av_attr.type = FI_AV_MAP;
     av_attr.rx_ctx_bits = NA_OFI_SEP_RX_CTX_BITS;
-    rc = fi_av_open(na_ofi_domain->nod_domain, &av_attr, &na_ofi_domain->nod_av,
+    rc = fi_av_open(na_ofi_domain->fi_domain, &av_attr, &na_ofi_domain->fi_av,
         NULL);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_av_open failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_av_open() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Create addr hash-table */
-    na_ofi_domain->nod_addr_ht = hg_hash_table_new(na_ofi_addr_ht_key_hash,
+    na_ofi_domain->addr_ht = hg_hash_table_new(na_ofi_addr_ht_key_hash,
         na_ofi_addr_ht_key_equal);
-    if (na_ofi_domain->nod_addr_ht == NULL) {
-        NA_LOG_ERROR("hg_hash_table_new failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    hg_hash_table_register_free_functions(na_ofi_domain->nod_addr_ht,
-        free, free);
+        NA_CHECK_ERROR(na_ofi_domain->addr_ht == NULL, error, ret,
+            NA_NOMEM_ERROR, "hg_hash_table_new() failed");
+    hg_hash_table_register_free_functions(na_ofi_domain->addr_ht, free, free);
 
     /* Insert to global domain list */
     hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
-    HG_LIST_INSERT_HEAD(&na_ofi_domain_list_g, na_ofi_domain, nod_entry);
+    HG_LIST_INSERT_HEAD(&na_ofi_domain_list_g, na_ofi_domain, entry);
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
 
     *na_ofi_domain_p = na_ofi_domain;
 
-out:
-    if (ret != NA_SUCCESS)
-       na_ofi_domain_close(na_ofi_domain);
+    fi_freeinfo(providers);
+
+    return ret;
+
+error:
+    na_ofi_domain_close(na_ofi_domain);
     if (providers)
         fi_freeinfo(providers);
+
     return ret;
 }
 
@@ -1882,86 +1782,70 @@ na_ofi_domain_close(struct na_ofi_domain *na_ofi_domain)
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    if (!na_ofi_domain) goto out;
+    if (!na_ofi_domain)
+        goto out;
 
     /* Remove from global domain list if not used anymore */
-    hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
-    if (hg_atomic_decr32(&na_ofi_domain->nod_refcount)) {
+    if (hg_atomic_decr32(&na_ofi_domain->refcount))
         /* Cannot free yet */
-        hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
         goto out;
-    }
+
     /* inserted to na_ofi_domain_list_g after nod_addr_ht created */
-    if (na_ofi_domain->nod_addr_ht != NULL)
-        HG_LIST_REMOVE(na_ofi_domain, nod_entry);
+    hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
+    if (na_ofi_domain->addr_ht != NULL)
+        HG_LIST_REMOVE(na_ofi_domain, entry);
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
 
     /* Close MR */
-    if (na_ofi_domain->nod_mr) {
-        rc = fi_close(&na_ofi_domain->nod_mr->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close MR failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_mr = NULL;
+    if (na_ofi_domain->fi_mr) {
+        rc = fi_close(&na_ofi_domain->fi_mr->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() MR failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_mr = NULL;
     }
 
     /* Close AV */
-    if (na_ofi_domain->nod_av) {
-        rc = fi_close(&na_ofi_domain->nod_av->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close AV failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_av = NULL;
+    if (na_ofi_domain->fi_av) {
+        rc = fi_close(&na_ofi_domain->fi_av->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() AV failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_av = NULL;
     }
 
     /* Close domain */
-    if (na_ofi_domain->nod_domain) {
-        rc = fi_close(&na_ofi_domain->nod_domain->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close domain failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_domain = NULL;
+    if (na_ofi_domain->fi_domain) {
+        rc = fi_close(&na_ofi_domain->fi_domain->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() domain failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_domain = NULL;
     }
 
     /* Close fabric */
-    if (na_ofi_domain->nod_fabric) {
-        rc = fi_close(&na_ofi_domain->nod_fabric->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close fabric failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_fabric = NULL;
+    if (na_ofi_domain->fi_fabric) {
+        rc = fi_close(&na_ofi_domain->fi_fabric->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() fabric failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_fabric = NULL;
     }
 
     /* Free OFI info */
-    if (na_ofi_domain->nod_prov) {
+    if (na_ofi_domain->fi_prov) {
         /* Prevent fi_freeinfo from attempting to free the key */
-        if (na_ofi_domain->nod_prov->domain_attr->auth_key)
-            na_ofi_domain->nod_prov->domain_attr->auth_key = NULL;
-        if (na_ofi_domain->nod_prov->domain_attr->auth_key_size)
-            na_ofi_domain->nod_prov->domain_attr->auth_key_size = 0;
-        fi_freeinfo(na_ofi_domain->nod_prov);
-        na_ofi_domain->nod_prov = NULL;
+        if (na_ofi_domain->fi_prov->domain_attr->auth_key)
+            na_ofi_domain->fi_prov->domain_attr->auth_key = NULL;
+        if (na_ofi_domain->fi_prov->domain_attr->auth_key_size)
+            na_ofi_domain->fi_prov->domain_attr->auth_key_size = 0;
+        fi_freeinfo(na_ofi_domain->fi_prov);
+        na_ofi_domain->fi_prov = NULL;
     }
 
-    if (na_ofi_domain->nod_addr_ht)
-        hg_hash_table_free(na_ofi_domain->nod_addr_ht);
+    if (na_ofi_domain->addr_ht)
+        hg_hash_table_free(na_ofi_domain->addr_ht);
 
-    hg_thread_mutex_destroy(&na_ofi_domain->nod_mutex);
-    hg_thread_rwlock_destroy(&na_ofi_domain->nod_rwlock);
+    hg_thread_mutex_destroy(&na_ofi_domain->mutex);
+    hg_thread_rwlock_destroy(&na_ofi_domain->rwlock);
 
-    free(na_ofi_domain->nod_prov_name);
+    free(na_ofi_domain->prov_name);
     free(na_ofi_domain);
 
 out:
@@ -1983,25 +1867,19 @@ na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
 
     na_ofi_endpoint = (struct na_ofi_endpoint *) malloc(
         sizeof(struct na_ofi_endpoint));
-    if (na_ofi_endpoint == NULL) {
-        NA_LOG_ERROR("Could not allocate na_ofi_endpoint");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_endpoint == NULL, out, ret, NA_NOMEM_ERROR,
+        "Could not allocate na_ofi_endpoint");
     memset(na_ofi_endpoint, 0, sizeof(struct na_ofi_endpoint));
 
     /* Dup fi_info */
-    hints = fi_dupinfo(na_ofi_domain->nod_prov);
-    if (!hints) {
-        NA_LOG_ERROR("Could not duplicate fi_info");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    hints = fi_dupinfo(na_ofi_domain->fi_prov);
+    NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM_ERROR,
+        "Could not duplicate fi_info");
 
     if (src_addr) {
         /* Set src addr hints (FI_SOURCE must not be set in that case) */
         free(hints->src_addr);
-        hints->addr_format = na_ofi_prov_addr_format[na_ofi_domain->nod_prov_type];
+        hints->addr_format = na_ofi_prov_addr_format[na_ofi_domain->prov_type];
         hints->src_addr = src_addr;
         hints->src_addrlen = src_addrlen;
     }
@@ -2011,27 +1889,17 @@ na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
     hints->ep_attr->rx_ctx_cnt = max_contexts;
 
     rc = fi_getinfo(NA_OFI_VERSION, node, NULL, flags, hints,
-        &na_ofi_endpoint->noe_prov);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_getinfo(%s) failed, rc: %d(%s).", node,
-            rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+        &na_ofi_endpoint->fi_prov);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_getinfo(%s) failed, rc: %d(%s)", node, rc, fi_strerror(-rc));
 
-    if ((na_ofi_prov_flags[na_ofi_domain->nod_prov_type] & NA_OFI_NO_SEP)
+    if ((na_ofi_prov_flags[na_ofi_domain->prov_type] & NA_OFI_NO_SEP)
         || max_contexts < 2) {
         ret = na_ofi_basic_ep_open(na_ofi_domain, no_wait, na_ofi_endpoint);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("na_ofi_basic_ep_open failed, ret: %d.", ret);
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(out, ret, "na_ofi_basic_ep_open() failed");
     } else {
         ret = na_ofi_sep_open(na_ofi_domain, na_ofi_endpoint);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("na_ofi_sep_open failed, ret: %d.", ret);
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(out, ret, "na_ofi_sep_open() failed");
     }
 
     *na_ofi_endpoint_p = na_ofi_endpoint;
@@ -2060,82 +1928,60 @@ na_ofi_basic_ep_open(const struct na_ofi_domain *na_ofi_domain,
     int rc;
 
     /* Create a transport level communication endpoint */
-    rc = fi_endpoint(na_ofi_domain->nod_domain, /* In:  Domain object */
-                     na_ofi_endpoint->noe_prov, /* In:  Provider */
-                     &na_ofi_endpoint->noe_ep,  /* Out: Endpoint object */
+    rc = fi_endpoint(na_ofi_domain->fi_domain,  /* In:  Domain object */
+                     na_ofi_endpoint->fi_prov,  /* In:  Provider */
+                     &na_ofi_endpoint->fi_ep,   /* Out: Endpoint object */
                      NULL);                     /* Optional context */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_endpoint failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_endpoint() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Initialize queue / mutex */
-    na_ofi_endpoint->noe_unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
-    if (!na_ofi_endpoint->noe_unexpected_op_queue) {
-        NA_LOG_ERROR("Could not allocate noe_unexpected_op_queue");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    HG_QUEUE_INIT(&na_ofi_endpoint->noe_unexpected_op_queue->noq_queue);
-    hg_thread_spin_init(&na_ofi_endpoint->noe_unexpected_op_queue->noq_lock);
+    na_ofi_endpoint->unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
+    NA_CHECK_ERROR(na_ofi_endpoint->unexpected_op_queue == NULL, out,
+        ret, NA_NOMEM_ERROR, "Could not allocate unexpected_op_queue");
+    HG_QUEUE_INIT(&na_ofi_endpoint->unexpected_op_queue->queue);
+    hg_thread_spin_init(&na_ofi_endpoint->unexpected_op_queue->lock);
 
     if (!no_wait) {
-        if (na_ofi_prov_flags[na_ofi_domain->nod_prov_type] & NA_OFI_WAIT_FD)
+        if (na_ofi_prov_flags[na_ofi_domain->prov_type] & NA_OFI_WAIT_FD)
             cq_attr.wait_obj = FI_WAIT_FD; /* Wait on fd */
         else {
             struct fi_wait_attr wait_attr = {0};
 
             /* Open wait set for other providers. */
             wait_attr.wait_obj = FI_WAIT_UNSPEC;
-            rc = fi_wait_open(na_ofi_domain->nod_fabric, &wait_attr,
-                &na_ofi_endpoint->noe_wait);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_wait_open failed, rc: %d(%s).", rc,
-                    fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
+            rc = fi_wait_open(na_ofi_domain->fi_fabric, &wait_attr,
+                &na_ofi_endpoint->fi_wait);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_wait_open() failed, rc: %d(%s)", rc, fi_strerror(-rc));
             cq_attr.wait_obj = FI_WAIT_SET; /* Wait on wait set */
-            cq_attr.wait_set = na_ofi_endpoint->noe_wait;
+            cq_attr.wait_set = na_ofi_endpoint->fi_wait;
         }
     }
     cq_attr.wait_cond = FI_CQ_COND_NONE;
     cq_attr.format = FI_CQ_FORMAT_TAGGED;
     cq_attr.size = NA_OFI_CQ_DEPTH;
-    rc = fi_cq_open(na_ofi_domain->nod_domain, &cq_attr,
-        &na_ofi_endpoint->noe_cq, NULL);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_cq_open failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_cq_open(na_ofi_domain->fi_domain, &cq_attr, &na_ofi_endpoint->fi_cq,
+        NULL);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_cq_open failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Bind the CQ and AV to the endpoint */
-    rc = fi_ep_bind(na_ofi_endpoint->noe_ep, &na_ofi_endpoint->noe_cq->fid,
+    rc = fi_ep_bind(na_ofi_endpoint->fi_ep, &na_ofi_endpoint->fi_cq->fid,
         FI_TRANSMIT | FI_RECV);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_ep_bind failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_ep_bind() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-    rc = fi_ep_bind(na_ofi_endpoint->noe_ep, &na_ofi_domain->nod_av->fid, 0);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_ep_bind failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_ep_bind(na_ofi_endpoint->fi_ep, &na_ofi_domain->fi_av->fid, 0);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_ep_bind() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Enable the endpoint for communication, and commits the bind operations */
-    rc = fi_enable(na_ofi_endpoint->noe_ep);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_enable failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_enable(na_ofi_endpoint->fi_ep);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_enable() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-    na_ofi_endpoint->noe_sep = NA_FALSE;
+    na_ofi_endpoint->sep = NA_FALSE;
 
 out:
     return ret;
@@ -2150,34 +1996,24 @@ na_ofi_sep_open(const struct na_ofi_domain *na_ofi_domain,
     int rc;
 
     /* Create a transport level communication endpoint (sep) */
-    rc = fi_scalable_ep(na_ofi_domain->nod_domain, /* In:  Domain object */
-                        na_ofi_endpoint->noe_prov, /* In:  Provider */
-                        &na_ofi_endpoint->noe_ep,  /* Out: Endpoint object */
-                        NULL);                     /* Optional context */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_scalable_ep failed, rc: %d(%s).",
-                     rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-
-    rc = fi_scalable_ep_bind(na_ofi_endpoint->noe_ep,
-        &na_ofi_domain->nod_av->fid, 0);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_ep_bind failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_scalable_ep(na_ofi_domain->fi_domain, /* In:  Domain object */
+                        na_ofi_endpoint->fi_prov, /* In:  Provider */
+                        &na_ofi_endpoint->fi_ep,  /* Out: Endpoint object */
+                        NULL);                    /* Optional context */
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_scalable_ep() failed, rc: %d(%s)", rc, fi_strerror(-rc));
+
+    rc = fi_scalable_ep_bind(na_ofi_endpoint->fi_ep, &na_ofi_domain->fi_av->fid,
+        0);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_ep_bind() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Enable the endpoint for communication, and commits the bind operations */
-    ret = fi_enable(na_ofi_endpoint->noe_ep);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_enable failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    ret = fi_enable(na_ofi_endpoint->fi_ep);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_enable() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-    na_ofi_endpoint->noe_sep = NA_TRUE;
+    na_ofi_endpoint->sep = NA_TRUE;
 
 out:
     return ret;
@@ -2190,64 +2026,52 @@ na_ofi_endpoint_close(struct na_ofi_endpoint *na_ofi_endpoint)
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    if (!na_ofi_endpoint) goto out;
+    if (!na_ofi_endpoint)
+        goto out;
 
     /* When not using SEP */
-    if (na_ofi_endpoint->noe_unexpected_op_queue) {
+    if (na_ofi_endpoint->unexpected_op_queue) {
         /* Check that unexpected op queue is empty */
-        if (!HG_QUEUE_IS_EMPTY(
-            &na_ofi_endpoint->noe_unexpected_op_queue->noq_queue)) {
-            NA_LOG_ERROR("Unexpected op queue should be empty");
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        hg_thread_spin_destroy(
-            &na_ofi_endpoint->noe_unexpected_op_queue->noq_lock);
-        free(na_ofi_endpoint->noe_unexpected_op_queue);
+        na_bool_t empty = HG_QUEUE_IS_EMPTY(
+            &na_ofi_endpoint->unexpected_op_queue->queue);
+        NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_PROTOCOL_ERROR,
+            "Unexpected op queue should be empty");
+        hg_thread_spin_destroy(&na_ofi_endpoint->unexpected_op_queue->lock);
+        free(na_ofi_endpoint->unexpected_op_queue);
     }
 
     /* Close endpoint */
-    if (na_ofi_endpoint->noe_ep) {
-        rc = fi_close(&na_ofi_endpoint->noe_ep->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close endpoint failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_endpoint->noe_ep = NULL;
+    if (na_ofi_endpoint->fi_ep) {
+        rc = fi_close(&na_ofi_endpoint->fi_ep->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() endpoint failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_endpoint->fi_ep = NULL;
     }
 
     /* Close completion queue */
-    if (na_ofi_endpoint->noe_cq) {
-        rc = fi_close(&na_ofi_endpoint->noe_cq->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close CQ failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_endpoint->noe_cq = NULL;
+    if (na_ofi_endpoint->fi_cq) {
+        rc = fi_close(&na_ofi_endpoint->fi_cq->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() CQ failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_endpoint->fi_cq = NULL;
     }
 
     /* Close wait set */
-    if (na_ofi_endpoint->noe_wait) {
-        rc = fi_close(&na_ofi_endpoint->noe_wait->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close wait failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_endpoint->noe_wait = NULL;
+    if (na_ofi_endpoint->fi_wait) {
+        rc = fi_close(&na_ofi_endpoint->fi_wait->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() wait failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_endpoint->fi_wait = NULL;
     }
 
     /* Free OFI info */
-    if (na_ofi_endpoint->noe_prov) {
-        fi_freeinfo(na_ofi_endpoint->noe_prov);
-        na_ofi_endpoint->noe_prov = NULL;
+    if (na_ofi_endpoint->fi_prov) {
+        fi_freeinfo(na_ofi_endpoint->fi_prov);
+        na_ofi_endpoint->fi_prov = NULL;
     }
 
-    if (na_ofi_endpoint->noe_addr)
-        na_ofi_addr_decref(na_ofi_endpoint->noe_addr);
+    if (na_ofi_endpoint->src_addr)
+        na_ofi_addr_decref(na_ofi_endpoint->src_addr);
     free(na_ofi_endpoint);
 
 out:
@@ -2259,42 +2083,35 @@ static na_return_t
 na_ofi_get_ep_addr(na_class_t *na_class, struct na_ofi_addr **na_ofi_addr_ptr)
 {
     struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_domain *na_ofi_domain = priv->nop_domain;
-    struct na_ofi_endpoint *na_ofi_endpoint = priv->nop_endpoint;
+    struct na_ofi_domain *na_ofi_domain = priv->domain;
+    struct na_ofi_endpoint *na_ofi_endpoint = priv->endpoint;
     struct na_ofi_addr *na_ofi_addr = NULL;
     void *addr = NULL;
-    size_t addrlen = na_ofi_domain->nod_prov->src_addrlen;
+    size_t addrlen = na_ofi_domain->fi_prov->src_addrlen;
     na_bool_t retried = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("Could not allocate NA OFI addr");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_addr = na_ofi_addr_alloc(priv->domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate NA OFI addr");
 
 retry_getname:
     if (retried)
         free(addr);
     addr = malloc(addrlen);
-    if (addr == NULL) {
-        NA_LOG_ERROR("Could not allocate addr.");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate addr");
 
-    rc = fi_getname(&na_ofi_endpoint->noe_ep->fid, addr, &addrlen);
-    if (rc != FI_SUCCESS) {
+    rc = fi_getname(&na_ofi_endpoint->fi_ep->fid, addr, &addrlen);
+    if (rc != 0) {
         if (rc == -FI_ETOOSMALL && retried == NA_FALSE) {
             retried = NA_TRUE;
             goto retry_getname;
         }
-        NA_LOG_ERROR("fi_getname failed, rc: %d(%s), addrlen: %zu.",
-                     rc, fi_strerror(-rc), addrlen);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
+        NA_GOTO_ERROR(error, ret, NA_PROTOCOL_ERROR,
+            "fi_getname() failed, rc: %d(%s), addrlen: %zu", rc,
+            fi_strerror(-rc), addrlen);
     }
 
     na_ofi_addr->addr = addr;
@@ -2303,19 +2120,17 @@ retry_getname:
 
     /* Get URI from address */
     ret = na_ofi_get_uri(na_class, na_ofi_addr->addr, &na_ofi_addr->uri);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not get URI from endpoint address");
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not get URI from endpoint address");
 
     /* TODO check address size */
    *na_ofi_addr_ptr = na_ofi_addr;
 
-out:
-    if (ret != NA_SUCCESS) {
-        free(addr);
-        free(na_ofi_addr);
-    }
+    return ret;
+
+error:
+    free(addr);
+    free(na_ofi_addr);
+
     return ret;
 }
 
@@ -2324,7 +2139,7 @@ static na_return_t
 na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
 {
     struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_domain *na_ofi_domain = priv->nop_domain;
+    struct na_ofi_domain *na_ofi_domain = priv->domain;
     char addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         fi_addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         *fi_addr_str_ptr, *uri = NULL;
@@ -2333,42 +2148,31 @@ na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
     int rc;
 
     /* Convert FI address to a printable string */
-    fi_av_straddr(na_ofi_domain->nod_av, addr, fi_addr_str, &fi_addr_strlen);
-    if (fi_addr_strlen > NA_OFI_MAX_URI_LEN) {
-        NA_LOG_ERROR("fi_av_straddr() address truncated, addrlen: %zu",
-            fi_addr_strlen);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    fi_av_straddr(na_ofi_domain->fi_av, addr, fi_addr_str, &fi_addr_strlen);
+    NA_CHECK_ERROR(fi_addr_strlen > NA_OFI_MAX_URI_LEN, out, ret,
+        NA_PROTOCOL_ERROR, "fi_av_straddr() address truncated, addrlen: %zu",
+        fi_addr_strlen);
 
     /* Remove unnecessary "://" prefix from string if present */
     if (strstr(fi_addr_str, "://")) {
         strtok_r(fi_addr_str, ":", &fi_addr_str_ptr);
-        if (strncmp(fi_addr_str_ptr, "//", 2) != 0) {
-            NA_LOG_ERROR("Bad address string format");
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = strncmp(fi_addr_str_ptr, "//", 2);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "Bad address string format");
         fi_addr_str_ptr += 2;
     } else
         fi_addr_str_ptr = fi_addr_str;
 
     /* Generate URI */
     rc = snprintf(addr_str, NA_OFI_MAX_URI_LEN, "%s://%s",
-        na_ofi_domain->nod_prov->fabric_attr->prov_name, fi_addr_str_ptr);
-    if (rc < 0 || rc > NA_OFI_MAX_URI_LEN) {
-        NA_LOG_ERROR("snprintf failed or name truncated, rc: %d.", rc);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+        na_ofi_domain->fi_prov->fabric_attr->prov_name, fi_addr_str_ptr);
+    NA_CHECK_ERROR(rc < 0 || rc > NA_OFI_MAX_URI_LEN, out, ret,
+        NA_PROTOCOL_ERROR, "snprintf() failed or name truncated, rc: %d", rc);
 
     /* Dup URI */
     uri = strdup(addr_str);
-    if (uri == NULL) {
-        NA_LOG_ERROR("Could not strdup EP address string.");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(uri == NULL, out, ret, NA_NOMEM_ERROR,
+        "Could not strdup address string");
 
     *uri_ptr = uri;
 
@@ -2378,19 +2182,22 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static struct na_ofi_addr *
-na_ofi_addr_alloc(void)
+na_ofi_addr_alloc(struct na_ofi_domain *na_ofi_domain)
 {
     struct na_ofi_addr *na_ofi_addr;
 
     na_ofi_addr = (struct na_ofi_addr *)calloc(1, sizeof(*na_ofi_addr));
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("Could not allocate addr");
-        return NULL;
-    }
+    NA_CHECK_ERROR_NORET(na_ofi_addr == NULL, out,
+        "Could not allocate addr");
+
+    /* Keep reference to domain */
+    na_ofi_addr->domain = na_ofi_domain;
+    hg_atomic_incr32(&na_ofi_domain->refcount);
 
     /* One refcount for the caller to hold until addr_free */
     hg_atomic_set32(&na_ofi_addr->refcount, 1);
 
+out:
     return na_ofi_addr;
 }
 
@@ -2413,6 +2220,7 @@ na_ofi_addr_decref(struct na_ofi_addr *na_ofi_addr)
         return;
 
     /* TODO need to fi_av_remove? */
+    na_ofi_domain_close(na_ofi_addr->domain);
     free(na_ofi_addr->addr);
     free(na_ofi_addr->uri);
     free(na_ofi_addr);
@@ -2428,16 +2236,13 @@ na_ofi_mem_pool_create(na_class_t *na_class, na_size_t block_size,
         + sizeof(struct na_ofi_mem_pool)
         + block_count * (offsetof(struct na_ofi_mem_node, block));
     struct fid_mr *mr_hdl = NULL;
-    char *mem_ptr = NULL;
     na_size_t i;
 
-    mem_ptr = (char *) na_ofi_mem_alloc(na_class, pool_size, &mr_hdl);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate %d bytes", (int) pool_size);
-        goto out;
-    }
+    na_ofi_mem_pool = (struct na_ofi_mem_pool *) na_ofi_mem_alloc(na_class,
+        pool_size, &mr_hdl);
+    NA_CHECK_ERROR_NORET(na_ofi_mem_pool == NULL, out,
+        "Could not allocate %d bytes", (int) pool_size);
 
-    na_ofi_mem_pool = (struct na_ofi_mem_pool *) mem_ptr;
     HG_QUEUE_INIT(&na_ofi_mem_pool->node_list);
     hg_thread_spin_init(&na_ofi_mem_pool->node_list_lock);
     na_ofi_mem_pool->mr_hdl = mr_hdl;
@@ -2446,7 +2251,8 @@ na_ofi_mem_pool_create(na_class_t *na_class, na_size_t block_size,
     /* Assign nodes and insert them to free list */
     for (i = 0; i < block_count; i++) {
         struct na_ofi_mem_node *na_ofi_mem_node =
-            (struct na_ofi_mem_node *) (mem_ptr + sizeof(struct na_ofi_mem_pool)
+            (struct na_ofi_mem_node *) ((char *) na_ofi_mem_pool
+                + sizeof(struct na_ofi_mem_pool)
                 + i * (offsetof(struct na_ofi_mem_node, block) + block_size));
         HG_QUEUE_PUSH_TAIL(&na_ofi_mem_pool->node_list, na_ofi_mem_node, entry);
     }
@@ -2467,29 +2273,27 @@ na_ofi_mem_pool_destroy(struct na_ofi_mem_pool *na_ofi_mem_pool)
 static NA_INLINE void *
 na_ofi_mem_alloc(na_class_t *na_class, na_size_t size, struct fid_mr **mr_hdl)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     na_size_t page_size = (na_size_t) hg_mem_get_page_size();
     void *mem_ptr = NULL;
 
     /* Allocate backend buffer */
     mem_ptr = hg_mem_aligned_alloc(page_size, size);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate %d bytes", (int) size);
-        goto out;
-    }
+    NA_CHECK_ERROR_NORET(mem_ptr == NULL, out,
+        "Could not allocate %d bytes", (int) size);
     memset(mem_ptr, 0, size);
 
     /* Register memory if FI_MR_LOCAL is set and provider uses it */
-    if (domain->nod_prov->domain_attr->mr_mode & FI_MR_LOCAL) {
+    if (domain->fi_prov->domain_attr->mr_mode & FI_MR_LOCAL) {
         int rc;
 
-        rc = fi_mr_reg(domain->nod_domain, mem_ptr, size, FI_REMOTE_READ
+        rc = fi_mr_reg(domain->fi_domain, mem_ptr, size, FI_REMOTE_READ
             | FI_REMOTE_WRITE | FI_SEND | FI_RECV | FI_READ | FI_WRITE, 0 /* offset */,
             0 /* requested key */, 0 /* flags */, mr_hdl, NULL /* context */);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_mr_reg failed, rc: %d (%s).", rc, fi_strerror(-rc));
+        if (unlikely(rc != 0)) {
             hg_mem_aligned_free(mem_ptr);
-            goto out;
+            NA_GOTO_ERROR(out, mem_ptr, NULL,
+                "fi_mr_reg() failed, rc: %d (%s)", rc, fi_strerror(-rc));
         }
     }
 
@@ -2503,16 +2307,14 @@ na_ofi_mem_free(void *mem_ptr, struct fid_mr *mr_hdl)
 {
     /* Release MR handle is there was any */
     if (mr_hdl) {
-        int rc;
-
-        rc = fi_close(&mr_hdl->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close mr_hdl failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-        }
+        int rc = fi_close(&mr_hdl->fid);
+        NA_CHECK_ERROR_NORET(rc != 0, out,
+            "fi_close() mr_hdl failed, rc: %d(%s)", rc, fi_strerror(-rc));
     }
 
+out:
     hg_mem_aligned_free(mem_ptr);
+    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2527,16 +2329,16 @@ na_ofi_mem_pool_alloc(na_class_t *na_class, na_size_t size,
 
 retry:
     /* Check whether we can get a block from one of the pools */
-    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
     HG_QUEUE_FOREACH(na_ofi_mem_pool,
-        &NA_OFI_CLASS(na_class)->nop_buf_pool, entry) {
+        &NA_OFI_CLASS(na_class)->buf_pool, entry) {
         hg_thread_spin_lock(&na_ofi_mem_pool->node_list_lock);
         found = !HG_QUEUE_IS_EMPTY(&na_ofi_mem_pool->node_list);
         hg_thread_spin_unlock(&na_ofi_mem_pool->node_list_lock);
         if (found)
             break;
     }
-    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
 
     /* If not, allocate and register a new pool */
     if (!found) {
@@ -2544,16 +2346,14 @@ retry:
             na_ofi_mem_pool_create(na_class,
                 na_ofi_msg_get_max_unexpected_size(na_class),
                 NA_OFI_MEM_BLOCK_COUNT);
-        hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
-        HG_QUEUE_PUSH_TAIL(&NA_OFI_CLASS(na_class)->nop_buf_pool,
+        hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
+        HG_QUEUE_PUSH_TAIL(&NA_OFI_CLASS(na_class)->buf_pool,
             na_ofi_mem_pool, entry);
-        hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+        hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
     }
 
-    if (size > na_ofi_mem_pool->block_size) {
-        NA_LOG_ERROR("Block size is too small for requested size");
-        goto out;
-    }
+    NA_CHECK_ERROR(size > na_ofi_mem_pool->block_size, out, mem_ptr, NULL,
+        "Block size is too small for requested size");
 
     /* Pick a node from one of the available pools */
     hg_thread_spin_lock(&na_ofi_mem_pool->node_list_lock);
@@ -2580,9 +2380,9 @@ na_ofi_mem_pool_free(na_class_t *na_class, void *mem_ptr, struct fid_mr *mr_hdl)
         container_of(mem_ptr, struct na_ofi_mem_node, block);
 
     /* Put the node back to the pool */
-    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
     HG_QUEUE_FOREACH(na_ofi_mem_pool,
-        &NA_OFI_CLASS(na_class)->nop_buf_pool, entry) {
+        &NA_OFI_CLASS(na_class)->buf_pool, entry) {
         /* If MR handle is NULL, it does not really matter which pool we push
          * the node back to.
          */
@@ -2593,7 +2393,7 @@ na_ofi_mem_pool_free(na_class_t *na_class, void *mem_ptr, struct fid_mr *mr_hdl)
             break;
         }
     }
-    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2601,8 +2401,8 @@ static NA_INLINE void
 na_ofi_op_id_addref(struct na_ofi_op_id *na_ofi_op_id)
 {
     /* init as 1 when op_create */
-    assert(hg_atomic_get32(&na_ofi_op_id->noo_refcount));
-    hg_atomic_incr32(&na_ofi_op_id->noo_refcount);
+    assert(hg_atomic_get32(&na_ofi_op_id->refcount));
+    hg_atomic_incr32(&na_ofi_op_id->refcount);
 
     return;
 }
@@ -2614,15 +2414,13 @@ na_ofi_op_id_decref(struct na_ofi_op_id *na_ofi_op_id)
     if (na_ofi_op_id == NULL)
         return;
 
-    assert(hg_atomic_get32(&na_ofi_op_id->noo_refcount) > 0);
+    assert(hg_atomic_get32(&na_ofi_op_id->refcount) > 0);
 
     /* If there are more references, return */
-    if (hg_atomic_decr32(&na_ofi_op_id->noo_refcount))
+    if (hg_atomic_decr32(&na_ofi_op_id->refcount))
         return;
 
     /* No more references, cleanup */
-    na_ofi_op_id->noo_magic_1 = 0;
-    na_ofi_op_id->noo_magic_2 = 0;
     free(na_ofi_op_id);
 
     return;
@@ -2635,12 +2433,6 @@ na_ofi_op_id_valid(struct na_ofi_op_id *na_ofi_op_id)
     if (na_ofi_op_id == NULL)
         return NA_FALSE;
 
-    if (na_ofi_op_id->noo_magic_1 != NA_OFI_OP_ID_MAGIC_1 ||
-        na_ofi_op_id->noo_magic_2 != NA_OFI_OP_ID_MAGIC_2) {
-        NA_LOG_ERROR("invalid magic number for na_ofi_op_id.");
-        return NA_FALSE;
-    }
-
     return NA_TRUE;
 }
 
@@ -2651,10 +2443,9 @@ na_ofi_msg_unexpected_op_push(na_context_t *context,
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
 
-    hg_thread_spin_lock(&ctx->noc_unexpected_op_queue->noq_lock);
-    HG_QUEUE_PUSH_TAIL(&ctx->noc_unexpected_op_queue->noq_queue, na_ofi_op_id,
-        noo_entry);
-    hg_thread_spin_unlock(&ctx->noc_unexpected_op_queue->noq_lock);
+    hg_thread_spin_lock(&ctx->unexpected_op_queue->lock);
+    HG_QUEUE_PUSH_TAIL(&ctx->unexpected_op_queue->queue, na_ofi_op_id, entry);
+    hg_thread_spin_unlock(&ctx->unexpected_op_queue->lock);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2664,10 +2455,10 @@ na_ofi_msg_unexpected_op_remove(na_context_t *context,
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
 
-    hg_thread_spin_lock(&ctx->noc_unexpected_op_queue->noq_lock);
-    HG_QUEUE_REMOVE(&ctx->noc_unexpected_op_queue->noq_queue, na_ofi_op_id,
-        na_ofi_op_id, noo_entry);
-    hg_thread_spin_unlock(&ctx->noc_unexpected_op_queue->noq_lock);
+    hg_thread_spin_lock(&ctx->unexpected_op_queue->lock);
+    HG_QUEUE_REMOVE(&ctx->unexpected_op_queue->queue, na_ofi_op_id,
+        na_ofi_op_id, entry);
+    hg_thread_spin_unlock(&ctx->unexpected_op_queue->lock);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2677,10 +2468,10 @@ na_ofi_msg_unexpected_op_pop(na_context_t *context)
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     struct na_ofi_op_id *na_ofi_op_id;
 
-    hg_thread_spin_lock(&ctx->noc_unexpected_op_queue->noq_lock);
-    na_ofi_op_id = HG_QUEUE_FIRST(&ctx->noc_unexpected_op_queue->noq_queue);
-    HG_QUEUE_POP_HEAD(&ctx->noc_unexpected_op_queue->noq_queue, noo_entry);
-    hg_thread_spin_unlock(&ctx->noc_unexpected_op_queue->noq_lock);
+    hg_thread_spin_lock(&ctx->unexpected_op_queue->lock);
+    na_ofi_op_id = HG_QUEUE_FIRST(&ctx->unexpected_op_queue->queue);
+    HG_QUEUE_POP_HEAD(&ctx->unexpected_op_queue->queue, entry);
+    hg_thread_spin_unlock(&ctx->unexpected_op_queue->lock);
 
     return na_ofi_op_id;
 }
@@ -2692,7 +2483,7 @@ na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
     fi_addr_t src_addrs[], void **src_err_addr, size_t *src_err_addrlen,
     size_t *actual_count)
 {
-    struct fid_cq *cq_hdl = NA_OFI_CONTEXT(context)->noc_cq;
+    struct fid_cq *cq_hdl = NA_OFI_CONTEXT(context)->fi_cq;
     char err_data[NA_OFI_CQ_MAX_ERR_DATA_SIZE];
     struct fi_cq_err_entry cq_err;
     na_return_t ret = NA_SUCCESS;
@@ -2707,12 +2498,8 @@ na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
         *actual_count = 0;
         goto out;
     }
-    if (rc != -FI_EAVAIL) { /* no error available */
-        NA_LOG_ERROR("fi_cq_readfrom() failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != -FI_EAVAIL, out, ret, NA_PROTOCOL_ERROR,
+        "fi_cq_readfrom() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
     memset(&cq_err, 0, sizeof(cq_err));
     memset(&err_data, 0, sizeof(err_data));
@@ -2722,12 +2509,8 @@ na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
 
     /* Read error entry */
     rc = fi_cq_readerr(cq_hdl, &cq_err, 0 /* flags */);
-    if (rc != 1) {
-        NA_LOG_ERROR("fi_cq_readerr() failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 1, out, ret, NA_PROTOCOL_ERROR,
+        "fi_cq_readerr() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
     switch (cq_err.err) {
         case FI_ECANCELED:
@@ -2737,31 +2520,27 @@ na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
 
         case FI_EADDRNOTAVAIL: {
             struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-            struct fid_av *av_hdl = priv->nop_domain->nod_av;
+            struct fid_av *av_hdl = priv->domain->fi_av;
             void *err_addr = NULL;
             size_t err_addrlen;
 
             /* Copy addr information */
             err_addr = malloc(cq_err.err_data_size);
-            if (!err_addr) {
-                NA_LOG_ERROR("Could not allocate err_addr");
-                ret = NA_NOMEM_ERROR;
-                goto out;
-            }
+            NA_CHECK_ERROR(err_addr == NULL, out, ret, NA_NOMEM_ERROR,
+                "Could not allocate err_addr");
             err_addrlen = cq_err.err_data_size;
             memcpy(err_addr, cq_err.err_data, err_addrlen);
 
-            na_ofi_domain_lock(priv->nop_domain);
+            na_ofi_domain_lock(priv->domain);
             /* Insert new source addr into AV if address was not found */
             rc = fi_av_insert(av_hdl, err_addr, 1, &src_addrs[0],
                 0 /* flags */, NULL /* context */);
-            na_ofi_domain_unlock(priv->nop_domain);
-            if (rc < 1) {
-                NA_LOG_ERROR("fi_av_insert failed, rc: %d(%s).",
-                    rc, fi_strerror((int) -rc));
-                ret = NA_PROTOCOL_ERROR;
+            na_ofi_domain_unlock(priv->domain);
+            if (unlikely(rc < 1)) {
                 free(err_addr);
-                goto out;
+                NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
+                    "fi_av_insert() failed, rc: %d(%s)",
+                    rc, fi_strerror((int) -rc));
             }
             /* Only one error event processed in that case */
             memcpy(&cq_events[0], &cq_err, sizeof(cq_events[0]));
@@ -2771,20 +2550,17 @@ na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
             break;
         }
         case FI_EIO:
-            NA_LOG_ERROR("fi_cq_readerr got err: %d(%s), "
-                "prov_errno: %d(%s).",
-                cq_err.err, fi_strerror(cq_err.err),
-                cq_err.prov_errno,
+            NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
+                "fi_cq_readerr() got err: %d(%s), prov_errno: %d(%s)",
+                cq_err.err, fi_strerror(cq_err.err), cq_err.prov_errno,
                 fi_strerror(-cq_err.prov_errno));
-            goto out;
+            break;
         default:
-            NA_LOG_ERROR("fi_cq_readerr got err: %d(%s), "
-                "prov_errno: %d(%s).",
-                cq_err.err, fi_strerror(cq_err.err),
-                cq_err.prov_errno,
+            NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
+                "fi_cq_readerr() got err: %d(%s), prov_errno: %d(%s)",
+                cq_err.err, fi_strerror(cq_err.err), cq_err.prov_errno,
                 fi_strerror(-cq_err.prov_errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
+            break;
     }
 
 out:
@@ -2798,65 +2574,47 @@ na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
     void *src_err_addr, size_t src_err_addrlen)
 {
     struct na_ofi_op_id *na_ofi_op_id = container_of(
-        cq_event->op_context, struct na_ofi_op_id, noo_fi_ctx);
+        cq_event->op_context, struct na_ofi_op_id, fi_ctx);
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_ofi_op_id_valid(na_ofi_op_id)) {
-        NA_LOG_ERROR("Bad na_ofi_op_id, ignoring event.");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-    if (hg_atomic_get32(&na_ofi_op_id->noo_canceled)) {
+    NA_CHECK_ERROR(!na_ofi_op_id_valid(na_ofi_op_id), out, ret,
+        NA_PROTOCOL_ERROR, "Bad na_ofi_op_id, ignoring event");
+    if (hg_atomic_get32(&na_ofi_op_id->canceled)) {
         ret = NA_CANCELED;
         goto complete;
     }
-    if (hg_atomic_get32(&na_ofi_op_id->noo_completed)) {
-        NA_LOG_ERROR("Ignoring CQ event as the op is completed.");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    // TODO check that
+    if (hg_atomic_get32(&na_ofi_op_id->completed))
+        NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
+            "Ignoring CQ event as the op is completed");
 
     if (cq_event->flags & FI_SEND) {
         ret = na_ofi_cq_process_send_event(na_ofi_op_id);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not process send event");
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(out, ret, "Could not process send event");
     } else if (cq_event->flags & FI_RECV) {
         if (cq_event->tag & ~NA_OFI_UNEXPECTED_TAG_IGNORE) {
             ret = na_ofi_cq_process_recv_expected_event(na_ofi_op_id,
                 cq_event->tag, cq_event->len);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not process expected recv event");
-                goto out;
-            }
+            NA_CHECK_NA_ERROR(out, ret,
+                "Could not process expected recv event");
         } else {
             ret = na_ofi_cq_process_recv_unexpected_event(na_class, context,
                 na_ofi_op_id, src_addr, src_err_addr, src_err_addrlen,
                 cq_event->tag, cq_event->len);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not process unexpected recv event");
-                goto out;
-            }
+            NA_CHECK_NA_ERROR(out, ret,
+                "Could not process unexpected recv event");
         }
     } else if (cq_event->flags & FI_RMA) {
         ret = na_ofi_cq_process_rma_event(na_ofi_op_id);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not process rma event");
-            goto out;
-        }
-    } else {
-        NA_LOG_ERROR("bad cq event flags: 0x%x.", cq_event->flags);
-        goto out;
-    }
+        NA_CHECK_NA_ERROR(out, ret, "Could not process rma event");
+    } else
+        NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
+            "Unsupported CQ event flags: 0x%x.", cq_event->flags);
 
 complete:
     /* Complete operation */
     ret = na_ofi_complete(na_ofi_op_id, ret);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Unable to complete operation");
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(out, ret, "Unable to complete operation");
 
 out:
     return ret;
@@ -2866,15 +2624,12 @@ out:
 static NA_INLINE na_return_t
 na_ofi_cq_process_send_event(struct na_ofi_op_id *na_ofi_op_id)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_SEND_EXPECTED && cb_type != NA_CB_SEND_UNEXPECTED) {
-        NA_LOG_ERROR("ignore the send_event as cb_type %d mismatched with "
-            "NA_CB_SEND_EXPECTED/_UNEXPECTED.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_SEND_EXPECTED
+        && cb_type != NA_CB_SEND_UNEXPECTED, out, ret, NA_PROTOCOL_ERROR,
+        "Invalid cb_type %d, expected NA_CB_SEND_EXPECTED/UNEXPECTED", cb_type);
 
 out:
     return ret;
@@ -2887,24 +2642,19 @@ na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
     fi_addr_t src_addr, void *src_err_addr, size_t src_err_addrlen,
     uint64_t tag, size_t len)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_RECV_UNEXPECTED) {
-        NA_LOG_ERROR("ignore the recv_event as cb_type %d mismatched with "
-            "NA_CB_RECV_UNEXPECTED.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_RECV_UNEXPECTED, out, ret,
+        NA_PROTOCOL_ERROR, "Invalid cb_type %d, expected NA_CB_RECV_UNEXPECTED",
+        cb_type);
 
     /* Allocate new address */
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("na_ofi_addr_alloc failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_addr = na_ofi_addr_alloc(priv->domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM_ERROR,
+        "na_ofi_addr_alloc() failed");
     na_ofi_addr->addr = src_err_addr; /* may be NULL */
     na_ofi_addr->addrlen = src_err_addrlen;
     /* Unexpected address may not have addr/addrlen info */
@@ -2913,26 +2663,26 @@ na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
     /* Process address info from msg header */
     if (na_ofi_with_msg_hdr(na_class)) {
         ret = na_ofi_addr_ht_lookup(na_class, FI_SOCKADDR_IN,
-            na_ofi_op_id->noo_info.noo_recv_unexpected.noi_buf,
+            na_ofi_op_id->info.recv_unexpected.buf,
             sizeof(struct na_ofi_sin_addr), &src_addr);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("na_ofi_addr_ht_lookup_reqhdr failed, ret: %d.", ret);
-            na_ofi_addr_decref(na_ofi_addr);
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
     }
     na_ofi_addr->fi_addr = src_addr;
     /* For unexpected msg, take one extra ref to be released by addr_free() */
     na_ofi_addr_addref(na_ofi_addr);
 
-    na_ofi_op_id->noo_addr = na_ofi_addr;
+    na_ofi_op_id->addr = na_ofi_addr;
     /* TODO check max tag */
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_tag = (na_tag_t) tag;
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_msg_size = len;
+    na_ofi_op_id->info.recv_unexpected.tag = (na_tag_t) tag;
+    na_ofi_op_id->info.recv_unexpected.msg_size = len;
     na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
 
 out:
     return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2940,26 +2690,19 @@ static NA_INLINE na_return_t
 na_ofi_cq_process_recv_expected_event(struct na_ofi_op_id *na_ofi_op_id,
     uint64_t tag, size_t len)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_RECV_EXPECTED) {
-        NA_LOG_ERROR("ignore the recv_event as cb_type %d mismatched with "
-            "NA_CB_RECV_EXPECTED.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-    if (na_ofi_op_id->noo_info.noo_recv_expected.noi_tag
-        != (tag & ~NA_OFI_EXPECTED_TAG_FLAG)) {
-        NA_LOG_ERROR("ignore the recv_event as noi_tag 0x%x mismatch with "
-            "cq_event->tag: 0x%x.",
-            na_ofi_op_id->noo_info.noo_recv_expected.noi_tag,
-            tag & ~NA_OFI_EXPECTED_TAG_FLAG);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_RECV_EXPECTED, out, ret,
+        NA_PROTOCOL_ERROR, "Invalid cb_type %d, expected NA_CB_RECV_EXPECTED",
+        cb_type);
+    NA_CHECK_ERROR(na_ofi_op_id->info.recv_expected.tag
+        != (tag & ~NA_OFI_EXPECTED_TAG_FLAG), out, ret, NA_PROTOCOL_ERROR,
+        "Invalid tag 0x%x, expected 0x%x",
+        na_ofi_op_id->info.recv_expected.tag,
+        tag & ~NA_OFI_EXPECTED_TAG_FLAG);
 
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_msg_size = len;
+    na_ofi_op_id->info.recv_expected.msg_size = len;
 
 out:
     return ret;
@@ -2969,15 +2712,12 @@ out:
 static NA_INLINE na_return_t
 na_ofi_cq_process_rma_event(struct na_ofi_op_id *na_ofi_op_id)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_PUT && cb_type != NA_CB_GET) {
-        NA_LOG_ERROR("ignore the send_event as cb_type %d mismatched with "
-            "NA_CB_PUT/_GET.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_PUT && cb_type != NA_CB_GET, out, ret,
+        NA_PROTOCOL_ERROR, "Invalid cb_type %d, expected NA_CB_PUT/GET",
+        cb_type);
 
 out:
     return ret;
@@ -2987,40 +2727,38 @@ out:
 static na_return_t
 na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id, na_return_t op_ret)
 {
-    struct na_ofi_addr *na_ofi_addr = na_ofi_op_id->noo_addr;
+    struct na_ofi_addr *na_ofi_addr = na_ofi_op_id->addr;
     struct na_cb_info *callback_info = NULL;
     na_return_t ret = NA_SUCCESS;
 
     /* Mark op id as completed */
-    if (!hg_atomic_cas32(&na_ofi_op_id->noo_completed, 0, 1))
+    if (!hg_atomic_cas32(&na_ofi_op_id->completed, 0, 1))
         return ret;
 
     /* Init callback info */
-    callback_info = &na_ofi_op_id->noo_completion_data.callback_info;
+    callback_info = &na_ofi_op_id->completion_data.callback_info;
     callback_info->ret = op_ret;
 
     switch (callback_info->type) {
     case NA_CB_LOOKUP:
         callback_info->info.lookup.addr =
-            na_ofi_op_id->noo_info.noo_lookup.noi_addr;
+            na_ofi_op_id->info.lookup.addr;
         break;
     case NA_CB_RECV_UNEXPECTED:
         /* Fill callback info */
         callback_info->info.recv_unexpected.actual_buf_size =
-            na_ofi_op_id->noo_info.noo_recv_unexpected.noi_msg_size;
+            na_ofi_op_id->info.recv_unexpected.msg_size;
         callback_info->info.recv_unexpected.source =
-            na_ofi_op_id->noo_addr;
+            na_ofi_op_id->addr;
         callback_info->info.recv_unexpected.tag =
-            na_ofi_op_id->noo_info.noo_recv_unexpected.noi_tag;
+            na_ofi_op_id->info.recv_unexpected.tag;
         break;
     case NA_CB_RECV_EXPECTED:
         /* Check buf_size and msg_size */
-        if (na_ofi_op_id->noo_info.noo_recv_expected.noi_msg_size >
-            na_ofi_op_id->noo_info.noo_recv_expected.noi_buf_size) {
-            NA_LOG_ERROR("Expected recv too large for buffer");
-            ret = NA_SIZE_ERROR;
-            goto out;
-        }
+        NA_CHECK_ERROR(
+            na_ofi_op_id->info.recv_expected.msg_size >
+            na_ofi_op_id->info.recv_expected.buf_size, out, ret,
+            NA_SIZE_ERROR, "Expected recv msg size too large for buffer");
         break;
     case NA_CB_SEND_UNEXPECTED:
     case NA_CB_SEND_EXPECTED:
@@ -3028,17 +2766,16 @@ na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id, na_return_t op_ret)
     case NA_CB_GET:
         break;
     default:
-        NA_LOG_ERROR("Operation type %d not supported.", callback_info->type);
-        ret = NA_INVALID_PARAM;
+        NA_GOTO_ERROR(out, ret, NA_INVALID_PARAM,
+            "Operation type %d not supported", callback_info->type);
         break;
     }
 
     /* Add OP to NA completion queue */
-    ret = na_cb_completion_add(na_ofi_op_id->noo_context,
-       &na_ofi_op_id->noo_completion_data);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add callback to completion queue");
-    }
+    ret = na_cb_completion_add(na_ofi_op_id->context,
+        &na_ofi_op_id->completion_data);
+    NA_CHECK_NA_ERROR(out, ret,
+        "Could not add callback to completion queue");
 
 out:
     if (na_ofi_addr)
@@ -3052,7 +2789,7 @@ na_ofi_release(void *arg)
 {
     struct na_ofi_op_id *na_ofi_op_id = (struct na_ofi_op_id *) arg;
 
-    if (na_ofi_op_id && !hg_atomic_get32(&na_ofi_op_id->noo_completed))
+    if (na_ofi_op_id && !hg_atomic_get32(&na_ofi_op_id->completed))
         NA_LOG_WARNING("Releasing resources from an uncompleted operation");
 
     na_ofi_op_id_decref(na_ofi_op_id);
@@ -3071,25 +2808,20 @@ na_ofi_check_protocol(const char *protocol_name)
     enum na_ofi_prov_type type;
 
     type = na_ofi_prov_name_to_type(protocol_name);
-    if(type == NA_OFI_PROV_NULL) {
-        NA_LOG_ERROR("protocol %s not supported", protocol_name);
-        goto out;
-    }
+    NA_CHECK_ERROR(type == NA_OFI_PROV_NULL, out, ret, NA_PROTOCOL_ERROR,
+        "Protocol %s not supported", protocol_name);
 
     /* Get info from provider */
     ret = na_ofi_getinfo(type, &providers);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_getinfo failed, ret: %d.", ret);
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(out, ret, "na_ofi_getinfo() failed");
 
     prov = providers;
     while (prov != NULL) {
-        /*
-        NA_LOG_DEBUG("fabric_attr - prov_name %s, name - %s, "
-                     "domain_attr - name %s, mode: 0x%llx, domain_attr->mode 0x%llx, caps: 0x%llx.", prov->fabric_attr->prov_name,
-                     prov->fabric_attr->name, prov->domain_attr->name, prov->mode, prov->domain_attr->mode, prov->caps);
-        */
+//        NA_LOG_DEBUG("fabric_attr - prov_name %s, name - %s, "
+//            "domain_attr - name %s, mode: 0x%llx, domain_attr->mode 0x%llx, caps: 0x%llx.",
+//            prov->fabric_attr->prov_name, prov->fabric_attr->name,
+//            prov->domain_attr->name, prov->mode, prov->domain_attr->mode,
+//            prov->caps);
         if (!strcmp(na_ofi_prov_name[type], prov->fabric_attr->prov_name)) {
             accept = NA_TRUE;
             break;
@@ -3097,9 +2829,9 @@ na_ofi_check_protocol(const char *protocol_name)
         prov = prov->next;
     }
 
+    fi_freeinfo(providers);
+
 out:
-    if (providers)
-        fi_freeinfo(providers);
     return accept;
 }
 
@@ -3122,41 +2854,32 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     na_return_t ret = NA_SUCCESS;
     enum na_ofi_prov_type prov_type;
 
-    /*
-    NA_LOG_DEBUG("Entering na_ofi_initialize class_name %s, protocol_name %s, "
-                 "host_name %s.\n", na_info->class_name, na_info->protocol_name,
-                 na_info->host_name);
-    */
+//    NA_LOG_DEBUG("Entering na_ofi_initialize class_name %s, protocol_name %s, "
+//                 "host_name %s.\n", na_info->class_name, na_info->protocol_name,
+//                 na_info->host_name);
 
     prov_type = na_ofi_prov_name_to_type(na_info->protocol_name);
-    if(prov_type == NA_OFI_PROV_NULL) {
-        NA_LOG_ERROR("protocol %s not supported", na_info->protocol_name);
-        ret = NA_INVALID_PARAM;
-        goto out;
-    }
+    NA_CHECK_ERROR(prov_type == NA_OFI_PROV_NULL, out, ret,
+        NA_INVALID_PARAM, "Protocol %s not supported", na_info->protocol_name);
 
 #if defined(NA_OFI_HAS_EXT_GNI_H) && defined(NA_OFI_GNI_HAS_UDREG)
     /* In case of GNI using udreg, we check to see whether MPICH_GNI_NDREG_ENTRIES
      * environment variable is set or not.  If not, this code is not likely
      * to work if Cray MPI is also used. Print error msg suggesting workaround.
      */
-    if (prov_type == NA_OFI_PROV_GNI && !getenv("MPICH_GNI_NDREG_ENTRIES"))
-    {
-        NA_LOG_ERROR("ofi+gni provider requested, but the MPICH_GNI_NDREG_ENTRIES environment variable is not set.");
-        NA_LOG_ERROR("Please run this executable with \"export MPICH_GNI_NDREG_ENTRIES=1024\" to ensure compatibility.");
-        ret = NA_INVALID_PARAM;
-        goto out;
-    }
+    NA_CHECK_ERROR(prov_type == NA_OFI_PROV_GNI
+        && !getenv("MPICH_GNI_NDREG_ENTRIES"), out, ret, NA_INVALID_PARAM,
+        "ofi+gni provider requested, but the MPICH_GNI_NDREG_ENTRIES "
+        "environment variable is not set.\n" "Please run this executable with "
+        "\"export MPICH_GNI_NDREG_ENTRIES=1024\" to ensure compatibility."
+    );
 #endif
 
     /* Use default interface name if no hostname was passed */
     if (na_info->host_name) {
         resolve_name = strdup(na_info->host_name);
-        if (!resolve_name) {
-            NA_LOG_ERROR("strdup() of host_name failed");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
+        NA_CHECK_ERROR(resolve_name == NULL, out, ret, NA_NOMEM_ERROR,
+            "strdup() of host_name failed");
 
         /* Extract hostname */
         if (strstr(resolve_name, ":")) {
@@ -3167,11 +2890,8 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
         }
     } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI) {
         resolve_name = strdup(NA_OFI_GNI_IFACE_DEFAULT);
-        if (!resolve_name) {
-            NA_LOG_ERROR("strdup() of NA_OFI_GNI_IFACE_DEFAULT failed");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
+        NA_CHECK_ERROR(resolve_name == NULL, out, ret, NA_NOMEM_ERROR,
+            "strdup() of NA_OFI_GNI_IFACE_DEFAULT failed");
     }
 
     /* Get hostname/port info if available */
@@ -3183,10 +2903,7 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
             /* Try to get matching IP/device */
             ret = na_ofi_check_interface(resolve_name, port, &ifa_name,
                 &na_ofi_sin_addr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not check interfaces");
-                goto out;
-            }
+            NA_CHECK_NA_ERROR(out, ret, "Could not check interfaces");
 
             /* Set SIN addr if found */
             if (na_ofi_sin_addr && ifa_name) {
@@ -3201,25 +2918,21 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
             }
         } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI) {
             struct na_ofi_sin_addr *na_ofi_sin_addr = NULL;
+            const char *ptr;
 
             /* Try to get matching IP/device (do not use port) */
             ret = na_ofi_check_interface(resolve_name, 0, NULL,
                 &na_ofi_sin_addr);
-            if (ret != NA_SUCCESS || !na_ofi_sin_addr) {
-                NA_LOG_ERROR("Could not check interfaces");
-                goto out;
-            }
+            NA_CHECK_ERROR(ret != NA_SUCCESS || !na_ofi_sin_addr, out, ret,
+                NA_PROTOCOL_ERROR, "Could not check interfaces");
 
             /* Node must match IP resolution */
-            if (!inet_ntop(na_ofi_sin_addr->sin.sin_family,
-                &na_ofi_sin_addr->sin.sin_addr, node, sizeof(node))) {
-                NA_LOG_ERROR("Could not convert IP to string");
-                free(na_ofi_sin_addr);
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            node_ptr = node;
+            ptr = inet_ntop(na_ofi_sin_addr->sin.sin_family,
+                &na_ofi_sin_addr->sin.sin_addr, node, sizeof(node));
             free(na_ofi_sin_addr);
+            NA_CHECK_ERROR(ptr == NULL, out, ret, NA_PROTOCOL_ERROR,
+                "Could not convert IP to string");
+            node_ptr = node;
         } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_PSMX2) {
             /* Nothing to do */
         }
@@ -3239,48 +2952,37 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     /* Create private data */
     na_class->plugin_class = (struct na_ofi_class *) malloc(
         sizeof(struct na_ofi_class));
-    if (!na_class->plugin_class) {
-        NA_LOG_ERROR("Could not allocate NA private data class");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_class->plugin_class == NULL, out, ret, NA_NOMEM_ERROR,
+        "Could not allocate NA private data class");
     memset(na_class->plugin_class, 0, sizeof(struct na_ofi_class));
     priv = NA_OFI_CLASS(na_class);
     priv->no_wait = no_wait;
-    priv->nop_listen = listen;
-    priv->nop_max_contexts = max_contexts;
-    priv->nop_contexts = 0;
+    priv->listen = listen;
+    priv->max_contexts = max_contexts;
+    priv->contexts = 0;
 
     /* Initialize queue / mutex */
-    hg_thread_mutex_init(&priv->nop_mutex);
+    hg_thread_mutex_init(&priv->mutex);
 
     /* Initialize buf pool */
-    hg_thread_spin_init(&priv->nop_buf_pool_lock);
-    HG_QUEUE_INIT(&priv->nop_buf_pool);
+    hg_thread_spin_init(&priv->buf_pool_lock);
+    HG_QUEUE_INIT(&priv->buf_pool);
 
     /* Create domain */
     ret = na_ofi_domain_open(na_class->plugin_class, prov_type, domain_name,
-        auth_key, &priv->nop_domain);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not open domain for %s, %s", na_ofi_prov_name[prov_type],
-            domain_name);
-        goto out;
-    }
+        auth_key, &priv->domain);
+    NA_CHECK_NA_ERROR(out, ret, "Could not open domain for %s, %s",
+        na_ofi_prov_name[prov_type], domain_name);
 
     /* Create endpoint */
-    ret = na_ofi_endpoint_open(priv->nop_domain, node_ptr, src_addr, src_addrlen,
-        priv->no_wait, priv->nop_max_contexts, &priv->nop_endpoint);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not create endpoint for %s", resolve_name);
-        goto out;
-    }
+    ret = na_ofi_endpoint_open(priv->domain, node_ptr, src_addr, src_addrlen,
+        priv->no_wait, priv->max_contexts, &priv->endpoint);
+    NA_CHECK_NA_ERROR(out, ret, "Could not create endpoint for %s",
+        resolve_name);
 
     /* Get address from endpoint */
-    ret = na_ofi_get_ep_addr(na_class, &priv->nop_endpoint->noe_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not get address from endpoint");
-        goto out;
-    }
+    ret = na_ofi_get_ep_addr(na_class, &priv->endpoint->src_addr);
+    NA_CHECK_NA_ERROR(out, ret, "Could not get address from endpoint");
 
 out:
     if (ret != NA_SUCCESS) {
@@ -3305,38 +3007,32 @@ na_ofi_finalize(na_class_t *na_class)
         goto out;
 
     /* Close endpoint */
-    if (priv->nop_endpoint) {
-        ret = na_ofi_endpoint_close(priv->nop_endpoint);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not close endpoint");
-            goto out;
-        }
-        priv->nop_endpoint = NULL;
+    if (priv->endpoint) {
+        ret = na_ofi_endpoint_close(priv->endpoint);
+        NA_CHECK_NA_ERROR(out, ret, "Could not close endpoint");
+        priv->endpoint = NULL;
     }
 
     /* Free memory pool (must be done before trying to close the domain as
      * the pool is holding memory handles) */
-    while (!HG_QUEUE_IS_EMPTY(&priv->nop_buf_pool)) {
+    while (!HG_QUEUE_IS_EMPTY(&priv->buf_pool)) {
         struct na_ofi_mem_pool *na_ofi_mem_pool =
-            HG_QUEUE_FIRST(&priv->nop_buf_pool);
-        HG_QUEUE_POP_HEAD(&priv->nop_buf_pool, entry);
+            HG_QUEUE_FIRST(&priv->buf_pool);
+        HG_QUEUE_POP_HEAD(&priv->buf_pool, entry);
 
         na_ofi_mem_pool_destroy(na_ofi_mem_pool);
     }
-    hg_thread_spin_destroy(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_destroy(&NA_OFI_CLASS(na_class)->buf_pool_lock);
 
     /* Close domain */
-    if (priv->nop_domain) {
-        ret = na_ofi_domain_close(priv->nop_domain);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not close domain");
-            goto out;
-        }
-        priv->nop_domain = NULL;
+    if (priv->domain) {
+        ret = na_ofi_domain_close(priv->domain);
+        NA_CHECK_NA_ERROR(out, ret, "Could not close domain");
+        priv->domain = NULL;
     }
 
     /* Close mutex / free private data */
-    hg_thread_mutex_destroy(&priv->nop_mutex);
+    hg_thread_mutex_destroy(&priv->mutex);
     free(priv);
     na_class->plugin_class = NULL;
 
@@ -3349,152 +3045,104 @@ static na_return_t
 na_ofi_context_create(na_class_t *na_class, void **context, na_uint8_t id)
 {
     struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_domain *domain = priv->nop_domain;
-    struct na_ofi_endpoint *ep = priv->nop_endpoint;
+    struct na_ofi_domain *domain = priv->domain;
+    struct na_ofi_endpoint *ep = priv->endpoint;
     struct na_ofi_context *ctx = NULL;
     struct fi_cq_attr cq_attr = {0};
     na_return_t ret = NA_SUCCESS;
     int rc = 0;
 
     ctx = (struct na_ofi_context *)calloc(1, sizeof(struct na_ofi_context));
-    if (!ctx) {
-        NA_LOG_ERROR("Could not allocate na_ofi_context.");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    ctx->noc_idx = id;
+    NA_CHECK_ERROR(ctx == NULL, out, ret, NA_NOMEM_ERROR,
+        "Could not allocate na_ofi_context");
+    ctx->idx = id;
 
     /* If not using SEP, just point to endpoint objects */
-    hg_thread_mutex_lock(&priv->nop_mutex);
+    hg_thread_mutex_lock(&priv->mutex);
+
     if (!na_ofi_with_sep(na_class)) {
-        ctx->noc_tx = ep->noe_ep;
-        ctx->noc_rx = ep->noe_ep;
-        ctx->noc_cq = ep->noe_cq;
-        ctx->noc_wait = ep->noe_wait;
-        ctx->noc_unexpected_op_queue = ep->noe_unexpected_op_queue;
+        ctx->fi_tx = ep->fi_ep;
+        ctx->fi_rx = ep->fi_ep;
+        ctx->fi_cq = ep->fi_cq;
+        ctx->fi_wait = ep->fi_wait;
+        ctx->unexpected_op_queue = ep->unexpected_op_queue;
     } else {
+        ctx->unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
+        NA_CHECK_ERROR(ctx->unexpected_op_queue == NULL, error, ret,
+            NA_NOMEM_ERROR, "Could not allocate unexpected_op_queue/_lock");
+
         /* Initialize queue / mutex */
-        ctx->noc_unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
-        if (!ctx->noc_unexpected_op_queue) {
-            NA_LOG_ERROR("Could not allocate noc_unexpected_op_queue/_lock");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-        HG_QUEUE_INIT(&ctx->noc_unexpected_op_queue->noq_queue);
-        hg_thread_spin_init(&ctx->noc_unexpected_op_queue->noq_lock);
-
-        if (priv->nop_contexts >= priv->nop_max_contexts ||
-            id >= priv->nop_max_contexts) {
-            NA_LOG_ERROR("nop_contexts %d, context id %d, nop_max_contexts %d "
-                "could not create context.", priv->nop_contexts,
-                id, priv->nop_max_contexts);
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        HG_QUEUE_INIT(&ctx->unexpected_op_queue->queue);
+        hg_thread_spin_init(&ctx->unexpected_op_queue->lock);
+
+        NA_CHECK_ERROR(priv->contexts >= priv->max_contexts ||
+            id >= priv->max_contexts, error, ret, NA_PROTOCOL_ERROR,
+            "contexts %d, context id %d, max_contexts %d",
+            priv->contexts, id, priv->max_contexts);
 
         if (!priv->no_wait) {
-            if (na_ofi_prov_flags[domain->nod_prov_type] & NA_OFI_WAIT_FD)
+            if (na_ofi_prov_flags[domain->prov_type] & NA_OFI_WAIT_FD)
                 cq_attr.wait_obj = FI_WAIT_FD; /* Wait on fd */
             else {
                 struct fi_wait_attr wait_attr = {0};
 
                 /* Open wait set for other providers. */
                 wait_attr.wait_obj = FI_WAIT_UNSPEC;
-                rc = fi_wait_open(domain->nod_fabric, &wait_attr,
-                    &ctx->noc_wait);
-                if (rc != 0) {
-                    NA_LOG_ERROR("fi_wait_open failed, rc: %d(%s).", rc,
-                        fi_strerror(-rc));
-                    hg_thread_mutex_unlock(&priv->nop_mutex);
-                    ret = NA_PROTOCOL_ERROR;
-                    goto out;
-                }
+                rc = fi_wait_open(domain->fi_fabric, &wait_attr,
+                    &ctx->fi_wait);
+                NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+                    "fi_wait_open() failed, rc: %d(%s)", rc, fi_strerror(-rc));
                 cq_attr.wait_obj = FI_WAIT_SET; /* Wait on wait set */
-                cq_attr.wait_set = ctx->noc_wait;
+                cq_attr.wait_set = ctx->fi_wait;
             }
         }
         cq_attr.wait_cond = FI_CQ_COND_NONE;
         cq_attr.format = FI_CQ_FORMAT_TAGGED;
         cq_attr.size = NA_OFI_CQ_DEPTH;
-        rc = fi_cq_open(domain->nod_domain, &cq_attr, &ctx->noc_cq, NULL);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_cq_open failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_cq_open(domain->fi_domain, &cq_attr, &ctx->fi_cq, NULL);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_cq_open() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_tx_context(ep->noe_ep, id, NULL, &ctx->noc_tx, NULL);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_tx_context failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_tx_context(ep->fi_ep, id, NULL, &ctx->fi_tx, NULL);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_tx_context() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_rx_context(ep->noe_ep, id, NULL, &ctx->noc_rx, NULL);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_rx_context failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_rx_context(ep->fi_ep, id, NULL, &ctx->fi_rx, NULL);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_rx_context() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_ep_bind(ctx->noc_tx, &ctx->noc_cq->fid, FI_TRANSMIT);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_ep_bind noc_tx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_ep_bind(ctx->fi_tx, &ctx->fi_cq->fid, FI_TRANSMIT);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_ep_bind() noc_tx failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_ep_bind(ctx->noc_rx, &ctx->noc_cq->fid, FI_RECV);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_ep_bind noc_rx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_ep_bind(ctx->fi_rx, &ctx->fi_cq->fid, FI_RECV);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_ep_bind() noc_rx failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_enable(ctx->noc_tx);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_enable noc_tx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_enable(ctx->fi_tx);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_enable() noc_tx failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_enable(ctx->noc_rx);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_enable noc_rx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_enable(ctx->fi_rx);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_enable() noc_rx failed, rc: %d(%s)", rc, fi_strerror(-rc));
     }
 
-    priv->nop_contexts++;
-    hg_thread_mutex_unlock(&priv->nop_mutex);
+    priv->contexts++;
+    hg_thread_mutex_unlock(&priv->mutex);
 
     *context = ctx;
 
 out:
-    if (ret != NA_SUCCESS && ctx) {
-        if (na_ofi_with_sep(na_class) && ctx->noc_unexpected_op_queue) {
-            hg_thread_spin_destroy(&ctx->noc_unexpected_op_queue->noq_lock);
-            free(ctx->noc_unexpected_op_queue);
-        }
-        free(ctx);
-    }
+    return ret;
 
+error:
+    hg_thread_mutex_unlock(&priv->mutex);
+    if (na_ofi_with_sep(na_class) && ctx->unexpected_op_queue) {
+        hg_thread_spin_destroy(&ctx->unexpected_op_queue->lock);
+        free(ctx->unexpected_op_queue);
+    }
+    free(ctx);
     return ret;
 }
 
@@ -3508,69 +3156,53 @@ na_ofi_context_destroy(na_class_t *na_class, void *context)
     int rc;
 
     /* Check that unexpected op queue is empty */
-    if (na_ofi_with_sep(na_class) &&
-        !HG_QUEUE_IS_EMPTY(&ctx->noc_unexpected_op_queue->noq_queue)) {
-        NA_LOG_ERROR("Unexpected op queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
+    if (na_ofi_with_sep(na_class)) {
+        na_bool_t empty = HG_QUEUE_IS_EMPTY(&ctx->unexpected_op_queue->queue);
+        NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_PROTOCOL_ERROR,
+            "Unexpected op queue should be empty");
     }
 
     if (na_ofi_with_sep(na_class)) {
-        if (ctx->noc_tx) {
-            rc = fi_close(&ctx->noc_tx->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close noc_tx failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_tx = NULL;
+        if (ctx->fi_tx) {
+            rc = fi_close(&ctx->fi_tx->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() noc_tx failed, rc: %d(%s)", rc, fi_strerror(-rc));
+            ctx->fi_tx = NULL;
         }
 
-        if (ctx->noc_rx) {
-            rc = fi_close(&ctx->noc_rx->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close noc_rx failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_rx = NULL;
+        if (ctx->fi_rx) {
+            rc = fi_close(&ctx->fi_rx->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() noc_rx failed, rc: %d(%s)", rc, fi_strerror(-rc));
+            ctx->fi_rx = NULL;
         }
 
         /* Close wait set */
-        if (ctx->noc_wait) {
-            rc = fi_close(&ctx->noc_wait->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close wait failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_wait = NULL;
+        if (ctx->fi_wait) {
+            rc = fi_close(&ctx->fi_wait->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() wait failed, rc: %d(%s)", rc, fi_strerror(-rc));
+            ctx->fi_wait = NULL;
         }
 
         /* Close completion queue */
-        if (ctx->noc_cq) {
-            rc = fi_close(&ctx->noc_cq->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close CQ failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_cq = NULL;
+        if (ctx->fi_cq) {
+            rc = fi_close(&ctx->fi_cq->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() CQ failed, rc: %d(%s)", rc, fi_strerror(-rc));
+            ctx->fi_cq = NULL;
         }
 
-        hg_thread_spin_destroy(&ctx->noc_unexpected_op_queue->noq_lock);
-        free(ctx->noc_unexpected_op_queue);
+        hg_thread_spin_destroy(&ctx->unexpected_op_queue->lock);
+        free(ctx->unexpected_op_queue);
     }
 
-    hg_thread_mutex_lock(&priv->nop_mutex);
-    priv->nop_contexts--;
-    hg_thread_mutex_unlock(&priv->nop_mutex);
+    hg_thread_mutex_lock(&priv->mutex);
+    priv->contexts--;
+    hg_thread_mutex_unlock(&priv->mutex);
 
     free(ctx);
+
 out:
     return ret;
 }
@@ -3582,21 +3214,15 @@ na_ofi_op_create(na_class_t NA_UNUSED *na_class)
     struct na_ofi_op_id *na_ofi_op_id = NULL;
 
     na_ofi_op_id = (struct na_ofi_op_id *)calloc(1, sizeof(struct na_ofi_op_id));
-    if (!na_ofi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA OFI operation ID");
-        goto out;
-    }
-    hg_atomic_init32(&na_ofi_op_id->noo_refcount, 1);
+    NA_CHECK_ERROR_NORET(na_ofi_op_id == NULL, out,
+        "Could not allocate NA OFI operation ID");
+    hg_atomic_init32(&na_ofi_op_id->refcount, 1);
     /* Completed by default */
-    hg_atomic_init32(&na_ofi_op_id->noo_completed, NA_TRUE);
-
-    /* Set op ID verification magic */
-    na_ofi_op_id->noo_magic_1 = NA_OFI_OP_ID_MAGIC_1;
-    na_ofi_op_id->noo_magic_2 = NA_OFI_OP_ID_MAGIC_2;
+    hg_atomic_init32(&na_ofi_op_id->completed, NA_TRUE);
 
     /* Set op ID release callbacks */
-    na_ofi_op_id->noo_completion_data.plugin_callback = na_ofi_release;
-    na_ofi_op_id->noo_completion_data.plugin_callback_args = na_ofi_op_id;
+    na_ofi_op_id->completion_data.plugin_callback = na_ofi_release;
+    na_ofi_op_id->completion_data.plugin_callback_args = na_ofi_op_id;
 
 out:
     return (na_op_id_t) na_ofi_op_id;
@@ -3618,92 +3244,92 @@ static na_return_t
 na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const char *name, na_op_id_t *op_id)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_op_id *na_ofi_op_id = NULL;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    /* Check provider from name */
-    if (na_ofi_addr_prov(name) != priv->nop_domain->nod_prov_type) {
-        NA_LOG_ERROR("Unrecognized provider type found from: %s", name);
-        ret = NA_INVALID_PARAM;
-        goto out;
-    }
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_LOOKUP;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_LOOKUP;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
+
+    /* Lookup addr */
+    ret = na_ofi_addr_lookup2(na_class, name, (na_addr_t *) &na_ofi_addr);
+    NA_CHECK_NA_ERROR(error, ret, "Could not lookup %s", name);
 
-    /* Allocate addr */
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("na_ofi_addr_alloc failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    na_ofi_addr->uri = strdup(name);
-    if (!na_ofi_addr->uri) {
-        NA_LOG_ERROR("strdup() of URI failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
     /* One extra refcount to be decref in na_ofi_complete(). */
     na_ofi_addr_addref(na_ofi_addr);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    na_ofi_op_id->noo_info.noo_lookup.noi_addr = (na_addr_t) na_ofi_addr;
+    na_ofi_op_id->addr = na_ofi_addr;
+    na_ofi_op_id->info.lookup.addr = (na_addr_t) na_ofi_addr;
+
+    /* As the fi_av_insert is blocking, always complete here */
+    ret = na_ofi_complete(na_ofi_op_id, ret);
+    NA_CHECK_NA_ERROR(error, ret, "Could not complete operation");
+
+out:
+    return ret;
+
+error:
+    na_ofi_op_id_decref(na_ofi_op_id);
+    if (na_ofi_addr) {
+        na_ofi_addr_decref(na_ofi_addr);
+        na_ofi_addr_decref(na_ofi_addr);
+    }
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ofi_addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr)
+{
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
+    struct na_ofi_addr *na_ofi_addr = NULL;
+    na_return_t ret = NA_SUCCESS;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    /* Check provider from name */
+    NA_CHECK_ERROR(
+        na_ofi_addr_prov(name) != priv->domain->prov_type, out, ret,
+        NA_INVALID_PARAM, "Unrecognized provider type found from: %s", name);
+
+    /* Allocate addr */
+    na_ofi_addr = na_ofi_addr_alloc(priv->domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM_ERROR,
+        "na_ofi_addr_alloc() failed");
+    na_ofi_addr->uri = strdup(name);
+    NA_CHECK_ERROR(na_ofi_addr->uri == NULL, error, ret, NA_NOMEM_ERROR,
+        "strdup() of URI failed");
 
     /* Convert name to address */
     ret = na_ofi_str_to_addr(name,
-        na_ofi_prov_addr_format[priv->nop_domain->nod_prov_type],
+        na_ofi_prov_addr_format[priv->domain->prov_type],
         &na_ofi_addr->addr, &na_ofi_addr->addrlen);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not convert string to address");
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not convert string to address");
 
     /* Lookup address */
     ret = na_ofi_addr_ht_lookup(na_class,
-        na_ofi_prov_addr_format[priv->nop_domain->nod_prov_type],
+        na_ofi_prov_addr_format[priv->domain->prov_type],
         na_ofi_addr->addr, na_ofi_addr->addrlen, &na_ofi_addr->fi_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_addr_ht_lookup(%s) failed, ret: %d.", name, ret);
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup(%s) failed", name);
 
-    /* As the fi_av_insert is blocking, always complete here */
-    ret = na_ofi_complete(na_ofi_op_id, ret);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto out;
-    }
+    *addr = (na_addr_t) na_ofi_addr;
 
 out:
-    if (ret != NA_SUCCESS) {
-        if (na_ofi_addr) {
-            free(na_ofi_addr->addr);
-            free(na_ofi_addr->uri);
-            free(na_ofi_addr);
-        }
-        free(na_ofi_op_id);
+    return ret;
+
+error:
+    if (na_ofi_addr) {
+        free(na_ofi_addr->addr);
+        free(na_ofi_addr->uri);
+        free(na_ofi_addr);
     }
     return ret;
 }
@@ -3713,10 +3339,10 @@ static NA_INLINE na_return_t
 na_ofi_addr_self(na_class_t *na_class, na_addr_t *addr)
 {
     struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_endpoint *ep = priv->nop_endpoint;
+    struct na_ofi_endpoint *ep = priv->endpoint;
 
-    na_ofi_addr_addref(ep->noe_addr); /* decref in na_ofi_addr_free() */
-    *addr = ep->noe_addr;
+    na_ofi_addr_addref(ep->src_addr); /* decref in na_ofi_addr_free() */
+    *addr = ep->src_addr;
 
     return NA_SUCCESS;
 }
@@ -3759,20 +3385,14 @@ na_ofi_addr_to_string(na_class_t NA_UNUSED *na_class, char *buf,
     na_size_t str_len;
     na_return_t ret = NA_SUCCESS;
 
-    if (na_ofi_addr->unexpected) {
-        NA_LOG_ERROR("Addr to string is not available on unexpected addresses");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_addr->unexpected, out, ret, NA_PROTOCOL_ERROR,
+        "Addr to string is not available on unexpected addresses");
 
     str_len = strlen(na_ofi_addr->uri);
     if (buf) {
-        if (str_len >= *buf_size) {
-            NA_LOG_ERROR("Buffer size too small to copy addr");
-            ret = NA_SIZE_ERROR;
-        } else {
-            strcpy(buf, na_ofi_addr->uri);
-        }
+        NA_CHECK_ERROR(str_len >= *buf_size, out, ret, NA_SIZE_ERROR,
+            "Buffer size too small to copy addr");
+        strcpy(buf, na_ofi_addr->uri);
     }
     *buf_size = str_len + 1;
 
@@ -3800,11 +3420,8 @@ na_ofi_addr_serialize(na_class_t NA_UNUSED *na_class, void *buf,
     na_return_t ret = NA_SUCCESS;
 
     len = na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen);
-    if (buf_size < len) {
-        NA_LOG_ERROR("Buffer size too small for serializing address");
-        ret = NA_SIZE_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(buf_size < len, out, ret, NA_SIZE_ERROR,
+        "Buffer size too small for serializing address");
 
     /* TODO could skip the addrlen but include it for sanity check */
     memcpy(buf, &na_ofi_addr->addrlen, sizeof(na_ofi_addr->addrlen));
@@ -3825,21 +3442,14 @@ na_ofi_addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
     na_return_t ret = NA_SUCCESS;
 
     /* Allocate addr */
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("na_ofi_addr_alloc failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_addr = na_ofi_addr_alloc(priv->domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM_ERROR,
+        "na_ofi_addr_alloc() failed");
     memcpy(&na_ofi_addr->addrlen, buf, sizeof(na_ofi_addr->addrlen));
 
     na_ofi_addr->addr = malloc(na_ofi_addr->addrlen);
-    if (!na_ofi_addr->addr) {
-        NA_LOG_ERROR("Could not allocate %zu bytes for address",
-            na_ofi_addr->addrlen);
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_addr->addr == NULL, error, ret, NA_NOMEM_ERROR,
+        "Could not allocate %zu bytes for address", na_ofi_addr->addrlen);
     memcpy(na_ofi_addr->addr,
         (const na_uint8_t *) buf + sizeof(na_ofi_addr->addrlen),
         na_ofi_addr->addrlen);
@@ -3848,18 +3458,18 @@ na_ofi_addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
 
     /* Lookup address */
     ret = na_ofi_addr_ht_lookup(na_class,
-        na_ofi_prov_addr_format[priv->nop_domain->nod_prov_type],
+        na_ofi_prov_addr_format[priv->domain->prov_type],
         na_ofi_addr->addr, na_ofi_addr->addrlen, &na_ofi_addr->fi_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_addr_ht_lookup(%s) failed, ret: %d.", "", ret);
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
 
     *addr = na_ofi_addr;
 
 out:
-    if (ret != NA_SUCCESS && na_ofi_addr)
-        free(na_ofi_addr);
+    return ret;
+
+error:
+    free(na_ofi_addr->addr);
+    free(na_ofi_addr);
     return ret;
 }
 
@@ -3869,25 +3479,22 @@ na_ofi_msg_get_max_unexpected_size(const na_class_t NA_UNUSED *na_class)
 {
     na_size_t max_unexpected_size = NA_OFI_UNEXPECTED_SIZE;
 #ifdef NA_OFI_HAS_EXT_GNI_H
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
 
-    if (domain->nod_prov_type == NA_OFI_PROV_GNI) {
+    if (domain->prov_type == NA_OFI_PROV_GNI) {
         struct fi_gni_ops_domain *gni_domain_ops;
         int rc;
 
-        rc = fi_open_ops(&domain->nod_domain->fid, FI_GNI_DOMAIN_OPS_1,
+        rc = fi_open_ops(&domain->fi_domain->fid, FI_GNI_DOMAIN_OPS_1,
             0, (void **) &gni_domain_ops, NULL);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_open_ops failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            goto out;
-        }
+        NA_CHECK_ERROR(rc != 0, out, max_unexpected_size, 0,
+            "fi_open_ops() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = gni_domain_ops->get_val(&domain->nod_domain->fid,
+        rc = gni_domain_ops->get_val(&domain->fi_domain->fid,
             GNI_MBOX_MSG_MAX_SIZE, &max_unexpected_size);
-        if (rc != 0) {
-            NA_LOG_ERROR("get_val failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            goto out;
-        }
+        NA_CHECK_ERROR(rc != 0, out, max_unexpected_size, 0,
+            "gni_domain_ops->get_val() failed, rc: %d(%s)", rc,
+            fi_strerror(-rc));
     }
 
 out:
@@ -3928,16 +3535,12 @@ na_ofi_msg_buf_alloc(na_class_t *na_class, na_size_t size, void **plugin_data)
 
 #ifdef NA_OFI_HAS_MEM_POOL
     mem_ptr = na_ofi_mem_pool_alloc(na_class, size, &mr_hdl);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate buffer from pool");
-        goto out;
-    }
+    NA_CHECK_ERROR_NORET(mem_ptr == NULL, out,
+        "Could not allocate buffer from pool");
 #else
     mem_ptr = na_ofi_mem_alloc(na_class, size, &mr_hdl);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate %d bytes", (int) size);
-        goto out;
-    }
+    NA_CHECK_ERROR_NORET(mem_ptr == NULL, out,
+        "Could not allocate %d bytes", (int) size);
 #endif
     *plugin_data = mr_hdl;
 
@@ -3972,7 +3575,7 @@ na_ofi_msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
     if (na_ofi_with_msg_hdr(na_class)) {
         struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
         struct na_ofi_sin_addr *na_ofi_sin_addr =
-            (struct na_ofi_sin_addr *) priv->nop_endpoint->noe_addr->addr;
+            (struct na_ofi_sin_addr *) priv->endpoint->src_addr->addr;
 
         assert(buf_size > sizeof(*na_ofi_sin_addr));
         memcpy(buf, na_ofi_sin_addr, sizeof(*na_ofi_sin_addr));
@@ -3989,7 +3592,7 @@ na_ofi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
+    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) dest_addr;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
     struct fid_mr *mr_hdl = plugin_data;
@@ -3997,56 +3600,43 @@ na_ofi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_SEND_UNEXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
     na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
-
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_SEND_UNEXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
 
     /* Post the FI unexpected send request */
     fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
     do {
-        rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-                      tag, &na_ofi_op_id->noo_fi_ctx);
+        rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr, tag,
+            &na_ofi_op_id->fi_ctx);
         /* for EAGAIN, progress and do it again */
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_tsend(unexpected) failed, rc: %d(%s)",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_tsend() unexpected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
+    return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
@@ -4057,62 +3647,51 @@ na_ofi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_rx;
+    struct fid_ep *ep_hdl = ctx->fi_rx;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
     struct fid_mr *mr_hdl = plugin_data;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_RECV_UNEXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    na_ofi_op_id->noo_addr = NULL; /* Make sure the addr is reset */
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_buf = buf;
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_buf_size = buf_size;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_RECV_UNEXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    na_ofi_op_id->addr = NULL; /* Make sure the addr is reset */
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
+    na_ofi_op_id->info.recv_unexpected.buf = buf;
+    na_ofi_op_id->info.recv_unexpected.buf_size = buf_size;
 
     na_ofi_msg_unexpected_op_push(context, na_ofi_op_id);
 
     /* Post the FI unexpected recv request */
     do {
         rc = fi_trecv(ep_hdl, buf, buf_size, mr_hdl, FI_ADDR_UNSPEC,
-                      1 /* tag */, NA_OFI_UNEXPECTED_TAG_IGNORE,
-                      &na_ofi_op_id->noo_fi_ctx);
+            1 /* tag */, NA_OFI_UNEXPECTED_TAG_IGNORE, &na_ofi_op_id->fi_ctx);
         /* for EAGAIN, progress and do it again */
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_trecv(unexpected) failed, rc: %d(%s)",
-                     rc, fi_strerror((int) -rc));
-        na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_trecv() unexpected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS && na_ofi_op_id != NULL)
-        na_ofi_op_id_decref(na_ofi_op_id);
+    return ret;
+
+error:
+    na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
@@ -4124,7 +3703,7 @@ na_ofi_msg_send_expected(na_class_t *na_class, na_context_t *context,
     na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
+    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) dest_addr;
     struct fid_mr *mr_hdl = plugin_data;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
@@ -4132,56 +3711,43 @@ na_ofi_msg_send_expected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_SEND_EXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
     na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
-
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_SEND_EXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
 
     /* Post the FI expected send request */
     fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
     do {
         rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-                NA_OFI_EXPECTED_TAG_FLAG | tag, &na_ofi_op_id->noo_fi_ctx);
+            NA_OFI_EXPECTED_TAG_FLAG | tag, &na_ofi_op_id->fi_ctx);
         /* for EAGAIN, progress and do it again */
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_tsend(expected) failed, rc: %d(%s)",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_tsend() expected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
+    return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
@@ -4193,7 +3759,7 @@ na_ofi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_rx;
+    struct fid_ep *ep_hdl = ctx->fi_rx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) source_addr;
     struct fid_mr *mr_hdl = plugin_data;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
@@ -4201,60 +3767,47 @@ na_ofi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_RECV_EXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
     na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
-
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_RECV_EXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_buf = buf;
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_buf_size = buf_size;
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_tag = tag;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    na_ofi_op_id->addr = na_ofi_addr;
+    na_ofi_op_id->info.recv_expected.buf = buf;
+    na_ofi_op_id->info.recv_expected.buf_size = buf_size;
+    na_ofi_op_id->info.recv_expected.tag = tag;
 
     /* Post the FI expected recv request */
     fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, source_id, NA_OFI_SEP_RX_CTX_BITS);
     do {
         rc = fi_trecv(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
             NA_OFI_EXPECTED_TAG_FLAG | tag, 0 /* ignore */,
-            &na_ofi_op_id->noo_fi_ctx);
+            &na_ofi_op_id->fi_ctx);
         /* for EAGAIN, progress and do it again */
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_trecv(expected) failed, rc: %d(%s)",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_trecv() expected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
+    return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
@@ -4269,11 +3822,8 @@ na_ofi_mem_handle_create(na_class_t NA_UNUSED *na_class, void *buf,
     /* Allocate memory handle */
     na_ofi_mem_handle = (struct na_ofi_mem_handle *) calloc(1,
         sizeof(struct na_ofi_mem_handle));
-    if (!na_ofi_mem_handle) {
-        NA_LOG_ERROR("Could not allocate NA OFI memory handle");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_mem_handle == NULL, out, ret, NA_NOMEM_ERROR,
+        "Could not allocate NA OFI memory handle");
 
     na_ofi_mem_handle->desc.base = (na_ptr_t)buf;
     na_ofi_mem_handle->desc.size = buf_size;
@@ -4300,7 +3850,7 @@ static na_return_t
 na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     struct na_ofi_mem_handle *na_ofi_mem_handle = mem_handle;
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     const void *base;
     na_uint64_t access;
     int rc = 0;
@@ -4308,11 +3858,11 @@ na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 
     /* Nothing to do for providers that do not need physically backed
      * virtual addresses (FI_MR_SCALABLE) */
-    if (!(domain->nod_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
+    if (!(domain->fi_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
         /* Use global handle and key */
-        na_ofi_mem_handle->mr_hdl = domain->nod_mr;
-        na_ofi_mem_handle->desc.mr_key = domain->nod_mr_key;
-        return NA_SUCCESS;
+        na_ofi_mem_handle->fi_mr = domain->fi_mr;
+        na_ofi_mem_handle->desc.fi_mr_key = domain->fi_mr_key;
+        goto out;
     }
 
     /* Set access mode */
@@ -4327,26 +3877,23 @@ na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
             access = FI_READ | FI_WRITE | FI_REMOTE_READ | FI_REMOTE_WRITE;
             break;
         default:
-            NA_LOG_ERROR("Invalid memory access flag");
-            ret = NA_INVALID_PARAM;
-            goto out;
+            NA_GOTO_ERROR(out, ret, NA_INVALID_PARAM,
+                "Invalid memory access flag");
+            break;
     }
 
     /* Register region */
-    base = (domain->nod_prov->domain_attr->mr_mode & FI_MR_VIRT_ADDR) ?
+    base = (domain->fi_prov->domain_attr->mr_mode & FI_MR_VIRT_ADDR) ?
         (const void *) na_ofi_mem_handle->desc.base : NULL;
-    rc = fi_mr_reg(domain->nod_domain, base,
+    rc = fi_mr_reg(domain->fi_domain, base,
         (size_t) na_ofi_mem_handle->desc.size, access, 0 /* offset */,
-        0 /* requested key */, 0 /* flags */, &na_ofi_mem_handle->mr_hdl,
+        0 /* requested key */, 0 /* flags */, &na_ofi_mem_handle->fi_mr,
         NULL /* context */);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_mr_reg failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_mr_reg() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Retrieve key */
-    na_ofi_mem_handle->desc.mr_key = fi_mr_key(na_ofi_mem_handle->mr_hdl);
+    na_ofi_mem_handle->desc.fi_mr_key = fi_mr_key(na_ofi_mem_handle->fi_mr);
 
 out:
     return ret;
@@ -4356,22 +3903,19 @@ out:
 static na_return_t
 na_ofi_mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     struct na_ofi_mem_handle *na_ofi_mem_handle = mem_handle;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    if (!(domain->nod_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)
-        || !na_ofi_mem_handle->mr_hdl)
+    if (!(domain->fi_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)
+        || !na_ofi_mem_handle->fi_mr)
         goto out;
 
     /* close MR handle */
-    rc = fi_close(&na_ofi_mem_handle->mr_hdl->fid);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_close mr_hdl failed, rc: %d(%s).",
-                     rc, fi_strerror(-rc));
-        return NA_PROTOCOL_ERROR;
-    }
+    rc = fi_close(&na_ofi_mem_handle->fi_mr->fid);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_close() mr_hdl failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
 out:
     return ret;
@@ -4394,11 +3938,8 @@ na_ofi_mem_handle_serialize(na_class_t NA_UNUSED *na_class, void *buf,
             (struct na_ofi_mem_handle *) mem_handle;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size < sizeof(struct na_ofi_mem_desc)) {
-        NA_LOG_ERROR("Buffer size too small for serializing handle");
-        ret = NA_SIZE_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(buf_size < sizeof(struct na_ofi_mem_desc), out, ret,
+        NA_SIZE_ERROR, "Buffer size too small for serializing handle");
 
     /* Copy struct */
     memcpy(buf, &na_ofi_mem_handle->desc, sizeof(na_ofi_mem_handle->desc));
@@ -4415,23 +3956,17 @@ na_ofi_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
     struct na_ofi_mem_handle *na_ofi_mem_handle = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size < sizeof(struct na_ofi_mem_desc)) {
-        NA_LOG_ERROR("Buffer size too small for deserializing handle");
-        ret = NA_SIZE_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(buf_size < sizeof(struct na_ofi_mem_desc), out, ret,
+        NA_SIZE_ERROR, "Buffer size too small for deserializing handle");
 
     na_ofi_mem_handle = (struct na_ofi_mem_handle *)
             malloc(sizeof(struct na_ofi_mem_handle));
-    if (!na_ofi_mem_handle) {
-          NA_LOG_ERROR("Could not allocate NA OFI memory handle");
-          ret = NA_NOMEM_ERROR;
-          goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_mem_handle == NULL, out, ret, NA_NOMEM_ERROR,
+        "Could not allocate NA OFI memory handle");
 
     /* Copy struct */
     memcpy(&na_ofi_mem_handle->desc, buf, sizeof(na_ofi_mem_handle->desc));
-    na_ofi_mem_handle->mr_hdl = NULL;
+    na_ofi_mem_handle->fi_mr = NULL;
 
     *mem_handle = (na_mem_handle_t) na_ofi_mem_handle;
 
@@ -4448,13 +3983,13 @@ na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
+    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_mem_handle *ofi_local_mem_handle =
         (struct na_ofi_mem_handle *) local_mem_handle;
     struct na_ofi_mem_handle *ofi_remote_mem_handle =
         (struct na_ofi_mem_handle *) remote_mem_handle;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) remote_addr;
-    void *local_desc = fi_mr_desc(ofi_local_mem_handle->mr_hdl);
+    void *local_desc = fi_mr_desc(ofi_local_mem_handle->fi_mr);
     struct iovec local_iov = {
         .iov_base = (char *)ofi_local_mem_handle->desc.base + local_offset,
         .iov_len = length
@@ -4462,7 +3997,7 @@ na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     struct fi_rma_iov remote_iov = {
         .addr = (na_uint64_t)ofi_remote_mem_handle->desc.base + remote_offset,
         .len = length,
-        .key = ofi_remote_mem_handle->desc.mr_key
+        .key = ofi_remote_mem_handle->desc.fi_mr_key
     };
     struct fi_msg_rma msg_rma = {
         .msg_iov = &local_iov,
@@ -4478,35 +4013,24 @@ na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_PUT;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
     na_ofi_addr_addref(na_ofi_addr); /* for na_ofi_complete() */
-
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *) na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_PUT;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    na_ofi_op_id->addr = na_ofi_addr;
 
     /* Assign context */
-    msg_rma.context = &na_ofi_op_id->noo_fi_ctx;
+    msg_rma.context = &na_ofi_op_id->fi_ctx;
 
     /* Post the OFI RMA write */
     do {
@@ -4519,18 +4043,16 @@ na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_writemsg() failed, rc: %d(%s)", rc,
-            fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_writemsg() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
+    return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
@@ -4543,13 +4065,13 @@ na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
+    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_mem_handle *ofi_local_mem_handle =
         (struct na_ofi_mem_handle *) local_mem_handle;
     struct na_ofi_mem_handle *ofi_remote_mem_handle =
         (struct na_ofi_mem_handle *) remote_mem_handle;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) remote_addr;
-    void *local_desc = fi_mr_desc(ofi_local_mem_handle->mr_hdl);
+    void *local_desc = fi_mr_desc(ofi_local_mem_handle->fi_mr);
     struct iovec local_iov = {
         .iov_base = (void *)(ofi_local_mem_handle->desc.base + local_offset),
         .iov_len = length
@@ -4557,7 +4079,7 @@ na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     struct fi_rma_iov remote_iov = {
         .addr = (uint64_t)(ofi_remote_mem_handle->desc.base + remote_offset),
         .len = length,
-        .key = ofi_remote_mem_handle->desc.mr_key
+        .key = ofi_remote_mem_handle->desc.fi_mr_key
     };
     struct fi_msg_rma msg_rma = {
         .msg_iov = &local_iov,
@@ -4573,35 +4095,24 @@ na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_GET;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
     na_ofi_addr_addref(na_ofi_addr); /* for na_ofi_complete() */
-
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *) na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_GET;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    na_ofi_op_id->addr = na_ofi_addr;
 
     /* Assign context */
-    msg_rma.context = &na_ofi_op_id->noo_fi_ctx;
+    msg_rma.context = &na_ofi_op_id->fi_ctx;
 
     /* Post the OFI RMA read */
     do {
@@ -4612,18 +4123,16 @@ na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_readmsg() failed, rc: %d(%s)", rc,
-            fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_readmsg() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
+    return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
@@ -4636,17 +4145,14 @@ na_ofi_poll_get_fd(na_class_t *na_class, na_context_t *context)
     int fd = -1, rc;
 
     if (priv->no_wait ||
-        (na_ofi_prov_flags[priv->nop_domain->nod_prov_type] & NA_OFI_WAIT_SET))
+        (na_ofi_prov_flags[priv->domain->prov_type] & NA_OFI_WAIT_SET))
         goto out;
 
-    rc = fi_control(&ctx->noc_cq->fid, FI_GETWAIT, &fd);
-    if (rc < 0 && rc != -FI_ENOSYS)
-        NA_LOG_ERROR("fi_control() failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-    if (fd < 0) {
-        NA_LOG_ERROR("Returned fd is not valid (%d), will not block", fd);
-        goto out;
-    }
+    rc = fi_control(&ctx->fi_cq->fid, FI_GETWAIT, &fd);
+    NA_CHECK_ERROR_NORET(rc != 0 && rc != -FI_ENOSYS, out,
+        "fi_control() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+    NA_CHECK_ERROR_NORET(fd < 0, out,
+        "Returned fd is not valid (%d), will not block", fd);
 
 out:
     return fd;
@@ -4665,20 +4171,20 @@ na_ofi_poll_try_wait(na_class_t *na_class, na_context_t *context)
         return NA_FALSE;
 
     /* Assume it is safe to block if provider is using wait set */
-    if ((na_ofi_prov_flags[priv->nop_domain->nod_prov_type] & NA_OFI_WAIT_SET)
+    if ((na_ofi_prov_flags[priv->domain->prov_type] & NA_OFI_WAIT_SET)
         /* PSM2 shows very slow performance with fi_trywait() */
-        || priv->nop_domain->nod_prov_type == NA_OFI_PROV_PSM2)
+        || priv->domain->prov_type == NA_OFI_PROV_PSM2)
            return NA_TRUE;
 
-    fids[0] = &ctx->noc_cq->fid;
+    fids[0] = &ctx->fi_cq->fid;
     /* Check whether it is safe to block on that fd */
-    rc = fi_trywait(priv->nop_domain->nod_fabric, fids, 1);
+    rc = fi_trywait(priv->domain->fi_fabric, fids, 1);
     if (rc == FI_SUCCESS)
         return NA_TRUE;
     else if (rc == -FI_EAGAIN)
         return NA_FALSE;
     else {
-        NA_LOG_ERROR("fi_trywait() failed, rc: %d(%s).",
+        NA_LOG_ERROR("fi_trywait() failed, rc: %d(%s)",
             rc, fi_strerror((int) -rc));
         return NA_FALSE;
     }
@@ -4702,53 +4208,49 @@ na_ofi_progress(na_class_t *na_class, na_context_t *context,
         hg_time_t t1, t2;
 
         if (timeout) {
-            struct fid_wait *wait_hdl = NA_OFI_CONTEXT(context)->noc_wait;
+            struct fid_wait *wait_hdl = NA_OFI_CONTEXT(context)->fi_wait;
 
             hg_time_get_current(&t1);
 
             if (wait_hdl) {
                 /* Wait in wait set if provider does not support wait on FDs */
-                int rc = fi_wait(wait_hdl, (int) (remaining * 1000.0));
+                int rc = 0, retry_cnt = 0;
+                do {
+                    rc = fi_wait(wait_hdl, (int) (remaining * 1000.0));
+                } while (rc == -FI_EINTR && retry_cnt++ < NA_OFI_MAX_EINTR_RETRY);
+
                 if (rc == -FI_ETIMEDOUT)
                     break;
-                else if (rc != FI_SUCCESS) {
-                    NA_LOG_ERROR("fi_wait() failed, rc: %d(%s).",
-                        rc, fi_strerror((int) -rc));
-                    ret = NA_PROTOCOL_ERROR;
-                    goto out;
-                }
+
+                NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                    "fi_wait() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
             }
         }
 
         /* Read from CQ */
         ret = na_ofi_cq_read(na_class, context, NA_OFI_CQ_EVENT_NUM, cq_events,
             src_addrs, &src_err_addr, &src_err_addrlen, &actual_count);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not read events from context CQ");
-            goto out;
-        } else {
-            if (timeout) {
-                hg_time_get_current(&t2);
-                remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
-            }
-            if (actual_count == 0) {
-                ret = NA_TIMEOUT; /* Return NA_TIMEOUT if no events */
-                if (remaining <= 0)
-                    break;
-                continue;
-            }
+        NA_CHECK_NA_ERROR(out, ret,
+            "Could not read events from context CQ");
+
+        if (timeout) {
+            hg_time_get_current(&t2);
+            remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
         }
 
+        if (actual_count == 0) {
+            ret = NA_TIMEOUT; /* Return NA_TIMEOUT if no events */
+            if (remaining <= 0)
+                break;
+            continue;
+        }
         /* Got at least one completion event */
         assert(actual_count > 0);
 
         for (i = 0; i < actual_count; i++) {
            ret = na_ofi_cq_process_event(na_class, context, &cq_events[i],
                src_addrs[i], src_err_addr, src_err_addrlen);
-           if (ret != NA_SUCCESS) {
-               NA_LOG_ERROR("Could not process event");
-               goto out;
-           }
+           NA_CHECK_NA_ERROR(out, ret, "Could not process event");
         }
     } while (remaining > 0 && ret != NA_SUCCESS);
 
@@ -4762,67 +4264,56 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context,
     na_op_id_t op_id)
 {
     struct na_ofi_op_id *na_ofi_op_id = (struct na_ofi_op_id *) op_id;
-    struct na_ofi_op_id *tmp = NULL, *first = NULL;
     ssize_t rc;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_ofi_op_id_valid(na_ofi_op_id)) {
-        NA_LOG_ERROR("bad na_ofi_op_id, ignore the cancel request.");
-        goto out;
-    }
-    if (hg_atomic_get32(&na_ofi_op_id->noo_completed))
+    NA_CHECK_ERROR(na_ofi_op_id_valid(na_ofi_op_id) == NA_FALSE, out, ret,
+        NA_PROTOCOL_ERROR, "Invalid operation ID");
+
+    if (hg_atomic_get32(&na_ofi_op_id->completed))
         goto out;
-    if (!hg_atomic_cas32(&na_ofi_op_id->noo_canceled, NA_FALSE, NA_TRUE)) {
+
+    if (!hg_atomic_cas32(&na_ofi_op_id->canceled, NA_FALSE, NA_TRUE)) {
         NA_LOG_WARNING("ignore canceling for a canceled op.");
         goto out;
     }
 
-    hg_atomic_incr32(&na_ofi_op_id->noo_canceled);
+    hg_atomic_incr32(&na_ofi_op_id->canceled);
 
-    switch (na_ofi_op_id->noo_completion_data.callback_info.type) {
+    switch (na_ofi_op_id->completion_data.callback_info.type) {
     case NA_CB_LOOKUP:
         break;
-    case NA_CB_RECV_UNEXPECTED:
-        rc = fi_cancel(&NA_OFI_CONTEXT(context)->noc_rx->fid,
-            &na_ofi_op_id->noo_fi_ctx);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_cancel unexpected recv failed, rc: %d(%s).",
-                         rc, fi_strerror((int) -rc));
-            ret = NA_CANCEL_ERROR;
-            goto out;
-        }
+    case NA_CB_RECV_UNEXPECTED: {
+        struct na_ofi_op_id *tmp = NULL, *first = NULL;
+
+        rc = fi_cancel(&NA_OFI_CONTEXT(context)->fi_rx->fid,
+            &na_ofi_op_id->fi_ctx);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_CANCEL_ERROR,
+            "fi_cancel() unexpected recv failed, rc: %d(%s)",
+            rc, fi_strerror((int) -rc));
 
         tmp = first = na_ofi_msg_unexpected_op_pop(context);
         do {
-            if (!tmp) {
-                NA_LOG_ERROR("got NULL head of unexpected op queue.");
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            if (tmp == na_ofi_op_id) {
+            NA_CHECK_ERROR(tmp == NULL, out, ret, NA_PROTOCOL_ERROR,
+                "Head of unexpected op queue is NULL");
+            if (tmp == na_ofi_op_id)
                 break;
-            }
-            na_ofi_msg_unexpected_op_push(context, tmp);
 
+            na_ofi_msg_unexpected_op_push(context, tmp);
             tmp = na_ofi_msg_unexpected_op_pop(context);
-            if (tmp == first) {
-                NA_LOG_ERROR("tmp == first");
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
+            NA_CHECK_ERROR(tmp == first, out, ret, NA_PROTOCOL_ERROR,
+                "Could not find operation ID");
         } while (tmp != na_ofi_op_id);
 
         ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
+    }
         break;
     case NA_CB_RECV_EXPECTED:
-        rc = fi_cancel(&NA_OFI_CONTEXT(context)->noc_rx->fid,
-            &na_ofi_op_id->noo_fi_ctx);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_cancel expected recv failed, rc: %d(%s).",
-                         rc, fi_strerror((int) -rc));
-            ret = NA_CANCEL_ERROR;
-            goto out;
-        }
+        rc = fi_cancel(&NA_OFI_CONTEXT(context)->fi_rx->fid,
+            &na_ofi_op_id->fi_ctx);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_CANCEL_ERROR,
+            "fi_cancel() expected recv failed, rc: %d(%s)",
+            rc, fi_strerror((int) -rc));
 
         ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
         break;
@@ -4831,10 +4322,10 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context,
     case NA_CB_PUT:
     case NA_CB_GET:
         /* May or may not be canceled in that case */
-        rc = fi_cancel(&NA_OFI_CONTEXT(context)->noc_tx->fid,
-            &na_ofi_op_id->noo_fi_ctx);
+        rc = fi_cancel(&NA_OFI_CONTEXT(context)->fi_tx->fid,
+            &na_ofi_op_id->fi_ctx);
         if (rc != 0) {
-            NA_LOG_WARNING("fi_cancel failed, rc: %d(%s).",
+            NA_LOG_WARNING("fi_cancel() failed, rc: %d(%s)",
                          rc, fi_strerror((int) -rc));
         }
         /* fi_cancel() is not guaranteed to return proper return code for now */
@@ -4849,16 +4340,14 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context,
     }
 
     /* Work around segfault on fi_cq_signal() in some providers */
-    if (!(na_ofi_prov_flags[NA_OFI_CLASS(na_class)->nop_domain->nod_prov_type]
+    if (!(na_ofi_prov_flags[NA_OFI_CLASS(na_class)->domain->prov_type]
         & NA_OFI_SKIP_SIGNAL)) {
         /* Signal CQ to wake up and no longer wait on FD */
-        rc = fi_cq_signal(NA_OFI_CONTEXT(context)->noc_cq);
-        if (rc != 0 && rc != -ENOSYS) {
-            NA_LOG_ERROR("fi_cq_signal (op type %d) failed, rc: %d(%s).",
-                na_ofi_op_id->noo_completion_data.callback_info.type, rc,
-                fi_strerror((int) -rc));
-            ret = NA_PROTOCOL_ERROR;
-        }
+        rc = fi_cq_signal(NA_OFI_CONTEXT(context)->fi_cq);
+        NA_CHECK_ERROR(rc != 0 && rc != -ENOSYS, out, ret,
+            NA_PROTOCOL_ERROR, "fi_cq_signal (op type %d) failed, rc: %d(%s)",
+            na_ofi_op_id->completion_data.callback_info.type, rc,
+            fi_strerror((int) -rc));
     }
 
 out:
diff --git a/src/na/na_plugin.h b/src/na/na_plugin.h
index 2db9207..848191c 100644
--- a/src/na/na_plugin.h
+++ b/src/na/na_plugin.h
@@ -12,6 +12,7 @@
 #define NA_PLUGIN_H
 
 #include "na.h"
+#include "na_error.h"
 
 #include "mercury_atomic_queue.h"
 #include "mercury_queue.h"
diff --git a/src/na/na_sm.c b/src/na/na_sm.c
index 3343891..de10eb9 100644
--- a/src/na/na_sm.c
+++ b/src/na/na_sm.c
@@ -900,6 +900,7 @@ NA_PLUGIN_OPS(sm) = {
     na_sm_op_create,                        /* op_create */
     na_sm_op_destroy,                       /* op_destroy */
     na_sm_addr_lookup,                      /* addr_lookup */
+    NULL,                                   /* addr_lookup2 */
     na_sm_addr_free,                        /* addr_free */
     na_sm_addr_self,                        /* addr_self */
     na_sm_addr_dup,                         /* addr_dup */
