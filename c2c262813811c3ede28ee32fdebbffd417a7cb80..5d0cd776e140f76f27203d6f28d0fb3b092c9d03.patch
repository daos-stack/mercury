diff --git a/.travis.yml b/.travis.yml
index df5607e..aa36dda 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -7,9 +7,7 @@ compiler:
     - gcc
     - clang
 
-sudo: true
-dist: trusty
-group: beta
+dist: xenial
 
 cache:
   directories:
@@ -18,12 +16,12 @@ cache:
 env:
   global:
     - MERCURY_NO_LOOP="true"
-  matrix:
+  jobs:
     - MERCURY_BUILD_CONFIGURATION="Debug"
     - MERCURY_BUILD_CONFIGURATION="RelWithDebInfo"
     - MERCURY_BUILD_CONFIGURATION="Release"
 
-matrix:
+jobs:
   include:
    - os: linux
      compiler: gcc
@@ -32,8 +30,8 @@ matrix:
          sources:
          - ubuntu-toolchain-r-test
          packages:
-         - gcc-8
-         - g++-8
+         - gcc-9
+         - g++-9
          - libtsan0
          - libasan5
          - liblsan0
@@ -45,8 +43,8 @@ matrix:
          sources:
          - ubuntu-toolchain-r-test
          packages:
-         - gcc-8
-         - g++-8
+         - gcc-9
+         - g++-9
          - libtsan0
          - libasan5
          - liblsan0
@@ -58,8 +56,8 @@ matrix:
          sources:
          - ubuntu-toolchain-r-test
          packages:
-         - gcc-8
-         - g++-8
+         - gcc-9
+         - g++-9
      env: MERCURY_DO_COVERAGE="true"
 
 branches:
@@ -81,7 +79,7 @@ before_script:
     - export PATH=$HOME/install/bin:$PATH
     - export LD_LIBRARY_PATH=$HOME/install/lib:$HOME/install/lib64:$LD_LIBRARY_PATH
     - export PKG_CONFIG_PATH=$HOME/install/lib/pkgconfig:$PKG_CONFIG_PATH
-    - if [[ "$CC" == "gcc" && `command -v gcc-8` ]]; then export CC=gcc-8; export CXX=g++-8; export AR=gcc-ar-8; export NM=gcc-nm-8; export RANLIB=gcc-ranlib-8; which gcov-8; fi
+    - if [[ "$CC" == "gcc" && `command -v gcc-9` ]]; then export CC=gcc-9; export CXX=g++-9; export AR=gcc-ar-9; export NM=gcc-nm-9; export RANLIB=gcc-ranlib-9; export COV=gcov-9; fi
     - $CC --version
     - if [[ "$TRAVIS_EVENT_TYPE" == "cron" ]]; then export MERCURY_DASHBOARD_MODEL="Nightly"; elif [[ "$TRAVIS_EVENT_TYPE" == "pull_request" ]]; then export MERCURY_DASHBOARD_MODEL="Experimental"; else export MERCURY_DASHBOARD_MODEL="Continuous"; fi
     - ctest --version
diff --git a/Testing/CMakeLists.txt b/Testing/CMakeLists.txt
index 4147f47..b401427 100644
--- a/Testing/CMakeLists.txt
+++ b/Testing/CMakeLists.txt
@@ -3,44 +3,56 @@
 #------------------------------------------------------------------------------
 set(MERCURY_TESTING_BUFFER_SIZE "16" CACHE STRING
   "Total buffer size (in MB) used for testing.")
+set(HG_TEST_BUFFER_SIZE ${MERCURY_TESTING_BUFFER_SIZE})
 mark_as_advanced(MERCURY_TESTING_BUFFER_SIZE)
 
+set(MERCURY_TESTING_MAX_HANDLES "16" CACHE STRING
+  "Max number of concurrent handles used for testing.")
+set(HG_TEST_MAX_HANDLES ${MERCURY_TESTING_MAX_HANDLES})
+mark_as_advanced(MERCURY_TESTING_MAX_HANDLES)
+
 option(MERCURY_TESTING_USE_THREAD_POOL "Run tests using thread pool." ON)
 if(MERCURY_TESTING_USE_THREAD_POOL)
-  set(MERCURY_TESTING_HAS_THREAD_POOL ON)
+  set(HG_TEST_HAS_THREAD_POOL 1)
 endif()
 mark_as_advanced(MERCURY_TESTING_USE_THREAD_POOL)
 
 option(MERCURY_TESTING_VERIFY_DATA
   "Verify data when running tests (disable when measuring bandwidth)." ON)
 if(MERCURY_TESTING_VERIFY_DATA)
-  set(MERCURY_TESTING_HAS_VERIFY_DATA ON)
+  set(HG_TEST_HAS_VERIFY_DATA 1)
 endif()
 mark_as_advanced(MERCURY_TESTING_VERIFY_DATA)
 
 option(MERCURY_TESTING_PRINT_PARTIAL
   "Print partial results between loops (disable when measuring)." OFF)
+if(MERCURY_TESTING_PRINT_PARTIAL)
+  set(HG_TEST_PRINT_PARTIAL 1)
+endif()
 mark_as_advanced(MERCURY_TESTING_PRINT_PARTIAL)
 
-option(MERCURY_ENABLE_PARALLEL_TESTING
+option(MERCURY_TESTING_ENABLE_PARALLEL
   "Enable testing in parallel (requires MPI)." OFF)
-if(MERCURY_ENABLE_PARALLEL_TESTING OR NA_USE_MPI)
-  set(MERCURY_HAS_PARALLEL_TESTING 1)
-  if(NA_USE_MPI AND NOT MERCURY_ENABLE_PARALLEL_TESTING)
+if(MERCURY_TESTING_ENABLE_PARALLEL OR NA_USE_MPI)
+  set(HG_TEST_HAS_PARALLEL 1)
+  if(NA_USE_MPI AND NOT MERCURY_TESTING_ENABLE_PARALLEL)
     # Always force parallel testing if NA_USE_MPI is turned ON
-    set(MERCURY_ENABLE_PARALLEL_TESTING "ON" CACHE BOOL
+    set(MERCURY_TESTING_ENABLE_PARALLEL "ON" CACHE BOOL
       "Enable testing in parallel (requires MPI)." FORCE)
   endif()
 else()
-  set(MERCURY_HAS_PARALLEL_TESTING 0)
+  set(HG_TEST_HAS_PARALLEL 0)
 endif()
+mark_as_advanced(MERCURY_TESTING_ENABLE_PARALLEL)
 
-set(MERCURY_TEST_INIT_COMMAND "" CACHE STRING
+set(MERCURY_TESTING_INIT_COMMAND "" CACHE STRING
   "Command to run before a client/server test begins. Multiple commands are separated by ';'.")
-mark_as_advanced(MERCURY_TEST_INIT_COMMAND)
+set(HG_TEST_INIT_COMMAND ${MERCURY_TESTING_INIT_COMMAND})
+mark_as_advanced(MERCURY_TESTING_INIT_COMMAND)
 
 set(MERCURY_TESTING_TEMP_DIRECTORY "." CACHE PATH
   "Location to use for temp data (default is current directory).")
+set(HG_TEST_TEMP_DIRECTORY ${MERCURY_TESTING_TEMP_DIRECTORY})
 mark_as_advanced(MERCURY_TESTING_TEMP_DIRECTORY)
 
 if(MERCURY_USE_SELF_FORWARD)
@@ -51,6 +63,8 @@ else()
 endif()
 mark_as_advanced(MERCURY_TESTING_CORESIDENT)
 
+set(HG_TEST_FAIL_REGULAR_EXPRESSION "[^a-z]Error;ERROR;Failed")
+
 #------------------------------------------------------------------------------
 # NA protocols used for testing
 # (case where the NA plugin defines multiple protocols)
@@ -81,7 +95,7 @@ if(NA_USE_OFI)
   if(NA_OFI_TESTING_USE_CRAY_DRC)
     find_package(DRC REQUIRED)
     if(DRC_FOUND)
-      set(HG_TESTING_HAS_CRAY_DRC 1)
+      set(HG_TEST_HAS_CRAY_DRC 1)
       include_directories(${DRC_INCLUDE_DIRS})
       set(MERCURY_TEST_EXT_LIB_DEPENDENCIES
         ${MERCURY_TEST_EXT_LIB_DEPENDENCIES}
@@ -99,7 +113,7 @@ if(NA_USE_SM)
 endif()
 
 # Detect <sys/prctl.h>
-check_include_files("sys/prctl.h" HG_TESTING_HAS_SYSPRCTL_H)
+check_include_files("sys/prctl.h" HG_TEST_HAS_SYSPRCTL_H)
 
 #------------------------------------------------------------------------------
 # Compile kwsys library and setup TestDriver
@@ -114,7 +128,7 @@ include_directories(
   ${CMAKE_CURRENT_BINARY_DIR}
 )
 
-if(MERCURY_ENABLE_PARALLEL_TESTING)
+if(MERCURY_TESTING_ENABLE_PARALLEL)
   find_package(MPI REQUIRED)
   if(MPI_FOUND)
     include_directories(${MPI_INCLUDE_PATH})
@@ -143,7 +157,7 @@ function(build_mercury_test test_name)
   endif()
 endfunction()
 
-macro(add_mercury_test_comm test_name comm protocol busy)
+macro(add_mercury_test_comm test_name comm protocol busy serial)
   # Set full test name
   set(full_test_name ${test_name})
   set(opt_names ${comm} ${protocol})
@@ -159,6 +173,11 @@ macro(add_mercury_test_comm test_name comm protocol busy)
   if(${busy})
     set(test_args ${test_args} --busy)
   endif()
+  if(${serial})
+    set(numprocs 1)
+  else()
+    set(numprocs ${MPIEXEC_MAX_NUMPROCS})
+  endif()
 
   # Static client/server test
   if(${comm} STREQUAL "mpi" AND ${protocol} STREQUAL "static")
@@ -166,55 +185,72 @@ macro(add_mercury_test_comm test_name comm protocol busy)
     add_test(NAME "mercury_${full_test_name}"
       COMMAND ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} 1
       ${MPIEXEC_PREFLAGS} $<TARGET_FILE:hg_test_server> ${MPIEXEC_POSTFLAGS}
-      ${static_test_args} : ${MPIEXEC_NUMPROC_FLAG} ${MPIEXEC_MAX_NUMPROCS}
+      ${static_test_args} : ${MPIEXEC_NUMPROC_FLAG} ${numprocs}
       ${MPIEXEC_PREFLAGS} $<TARGET_FILE:hg_test_${test_name}> ${static_test_args}
     )
+    set_tests_properties("mercury_${full_test_name}" PROPERTIES
+      FAIL_REGULAR_EXPRESSION ${HG_TEST_FAIL_REGULAR_EXPRESSION}
+    )
   else()
+    set(driver_args --server $<TARGET_FILE:hg_test_server>       ${test_args}
+                    --client $<TARGET_FILE:hg_test_${test_name}> ${test_args})
+    if(${serial})
+      set(driver_args ${driver_args} --serial)
+    endif()
     # Dynamic client/server test
     add_test(NAME "mercury_${full_test_name}"
       COMMAND $<TARGET_FILE:mercury_test_driver>
-      --server $<TARGET_FILE:hg_test_server>
-      --client $<TARGET_FILE:hg_test_${test_name}> ${test_args}
+      ${driver_args}
     )
   endif()
 
   # Coresident test (disable for BMI and MPI)
   if(MERCURY_TESTING_CORESIDENT AND
     (NOT ((${comm} STREQUAL "bmi") OR (${comm} STREQUAL "mpi") OR (${test_name} STREQUAL "cancel"))))
-    set(cores_test_name ${full_test_name}_self)
-    set(cores_test_args ${test_args} --self_send)
-    if (MERCURY_ENABLE_PARALLEL_TESTING)
-      add_test(NAME "mercury_${cores_test_name}"
-        COMMAND ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} ${MPIEXEC_MAX_NUMPROCS}
+    set(self_test_name ${full_test_name}_self)
+    set(self_test_args ${test_args} --self_send)
+    if(MERCURY_TESTING_ENABLE_PARALLEL)
+      add_test(NAME "mercury_${self_test_name}"
+        COMMAND ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} ${numprocs}
         ${MPIEXEC_PREFLAGS} $<TARGET_FILE:hg_test_${test_name}> ${MPIEXEC_POSTFLAGS}
-        ${cores_test_args}
+        ${self_test_args}
+      )
+      set_tests_properties("mercury_${self_test_name}" PROPERTIES
+        FAIL_REGULAR_EXPRESSION ${HG_TEST_FAIL_REGULAR_EXPRESSION}
       )
     else()
       add_test(NAME "mercury_${cores_test_name}"
-        COMMAND $<TARGET_FILE:hg_test_${test_name}> ${cores_test_args}
+        COMMAND $<TARGET_FILE:hg_test_${test_name}> ${self_test_args}
+      )
+      set_tests_properties("mercury_${cores_test_name}" PROPERTIES
+        FAIL_REGULAR_EXPRESSION ${HG_TEST_FAIL_REGULAR_EXPRESSION}
       )
     endif()
   endif()
 
   # Scalable endpoint test
-  if(MERCURY_TESTING_HAS_THREAD_POOL AND ${comm} STREQUAL "ofi" AND
+  if(MERCURY_TESTING_USE_THREAD_POOL AND ${comm} STREQUAL "ofi" AND
     (NOT ((${protocol} STREQUAL "tcp") OR (${protocol} STREQUAL "verbs"))))
-    set(cores_test_name ${full_test_name}_scalable)
-    set(cores_test_args ${test_args} -C 2)
-    add_test(NAME "mercury_${cores_test_name}"
+    set(scalable_test_name ${full_test_name}_scalable)
+    set(scalable_test_args ${test_args} -C 2)
+    set(driver_args --server $<TARGET_FILE:hg_test_server>       ${scalable_test_args}
+                    --client $<TARGET_FILE:hg_test_${test_name}> ${scalable_test_args})
+    if(${serial})
+      set(driver_args ${driver_args} --serial)
+    endif()
+    add_test(NAME "mercury_${scalable_test_name}"
       COMMAND $<TARGET_FILE:mercury_test_driver>
-      --server $<TARGET_FILE:hg_test_server>
-      --client $<TARGET_FILE:hg_test_${test_name}> ${cores_test_args}
+      ${driver_args}
     )
   endif()
 endmacro()
 
-function(add_mercury_test test_name)
+function(add_mercury_test test_name serial)
   foreach(comm ${NA_PLUGINS})
     string(TOUPPER ${comm} upper_comm)
     foreach(protocol ${NA_${upper_comm}_TESTING_PROTOCOL})
-      add_mercury_test_comm(${test_name} ${comm} ${protocol} false)
-      add_mercury_test_comm(${test_name} ${comm} ${protocol} true)
+      add_mercury_test_comm(${test_name} ${comm} ${protocol} false ${serial})
+      add_mercury_test_comm(${test_name} ${comm} ${protocol} true ${serial})
     endforeach()
   endforeach()
 endfunction()
@@ -250,7 +286,7 @@ endif()
 #----------------------------------------------------------------------------
 
 add_library(mercury_test STATIC ${MERCURY_TEST_SRCS})
-target_link_libraries(mercury_test mercury_hl na_test
+target_link_libraries(mercury_test mercury na_test
   ${MERCURY_TEST_EXT_LIB_DEPENDENCIES}
 )
 if(MERCURY_ENABLE_COVERAGE)
@@ -264,23 +300,31 @@ endif()
 # Server used for testing
 build_mercury_test(server)
 
-set(MERCURY_tests
+# List of tests
+set(MERCURY_TESTS
   rpc
   bulk
 )
 
-# Benchmarks
-build_mercury_test(rpc_lat)
-build_mercury_test(write_bw)
-build_mercury_test(read_bw)
+# List of serial tests
+set(MERCURY_SERIAL_TESTS
+  rpc_lat
+  write_bw
+  read_bw
+)
 
 # Cray DRC test
-if(HG_TESTING_HAS_CRAY_DRC)
+if(NA_OFI_TESTING_USE_CRAY_DRC)
   build_mercury_test(drc_auth)
 endif()
 
 # Build tests and add them to ctest
-foreach(MERCURY_test ${MERCURY_tests})
-  build_mercury_test(${MERCURY_test})
-  add_mercury_test(${MERCURY_test})
+foreach(test ${MERCURY_TESTS})
+  build_mercury_test(${test})
+  add_mercury_test(${test} false)
+endforeach()
+
+foreach(test ${MERCURY_SERIAL_TESTS})
+  build_mercury_test(${test})
+#  add_mercury_test(${test} true)
 endforeach()
diff --git a/Testing/driver/CMakeLists.txt b/Testing/driver/CMakeLists.txt
index fa46fd6..3055e12 100644
--- a/Testing/driver/CMakeLists.txt
+++ b/Testing/driver/CMakeLists.txt
@@ -1,4 +1,4 @@
-cmake_minimum_required(VERSION 2.8.5 FATAL_ERROR)
+cmake_minimum_required(VERSION 2.8.12.2 FATAL_ERROR)
 project(MERCURY_TEST_DRIVER CXX)
 
 set(KWSYS_NAMESPACE mercury_sys)
diff --git a/Testing/driver/mercury_test_driver.cxx b/Testing/driver/mercury_test_driver.cxx
index e6d8fb7..4b94597 100644
--- a/Testing/driver/mercury_test_driver.cxx
+++ b/Testing/driver/mercury_test_driver.cxx
@@ -1,7 +1,8 @@
-#include "mercury_test_driver.h"
+#include "mercury_test_driver.hxx"
 #include "mercury_test_config.h"
 
 #include <cstdio>
+#include <sstream>
 #include <iostream>
 #include <cstring>
 #include <cstdlib>
@@ -18,696 +19,686 @@ using std::string;
 using std::cerr;
 
 // The main function as this class should only be used by this program
-int main(int argc, char* argv[])
+int
+main(int argc, char *argv[])
 {
-  HGTestDriver d;
-  return d.Main(argc, argv);
+    HGTestDriver d;
+    return d.Main(argc, argv);
 }
+
 //----------------------------------------------------------------------------
 HGTestDriver::HGTestDriver()
 {
-  this->AllowErrorInOutput = 0;
-  this->TimeOut = 300;
-  this->ServerExitTimeOut = 60;
-  this->TestServer = 0;
+    this->ClientArgStart = 0;
+    this->ClientArgCount = 0;
+    this->ServerArgStart = 0;
+    this->ServerArgCount = 0;
+    this->AllowErrorInOutput = false;
+    // try to make sure that this times out before dart so it can kill all the processes
+    this->TimeOut = DART_TESTING_TIMEOUT - 10.0;
+    this->ServerExitTimeOut = 2; /* 2 seconds timeout for server to exit */
+    this->TestServer = false;
+    this->TestSerial = false;
 }
+
 //----------------------------------------------------------------------------
 HGTestDriver::~HGTestDriver()
 {
 }
+
 //----------------------------------------------------------------------------
-void HGTestDriver::SeparateArguments(const char* str,
-                                     vector<string>& flags)
+void
+HGTestDriver::SeparateArguments(const char *str, vector<string> &flags)
 {
-  string arg = str;
-  string::size_type pos1 = 0;
-  string::size_type pos2 = arg.find_first_of(" ;");
-  if(pos2 == arg.npos)
-    {
-    flags.push_back(str);
-    return;
-    }
-  while(pos2 != arg.npos)
-    {
-    flags.push_back(arg.substr(pos1, pos2-pos1));
-    pos1 = pos2+1;
-    pos2 = arg.find_first_of(" ;", pos1+1);
-    }
-  flags.push_back(arg.substr(pos1, pos2-pos1));
+    string arg = str;
+    string::size_type pos1 = 0;
+    string::size_type pos2 = arg.find_first_of(" ;");
+    if (pos2 == arg.npos) {
+        flags.push_back(str);
+        return;
+    }
+    while (pos2 != arg.npos) {
+        flags.push_back(arg.substr(pos1, pos2 - pos1));
+        pos1 = pos2 + 1;
+        pos2 = arg.find_first_of(" ;", pos1 + 1);
+    }
+    flags.push_back(arg.substr(pos1, pos2 - pos1));
 }
+
 //----------------------------------------------------------------------------
-void HGTestDriver::CollectConfiguredOptions()
+void
+HGTestDriver::CollectConfiguredOptions()
 {
-  // try to make sure that this timesout before dart so it can kill all the processes
-  this->TimeOut = DART_TESTING_TIMEOUT - 10.0;
-  if(this->TimeOut < 0)
-    {
-    this->TimeOut = 1500;
-    }
+    if (this->TimeOut < 0)
+        this->TimeOut = 1500;
+
+#ifdef HG_TEST_ENV_VARS
+    this->SeparateArguments(HG_TEST_ENV_VARS, this->ClientEnvVars);
+#endif
 
-  // now find all the mpi information if mpi run is set
+    // now find all the mpi information if mpi run is set
 #ifdef MPIEXEC_EXECUTABLE
-  this->MPIRun = MPIEXEC_EXECUTABLE;
+    this->MPIRun = MPIEXEC_EXECUTABLE;
 #else
-  return;
+    return;
 #endif
-  int maxNumProc = 1;
+    int maxNumProc = 1;
 
 # ifdef MPIEXEC_MAX_NUMPROCS
-  maxNumProc = MPIEXEC_MAX_NUMPROCS;
+    if (!this->TestSerial)
+        maxNumProc = MPIEXEC_MAX_NUMPROCS;
 # endif
 # ifdef MPIEXEC_NUMPROC_FLAG
-  this->MPINumProcessFlag = MPIEXEC_NUMPROC_FLAG;
+    this->MPINumProcessFlag = MPIEXEC_NUMPROC_FLAG;
 # endif
 # ifdef MPIEXEC_PREFLAGS
-  this->SeparateArguments(MPIEXEC_PREFLAGS, this->MPIPreFlags);
+    this->SeparateArguments(MPIEXEC_PREFLAGS, this->MPIClientPreFlags);
 # endif
 # ifdef MPIEXEC_POSTFLAGS
-  this->SeparateArguments(MPIEXEC_POSTFLAGS, this->MPIPostFlags);
+    this->SeparateArguments(MPIEXEC_POSTFLAGS, this->MPIClientPostFlags);
+# endif
+# ifdef MPIEXEC_SERVER_PREFLAGS
+    this->SeparateArguments(MPIEXEC_SERVER_PREFLAGS, this->MPIServerPreFlags);
+#else
+    this->MPIServerPreFlags = this->MPIClientPreFlags;
 # endif
-  char buf[32];
-  sprintf(buf, "%d", maxNumProc);
-  this->MPIServerNumProcessFlag = "1";
-  this->MPIClientNumProcessFlag = buf;
+# ifdef MPIEXEC_SERVER_POSTFLAGS
+    this->SeparateArguments(MPIEXEC_SERVER_POSTFLAGS, this->MPIServerPostFlags);
+#else
+    this->MPIServerPostFlags = this->MPIClientPostFlags;
+# endif
+    std::stringstream ss;
+    ss << maxNumProc;
+    this->MPIServerNumProcessFlag = "1";
+    this->MPIClientNumProcessFlag = ss.str();
 }
+
 //----------------------------------------------------------------------------
 /// This adds the debug/build configuration crap for the executable on windows.
-static string FixExecutablePath(const string& path)
+static string
+FixExecutablePath(const string &path)
 {
 #ifdef  CMAKE_INTDIR
-  string parent_dir =
+    string parent_dir =
     mercury_sys::SystemTools::GetFilenamePath(path.c_str());
 
-  string filename =
+    string filename =
     mercury_sys::SystemTools::GetFilenameName(path);
 
-  if (!mercury_sys::SystemTools::StringEndsWith(parent_dir.c_str(), CMAKE_INTDIR)) {
-    parent_dir += "/" CMAKE_INTDIR;
-  }
-  return parent_dir + "/" + filename;
+    if (!mercury_sys::SystemTools::StringEndsWith(parent_dir.c_str(), CMAKE_INTDIR)) {
+        parent_dir += "/" CMAKE_INTDIR;
+    }
+    return parent_dir + "/" + filename;
 #endif
 
-  return path;
+    return path;
 }
+
 //----------------------------------------------------------------------------
-int HGTestDriver::ProcessCommandLine(int argc, char* argv[])
+int
+HGTestDriver::ProcessCommandLine(int argc, char *argv[])
 {
-  this->ArgStart = 1;
-  int i;
-  for(i =1; i < argc - 1; ++i)
-    {
-    if(strcmp(argv[i], "--client") == 0)
-      {
-      this->ArgStart = i+2;
-      this->ClientExecutable = ::FixExecutablePath(argv[i+1]);
-      }
-    if(strcmp(argv[i], "--server") == 0)
-      {
-      this->ArgStart = i+2;
-      this->TestServer = 1;
-      this->ServerExecutable = ::FixExecutablePath(argv[i+1]);
-      fprintf(stderr, "Test Server.\n");
-      }
-    if(strcmp(argv[i], "--timeout") == 0)
-      {
-      this->ArgStart = i+2;
-      this->TimeOut = atoi(argv[i+1]);
-      fprintf(stderr, "The timeout was set to %f.\n", this->TimeOut);
-      }
-    if (strncmp(argv[i], "--allow-errors", strlen("--allow-errors"))==0)
-      {
-      this->ArgStart =i+1;
-      this->AllowErrorInOutput = 1;
-      fprintf(stderr, "The allow erros in output flag was set to %d.\n", 
-        this->AllowErrorInOutput);
-      }
+    int *ArgCountP = NULL;
+    int i;
+    for (i = 1; i < argc; ++i) {
+        if (strcmp(argv[i], "--client") == 0) {
+            this->ClientExecutable = ::FixExecutablePath(argv[i + 1]);
+            ++i; /* Skip executable */
+            this->ClientArgStart = i + 1;
+            this->ClientArgCount = this->ClientArgStart;
+            ArgCountP = &this->ClientArgCount;
+            continue;
+        }
+        if (strcmp(argv[i], "--server") == 0) {
+            std::cerr << "Test Server" << std::endl;
+            this->TestServer = true;
+            this->ServerExecutable = ::FixExecutablePath(argv[i + 1]);
+            ++i; /* Skip executable */
+            this->ServerArgStart = i + 1;
+            this->ServerArgCount = this->ServerArgStart;
+            ArgCountP = &this->ServerArgCount;
+            continue;
+        }
+        if (strcmp(argv[i], "--timeout") == 0) {
+            this->TimeOut = atoi(argv[i + 1]);
+            std::cerr << "The timeout was set to " << this->TimeOut << std::endl;
+            ArgCountP = NULL;
+            continue;
+        }
+        if (strncmp(argv[i], "--allow-errors", strlen("--allow-errors")) == 0) {
+            this->AllowErrorInOutput = true;
+            std::cerr << "The allow errors in output flag was set to " <<
+                this->AllowErrorInOutput << std::endl;
+            ArgCountP = NULL;
+            continue;
+        }
+        if (strcmp(argv[i], "--serial") == 0) {
+            this->TestSerial = true;
+            std::cerr << "This is a serial test" << std::endl;
+            ArgCountP = NULL;
+            continue;
+        }
+        if (ArgCountP)
+            (*ArgCountP)++;
     }
 
-  return 1;
+    return 1;
 }
+
 //----------------------------------------------------------------------------
 void
-HGTestDriver::CreateCommandLine(vector<const char*>& commandLine,
-                                const char* cmd,
-                                const char* numProc,
-                                int argStart,
-                                int argCount,
-                                char* argv[])
+HGTestDriver::CreateCommandLine(vector<const char*> &commandLine,
+    const char *cmd, int isServer, int isHelper, const char *numProc, int argStart,
+    int argCount, char *argv[])
 {
-  if(this->MPIRun.size())
-    {
-    commandLine.push_back(this->MPIRun.c_str());
-    commandLine.push_back(this->MPINumProcessFlag.c_str());
-    commandLine.push_back(numProc);
-
-    for(unsigned int i = 0; i < this->MPIPreFlags.size(); ++i)
-      {
-      commandLine.push_back(this->MPIPreFlags[i].c_str());
-      }
+    if (!isServer && this->ClientEnvVars.size()) {
+        for (unsigned int i = 0; i < this->ClientEnvVars.size(); ++i)
+            commandLine.push_back(this->ClientEnvVars[i].c_str());
     }
 
-  commandLine.push_back(cmd);
+    if (!isHelper && this->MPIRun.size()) {
+        commandLine.push_back(this->MPIRun.c_str());
+        commandLine.push_back(this->MPINumProcessFlag.c_str());
+        commandLine.push_back(numProc);
 
-  for(unsigned int i = 0; i < this->MPIPostFlags.size(); ++i)
-    {
-    commandLine.push_back(MPIPostFlags[i].c_str());
+        if (isServer)
+            for (unsigned int i = 0; i < this->MPIServerPreFlags.size(); ++i)
+                commandLine.push_back(this->MPIServerPreFlags[i].c_str());
+        else
+            for (unsigned int i = 0; i < this->MPIClientPreFlags.size(); ++i)
+                commandLine.push_back(this->MPIClientPreFlags[i].c_str());
     }
 
-  // remaining flags for the test
-  for(int ii = argStart; ii < argCount; ++ii)
-    {
-    commandLine.push_back(argv[ii]);
+    commandLine.push_back(cmd);
+
+    if (isServer)
+        for (unsigned int i = 0; i < this->MPIServerPostFlags.size(); ++i)
+            commandLine.push_back(MPIServerPostFlags[i].c_str());
+    else
+        for (unsigned int i = 0; i < this->MPIClientPostFlags.size(); ++i)
+            commandLine.push_back(MPIClientPostFlags[i].c_str());
+
+    // remaining flags for the test
+//    cerr << "Arg start is " << argStart << "\n";
+//    cerr << "Arg count is " << argCount << "\n";
+    for (int ii = argStart; ii < argCount; ++ii) {
+        commandLine.push_back(argv[ii]);
     }
 
-  commandLine.push_back(0);
+    commandLine.push_back(0);
 }
+
 //----------------------------------------------------------------------------
-int HGTestDriver::StartServer(mercury_sysProcess* server, const char* name,
-                              vector<char>& out,
-                              vector<char>& err)
+int
+HGTestDriver::StartServer(mercury_sysProcess *server, const char *name,
+    vector<char> &out, vector<char> &err)
 {
-  if(!server)
-    {
-    return 1;
-    }
-  cerr << "HGTestDriver: starting process " << name << "\n";
-  mercury_sysProcess_SetTimeout(server, this->TimeOut);
-  mercury_sysProcess_Execute(server);
-  int foundWaiting = 0;
-  string output;
-  while(!foundWaiting)
-    {
-    int pipe = this->WaitForAndPrintLine(name, server, output, 100.0, out, err,
-                                         &foundWaiting);
-    if(pipe == mercury_sysProcess_Pipe_None ||
-       pipe == mercury_sysProcess_Pipe_Timeout)
-      {
-      break;
-      }
+    if (!server)
+        return 1;
+
+    cerr << "HGTestDriver: starting process " << name << "\n";
+    mercury_sysProcess_SetTimeout(server, this->TimeOut);
+    mercury_sysProcess_Execute(server);
+    int foundWaiting = 0;
+    string output;
+    while (!foundWaiting) {
+        int pipe = this->WaitForAndPrintLine(name, server, output, 100.0, out,
+            err, &foundWaiting);
+        if (pipe == mercury_sysProcess_Pipe_None
+            || pipe == mercury_sysProcess_Pipe_Timeout) {
+            break;
+        }
     }
-  if(foundWaiting)
-    {
-    cerr << "HGTestDriver: " << name << " sucessfully started.\n";
-    return 1;
-    }
-  else
-    {
-    cerr << "HGTestDriver: " << name << " never started.\n";
-    mercury_sysProcess_Kill(server);
-    return 0;
+    if (foundWaiting) {
+        cerr << "HGTestDriver: " << name << " sucessfully started.\n";
+        return 1;
+    } else {
+        cerr << "HGTestDriver: " << name << " never started.\n";
+        mercury_sysProcess_Kill(server);
+        return 0;
     }
 }
+
 //----------------------------------------------------------------------------
-int HGTestDriver::StartClient(mercury_sysProcess* client, const char* name)
+int
+HGTestDriver::StartClient(mercury_sysProcess *client, const char *name)
 {
-  if(!client)
-    {
-    return 1;
-    }
-  cerr << "HGTestDriver: starting process " << name << "\n";
-  mercury_sysProcess_SetTimeout(client, this->TimeOut);
-  mercury_sysProcess_Execute(client);
-  if(mercury_sysProcess_GetState(client) == mercury_sysProcess_State_Executing)
-    {
-    cerr << "HGTestDriver: " << name << " sucessfully started.\n";
-    return 1;
-    }
-  else
-    {
-    this->ReportStatus(client, name);
-    mercury_sysProcess_Kill(client);
-    return 0;
+    if (!client)
+        return 1;
+
+    cerr << "HGTestDriver: starting process " << name << "\n";
+    mercury_sysProcess_SetTimeout(client, this->TimeOut);
+    mercury_sysProcess_Execute(client);
+    if (mercury_sysProcess_GetState(client)
+        == mercury_sysProcess_State_Executing) {
+        cerr << "HGTestDriver: " << name << " sucessfully started.\n";
+        return 1;
+    } else {
+        this->ReportStatus(client, name);
+        mercury_sysProcess_Kill(client);
+        return 0;
     }
 }
+
 //----------------------------------------------------------------------------
-void HGTestDriver::Stop(mercury_sysProcess* p, const char* name)
+void
+HGTestDriver::Stop(mercury_sysProcess *p, const char *name)
 {
-  if(p)
-    {
-    cerr << "HGTestDriver: killing process " << name << "\n";
-    mercury_sysProcess_Kill(p);
-    mercury_sysProcess_WaitForExit(p, 0);
+    if (p) {
+        cerr << "HGTestDriver: killing process " << name << "\n";
+        mercury_sysProcess_Kill(p);
+        mercury_sysProcess_WaitForExit(p, 0);
     }
 }
+
 //----------------------------------------------------------------------------
-int HGTestDriver::OutputStringHasError(const char* pname, string& output)
+int
+HGTestDriver::OutputStringHasError(const char *pname, string &output)
 {
-  const char* possibleMPIErrors[] = {
-    "error",
-    "Error",
-    "Missing:",
-    "core dumped",
-    "process in local group is dead",
-    "Segmentation fault",
-    "erroneous",
-    "ERROR:",
-    "Error:",
-    "mpirun can *only* be used with MPI programs",
-    "due to signal",
-    "failure",
-    "abnormal termination",
-    "failed",
-    "FAILED",
-    "Failed",
-    0
-  };
-
-  const char* nonErrors[] = {
-    "Memcheck, a memory error detector",  //valgrind
-    "error in locking authority file",  //Ice-T
-    "WARNING: Far depth failed sanity check, resetting.", //Ice-T
-    // these are all caused (we think) by the dodgy SMPD shutdown bug in mpich2 on windows mpich2 1.4.1p1
-    "Error posting writev,",     
-    "sock error: Error = 10058", 
-    "state machine failed.", 
-    0
-  };
-
-  if(this->AllowErrorInOutput)
-    {
-    return 0;
-    }
-
-  vector<string> lines;
-  vector<string>::iterator it;
-  mercury_sys::SystemTools::Split(output.c_str(), lines);
-
-  int i, j;
-
-  for ( it = lines.begin(); it != lines.end(); ++ it )
-    {
-    for(i = 0; possibleMPIErrors[i]; ++i)
-      {
-      if(it->find(possibleMPIErrors[i]) != it->npos)
-        {
-        int found = 1;
-        for (j = 0; nonErrors[j]; ++ j)
-          {
-          if ( it->find(nonErrors[j]) != it->npos )
-            {
-            found = 0;
-            cerr << "Non error \"" << it->c_str() << "\" suppressed " << std::endl;
-            }      
-          }
-        if ( found )
-          {
-          cerr << "HGTestDriver: ***** Test will fail, because the string: \""
-            << possibleMPIErrors[i]
-            << "\"\nHGTestDriver: ***** was found in the following output from the "
-            << pname << ":\n\""
-            << it->c_str() << "\"\n";
-          return 1;
-          }
+    const char* possibleMPIErrors[] = {"error", "Error", "Missing:",
+        "core dumped", "process in local group is dead", "Segmentation fault",
+        "erroneous", "ERROR:", "Error:",
+        "mpirun can *only* be used with MPI programs", "due to signal",
+        "failure", "abnormal termination", "failed", "FAILED", "Failed", 0};
+
+    const char* nonErrors[] = {
+        "Memcheck, a memory error detector",  //valgrind
+        0};
+
+    if (this->AllowErrorInOutput)
+        return 0;
+
+    vector<string> lines;
+    vector<string>::iterator it;
+    mercury_sys::SystemTools::Split(output.c_str(), lines);
+
+    int i, j;
+
+    for (it = lines.begin(); it != lines.end(); ++it) {
+        for (i = 0; possibleMPIErrors[i]; ++i) {
+            if (it->find(possibleMPIErrors[i]) != it->npos) {
+                int found = 1;
+                for (j = 0; nonErrors[j]; ++j) {
+                    if (it->find(nonErrors[j]) != it->npos) {
+                        found = 0;
+                        cerr << "Non error \"" << it->c_str()
+                            << "\" suppressed " << std::endl;
+                    }
+                }
+                if (found) {
+                    cerr
+                        << "HGTestDriver: ***** Test will fail, because the string: \""
+                        << possibleMPIErrors[i]
+                        << "\"\nHGTestDriver: ***** was found in the following output from the "
+                        << pname << ":\n\"" << it->c_str() << "\"\n";
+                    return 1;
+                }
+            }
         }
-      }
     }
-  return 0;
+    return 0;
 }
+
 //----------------------------------------------------------------------------
-#define HG_CLEAN_PROCESSES \
-  mercury_sysProcess_Delete(client); \
-  mercury_sysProcess_Delete(server);
+#define HG_CLEAN_PROCESSES do {         \
+  mercury_sysProcess_Delete(client);    \
+  mercury_sysProcess_Delete(server);    \
+} while (0)
+
 //----------------------------------------------------------------------------
-int HGTestDriver::Main(int argc, char* argv[])
+int
+HGTestDriver::Main(int argc, char* argv[])
 {
-#ifdef MERCURY_TEST_INIT_COMMAND
-  // run user-specified commands before initialization.
-  // For example: "killall -9 rsh test;"
-  if(strlen(MERCURY_TEST_INIT_COMMAND) > 0)
-    {
-    std::vector<mercury_sys::String> commands = mercury_sys::SystemTools::SplitString(
-      MERCURY_TEST_INIT_COMMAND, ';');
-    for (unsigned int cc=0; cc < commands.size(); cc++)
-      {
-      std::string command = commands[cc];
-      if (command.size() > 0)
-        {
-        system(command.c_str());
+#ifdef HG_TEST_INIT_COMMAND
+    // run user-specified commands before initialization.
+    // For example: "killall -9 rsh test;"
+    if (strlen(HG_TEST_INIT_COMMAND) > 0) {
+//        std::vector<std::string> commands =
+        std::vector<mercury_sys::String> commands =
+            mercury_sys::SystemTools::SplitString(HG_TEST_INIT_COMMAND, ';');
+        for (unsigned int cc = 0; cc < commands.size(); cc++) {
+            std::string command = commands[cc];
+            if (command.size() > 0)
+                system(command.c_str());
         }
-      }
     }
 #endif
 
-  this->CollectConfiguredOptions();
-  if(!this->ProcessCommandLine(argc, argv))
-    {
-    return 1;
+    if (!this->ProcessCommandLine(argc, argv))
+        return 1;
+    this->CollectConfiguredOptions();
+
+    // mpi code
+    // Allocate process managers.
+    mercury_sysProcess *server = 0;
+    mercury_sysProcess *client = 0;
+    if (this->TestServer) {
+        server = mercury_sysProcess_New();
+        if (!server) {
+            HG_CLEAN_PROCESSES;
+            cerr << "HGTestDriver: Cannot allocate mercury_sysProcess to "
+                "run the server.\n";
+            return 1;
+        }
     }
 
-  // mpi code
-  // Allocate process managers.
-  mercury_sysProcess* server = 0;
-  mercury_sysProcess* client = 0;
-  if(this->TestServer)
-    {
-    server = mercury_sysProcess_New();
-    if(!server)
-      {
-      HG_CLEAN_PROCESSES;
-      cerr << "HGTestDriver: Cannot allocate mercury_sysProcess to run the server.\n";
-      return 1;
-      }
+    client = mercury_sysProcess_New();
+    if (!client) {
+        HG_CLEAN_PROCESSES;
+        cerr << "HGTestDriver: Cannot allocate mercury_sysProcess to "
+            "run the client.\n";
+        return 1;
+    }
+
+    vector<char> ClientStdOut;
+    vector<char> ClientStdErr;
+    vector<char> ServerStdOut;
+    vector<char> ServerStdErr;
+
+    vector<const char *> serverCommand;
+    if (server) {
+        const char* serverExe = this->ServerExecutable.c_str();
+
+        this->CreateCommandLine(serverCommand, serverExe, 1, 0,
+            this->MPIServerNumProcessFlag.c_str(), this->ServerArgStart,
+            this->ServerArgCount, argv);
+        this->ReportCommand(&serverCommand[0], "server");
+        mercury_sysProcess_SetCommand(server, &serverCommand[0]);
+        mercury_sysProcess_SetWorkingDirectory(server,
+            this->GetDirectory(serverExe).c_str());
+    }
+
+    // Construct the client process command line.
+    vector<const char *> clientCommand;
+    const char *clientExe = this->ClientExecutable.c_str();
+    this->CreateCommandLine(clientCommand, clientExe, 0, 0,
+        this->MPIClientNumProcessFlag.c_str(), this->ClientArgStart,
+        this->ClientArgCount, argv);
+    this->ReportCommand(&clientCommand[0], "client");
+    mercury_sysProcess_SetCommand(client, &clientCommand[0]);
+    mercury_sysProcess_SetWorkingDirectory(client,
+        this->GetDirectory(clientExe).c_str());
+
+    // Start the server if there is one
+    if (!this->StartServer(server, "server", ServerStdOut, ServerStdErr)) {
+        cerr << "HGTestDriver: Server never started.\n";
+        HG_CLEAN_PROCESSES;
+        return -1;
+    }
+
+    // Now run the client
+    if (!this->StartClient(client, "client")) {
+        this->Stop(server, "server");
+        HG_CLEAN_PROCESSES;
+        return -1;
+    }
+
+    // Report the output of the processes.
+    int clientPipe = 1;
+
+    string output;
+    int mpiError = 0;
+    while (clientPipe) {
+        clientPipe = this->WaitForAndPrintLine("client", client, output, 0.1,
+            ClientStdOut, ClientStdErr, 0);
+        if (!mpiError && this->OutputStringHasError("client", output)) {
+            mpiError = 1;
+        }
+        // If client has died, we wait for output from the server processess
+        // for this->ServerExitTimeOut, then we'll kill the servers, if needed.
+        double timeout = (clientPipe) ? 0 : this->ServerExitTimeOut;
+        output = "";
+        this->WaitForAndPrintLine("server", server, output, timeout,
+            ServerStdOut, ServerStdErr, 0);
+        if (!mpiError && this->OutputStringHasError("server", output)) {
+            mpiError = 1;
+        }
+        output = "";
+    }
+
+    // Wait for the client and server to exit.
+    mercury_sysProcess_WaitForExit(client, 0);
+
+    // Once client is finished, the servers
+    // must finish quickly. If not, it usually is a sign that
+    // the client crashed/exited before it attempted to connect to
+    // the server.
+    if (server) {
+#ifdef HG_TEST_SERVER_EXIT_COMMAND
+    // run user-specified commands before initialization.
+    // For example: "killall -9 rsh test;"
+    if (strlen(HG_TEST_SERVER_EXIT_COMMAND) > 0) {
+//        std::vector<std::string> commands =
+        std::vector<mercury_sys::String> commands =
+            mercury_sys::SystemTools::SplitString(HG_TEST_SERVER_EXIT_COMMAND,
+                ';');
+        for (unsigned int cc = 0; cc < commands.size(); cc++) {
+            std::string command = commands[cc];
+            if (command.size() > 0) {
+                std::cout << command.c_str() << std::endl;
+                system(command.c_str());
+            }
+        }
     }
-  client = mercury_sysProcess_New();
-  if(!client)
-    {
-    HG_CLEAN_PROCESSES;
-    cerr << "HGTestDriver: Cannot allocate mercury_sysProcess to run the client.\n";
-    return 1;
+#endif
+        mercury_sysProcess_WaitForExit(server, &this->ServerExitTimeOut);
     }
 
-  vector<char> ClientStdOut;
-  vector<char> ClientStdErr;
-  vector<char> ServerStdOut;
-  vector<char> ServerStdErr;
-
-  vector<const char*> serverCommand;
-  if(server)
-    {
-    const char* serverExe = this->ServerExecutable.c_str();
-
-    this->CreateCommandLine(serverCommand,
-                            serverExe,
-                            this->MPIServerNumProcessFlag.c_str(),
-                            this->ArgStart, argc, argv);
-    this->ReportCommand(&serverCommand[0], "server");
-    mercury_sysProcess_SetCommand(server, &serverCommand[0]);
-    mercury_sysProcess_SetWorkingDirectory(server, this->GetDirectory(serverExe).c_str());
+    // Get the results.
+    int clientResult = this->ReportStatus(client, "client");
+    int serverResult = 0;
+    if (server) {
+        serverResult = this->ReportStatus(server, "server");
+        mercury_sysProcess_Kill(server);
     }
 
-  // Construct the client process command line.
-  vector<const char*> clientCommand;
-  
-  const char* clientExe = this->ClientExecutable.c_str();
-  this->CreateCommandLine(clientCommand,
-                          clientExe,
-                          this->MPIClientNumProcessFlag.c_str(),
-                          this->ArgStart, argc, argv);
-  this->ReportCommand(&clientCommand[0], "client");
-  mercury_sysProcess_SetCommand(client, &clientCommand[0]);
-  mercury_sysProcess_SetWorkingDirectory(client, this->GetDirectory(clientExe).c_str());
-
-  // Start the server if there is one
-  if(!this->StartServer(server, "server",
-      ServerStdOut, ServerStdErr))
-    {
-    cerr << "HGTestDriver: Server never started.\n";
-    HG_CLEAN_PROCESSES;
-    return -1;
-    }
-  // Now run the client
-  if(!this->StartClient(client, "client"))
-    {
-    this->Stop(server, "server");
+    // Free process managers.
     HG_CLEAN_PROCESSES;
-    return -1;
-    }
-
-  // Report the output of the processes.
-  int clientPipe = 1;
-
-  string output;
-  int mpiError = 0;
-  while(clientPipe)
-    {
-    clientPipe = this->WaitForAndPrintLine("client", client, output, 0.1,
-                                           ClientStdOut, ClientStdErr, 0);
-    if(!mpiError && this->OutputStringHasError("client", output))
-      {
-      mpiError = 1;
-      }
-    // If client has died, we wait for output from the server processess
-    // for this->ServerExitTimeOut, then we'll kill the servers, if needed.
-    double timeout = (clientPipe)? 0.1 : this->ServerExitTimeOut;
-    output = "";
-    this->WaitForAndPrintLine("server", server, output, timeout,
-                              ServerStdOut, ServerStdErr, 0);
-    if(!mpiError && this->OutputStringHasError("server", output))
-      {
-      mpiError = 1;
-      }
-    output = "";
-    }
-
-  // Wait for the client and server to exit.
-  mercury_sysProcess_WaitForExit(client, 0);
-
-  // Once client is finished, the servers
-  // must finish quickly. If not, is usually is a sign that
-  // the client crashed/exited before it attempted to connect to 
-  // the server.
-  if(server)
-    {
-    mercury_sysProcess_WaitForExit(server, &this->ServerExitTimeOut);
-    }
-
-  // Get the results.
-  int clientResult = this->ReportStatus(client, "client");
-  int serverResult = 0;
-  if(server)
-    {
-    serverResult = this->ReportStatus(server, "server");
-    mercury_sysProcess_Kill(server);
-    }
 
-  // Free process managers.
-  HG_CLEAN_PROCESSES;
+    // Report the server return code if it is nonzero.  Otherwise report
+    // the client return code.
+    if (serverResult)
+        return serverResult;
 
-  // Report the server return code if it is nonzero.  Otherwise report
-  // the client return code.
-  if(serverResult)
-    {
-    return serverResult;
+    if (mpiError) {
+        cerr
+            << "HGTestDriver: Error string found in ouput, HGTestDriver returning "
+            << mpiError << "\n";
+        return mpiError;
     }
 
-  if(mpiError)
-    {
-    cerr << "HGTestDriver: Error string found in ouput, HGTestDriver returning "
-         << mpiError << "\n";
-    return mpiError;
-    }
-  // if server is fine return the client result
-  return clientResult;
+    // if server is fine return the client result
+    return clientResult;
 }
 
 //----------------------------------------------------------------------------
-void HGTestDriver::ReportCommand(const char* const* command, const char* name)
+void
+HGTestDriver::ReportCommand(const char * const *command, const char *name)
 {
-  cerr << "HGTestDriver: " << name << " command is:\n";
-  for(const char* const * c = command; *c; ++c)
-    {
-    cerr << " \"" << *c << "\"";
-    }
-  cerr << "\n";
+    cerr << "HGTestDriver: " << name << " command is:\n";
+    for (const char * const *c = command; *c; ++c)
+        cerr << " \"" << *c << "\"";
+    cerr << "\n";
 }
 
 //----------------------------------------------------------------------------
-int HGTestDriver::ReportStatus(mercury_sysProcess* process, const char* name)
-{
-  int result = 1;
-  switch(mercury_sysProcess_GetState(process))
-    {
-    case mercury_sysProcess_State_Starting:
-      {
-      cerr << "HGTestDriver: Never started " << name << " process.\n";
-      } break;
-    case mercury_sysProcess_State_Error:
-      {
-      cerr << "HGTestDriver: Error executing " << name << " process: "
-           << mercury_sysProcess_GetErrorString(process)
-           << "\n";
-      } break;
-    case mercury_sysProcess_State_Exception:
-      {
-      cerr << "HGTestDriver: " << name
-                      << " process exited with an exception: ";
-      switch(mercury_sysProcess_GetExitException(process))
-        {
-        case mercury_sysProcess_Exception_None:
-          {
-          cerr << "None";
-          } break;
-        case mercury_sysProcess_Exception_Fault:
-          {
-          cerr << "Segmentation fault";
-          } break;
-        case mercury_sysProcess_Exception_Illegal:
-          {
-          cerr << "Illegal instruction";
-          } break;
-        case mercury_sysProcess_Exception_Interrupt:
-          {
-          cerr << "Interrupted by user";
-          } break;
-        case mercury_sysProcess_Exception_Numerical:
-          {
-          cerr << "Numerical exception";
-          } break;
-        case mercury_sysProcess_Exception_Other:
-          {
-          cerr << "Unknown";
-          } break;
-        }
-      cerr << "\n";
-      } break;
-    case mercury_sysProcess_State_Executing:
-      {
-      cerr << "HGTestDriver: Never terminated " << name << " process.\n";
-      } break;
-    case mercury_sysProcess_State_Exited:
-      {
-      result = mercury_sysProcess_GetExitValue(process);
-      cerr << "HGTestDriver: " << name << " process exited with code "
-                      << result << "\n";
-      } break;
-    case mercury_sysProcess_State_Expired:
-      {
-      cerr << "HGTestDriver: killed " << name << " process due to timeout.\n";
-      } break;
-    case mercury_sysProcess_State_Killed:
-      {
-      cerr << "HGTestDriver: killed " << name << " process.\n";
-      } break;
-    }
-  return result;
-}
-//----------------------------------------------------------------------------
-
-int HGTestDriver::WaitForLine(mercury_sysProcess* process, string& line,
-                              double timeout,
-                              vector<char>& out,
-                              vector<char>& err)
+int
+HGTestDriver::ReportStatus(mercury_sysProcess *process, const char *name)
 {
-  line = "";
-  vector<char>::iterator outiter = out.begin();
-  vector<char>::iterator erriter = err.begin();
-  while(1)
-    {
-    // Check for a newline in stdout.
-    for(;outiter != out.end(); ++outiter)
-      {
-      if((*outiter == '\r') && ((outiter+1) == out.end()))
-        {
-        break;
+    int result = 1;
+    switch (mercury_sysProcess_GetState(process)) {
+        case mercury_sysProcess_State_Starting: {
+            cerr << "HGTestDriver: Never started " << name << " process.\n";
         }
-      else if(*outiter == '\n' || *outiter == '\0')
-        {
-        int length = outiter-out.begin();
-        if(length > 1 && *(outiter-1) == '\r')
-          {
-          --length;
-          }
-        if(length > 0)
-          {
-          line.append(&out[0], length);
-          }
-        out.erase(out.begin(), outiter+1);
-        return mercury_sysProcess_Pipe_STDOUT;
+            break;
+        case mercury_sysProcess_State_Error: {
+            cerr << "HGTestDriver: Error executing " << name << " process: "
+                << mercury_sysProcess_GetErrorString(process) << "\n";
         }
-      }
-
-    // Check for a newline in stderr.
-    for(;erriter != err.end(); ++erriter)
-      {
-      if((*erriter == '\r') && ((erriter+1) == err.end()))
-        {
-        break;
+            break;
+        case mercury_sysProcess_State_Exception: {
+            cerr << "HGTestDriver: " << name
+                << " process exited with an exception: ";
+            switch (mercury_sysProcess_GetExitException(process)) {
+                case mercury_sysProcess_Exception_None: {
+                    cerr << "None";
+                }
+                    break;
+                case mercury_sysProcess_Exception_Fault: {
+                    cerr << "Segmentation fault";
+                }
+                    break;
+                case mercury_sysProcess_Exception_Illegal: {
+                    cerr << "Illegal instruction";
+                }
+                    break;
+                case mercury_sysProcess_Exception_Interrupt: {
+                    cerr << "Interrupted by user";
+                }
+                    break;
+                case mercury_sysProcess_Exception_Numerical: {
+                    cerr << "Numerical exception";
+                }
+                    break;
+                case mercury_sysProcess_Exception_Other: {
+                    cerr << "Unknown";
+                }
+                    break;
+            }
+            cerr << "\n";
         }
-      else if(*erriter == '\n' || *erriter == '\0')
-        {
-        int length = erriter-err.begin();
-        if(length > 1 && *(erriter-1) == '\r')
-          {
-          --length;
-          }
-        if(length > 0)
-          {
-          line.append(&err[0], length);
-          }
-        err.erase(err.begin(), erriter+1);
-        return mercury_sysProcess_Pipe_STDERR;
+            break;
+        case mercury_sysProcess_State_Executing: {
+            cerr << "HGTestDriver: Never terminated " << name
+                << " process.\n";
         }
-      }
-
-    // No newlines found.  Wait for more data from the process.
-    int length;
-    char* data;
-    int pipe = mercury_sysProcess_WaitForData(process, &data, &length, &timeout);
-    if(pipe == mercury_sysProcess_Pipe_Timeout)
-      {
-      // Timeout has been exceeded.
-      return pipe;
-      }
-    else if(pipe == mercury_sysProcess_Pipe_STDOUT)
-      {
-      // Append to the stdout buffer.
-      vector<char>::size_type size = out.size();
-      out.insert(out.end(), data, data+length);
-      outiter = out.begin()+size;
-      }
-    else if(pipe == mercury_sysProcess_Pipe_STDERR)
-      {
-      // Append to the stderr buffer.
-      vector<char>::size_type size = err.size();
-      err.insert(err.end(), data, data+length);
-      erriter = err.begin()+size;
-      }
-    else if(pipe == mercury_sysProcess_Pipe_None)
-      {
-      // Both stdout and stderr pipes have broken.  Return leftover data.
-      if(!out.empty())
-        {
-        line.append(&out[0], outiter-out.begin());
-        out.erase(out.begin(), out.end());
-        return mercury_sysProcess_Pipe_STDOUT;
+            break;
+        case mercury_sysProcess_State_Exited: {
+            result = mercury_sysProcess_GetExitValue(process);
+            cerr << "HGTestDriver: " << name << " process exited with code "
+                << result << "\n";
         }
-      else if(!err.empty())
-        {
-        line.append(&err[0], erriter-err.begin());
-        err.erase(err.begin(), err.end());
-        return mercury_sysProcess_Pipe_STDERR;
+            break;
+        case mercury_sysProcess_State_Expired: {
+            cerr << "HGTestDriver: killed " << name
+                << " process due to timeout.\n";
         }
-      else
-        {
-        return mercury_sysProcess_Pipe_None;
+            break;
+        case mercury_sysProcess_State_Killed: {
+            cerr << "HGTestDriver: killed " << name << " process.\n";
         }
-      }
+            break;
     }
+    return result;
 }
+
 //----------------------------------------------------------------------------
-void HGTestDriver::PrintLine(const char* pname, const char* line)
+int
+HGTestDriver::WaitForLine(mercury_sysProcess *process, string &line,
+    double timeout, vector<char> &out, vector<char> &err)
 {
-  // if the name changed then the line is output from a different process
-  if(this->CurrentPrintLineName != pname)
-    {
-    cerr << "-------------- " << pname
-         << " output --------------\n";
-    // save the current pname
-    this->CurrentPrintLineName = pname;
+    line = "";
+    vector<char>::iterator outiter = out.begin();
+    vector<char>::iterator erriter = err.begin();
+    while (1) {
+        // Check for a newline in stdout.
+        for (; outiter != out.end(); ++outiter) {
+            if ((*outiter == '\r') && ((outiter + 1) == out.end())) {
+                break;
+            } else if (*outiter == '\n' || *outiter == '\0') {
+                int length = outiter - out.begin();
+                if (length > 1 && *(outiter - 1) == '\r')
+                    --length;
+                if (length > 0)
+                    line.append(&out[0], length);
+                out.erase(out.begin(), outiter + 1);
+                return mercury_sysProcess_Pipe_STDOUT;
+            }
+        }
+
+        // Check for a newline in stderr.
+        for (; erriter != err.end(); ++erriter) {
+            if ((*erriter == '\r') && ((erriter + 1) == err.end())) {
+                break;
+            } else if (*erriter == '\n' || *erriter == '\0') {
+                int length = erriter - err.begin();
+                if (length > 1 && *(erriter - 1) == '\r')
+                    --length;
+                if (length > 0)
+                    line.append(&err[0], length);
+                err.erase(err.begin(), erriter + 1);
+                return mercury_sysProcess_Pipe_STDERR;
+            }
+        }
+
+        // No newlines found.  Wait for more data from the process.
+        int length;
+        char *data;
+        int pipe = mercury_sysProcess_WaitForData(process, &data, &length,
+            &timeout);
+        if (pipe == mercury_sysProcess_Pipe_Timeout) {
+            // Timeout has been exceeded.
+            return pipe;
+        } else if (pipe == mercury_sysProcess_Pipe_STDOUT) {
+            // Append to the stdout buffer.
+            vector<char>::size_type size = out.size();
+            out.insert(out.end(), data, data + length);
+            outiter = out.begin() + size;
+        } else if (pipe == mercury_sysProcess_Pipe_STDERR) {
+            // Append to the stderr buffer.
+            vector<char>::size_type size = err.size();
+            err.insert(err.end(), data, data + length);
+            erriter = err.begin() + size;
+        } else if (pipe == mercury_sysProcess_Pipe_None) {
+            // Both stdout and stderr pipes have broken.  Return leftover data.
+            if (!out.empty()) {
+                line.append(&out[0], outiter - out.begin());
+                out.erase(out.begin(), out.end());
+                return mercury_sysProcess_Pipe_STDOUT;
+            } else if (!err.empty()) {
+                line.append(&err[0], erriter - err.begin());
+                err.erase(err.begin(), err.end());
+                return mercury_sysProcess_Pipe_STDERR;
+            } else {
+                return mercury_sysProcess_Pipe_None;
+            }
+        }
     }
-  cerr << line << "\n";
-  cerr.flush();
 }
+
 //----------------------------------------------------------------------------
-int HGTestDriver::WaitForAndPrintLine(const char* pname, mercury_sysProcess* process,
-                                      string& line, double timeout,
-                                      vector<char>& out,
-                                      vector<char>& err,
-                                      int* foundWaiting)
+void
+HGTestDriver::PrintLine(const char *pname, const char *line)
 {
-  int pipe = this->WaitForLine(process, line, timeout, out, err);
-  if(pipe == mercury_sysProcess_Pipe_STDOUT || pipe == mercury_sysProcess_Pipe_STDERR)
-    {
-    this->PrintLine(pname, line.c_str());
-    if(foundWaiting && (line.find("Waiting") != line.npos))
-      {
-      *foundWaiting = 1;
-      }
-    }
-  return pipe;
+    // if the name changed then the line is output from a different process
+    if (this->CurrentPrintLineName != pname) {
+        cerr << "-------------- " << pname << " output --------------\n";
+        // save the current pname
+        this->CurrentPrintLineName = pname;
+    }
+    cerr << line << "\n";
+    cerr.flush();
 }
+
+//----------------------------------------------------------------------------
+int
+HGTestDriver::WaitForAndPrintLine(const char *pname,
+    mercury_sysProcess *process, string &line, double timeout,
+    vector<char> &out, vector<char> &err, int *foundWaiting)
+{
+    int pipe = this->WaitForLine(process, line, timeout, out, err);
+    if (pipe == mercury_sysProcess_Pipe_STDOUT
+        || pipe == mercury_sysProcess_Pipe_STDERR) {
+        this->PrintLine(pname, line.c_str());
+        if (foundWaiting && (line.find(HG_TEST_SERVER_START_MSG) != line.npos))
+            *foundWaiting = 1;
+    }
+    return pipe;
+}
+
 //----------------------------------------------------------------------------
-string HGTestDriver::GetDirectory(string location)
+string
+HGTestDriver::GetDirectory(string location)
 {
-  return mercury_sys::SystemTools::GetParentDirectory(location.c_str());
+    return mercury_sys::SystemTools::GetParentDirectory(location.c_str());
 }
diff --git a/Testing/driver/mercury_test_driver.h b/Testing/driver/mercury_test_driver.h
deleted file mode 100644
index 137cc2c..0000000
--- a/Testing/driver/mercury_test_driver.h
+++ /dev/null
@@ -1,76 +0,0 @@
-#ifndef SHIPPER_TEST_DRIVER_H
-#define SHIPPER_TEST_DRIVER_H
-
-#include <string>
-#include <vector>
-
-#include <mercury_sys/Process.h>
-
-class HGTestDriver
-{
-public:
-  int Main(int argc, char* argv[]);
-  HGTestDriver();
-  ~HGTestDriver();
-
-protected:
-  void SeparateArguments(const char* str, 
-                         std::vector<std::string>& flags);
-  
-  void ReportCommand(const char* const* command, const char* name);
-  int ReportStatus(mercury_sysProcess* process, const char* name);
-  int ProcessCommandLine(int argc, char* argv[]);
-  void CollectConfiguredOptions();
-  void CreateCommandLine(std::vector<const char*>& commandLine,
-                         const char* paraView,
-                         const char* numProc,
-                         int argStart=0,
-                         int argCount=0,
-                         char* argv[]=0);
-  
-  int StartServer(mercury_sysProcess* server, const char* name,
-                  std::vector<char>& out, std::vector<char>& err);
-  int StartClient(mercury_sysProcess* client, const char* name);
-  void Stop(mercury_sysProcess* p, const char* name);
-  int OutputStringHasError(const char* pname, std::string& output);
-
-  int WaitForLine(mercury_sysProcess* process, std::string& line, double timeout,
-                  std::vector<char>& out, std::vector<char>& err);
-  void PrintLine(const char* pname, const char* line);
-  int WaitForAndPrintLine(const char* pname, mercury_sysProcess* process,
-                          std::string& line, double timeout,
-                          std::vector<char>& out, std::vector<char>& err,
-                          int* foundWaiting);
-
-  std::string GetDirectory(std::string location);
-
-private:
-  std::string ClientExecutable;  // fullpath to paraview executable
-  std::string ServerExecutable;  // fullpath to paraview server executable
-  std::string MPIRun;  // fullpath to mpirun executable
-
-  // This specify the preflags and post flags that can be set using:
-  // VTK_MPI_PRENUMPROC_FLAGS VTK_MPI_PREFLAGS / VTK_MPI_POSTFLAGS at config time
-  std::vector<std::string> MPIPreNumProcFlags;
-  std::vector<std::string> MPIPreFlags;
-  std::vector<std::string> MPIPostFlags;
-  
-  // Specify the number of process flag, this can be set using: VTK_MPI_NUMPROC_FLAG. 
-  // This is then split into : 
-  // MPIServerNumProcessFlag & MPIRenderServerNumProcessFlag
-  std::string MPINumProcessFlag;
-  std::string MPIServerNumProcessFlag;
-  std::string MPIClientNumProcessFlag;
-
-  std::string CurrentPrintLineName;
-
-  double TimeOut;
-  double ServerExitTimeOut; // time to wait for servers to finish.
-  int TestServer;
-
-  int ArgStart;
-  int AllowErrorInOutput;
-};
-
-#endif //SHIPPER_TEST_DRIVER_H
-
diff --git a/Testing/driver/mercury_test_driver.hxx b/Testing/driver/mercury_test_driver.hxx
new file mode 100644
index 0000000..245d2f1
--- /dev/null
+++ b/Testing/driver/mercury_test_driver.hxx
@@ -0,0 +1,75 @@
+#ifndef MERCURY_TEST_DRIVER_H
+#define MERCURY_TEST_DRIVER_H
+
+#include <mercury_sys/Process.h>
+#include <string>
+#include <vector>
+
+class HGTestDriver {
+public:
+    int Main(int argc, char *argv[]);
+    HGTestDriver();
+    ~HGTestDriver();
+
+protected:
+    void SeparateArguments(const char* str, std::vector<std::string> &flags);
+
+    void ReportCommand(const char * const *command, const char *name);
+    int  ReportStatus(mercury_sysProcess *process, const char *name);
+    int  ProcessCommandLine(int argc, char *argv[]);
+    void CollectConfiguredOptions();
+    void CreateCommandLine(std::vector<const char *> &commandLine,
+        const char *cmd, int isServer, int isHelper, const char *numProc,
+        int argStart = 0, int argCount = 0, char *argv[] = 0);
+
+    int StartServer(mercury_sysProcess *server, const char *name,
+        std::vector<char> &out, std::vector<char> &err);
+    int StartClient(mercury_sysProcess *client, const char *name);
+    void Stop(mercury_sysProcess *p, const char *name);
+    int OutputStringHasError(const char *pname, std::string &output);
+
+    int WaitForLine(mercury_sysProcess *process, std::string &line,
+        double timeout, std::vector<char> &out, std::vector<char> &err);
+    void PrintLine(const char *pname, const char *line);
+    int WaitForAndPrintLine(const char *pname, mercury_sysProcess *process,
+        std::string &line, double timeout, std::vector<char> &out,
+        std::vector<char> &err, int *foundWaiting);
+
+    std::string GetDirectory(std::string location);
+
+private:
+    std::string ClientExecutable;       // fullpath to client executable
+    std::string ServerExecutable;       // fullpath to server executable
+    std::string MPIRun;                 // fullpath to mpirun executable
+
+    // This specify the preflags and post flags that can be set using:
+    // VTK_MPI_PRENUMPROC_FLAGS VTK_MPI_PREFLAGS / VTK_MPI_POSTFLAGS at config time
+    // std::vector<std::string> MPIPreNumProcFlags;
+    std::vector<std::string> ClientEnvVars;
+    std::vector<std::string> MPIClientPreFlags;
+    std::vector<std::string> MPIClientPostFlags;
+    std::vector<std::string> MPIServerPreFlags;
+    std::vector<std::string> MPIServerPostFlags;
+
+    // Specify the number of process flag, this can be set using: VTK_MPI_NUMPROC_FLAG.
+    // This is then split into :
+    // MPIServerNumProcessFlag & MPIRenderServerNumProcessFlag
+    std::string MPINumProcessFlag;
+    std::string MPIServerNumProcessFlag;
+    std::string MPIClientNumProcessFlag;
+
+    std::string CurrentPrintLineName;
+
+    double TimeOut;
+    double ServerExitTimeOut;   // time to wait for servers to finish.
+    bool TestServer;
+
+    int ClientArgStart;
+    int ClientArgCount;
+    int ServerArgStart;
+    int ServerArgCount;
+    bool AllowErrorInOutput;
+    bool TestSerial;
+};
+
+#endif //MERCURY_TEST_DRIVER_H
diff --git a/Testing/mercury_rpc_cb.c b/Testing/mercury_rpc_cb.c
index 45bdbf9..3fa3fac 100644
--- a/Testing/mercury_rpc_cb.c
+++ b/Testing/mercury_rpc_cb.c
@@ -11,7 +11,7 @@
 #include "mercury_test.h"
 
 #include "mercury_time.h"
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
 #include "mercury_thread_pool.h"
 #endif
 #include "mercury_atomic.h"
@@ -21,24 +21,14 @@
 /****************/
 /* Local Macros */
 /****************/
-#define PIPELINE_SIZE 4
-#define MIN_BUFFER_SIZE (2 << 15) /* 11 Stop at 4KB buffer size */
 
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
-
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
 #define HG_TEST_ALLOC(size) calloc(size, sizeof(char))
 #else
 #define HG_TEST_ALLOC(size) malloc(size)
 #endif
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
 #define HG_TEST_RPC_CB(func_name, handle) \
     static hg_return_t \
     func_name ## _thread_cb(hg_handle_t handle)
@@ -47,40 +37,40 @@
  * will define func_name_thread and func_name_thread_cb that can be used
  * to execute RPC callback from a thread
  */
-#define HG_TEST_THREAD_CB(func_name) \
-        static HG_INLINE HG_THREAD_RETURN_TYPE \
-        func_name ## _thread \
-        (void *arg) \
-        { \
-            hg_handle_t handle = (hg_handle_t) arg; \
-            hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0; \
-            \
-            func_name ## _thread_cb(handle); \
-            \
-            return thread_ret; \
-        } \
-        hg_return_t \
-        func_name ## _cb(hg_handle_t handle) \
-        { \
-            struct hg_test_info *hg_test_info = \
-                (struct hg_test_info *) HG_Class_get_data( \
-                    HG_Get_info(handle)->hg_class); \
-            hg_return_t ret = HG_SUCCESS; \
-            \
-            if (!hg_test_info->secondary_contexts) { \
-                struct hg_thread_work *work = HG_Get_data(handle); \
-                work->func = func_name ## _thread; \
-                work->args = handle; \
-                hg_thread_pool_post(hg_test_info->thread_pool, work); \
-            } else { \
-                func_name ## _thread(handle); \
-            } \
-            \
-            return ret; \
+#define HG_TEST_THREAD_CB(func_name)                                    \
+        static HG_INLINE HG_THREAD_RETURN_TYPE                          \
+        func_name ## _thread                                            \
+        (void *arg)                                                     \
+        {                                                               \
+            hg_handle_t handle = (hg_handle_t) arg;                     \
+            hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;           \
+                                                                        \
+            func_name ## _thread_cb(handle);                            \
+                                                                        \
+            return thread_ret;                                          \
+        }                                                               \
+        hg_return_t                                                     \
+        func_name ## _cb(hg_handle_t handle)                            \
+        {                                                               \
+            struct hg_test_info *hg_test_info =                         \
+                (struct hg_test_info *) HG_Class_get_data(              \
+                    HG_Get_info(handle)->hg_class);                     \
+            hg_return_t ret = HG_SUCCESS;                               \
+                                                                        \
+            if (hg_test_info->na_test_info.max_contexts > 1) {          \
+                func_name ## _thread(handle);                           \
+            } else {                                                    \
+                struct hg_thread_work *work = HG_Get_data(handle);      \
+                work->func = func_name ## _thread;                      \
+                work->args = handle;                                    \
+                hg_thread_pool_post(hg_test_info->thread_pool, work);   \
+            }                                                           \
+                                                                        \
+            return ret;                                                 \
         }
 #else
-#define HG_TEST_RPC_CB(func_name, handle) \
-    hg_return_t \
+#define HG_TEST_RPC_CB(func_name, handle)                               \
+    hg_return_t                                                         \
     func_name ## _cb(hg_handle_t handle)
 #define HG_TEST_THREAD_CB(func_name)
 #endif
@@ -88,6 +78,7 @@
 /************************************/
 /* Local Type and Struct Definition */
 /************************************/
+
 #ifdef _WIN32
 #  ifndef _SSIZE_T_DEFINED
     typedef SSIZE_T ssize_t;
@@ -107,6 +98,7 @@ struct hg_test_bulk_args {
 /********************/
 /* Local Prototypes */
 /********************/
+
 static hg_return_t
 hg_test_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info);
 
@@ -114,12 +106,6 @@ static hg_return_t
 hg_test_bulk_bind_transfer_cb(const struct hg_cb_info *hg_cb_info);
 
 static hg_return_t
-hg_test_posix_write_transfer_cb(const struct hg_cb_info *hg_cb_info);
-
-static hg_return_t
-hg_test_posix_read_transfer_cb(const struct hg_cb_info *hg_cb_info);
-
-static hg_return_t
 hg_test_perf_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info);
 
 /*******************/
@@ -135,9 +121,10 @@ hg_test_perf_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info);
 static HG_INLINE int
 rpc_open(const char *path, rpc_handle_t handle, int *event_id)
 {
-    printf("Called rpc_open of %s with cookie %lu\n", path,
+    HG_TEST_LOG_DEBUG("Called rpc_open of %s with cookie %lu\n", path,
         (unsigned long) handle.cookie);
     *event_id = (int) handle.cookie;
+
     return HG_SUCCESS;
 }
 
@@ -146,7 +133,7 @@ static HG_INLINE size_t
 bulk_write(int fildes, const void *buf, size_t offset, size_t start_value,
     size_t nbyte, int verbose)
 {
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
     size_t i;
     int error = 0;
     const char *buf_ptr = (const char *) buf;
@@ -191,22 +178,18 @@ bulk_write(int fildes, const void *buf, size_t offset, size_t start_value,
 /*---------------------------------------------------------------------------*/
 HG_TEST_RPC_CB(hg_test_rpc_open, handle)
 {
-    hg_return_t ret = HG_SUCCESS;
-
     rpc_open_in_t  in_struct;
     rpc_open_out_t out_struct;
-
     hg_const_string_t path;
     rpc_handle_t rpc_handle;
     int event_id;
     int open_ret;
+    hg_return_t ret = HG_SUCCESS;
 
     /* Get input buffer */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get parameters */
     path = in_struct.path;
@@ -216,7 +199,9 @@ HG_TEST_RPC_CB(hg_test_rpc_open, handle)
     open_ret = rpc_open(path, rpc_handle, &event_id);
 
     /* Free input */
-    HG_Free_input(handle, &in_struct);
+    ret = HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill output structure */
     out_struct.event_id = event_id;
@@ -224,12 +209,13 @@ HG_TEST_RPC_CB(hg_test_rpc_open, handle)
 
     /* Send response back */
     ret = HG_Respond(handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Destroy(handle);
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
@@ -237,18 +223,16 @@ HG_TEST_RPC_CB(hg_test_rpc_open, handle)
 /*---------------------------------------------------------------------------*/
 HG_TEST_RPC_CB(hg_test_rpc_open_no_resp, handle)
 {
-    hg_return_t ret = HG_SUCCESS;
     rpc_open_in_t  in_struct;
     hg_const_string_t path;
     rpc_handle_t rpc_handle;
     int event_id;
+    hg_return_t ret = HG_SUCCESS;
 
     /* Get input buffer */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get parameters */
     path = in_struct.path;
@@ -257,8 +241,67 @@ HG_TEST_RPC_CB(hg_test_rpc_open_no_resp, handle)
     /* Call rpc_open */
     rpc_open(path, rpc_handle, &event_id);
 
-    HG_Free_input(handle, &in_struct);
-    HG_Destroy(handle);
+    ret = HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
+
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+HG_TEST_RPC_CB(hg_test_overflow, handle)
+{
+    size_t max_size =
+        HG_Class_get_output_eager_size(HG_Get_info(handle)->hg_class);
+    overflow_out_t out_struct;
+    hg_string_t string;
+    size_t string_len = max_size * 2;
+    hg_return_t ret = HG_SUCCESS;
+
+    string = (hg_string_t) malloc(string_len + 1);
+    HG_TEST_CHECK_ERROR(string == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate string");
+
+    memset(string, 'h', string_len);
+    string[string_len] = '\0';
+
+    /* Fill output structure */
+    out_struct.string = string;
+    out_struct.string_len = string_len;
+
+    /* Send response back */
+    ret = HG_Respond(handle, NULL, NULL, &out_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
+
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    free(string);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+HG_TEST_RPC_CB(hg_test_cancel_rpc, handle)
+{
+    hg_return_t ret = HG_SUCCESS;
+
+    /* Destroy twice and do not send expected response back */
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
@@ -277,6 +320,8 @@ HG_TEST_RPC_CB(hg_test_bulk_write, handle)
 
     bulk_args = (struct hg_test_bulk_args *) malloc(
             sizeof(struct hg_test_bulk_args));
+    HG_TEST_CHECK_ERROR(bulk_args == NULL, error, ret, HG_NOMEM_ERROR,
+        "Could not allocate bulk_args");
 
     /* Keep handle to pass to callback */
     bulk_args->handle = handle;
@@ -286,10 +331,8 @@ HG_TEST_RPC_CB(hg_test_bulk_write, handle)
 
     /* Get input parameters and data */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get parameters */
     fildes = in_struct.fildes;
@@ -301,13 +344,21 @@ HG_TEST_RPC_CB(hg_test_bulk_write, handle)
     bulk_args->target_offset = in_struct.target_offset;
     bulk_args->fildes = fildes;
 
+    ret = HG_Bulk_ref_incr(origin_bulk_handle);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_ref_incr() failed (%s)",
+        HG_Error_to_string(ret));
+
     /* Free input */
-    HG_Bulk_ref_incr(origin_bulk_handle);
-    HG_Free_input(handle, &in_struct);
+    ret = HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Create a new block handle to read the data */
-    HG_Bulk_create(hg_info->hg_class, 1, NULL, (hg_size_t *) &bulk_args->nbytes,
+    ret = HG_Bulk_create(hg_info->hg_class, 1, NULL,
+        (hg_size_t *) &bulk_args->nbytes,
         HG_BULK_READWRITE, &local_bulk_handle);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Pull bulk data */
     HG_TEST_LOG_DEBUG("Requesting transfer_size=%zu, origin_offset=%zu, "
@@ -317,21 +368,24 @@ HG_TEST_RPC_CB(hg_test_bulk_write, handle)
         bulk_args, HG_BULK_PULL, hg_info->addr, hg_info->context_id,
         origin_bulk_handle, bulk_args->origin_offset, local_bulk_handle,
         bulk_args->target_offset, bulk_args->transfer_size, &hg_bulk_op_id);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_transfer_id() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Test HG_Bulk_Cancel() */
     if (fildes < 0) {
         ret = HG_Bulk_cancel(hg_bulk_op_id);
-        if (ret != HG_SUCCESS){
-            fprintf(stderr, "Could not cancel bulk data\n");
-            return ret;
-        }
+        HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_cancel() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     return ret;
+
+error:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -347,6 +401,8 @@ HG_TEST_RPC_CB(hg_test_bulk_bind_write, handle)
 
     bulk_args = (struct hg_test_bulk_args *) malloc(
             sizeof(struct hg_test_bulk_args));
+    HG_TEST_CHECK_ERROR(bulk_args == NULL, error, ret, HG_NOMEM_ERROR,
+        "Could not allocate bulk_args");
 
     /* Keep handle to pass to callback */
     bulk_args->handle = handle;
@@ -356,10 +412,8 @@ HG_TEST_RPC_CB(hg_test_bulk_bind_write, handle)
 
     /* Get input parameters and data */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get parameters */
     fildes = in_struct.fildes;
@@ -372,8 +426,11 @@ HG_TEST_RPC_CB(hg_test_bulk_bind_write, handle)
     bulk_args->fildes = fildes;
 
     /* Create a new block handle to read the data */
-    HG_Bulk_create(hg_info->hg_class, 1, NULL, (hg_size_t *) &bulk_args->nbytes,
+    ret = HG_Bulk_create(hg_info->hg_class, 1, NULL,
+        (hg_size_t *) &bulk_args->nbytes,
         HG_BULK_READWRITE, &local_bulk_handle);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Pull bulk data */
     HG_TEST_LOG_DEBUG("Requesting transfer_size=%zu, origin_offset=%zu, "
@@ -383,10 +440,15 @@ HG_TEST_RPC_CB(hg_test_bulk_bind_write, handle)
         bulk_args, HG_BULK_PULL,
         origin_bulk_handle, bulk_args->origin_offset, local_bulk_handle,
         bulk_args->target_offset, bulk_args->transfer_size, HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_bind_transfer() failed (%s)",
+        HG_Error_to_string(ret));
+
+    return ret;
+
+error:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
@@ -405,50 +467,46 @@ hg_test_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info)
     size_t write_ret;
 
     if (hg_cb_info->ret == HG_CANCELED) {
-        printf("HG_Bulk_transfer() was successfully canceled\n");
-
+        HG_TEST_LOG_DEBUG("HG_Bulk_transfer() was canceled\n");
         /* Fill output structure */
         out_struct.ret = 0;
-    } else if (hg_cb_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Error in callback");
-        ret = HG_PROTOCOL_ERROR;
         goto done;
-    }
+    } else
+        HG_TEST_CHECK_ERROR_NORET(hg_cb_info->ret != HG_SUCCESS, done,
+            "Error in HG callback (%s)", HG_Error_to_string(hg_cb_info->ret));
 
-    if (hg_cb_info->ret == HG_SUCCESS) {
-        /* Call bulk_write */
-        HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes,
-            HG_BULK_READ_ONLY, 1, &buf, NULL, NULL);
+    ret = HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes,
+        HG_BULK_READ_ONLY, 1, &buf, NULL, NULL);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_access() failed (%s)",
+        HG_Error_to_string(ret));
 
-        write_ret = bulk_write(bulk_args->fildes, buf, bulk_args->target_offset,
-            bulk_args->origin_offset - bulk_args->target_offset,
-            bulk_args->transfer_size, 1);
+    /* Call bulk_write */
+    write_ret = bulk_write(bulk_args->fildes, buf, bulk_args->target_offset,
+        bulk_args->origin_offset - bulk_args->target_offset,
+        bulk_args->transfer_size, 1);
 
-        /* Fill output structure */
-        out_struct.ret = write_ret;
-    }
+    /* Fill output structure */
+    out_struct.ret = write_ret;
 
+done:
     /* Free block handle */
     ret = HG_Bulk_free(local_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
+
     ret = HG_Bulk_free(origin_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Send response back */
     ret = HG_Respond(bulk_args->handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
+
+    ret = HG_Destroy(bulk_args->handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
-done:
-    HG_Destroy(bulk_args->handle);
     free(bulk_args);
 
     return ret;
@@ -475,386 +533,54 @@ hg_test_bulk_bind_transfer_cb(const struct hg_cb_info *hg_cb_info)
     size_t write_ret;
 
     if (hg_cb_info->ret == HG_CANCELED) {
-        printf("HG_Bulk_transfer() was successfully canceled\n");
-
+        HG_TEST_LOG_DEBUG("HG_Bulk_transfer() was successfully canceled\n");
         /* Fill output structure */
         out_struct.ret = 0;
-    } else if (hg_cb_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Error in callback");
-        ret = HG_PROTOCOL_ERROR;
         goto done;
-    }
+    } else
+        HG_TEST_CHECK_ERROR_NORET(hg_cb_info->ret != HG_SUCCESS, done,
+            "Error in HG callback (%s)", HG_Error_to_string(hg_cb_info->ret));
 
-    if (hg_cb_info->ret == HG_SUCCESS) {
-        /* Call bulk_write */
-        HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes,
-            HG_BULK_READ_ONLY, 1, &buf, NULL, NULL);
-
-        write_ret = bulk_write(bulk_args->fildes, buf, bulk_args->target_offset,
-            bulk_args->origin_offset - bulk_args->target_offset,
-            bulk_args->transfer_size, 1);
-
-        /* Fill output structure */
-        out_struct.ret = write_ret;
-    }
-
-    /* Try to send the bulk handle back */
-    out_struct.bulk_handle = origin_bulk_handle;
-
-    /* Free block handle */
-    ret = HG_Bulk_free(local_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
-
-    /* Send response back */
-    ret = HG_Respond(bulk_args->handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
-
-    /* Free input */
-    HG_Free_input(bulk_args->handle, &in_struct);
-
-done:
-    HG_Destroy(bulk_args->handle);
-    free(bulk_args);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-#ifndef _WIN32
-HG_TEST_RPC_CB(hg_test_posix_open, handle)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    open_in_t in_struct;
-    open_out_t out_struct;
-
-    const char *path;
-    int flags;
-    mode_t mode;
-    int open_ret;
-
-    /* Get input struct */
-    ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
-
-    path = in_struct.path;
-    flags = in_struct.flags;
-    mode = in_struct.mode;
-
-    /* Call open */
-    printf("Calling open with path: %s\n", path);
-    open_ret = open(path, flags, mode);
-
-    /* Free input */
-    HG_Free_input(handle, &in_struct);
-
-    /* Fill output structure */
-    out_struct.ret = open_ret;
-
-    /* Send response back */
-    ret = HG_Respond(handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
-
-    HG_Destroy(handle);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_posix_close, handle)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    close_in_t in_struct;
-    close_out_t out_struct;
-
-    int fd;
-    int close_ret;
-
-    /* Get input struct */
-    ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
-
-    fd = in_struct.fd;
-
-    /* Free input */
-    HG_Free_input(handle, &in_struct);
-
-    /* Call close */
-    printf("Calling close with fd: %d\n", fd);
-    close_ret = close(fd);
-
-    /* Fill output structure */
-    out_struct.ret = close_ret;
-
-    /* Send response back */
-    ret = HG_Respond(handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
-
-    HG_Destroy(handle);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_posix_write, handle)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    const struct hg_info *hg_info = NULL;
-    hg_bulk_t origin_bulk_handle = HG_BULK_NULL;
-    hg_bulk_t local_bulk_handle = HG_BULK_NULL;
-    struct hg_test_bulk_args *bulk_args = NULL;
-    write_in_t in_struct;
-
-    bulk_args = (struct hg_test_bulk_args *) malloc(
-            sizeof(struct hg_test_bulk_args));
-
-    /* Keep handle to pass to callback */
-    bulk_args->handle = handle;
-
-    /* Get info from handle */
-    hg_info = HG_Get_info(handle);
-
-    /* Get input struct */
-    ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
-
-    origin_bulk_handle = in_struct.bulk_handle;
-
-    /* Create a new block handle to read the data */
-    bulk_args->nbytes = HG_Bulk_get_size(origin_bulk_handle);
-    bulk_args->fildes = in_struct.fd;
-
-    /* Free input */
-    HG_Bulk_ref_incr(origin_bulk_handle);
-    HG_Free_input(handle, &in_struct);
-
-    /* Create a new bulk handle to read the data */
-    HG_Bulk_create(hg_info->hg_class, 1, NULL, &bulk_args->nbytes,
-            HG_BULK_READWRITE, &local_bulk_handle);
-
-    /* Pull bulk data */
-    ret = HG_Bulk_transfer_id(hg_info->context, hg_test_posix_write_transfer_cb,
-            bulk_args, HG_BULK_PULL, hg_info->addr, hg_info->context_id,
-            origin_bulk_handle, 0, local_bulk_handle, 0, bulk_args->nbytes,
-            HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_posix_write_transfer_cb(const struct hg_cb_info *hg_cb_info)
-{
-    struct hg_test_bulk_args *bulk_args = (struct hg_test_bulk_args *)
-            hg_cb_info->arg;
-    hg_bulk_t local_bulk_handle = hg_cb_info->info.bulk.local_handle;
-    hg_bulk_t origin_bulk_handle = hg_cb_info->info.bulk.origin_handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    write_out_t out_struct;
-
-    void *buf;
-    ssize_t write_ret;
-
-    /* for debug */
-    int i;
-    const int *buf_ptr;
+    ret = HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes,
+        HG_BULK_READ_ONLY, 1, &buf, NULL, NULL);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_access() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Call bulk_write */
-    HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes, HG_BULK_READWRITE,
-            1, &buf, NULL, NULL);
-
-    /* Check bulk buf */
-    buf_ptr = (const int*) buf;
-    for (i = 0; i < (int)(bulk_args->nbytes / sizeof(int)); i++) {
-        if (buf_ptr[i] != i) {
-            printf("Error detected in bulk transfer, buf[%d] = %d, was expecting %d!\n", i, buf_ptr[i], i);
-            break;
-        }
-    }
-
-    printf("Calling write with fd: %d\n", bulk_args->fildes);
-    write_ret = write(bulk_args->fildes, buf, bulk_args->nbytes);
+    write_ret = bulk_write(bulk_args->fildes, buf, bulk_args->target_offset,
+        bulk_args->origin_offset - bulk_args->target_offset,
+        bulk_args->transfer_size, 1);
 
     /* Fill output structure */
     out_struct.ret = write_ret;
 
+done:
+    /* Try to send the bulk handle back */
+    out_struct.bulk_handle = origin_bulk_handle;
+
     /* Free block handle */
     ret = HG_Bulk_free(local_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
-
-    /* Free origin handle */
-    ret = HG_Bulk_free(origin_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Send response back */
     ret = HG_Respond(bulk_args->handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
-
-    HG_Destroy(bulk_args->handle);
-    free(bulk_args);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_posix_read, handle)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    const struct hg_info *hg_info = NULL;
-    hg_bulk_t origin_bulk_handle = HG_BULK_NULL;
-    hg_bulk_t local_bulk_handle = HG_BULK_NULL;
-    struct hg_test_bulk_args *bulk_args = NULL;
-    read_in_t in_struct;
-
-    void *buf;
-    ssize_t read_ret;
-
-    /* for debug */
-    int i;
-    const int *buf_ptr;
-
-    bulk_args = (struct hg_test_bulk_args *) malloc(
-            sizeof(struct hg_test_bulk_args));
-
-    /* Keep handle to pass to callback */
-    bulk_args->handle = handle;
-
-    /* Get info from handle */
-    hg_info = HG_Get_info(handle);
-
-    /* Get input struct */
-    ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
-
-    origin_bulk_handle = in_struct.bulk_handle;
-
-    /* Create a new block handle to read the data */
-    bulk_args->nbytes = HG_Bulk_get_size(origin_bulk_handle);
-    bulk_args->fildes = in_struct.fd;
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Free input */
-    HG_Bulk_ref_incr(origin_bulk_handle);
-    HG_Free_input(handle, &in_struct);
-
-    /* Create a new bulk handle to read the data */
-    HG_Bulk_create(hg_info->hg_class, 1, NULL, (hg_size_t *) &bulk_args->nbytes,
-            HG_BULK_READ_ONLY, &local_bulk_handle);
-
-    /* Call bulk_write */
-    HG_Bulk_access(local_bulk_handle, 0, bulk_args->nbytes, HG_BULK_READWRITE,
-            1, &buf, NULL, NULL);
-
-    printf("Calling read with fd: %d\n", in_struct.fd);
-    read_ret = read(in_struct.fd, buf, bulk_args->nbytes);
-
-    /* Check bulk buf */
-    buf_ptr = (const int*) buf;
-    for (i = 0; i < (int)(bulk_args->nbytes / sizeof(int)); i++) {
-        if (buf_ptr[i] != i) {
-            printf("Error detected after read, buf[%d] = %d, was expecting %d!\n", i, buf_ptr[i], i);
-            break;
-        }
-    }
-
-    /* Fill output structure */
-    bulk_args->ret = read_ret;
-
-    /* Push bulk data */
-    ret = HG_Bulk_transfer_id(hg_info->context, hg_test_posix_read_transfer_cb,
-            bulk_args, HG_BULK_PUSH, hg_info->addr, hg_info->context_id,
-            origin_bulk_handle, 0, local_bulk_handle, 0, bulk_args->nbytes,
-            HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_posix_read_transfer_cb(const struct hg_cb_info *hg_cb_info)
-{
-    struct hg_test_bulk_args *bulk_args = (struct hg_test_bulk_args *)
-            hg_cb_info->arg;
-    hg_bulk_t local_bulk_handle = hg_cb_info->info.bulk.local_handle;
-    hg_bulk_t origin_bulk_handle = hg_cb_info->info.bulk.origin_handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    write_out_t out_struct;
-
-    /* Fill output structure */
-    out_struct.ret = bulk_args->ret;
-
-    /* Free block handle */
-    ret = HG_Bulk_free(local_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
-
-    /* Free origin handle */
-    ret = HG_Bulk_free(origin_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
+    ret = HG_Free_input(bulk_args->handle, &in_struct);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 
-    /* Send response back */
-    ret = HG_Respond(bulk_args->handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
+    ret = HG_Destroy(bulk_args->handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Destroy(bulk_args->handle);
     free(bulk_args);
 
     return ret;
 }
-#endif /* _WIN32 */
 
 /*---------------------------------------------------------------------------*/
 HG_TEST_RPC_CB(hg_test_perf_rpc, handle)
@@ -863,12 +589,13 @@ HG_TEST_RPC_CB(hg_test_perf_rpc, handle)
 
     /* Send response back */
     ret = HG_Respond(handle, NULL, NULL, NULL);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Destroy(handle);
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
@@ -877,28 +604,28 @@ HG_TEST_RPC_CB(hg_test_perf_rpc, handle)
 HG_TEST_RPC_CB(hg_test_perf_rpc_lat, handle)
 {
     hg_return_t ret = HG_SUCCESS;
-
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
     perf_rpc_lat_in_t in_struct;
 
     /* Get input struct */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Free_input(handle, &in_struct);
+    ret= HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 #endif
 
     /* Send response back */
     ret = HG_Respond(handle, NULL, NULL, NULL);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Destroy(handle);
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
@@ -906,51 +633,65 @@ HG_TEST_RPC_CB(hg_test_perf_rpc_lat, handle)
 /*---------------------------------------------------------------------------*/
 HG_TEST_RPC_CB(hg_test_perf_bulk, handle)
 {
-    hg_return_t ret = HG_SUCCESS;
     const struct hg_info *hg_info = NULL;
     struct hg_test_info *hg_test_info = NULL;
     hg_bulk_t origin_bulk_handle = HG_BULK_NULL;
     hg_bulk_t local_bulk_handle = HG_BULK_NULL;
     bulk_write_in_t in_struct;
+    hg_return_t ret = HG_SUCCESS;
 
     /* Get info from handle */
     hg_info = HG_Get_info(handle);
 
     /* Get test info */
     hg_test_info = (struct hg_test_info *) HG_Class_get_data(hg_info->hg_class);
+    HG_TEST_CHECK_ERROR(hg_test_info == NULL, error, ret, HG_INVALID_ARG,
+        "NULL hg_test_info");
 
     /* Get input struct */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     origin_bulk_handle = in_struct.bulk_handle;
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
     hg_thread_mutex_lock(&hg_test_info->bulk_handle_mutex);
 #endif
     local_bulk_handle = hg_test_info->bulk_handle;
 
+    ret = HG_Bulk_ref_incr(origin_bulk_handle);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_ref_incr() failed (%s)",
+        HG_Error_to_string(ret));
+
     /* Free input */
-    HG_Bulk_ref_incr(origin_bulk_handle);
     HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Pull bulk data */
     ret = HG_Bulk_transfer_id(hg_info->context, hg_test_perf_bulk_transfer_cb,
             handle, HG_BULK_PULL, hg_info->addr, hg_info->context_id,
             origin_bulk_handle, 0, local_bulk_handle, 0,
             HG_Bulk_get_size(origin_bulk_handle), HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_transfer_id() failed (%s)",
+        HG_Error_to_string(ret));
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+    hg_thread_mutex_unlock(&hg_test_info->bulk_handle_mutex);
+#endif
+
+    return ret;
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+error:
+#ifdef HG_TEST_HAS_THREAD_POOL
     hg_thread_mutex_unlock(&hg_test_info->bulk_handle_mutex);
 #endif
 
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
     return ret;
 }
 
@@ -969,24 +710,29 @@ HG_TEST_RPC_CB(hg_test_perf_bulk_read, handle)
 
     /* Get test info */
     hg_test_info = (struct hg_test_info *) HG_Class_get_data(hg_info->hg_class);
+    HG_TEST_CHECK_ERROR(hg_test_info == NULL, error, ret, HG_INVALID_ARG,
+        "NULL hg_test_info");
 
     /* Get input struct */
     ret = HG_Get_input(handle, &in_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get input struct\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Get_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     origin_bulk_handle = in_struct.bulk_handle;
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
     hg_thread_mutex_lock(&hg_test_info->bulk_handle_mutex);
 #endif
     local_bulk_handle = hg_test_info->bulk_handle;
 
+    ret = HG_Bulk_ref_incr(origin_bulk_handle);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_ref_incr() failed (%s)",
+        HG_Error_to_string(ret));
+
     /* Free input */
-    HG_Bulk_ref_incr(origin_bulk_handle);
-    HG_Free_input(handle, &in_struct);
+    ret = HG_Free_input(handle, &in_struct);
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Free_input() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Pull bulk data */
     ret = HG_Bulk_transfer_id(hg_info->context, hg_test_perf_bulk_transfer_cb,
@@ -994,15 +740,24 @@ HG_TEST_RPC_CB(hg_test_perf_bulk_read, handle)
         origin_bulk_handle, 0, local_bulk_handle, 0,
         HG_Bulk_get_size(origin_bulk_handle),
         HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not read bulk data\n");
-        return ret;
-    }
+    HG_TEST_CHECK_HG_ERROR(error, ret, "HG_Bulk_transfer_id() failed (%s)",
+        HG_Error_to_string(ret));
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+    hg_thread_mutex_unlock(&hg_test_info->bulk_handle_mutex);
+#endif
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+    return ret;
+
+error:
+#ifdef HG_TEST_HAS_THREAD_POOL
     hg_thread_mutex_unlock(&hg_test_info->bulk_handle_mutex);
 #endif
 
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
     return ret;
 }
 
@@ -1012,7 +767,7 @@ hg_test_perf_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info)
 {
     hg_handle_t handle = (hg_handle_t) hg_cb_info->arg;
     hg_bulk_t origin_bulk_handle = hg_cb_info->info.bulk.origin_handle;
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
     size_t size = HG_Bulk_get_size(hg_cb_info->info.bulk.origin_handle);
     void *buf;
     const char *buf_ptr;
@@ -1020,84 +775,43 @@ hg_test_perf_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info)
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
-    HG_Bulk_access(hg_cb_info->info.bulk.local_handle, 0,
+    HG_TEST_CHECK_ERROR_NORET(hg_cb_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(hg_cb_info->ret));
+
+#ifdef HG_TEST_HAS_VERIFY_DATA
+    ret = HG_Bulk_access(hg_cb_info->info.bulk.local_handle, 0,
         size, HG_BULK_READWRITE, 1, &buf, NULL, NULL);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_access() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Check bulk buf */
     buf_ptr = (const char*) buf;
     for (i = 0; i < size; i++) {
-        if (buf_ptr[i] != (char) i) {
-            printf("Error detected in bulk transfer, buf[%d] = %d, "
-                "was expecting %d!\n", (int) i, (char) buf_ptr[i], (char) i);
-            break;
-        }
+        HG_TEST_CHECK_ERROR(buf_ptr[i] != (char) i, done, ret, HG_SUCCESS,
+            "Error detected in bulk transfer, buf[%d] = %d, "
+            "was expecting %d!\n", (int) i, (char) buf_ptr[i], (char) i);
     }
 #endif
 
+done:
     /* Free origin handle */
     ret = HG_Bulk_free(origin_bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free HG bulk handle\n");
-        return ret;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Send response back */
     ret = HG_Respond(handle, NULL, NULL, NULL);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        goto done;
-    }
-
-done:
-    HG_Destroy(handle);
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_overflow, handle)
-{
-    size_t max_size =
-        HG_Class_get_output_eager_size(HG_Get_info(handle)->hg_class);
-    hg_return_t ret = HG_SUCCESS;
-
-    overflow_out_t out_struct;
-
-    hg_string_t string;
-    size_t string_len = max_size * 2;
-
-    string = (hg_string_t) malloc(string_len + 1);
-    memset(string, 'h', string_len);
-    string[string_len] = '\0';
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
-    /* Fill output structure */
-    out_struct.string = string;
-    out_struct.string_len = string_len;
-
-    /* Send response back */
-    ret = HG_Respond(handle, NULL, NULL, &out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not respond\n");
-        return ret;
-    }
-
-    HG_Destroy(handle);
-    free(string);
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
-HG_TEST_RPC_CB(hg_test_cancel_rpc, handle)
-{
-    /* Destroy twice and do not send expected response back */
-    HG_Destroy(handle);
-    HG_Destroy(handle);
-
-    return HG_SUCCESS;
-}
-
-/*---------------------------------------------------------------------------*/
 //static hg_return_t
 //hg_test_nested1_forward_cb(const struct hg_cb_info *callback_info)
 //{
@@ -1173,21 +887,16 @@ HG_TEST_RPC_CB(hg_test_cancel_rpc, handle)
 /*---------------------------------------------------------------------------*/
 HG_TEST_THREAD_CB(hg_test_rpc_open)
 HG_TEST_THREAD_CB(hg_test_rpc_open_no_resp)
+HG_TEST_THREAD_CB(hg_test_overflow)
+HG_TEST_THREAD_CB(hg_test_cancel_rpc)
+
 HG_TEST_THREAD_CB(hg_test_bulk_write)
 HG_TEST_THREAD_CB(hg_test_bulk_bind_write)
-//HG_TEST_THREAD_CB(hg_test_pipeline_write)
-#ifndef _WIN32
-HG_TEST_THREAD_CB(hg_test_posix_open)
-HG_TEST_THREAD_CB(hg_test_posix_close)
-HG_TEST_THREAD_CB(hg_test_posix_write)
-HG_TEST_THREAD_CB(hg_test_posix_read)
-#endif
+
 HG_TEST_THREAD_CB(hg_test_perf_rpc)
 HG_TEST_THREAD_CB(hg_test_perf_rpc_lat)
 HG_TEST_THREAD_CB(hg_test_perf_bulk)
 HG_TEST_THREAD_CB(hg_test_perf_bulk_read)
-HG_TEST_THREAD_CB(hg_test_overflow)
-HG_TEST_THREAD_CB(hg_test_cancel_rpc)
 //HG_TEST_THREAD_CB(hg_test_nested1)
 //HG_TEST_THREAD_CB(hg_test_nested2)
 
diff --git a/Testing/mercury_rpc_cb.h b/Testing/mercury_rpc_cb.h
index 11c77bb..772f542 100644
--- a/Testing/mercury_rpc_cb.h
+++ b/Testing/mercury_rpc_cb.h
@@ -16,12 +16,12 @@
  */
 hg_return_t
 hg_test_rpc_open_cb(hg_handle_t handle);
-
-/**
- * test_rpc (no response)
- */
 hg_return_t
 hg_test_rpc_open_no_resp_cb(hg_handle_t handle);
+hg_return_t
+hg_test_overflow_cb(hg_handle_t handle);
+hg_return_t
+hg_test_cancel_rpc_cb(hg_handle_t handle);
 
 /**
  * test_bulk
@@ -31,24 +31,6 @@ hg_test_bulk_write_cb(hg_handle_t handle);
 hg_return_t
 hg_test_bulk_bind_write_cb(hg_handle_t handle);
 
-///**
-// * test_pipeline
-// */
-//hg_return_t
-//hg_test_pipeline_write_cb(hg_handle_t handle);
-
-/**
- * test_posix
- */
-hg_return_t
-hg_test_posix_open_cb(hg_handle_t handle);
-hg_return_t
-hg_test_posix_write_cb(hg_handle_t handle);
-hg_return_t
-hg_test_posix_read_cb(hg_handle_t handle);
-hg_return_t
-hg_test_posix_close_cb(hg_handle_t handle);
-
 /**
  * test_perf
  */
@@ -62,18 +44,6 @@ hg_return_t
 hg_test_perf_bulk_read_cb(hg_handle_t handle);
 
 /**
- * test_overflow
- */
-hg_return_t
-hg_test_overflow_cb(hg_handle_t handle);
-
-/**
- * test_cancel
- */
-hg_return_t
-hg_test_cancel_rpc_cb(hg_handle_t handle);
-
-/**
  * test_nested
  */
 hg_return_t
diff --git a/Testing/mercury_test.c b/Testing/mercury_test.c
index 69b4734..e153b40 100644
--- a/Testing/mercury_test.c
+++ b/Testing/mercury_test.c
@@ -11,12 +11,10 @@
 #include "mercury_test.h"
 #include "na_test_getopt.h"
 #include "mercury_rpc_cb.h"
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
 # include <mercury_test_drc.h>
 #endif
 
-#include "mercury_hl.h"
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -29,6 +27,11 @@
 /* Local Type and Struct Definition */
 /************************************/
 
+struct hg_test_lookup_arg {
+    hg_addr_t *addr_ptr;
+    hg_request_t *request;
+};
+
 /********************/
 /* Local Prototypes */
 /********************/
@@ -40,12 +43,21 @@ void
 hg_test_parse_options(int argc, char *argv[],
     struct hg_test_info *hg_test_info);
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+static int
+hg_test_request_progress(unsigned int timeout, void *arg);
+
+static int
+hg_test_request_trigger(unsigned int timeout, unsigned int *flag, void *arg);
+
+#ifdef HG_TEST_HAS_THREAD_POOL
 static hg_return_t
 hg_test_handle_create_cb(hg_handle_t handle, void *arg);
 #endif
 
 static hg_return_t
+hg_test_addr_lookup_cb(const struct hg_cb_info *callback_info);
+
+static hg_return_t
 hg_test_finalize_rpc(struct hg_test_info *hg_test_info, hg_uint8_t target_id);
 
 static hg_return_t
@@ -74,20 +86,13 @@ extern const struct na_test_opt na_test_opt_g[];
 /* test_rpc */
 hg_id_t hg_test_rpc_open_id_g = 0;
 hg_id_t hg_test_rpc_open_id_no_resp_g = 0;
+hg_id_t hg_test_overflow_id_g = 0;
+hg_id_t hg_test_cancel_rpc_id_g = 0;
 
 /* test_bulk */
 hg_id_t hg_test_bulk_write_id_g = 0;
 hg_id_t hg_test_bulk_bind_write_id_g = 0;
 
-/* test_pipeline */
-hg_id_t hg_test_pipeline_write_id_g = 0;
-
-/* test_posix */
-hg_id_t hg_test_posix_open_id_g = 0;
-hg_id_t hg_test_posix_write_id_g = 0;
-hg_id_t hg_test_posix_read_id_g = 0;
-hg_id_t hg_test_posix_close_id_g = 0;
-
 /* test_perf */
 hg_id_t hg_test_perf_rpc_id_g = 0;
 hg_id_t hg_test_perf_rpc_lat_id_g = 0;
@@ -95,12 +100,6 @@ hg_id_t hg_test_perf_bulk_id_g = 0;
 hg_id_t hg_test_perf_bulk_write_id_g = 0;
 hg_id_t hg_test_perf_bulk_read_id_g = 0;
 
-/* test_overflow */
-hg_id_t hg_test_overflow_id_g = 0;
-
-/* test_cancel */
-hg_id_t hg_test_cancel_rpc_id_g = 0;
-
 /* test_nested */
 hg_id_t hg_test_nested1_id_g = 0;
 hg_id_t hg_test_nested2_id_g = 0;
@@ -136,7 +135,7 @@ hg_test_parse_options(int argc, char *argv[], struct hg_test_info *hg_test_info)
             case 'a': /* auth service */
                 hg_test_info->auth = HG_TRUE;
                 break;
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
             case 'k': /* auth key */
                 hg_test_info->credential = (uint32_t) atoi(na_test_opt_arg_g);
 #endif
@@ -155,11 +154,39 @@ hg_test_parse_options(int argc, char *argv[], struct hg_test_info *hg_test_info)
     na_test_opt_ind_g = 1;
 
     if (!hg_test_info->thread_count)
-        hg_test_info->thread_count = MERCURY_TESTING_NUM_THREADS_DEFAULT;
+        hg_test_info->thread_count = HG_TEST_NUM_THREADS_DEFAULT;
+}
+
+/*---------------------------------------------------------------------------*/
+static int
+hg_test_request_progress(unsigned int timeout, void *arg)
+{
+    hg_context_t *context = (hg_context_t *) arg;
+    int ret = HG_UTIL_SUCCESS;
+
+    if (HG_Progress(context, timeout) != HG_SUCCESS)
+        ret = HG_UTIL_FAIL;
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static int
+hg_test_request_trigger(unsigned int timeout, unsigned int *flag, void *arg)
+{
+    hg_context_t *context = (hg_context_t *) arg;
+    unsigned int actual_count = 0;
+    int ret = HG_UTIL_SUCCESS;
+
+    if (HG_Trigger(context, timeout, 1, &actual_count)
+            != HG_SUCCESS) ret = HG_UTIL_FAIL;
+    *flag = (actual_count) ? HG_UTIL_TRUE : HG_UTIL_FALSE;
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
 static hg_return_t
 hg_test_handle_create_cb(hg_handle_t handle, void *arg)
 {
@@ -180,6 +207,20 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
+hg_test_addr_lookup_cb(const struct hg_cb_info *callback_info)
+{
+    struct hg_test_lookup_arg *request_args =
+            (struct hg_test_lookup_arg *) callback_info->arg;
+
+    *request_args->addr_ptr = callback_info->info.lookup.addr;
+
+    hg_request_complete(request_args->request);
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
 hg_test_finalize_rpc(struct hg_test_info *hg_test_info, hg_uint8_t target_id)
 {
     hg_request_t *request_object = NULL;
@@ -259,14 +300,20 @@ hg_test_register(hg_class_t *hg_class)
     /* test_rpc */
     hg_test_rpc_open_id_g = MERCURY_REGISTER(hg_class, "hg_test_rpc_open",
             rpc_open_in_t, rpc_open_out_t, hg_test_rpc_open_cb);
-
-    /* Disable response */
     hg_test_rpc_open_id_no_resp_g = MERCURY_REGISTER(hg_class,
         "hg_test_rpc_open_no_resp", rpc_open_in_t, rpc_open_out_t,
         hg_test_rpc_open_no_resp_cb);
+
+    /* Disable response */
     HG_Registered_disable_response(hg_class, hg_test_rpc_open_id_no_resp_g,
         HG_TRUE);
 
+    hg_test_overflow_id_g = MERCURY_REGISTER(hg_class, "hg_test_overflow",
+            void, overflow_out_t, hg_test_overflow_cb);
+    hg_test_cancel_rpc_id_g = MERCURY_REGISTER(hg_class, "hg_test_cancel_rpc",
+            void, void, hg_test_cancel_rpc_cb);
+
+
     /* test_bulk */
     hg_test_bulk_write_id_g = MERCURY_REGISTER(hg_class, "hg_test_bulk_write",
             bulk_write_in_t, bulk_write_out_t, hg_test_bulk_write_cb);
@@ -274,18 +321,6 @@ hg_test_register(hg_class_t *hg_class)
         "hg_test_bulk_bind_write", bulk_write_in_t, bulk_bind_write_out_t,
         hg_test_bulk_bind_write_cb);
 
-#ifndef _WIN32
-    /* test_posix */
-    hg_test_posix_open_id_g = MERCURY_REGISTER(hg_class, "hg_test_posix_open",
-            open_in_t, open_out_t, hg_test_posix_open_cb);
-    hg_test_posix_write_id_g = MERCURY_REGISTER(hg_class, "hg_test_posix_write",
-            write_in_t, write_out_t, hg_test_posix_write_cb);
-    hg_test_posix_read_id_g = MERCURY_REGISTER(hg_class, "hg_test_posix_read",
-            read_in_t, read_out_t, hg_test_posix_read_cb);
-    hg_test_posix_close_id_g = MERCURY_REGISTER(hg_class, "hg_test_posix_close",
-            close_in_t, close_out_t, hg_test_posix_close_cb);
-#endif
-
     /* test_perf */
     hg_test_perf_rpc_id_g = MERCURY_REGISTER(hg_class, "hg_test_perf_rpc",
             void, void, hg_test_perf_rpc_cb);
@@ -299,14 +334,6 @@ hg_test_register(hg_class_t *hg_class)
             "hg_test_perf_bulk_read", bulk_write_in_t, void,
             hg_test_perf_bulk_read_cb);
 
-    /* test_overflow */
-    hg_test_overflow_id_g = MERCURY_REGISTER(hg_class, "hg_test_overflow",
-            void, overflow_out_t, hg_test_overflow_cb);
-
-    /* test_cancel */
-    hg_test_cancel_rpc_id_g = MERCURY_REGISTER(hg_class, "hg_test_cancel_rpc",
-            void, void, hg_test_cancel_rpc_cb);
-
     /* test_nested */
 //    hg_test_nested1_id_g = MERCURY_REGISTER(hg_class, "hg_test_nested",
 //            void, void, hg_test_nested1_cb);
@@ -322,7 +349,7 @@ hg_test_register(hg_class_t *hg_class)
 hg_return_t
 HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
 {
-    struct hg_init_info hg_init_info;
+    struct hg_init_info hg_init_info = HG_INIT_INFO_INITIALIZER;
     struct hg_test_context_info *hg_test_context_info;
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
@@ -339,7 +366,7 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     hg_test_parse_options(argc, argv, hg_test_info);
 
     if (hg_test_info->auth) {
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
         char hg_test_drc_key[NA_TEST_MAX_ADDR_NAME] = { '\0' };
 
         ret = hg_test_drc_acquire(argc, argv, hg_test_info);
@@ -357,13 +384,9 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     HG_TEST_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
         "NA_Test_init() failed (%s)",  NA_Error_to_string(na_ret));
 
-    memset(&hg_init_info, 0, sizeof(struct hg_init_info));
-
     /* Set progress mode */
     if (hg_test_info->na_test_info.busy_wait)
         hg_init_info.na_init_info.progress_mode = NA_NO_BLOCK;
-    else
-        hg_init_info.na_init_info.progress_mode = NA_DEFAULT;
 
     /* Set stats */
 #ifdef HG_HAS_COLLECT_STATS
@@ -387,14 +410,13 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         hg_test_info->na_test_info.listen, &hg_init_info);
     HG_TEST_CHECK_ERROR(hg_test_info->hg_class == NULL, done, ret, HG_FAULT,
         "HG_Init_opt() failed (%s)");
-    HG_CLASS_DEFAULT = hg_test_info->hg_class;
 
     /* Attach test info to class */
     ret = HG_Class_set_data(hg_test_info->hg_class, hg_test_info, NULL);
     HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Class_set_data() failed (%s)",
         HG_Error_to_string(ret));
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
     /* Attach handle created */
     ret = HG_Class_set_handle_create_callback(hg_test_info->hg_class,
         hg_test_handle_create_cb, hg_test_info->hg_class);
@@ -409,21 +431,23 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     HG_Class_set_output_offset(hg_test_info->hg_class, sizeof(hg_uint64_t));
     */
 
-    /* For convenience */
-    ret = HG_Hl_init_opt(NULL, hg_test_info->na_test_info.listen,
-        &hg_init_info);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_init_opt() failed (%s)",
-        HG_Error_to_string(ret));
+    /* Create primary context */
+    hg_test_info->context = HG_Context_create(hg_test_info->hg_class);
+    HG_TEST_CHECK_ERROR(hg_test_info->context == NULL, done, ret, HG_FAULT,
+        "Could not create HG context");
 
-    hg_test_info->context = HG_CONTEXT_DEFAULT;
-    hg_test_info->request_class = HG_REQUEST_CLASS_DEFAULT;
+    /* Create request class */
+    hg_test_info->request_class = hg_request_init(hg_test_request_progress,
+        hg_test_request_trigger, hg_test_info->context);
+    HG_TEST_CHECK_ERROR(hg_test_info->request_class == NULL, done, ret,
+        HG_FAULT, "Could not create request class");
 
     /* Attach context info to context */
     hg_test_context_info = malloc(sizeof(struct hg_test_context_info));
     HG_TEST_CHECK_ERROR(hg_test_context_info == NULL, done, ret, HG_NOMEM_ERROR,
         "Could not allocate HG test context info");
 
-    hg_atomic_set32(&hg_test_context_info->finalizing, 0);
+    hg_atomic_init32(&hg_test_context_info->finalizing, 0);
     ret = HG_Context_set_data(hg_test_info->context, hg_test_context_info, free);
     HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_set_data() failed (%s)",
         HG_Error_to_string(ret));
@@ -433,11 +457,11 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
     if (hg_test_info->na_test_info.listen
         || hg_test_info->na_test_info.self_send) {
-        size_t bulk_size = 1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE;
+        size_t bulk_size = 1024 * 1024 * HG_TEST_BUFFER_SIZE;
         char *buf_ptr;
         size_t i;
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
         /* Make sure that thread count is at least max_contexts */
         if (hg_test_info->thread_count <
             hg_test_info->na_test_info.max_contexts)
@@ -453,7 +477,6 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         /* Create bulk handle mutex */
         hg_thread_mutex_init(&hg_test_info->bulk_handle_mutex);
 #endif
-
         /* Create bulk buffer that can be used for receiving data */
         ret = HG_Bulk_create(hg_test_info->hg_class, 1, NULL,
             (hg_size_t *) &bulk_size, HG_BULK_READWRITE,
@@ -474,37 +497,6 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         na_size_t addr_string_len = NA_TEST_MAX_ADDR_NAME;
         hg_addr_t self_addr;
 
-        /* Create additional contexts (do not exceed total max contexts) */
-        if (hg_test_info->na_test_info.max_contexts > 1) {
-            hg_uint8_t secondary_contexts_count = (hg_uint8_t)
-                (hg_test_info->na_test_info.max_contexts - 1);
-            hg_uint8_t i;
-
-            hg_test_info->secondary_contexts = malloc(
-                secondary_contexts_count * sizeof(hg_context_t *));
-            HG_TEST_CHECK_ERROR(hg_test_info->secondary_contexts == NULL, done,
-                ret, HG_NOMEM_ERROR, "Could not allocate secondary contexts");
-            for (i = 0; i < secondary_contexts_count; i++) {
-                hg_uint8_t context_id = (hg_uint8_t) (i + 1);
-                hg_test_info->secondary_contexts[i] =
-                    HG_Context_create_id(hg_test_info->hg_class, context_id);
-                HG_TEST_CHECK_ERROR(hg_test_info->secondary_contexts[i] == NULL,
-                    done, ret, HG_FAULT, "HG_Context_create_id() failed");
-
-                /* Attach context info to context */
-                hg_test_context_info = malloc(
-                    sizeof(struct hg_test_context_info));
-                HG_TEST_CHECK_ERROR(hg_test_context_info == NULL, done, ret,
-                    HG_NOMEM_ERROR, "Could not allocate HG test context info");
-
-                hg_atomic_set32(&hg_test_context_info->finalizing, 0);
-                ret = HG_Context_set_data(hg_test_info->secondary_contexts[i],
-                    hg_test_context_info, free);
-                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_set_data() failed"
-                    " (%s)", HG_Error_to_string(ret));
-            }
-        }
-
         /* TODO only rank 0 */
         ret = HG_Addr_self(hg_test_info->hg_class, &self_addr);
         HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_self() failed (%s)",
@@ -521,14 +513,14 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
         na_test_set_config(addr_string);
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
         /* If static client, must wait for server to write config file */
         if (hg_test_info->na_test_info.mpi_static)
             MPI_Barrier(MPI_COMM_WORLD);
 #endif
 
         /* Used by CTest Test Driver to know when to launch clients */
-        MERCURY_TESTING_READY_MSG();
+        HG_TEST_READY_MSG();
     } else if (hg_test_info->na_test_info.self_send) {
         /* Self addr is target */
         ret = HG_Addr_self(hg_test_info->hg_class, &hg_test_info->target_addr);
@@ -536,16 +528,18 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
             HG_Error_to_string(ret));
     } else {
         char test_addr_name[NA_TEST_MAX_ADDR_NAME] = { '\0' };
+        hg_request_t *request = NULL;
+        unsigned int flag = 0;
+        struct hg_test_lookup_arg lookup_args;
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
         /* If static client must wait for server to write config file */
         if (hg_test_info->na_test_info.mpi_static)
             MPI_Barrier(MPI_COMM_WORLD);
 #endif
 
-        if (hg_test_info->na_test_info.mpi_comm_rank == 0) {
+        if (hg_test_info->na_test_info.mpi_comm_rank == 0)
             na_test_get_config(test_addr_name, NA_TEST_MAX_ADDR_NAME);
-        }
 
         /* Broadcast addr name */
         NA_Test_bcast(test_addr_name, NA_TEST_MAX_ADDR_NAME, 0,
@@ -558,11 +552,24 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
             hg_test_info->na_test_info.target_name);
 
         /* Look up target addr using target name info */
-        ret = HG_Hl_addr_lookup_wait(hg_test_info->context,
-            hg_test_info->request_class, hg_test_info->na_test_info.target_name,
-            &hg_test_info->target_addr, HG_MAX_IDLE_TIME);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_addr_lookup_wait() failed (%s)",
+        request = hg_request_create(hg_test_info->request_class);
+        lookup_args.addr_ptr = &hg_test_info->target_addr;
+        lookup_args.request = request;
+
+        /* Forward call to remote addr and get a new request */
+        ret = HG_Addr_lookup(hg_test_info->context, hg_test_addr_lookup_cb,
+            &lookup_args, hg_test_info->na_test_info.target_name,
+            HG_OP_ID_IGNORE);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_lookup() failed (%s)",
             HG_Error_to_string(ret));
+
+        /* Wait for request to be marked completed */
+        hg_request_wait(request, HG_MAX_IDLE_TIME, &flag);
+        HG_TEST_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
+            "Operation did not complete");
+
+        /* Free request */
+        hg_request_destroy(request);
     }
 
 done:
@@ -578,8 +585,8 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
 
     NA_Test_barrier(&hg_test_info->na_test_info);
 
+    /* Client sends request to terminate server */
     if (!hg_test_info->na_test_info.listen) {
-        /* Send request to terminate server */
         if (hg_test_info->na_test_info.mpi_comm_rank == 0) {
             hg_uint8_t i, context_count =
                 hg_test_info->na_test_info.max_contexts ?
@@ -587,48 +594,55 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
             for (i = 0; i < context_count; i++)
                 hg_test_finalize_rpc(hg_test_info, i);
         }
+    }
 
-        /* Free addr id */
+    NA_Test_barrier(&hg_test_info->na_test_info);
+
+    /* Free target addr */
+    if (hg_test_info->target_addr != HG_ADDR_NULL) {
         ret = HG_Addr_free(hg_test_info->hg_class, hg_test_info->target_addr);
         HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_free() failed (%s)",
             HG_Error_to_string(ret));
+        hg_test_info->target_addr = HG_ADDR_NULL;
     }
 
-    NA_Test_barrier(&hg_test_info->na_test_info);
+    /* Finalize request class */
+    if (hg_test_info->request_class) {
+        hg_request_finalize(hg_test_info->request_class, NULL);
+        hg_test_info->request_class = NULL;
+    }
 
-    if (hg_test_info->na_test_info.listen
-        || hg_test_info->na_test_info.self_send) {
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
-        /* Give some time before shutting down */
-        sleep(1);
+    /* Destroy context */
+    if (hg_test_info->context) {
+        ret = HG_Context_destroy(hg_test_info->context);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_destroy() failed"
+            " (%s)", HG_Error_to_string(ret));
+        hg_test_info->context = NULL;
+    }
 
+#ifdef HG_TEST_HAS_THREAD_POOL
+    if (hg_test_info->thread_pool) {
         hg_thread_pool_destroy(hg_test_info->thread_pool);
+        hg_test_info->thread_pool = NULL;
         hg_thread_mutex_destroy(&hg_test_info->bulk_handle_mutex);
+    }
 #endif
+
+    if (hg_test_info->bulk_handle != HG_BULK_NULL) {
         /* Destroy bulk handle */
         ret = HG_Bulk_free(hg_test_info->bulk_handle);
         HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
             HG_Error_to_string(ret));
-
-        /* Destroy secondary contexts */
-        if (hg_test_info->secondary_contexts) {
-            hg_uint8_t secondary_contexts_count = (hg_uint8_t)
-                (hg_test_info->na_test_info.max_contexts - 1);
-            hg_uint8_t i;
-
-            for (i = 0; i < secondary_contexts_count; i++) {
-                ret = HG_Context_destroy(hg_test_info->secondary_contexts[i]);
-                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_destroy() failed"
-                    " (%s)", HG_Error_to_string(ret));
-            }
-            free(hg_test_info->secondary_contexts);
-        }
+        hg_test_info->bulk_handle = HG_BULK_NULL;
     }
 
     /* Finalize interface */
-    ret = HG_Hl_finalize();
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_finalize() failed (%s)",
-        HG_Error_to_string(ret));
+    if (hg_test_info->hg_class) {
+        ret = HG_Finalize(hg_test_info->hg_class);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Finalize() failed (%s)",
+            HG_Error_to_string(ret));
+        hg_test_info->hg_class = NULL;
+    }
 
     /* Finalize NA test interface */
     na_ret = NA_Test_finalize(&hg_test_info->na_test_info);
@@ -636,7 +650,7 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
         "NA_Test_finalize() failed (%s)", NA_Error_to_string(na_ret));
 
     if (hg_test_info->auth) {
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
         ret = hg_test_drc_release(hg_test_info);
         HG_TEST_CHECK_HG_ERROR(done, ret, "hg_test_drc_release() failed (%s)",
             HG_Error_to_string(ret));
diff --git a/Testing/mercury_test.h b/Testing/mercury_test.h
index a7cff08..b0c8f8a 100644
--- a/Testing/mercury_test.h
+++ b/Testing/mercury_test.h
@@ -15,7 +15,7 @@
 
 #include "mercury.h"
 #include "mercury_request.h"
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+#ifdef HG_TEST_HAS_THREAD_POOL
 # include "mercury_thread_pool.h"
 # include "mercury_thread_mutex.h"
 #endif
@@ -23,12 +23,9 @@
 
 #include "test_rpc.h"
 #include "test_bulk.h"
-#ifndef _WIN32
-# include "test_posix.h"
-#endif
 #include "test_overflow.h"
 
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
 # include <rdmacred.h>
 #endif
 
@@ -37,26 +34,25 @@
 /*************************************/
 
 struct hg_test_info {
+    struct na_test_info na_test_info;
+#ifdef HG_TEST_HAS_THREAD_POOL
+    hg_thread_mutex_t bulk_handle_mutex;
+    hg_thread_pool_t *thread_pool;
+#endif
     hg_class_t *hg_class;
     hg_context_t *context;
-    hg_context_t **secondary_contexts;
     hg_request_class_t *request_class;
     hg_addr_t target_addr;
+    hg_bulk_t bulk_handle;
     hg_bool_t auth;
-#ifdef HG_TESTING_HAS_CRAY_DRC
+#ifdef HG_TEST_HAS_CRAY_DRC
     uint32_t credential;
     uint32_t wlm_id;
     drc_info_handle_t credential_info;
     uint32_t cookie;
 #endif
-    hg_bool_t auto_sm;
-    struct na_test_info na_test_info;
     unsigned int thread_count;
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
-    hg_thread_pool_t *thread_pool;
-    hg_thread_mutex_t bulk_handle_mutex;
-#endif
-    hg_bulk_t bulk_handle;
+    hg_bool_t auto_sm;
 };
 
 struct hg_test_context_info {
@@ -67,9 +63,6 @@ struct hg_test_context_info {
 /* Public Macros */
 /*****************/
 
-/* Number of threads */
-#define MERCURY_TESTING_NUM_THREADS_DEFAULT 8
-
 /* Default error macro */
 #ifdef HG_HAS_VERBOSE_ERROR
 # include <mercury_log.h>
diff --git a/Testing/mercury_test_config.h.in b/Testing/mercury_test_config.h.in
index c1b44f1..18d3712 100644
--- a/Testing/mercury_test_config.h.in
+++ b/Testing/mercury_test_config.h.in
@@ -8,46 +8,74 @@
  * found at the root of the source code distribution tree.
  */
 
+/* Generated file. Only edit mercury_test_config.h.in. */
+
 #ifndef MERCURY_TEST_CONFIG_H
 #define MERCURY_TEST_CONFIG_H
 
-#include <stdio.h>
-#define MERCURY_TESTING_READY_MSG() do {    \
-    /* Used by CTest Test Driver */         \
-    printf("# Waiting for client...\n");    \
-    fflush(stdout);                         \
-} while (0)
+/*************************************/
+/* Public Type and Struct Definition */
+/*************************************/
 
-#cmakedefine MERCURY_HAS_PARALLEL_TESTING
-#ifdef MERCURY_HAS_PARALLEL_TESTING
-#cmakedefine MPIEXEC_EXECUTABLE "@MPIEXEC_EXECUTABLE@"
-#cmakedefine MPIEXEC "@MPIEXEC@" /* For compatibility */
-#ifndef MPIEXEC_EXECUTABLE
-# define MPIEXEC_EXECUTABLE MPIEXEC
-#endif
-#cmakedefine MPIEXEC_NUMPROC_FLAG "@MPIEXEC_NUMPROC_FLAG@"
-#cmakedefine MPIEXEC_PREFLAGS "@MPIEXEC_PREFLAGS@"
-#cmakedefine MPIEXEC_POSTFLAGS "@MPIEXEC_POSTFLAGS@"
-#cmakedefine MPIEXEC_MAX_NUMPROCS @MPIEXEC_MAX_NUMPROCS@
-#endif
 
-#cmakedefine DART_TESTING_TIMEOUT @DART_TESTING_TIMEOUT@
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* MPI flags */
+#cmakedefine HG_TEST_HAS_PARALLEL
+#ifdef HG_TEST_HAS_PARALLEL
+# cmakedefine MPIEXEC_EXECUTABLE        "@MPIEXEC_EXECUTABLE@"
+# cmakedefine MPIEXEC                   "@MPIEXEC@" /* For compatibility */
+# ifndef MPIEXEC_EXECUTABLE
+#  define MPIEXEC_EXECUTABLE MPIEXEC
+# endif
+# cmakedefine MPIEXEC_NUMPROC_FLAG      "@MPIEXEC_NUMPROC_FLAG@"
+# cmakedefine MPIEXEC_PREFLAGS          "@MPIEXEC_PREFLAGS@"
+# cmakedefine MPIEXEC_POSTFLAGS         "@MPIEXEC_POSTFLAGS@"
+/* Server-specific flags if different */
+# cmakedefine MPIEXEC_SERVER_PREFLAGS   "@MPIEXEC_SERVER_PREFLAGS@"
+# cmakedefine MPIEXEC_SERVER_POSTFLAGS  "@MPIEXEC_SERVER_POSTFLAGS@"
+# cmakedefine MPIEXEC_MAX_NUMPROCS      (@MPIEXEC_MAX_NUMPROCS@)
+#endif /* HG_TEST_HAS_PARALLEL */
+
+/* Timeout */
+#cmakedefine DART_TESTING_TIMEOUT   @DART_TESTING_TIMEOUT@
 #ifndef DART_TESTING_TIMEOUT
-# define DART_TESTING_TIMEOUT 1500
+# define DART_TESTING_TIMEOUT   1500
+#endif
+
+/* Init/kill commands */
+#cmakedefine HG_TEST_INIT_COMMAND           "@HG_TEST_INIT_COMMAND@"
+#cmakedefine HG_TEST_SERVER_EXIT_COMMAND    "@HG_TEST_SERVER_EXIT_COMMAND@"
+
+/* Start msg */
+#cmakedefine HG_TEST_SERVER_START_MSG   "@HG_TEST_SERVER_START_MSG@"
+#ifndef HG_TEST_SERVER_START_MSG
+# define HG_TEST_SERVER_START_MSG   "# Waiting for client"
 #endif
+#include <stdio.h>
+#define HG_TEST_READY_MSG() do {            \
+    /* Used by CTest Test Driver */         \
+    printf(HG_TEST_SERVER_START_MSG "\n");  \
+    fflush(stdout);                         \
+} while (0)
 
-#cmakedefine MERCURY_TEST_INIT_COMMAND "@MERCURY_TEST_INIT_COMMAND@"
+/* Test options */
+#cmakedefine HG_TEST_BUFFER_SIZE        (@HG_TEST_BUFFER_SIZE@)
+#cmakedefine HG_TEST_MAX_HANDLES        (@HG_TEST_MAX_HANDLES@)
+#cmakedefine HG_TEST_HAS_THREAD_POOL
+#cmakedefine HG_TEST_HAS_VERIFY_DATA
+#cmakedefine HG_TEST_PRINT_PARTIAL
+#cmakedefine HG_TEST_TEMP_DIRECTORY     "@HG_TEST_TEMP_DIRECTORY@"
 
-#cmakedefine MERCURY_TESTING_BUFFER_SIZE @MERCURY_TESTING_BUFFER_SIZE@
-#cmakedefine MERCURY_TESTING_HAS_THREAD_POOL
-#cmakedefine MERCURY_TESTING_HAS_VERIFY_DATA
-#cmakedefine MERCURY_TESTING_PRINT_PARTIAL
-#cmakedefine MERCURY_TESTING_TEMP_DIRECTORY "@MERCURY_TESTING_TEMP_DIRECTORY@"
+/* Number of threads */
+#define HG_TEST_NUM_THREADS_DEFAULT     (8)
 
 /* Define if has <sys/prctl.h> */
-#cmakedefine HG_TESTING_HAS_SYSPRCTL_H
+#cmakedefine HG_TEST_HAS_SYSPRCTL_H
 
 /* Define if has <rdmacred.h> */
-#cmakedefine HG_TESTING_HAS_CRAY_DRC
+#cmakedefine HG_TEST_HAS_CRAY_DRC
 
 #endif /* MERCURY_TEST_CONFIG_H */
diff --git a/Testing/mercury_test_drc.c b/Testing/mercury_test_drc.c
index 2fbede4..c31d194 100644
--- a/Testing/mercury_test_drc.c
+++ b/Testing/mercury_test_drc.c
@@ -468,7 +468,7 @@ hg_return_t
 hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
 {
     struct hg_test_info hg_test_drc_info = { 0 };
-    struct hg_init_info hg_test_drc_init_info = { 0 };
+    struct hg_init_info hg_test_drc_init_info = HG_INIT_INFO_INITIALIZER;
     hg_return_t ret = HG_SUCCESS;
 
     if (!hg_test_info->credential) {
@@ -532,7 +532,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
         na_test_set_config(addr_string);
 
         /* Used by CTest Test Driver to know when to launch clients */
-        MERCURY_TESTING_READY_MSG();
+        HG_TEST_READY_MSG();
 
         /* Progress */
         do {
@@ -571,7 +571,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
         }
     }
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     /* TODO bcast cookie when parallel mode */
 #endif
 
@@ -583,7 +583,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     }
 
     /* Finalize NA test class interface */
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     hg_test_drc_info.na_test_info.mpi_no_finalize = NA_TRUE;
 #endif
     if (NA_Test_finalize(&hg_test_drc_info.na_test_info) != NA_SUCCESS) {
diff --git a/Testing/na/na_test.c b/Testing/na/na_test.c
index 2d55055..b72cae1 100644
--- a/Testing/na/na_test.c
+++ b/Testing/na/na_test.c
@@ -29,7 +29,7 @@
 #include <arpa/inet.h>
 #include <netdb.h>
 #include <unistd.h>
-#if defined(HG_TESTING_HAS_SYSPRCTL_H)
+#if defined(HG_TEST_HAS_SYSPRCTL_H)
 #include <sys/prctl.h>
 #endif
 #endif
@@ -51,7 +51,7 @@ static void
 na_test_parse_options(int argc, char *argv[],
     struct na_test_info *na_test_info);
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
 static void
 na_test_mpi_init(struct na_test_info *na_test_info);
 
@@ -179,7 +179,7 @@ na_test_parse_options(int argc, char *argv[],
 }
 
 /*---------------------------------------------------------------------------*/
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
 static void
 na_test_mpi_init(struct na_test_info *na_test_info)
 {
@@ -348,10 +348,10 @@ na_test_set_config(const char *addr_name)
 {
     FILE *config = NULL;
 
-    config = fopen(MERCURY_TESTING_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME, "w+");
+    config = fopen(HG_TEST_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME, "w+");
     if (!config) {
         NA_LOG_ERROR("Could not open config file from: %s",
-            MERCURY_TESTING_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME);
+            HG_TEST_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME);
         exit(1);
     }
     fprintf(config, "%s\n", addr_name);
@@ -364,10 +364,10 @@ na_test_get_config(char *addr_name, na_size_t len)
 {
     FILE *config = NULL;
 
-    config = fopen(MERCURY_TESTING_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME, "r");
+    config = fopen(HG_TEST_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME, "r");
     if (!config) {
         NA_LOG_ERROR("Could not open config file from: %s",
-            MERCURY_TESTING_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME);
+            HG_TEST_TEMP_DIRECTORY HG_TEST_CONFIG_FILE_NAME);
         exit(1);
     }
     if (fgets(addr_name, (int) len, config) == NULL) {
@@ -385,12 +385,12 @@ na_return_t
 NA_Test_init(int argc, char *argv[], struct na_test_info *na_test_info)
 {
     char *info_string = NULL;
-    struct na_init_info na_init_info;
+    struct na_init_info na_init_info = NA_INIT_INFO_INITIALIZER;
     na_return_t ret = NA_SUCCESS;
 
     na_test_parse_options(argc, argv, na_test_info);
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     /* Test run in parallel using mpirun so must intialize MPI to get
      * basic setup info etc */
     na_test_mpi_init(na_test_info);
@@ -413,12 +413,10 @@ NA_Test_init(int argc, char *argv[], struct na_test_info *na_test_info)
     if (na_test_info->listen && na_test_info->mpi_comm_rank == 0)
         NA_Cleanup();
 
-    memset(&na_init_info, 0, sizeof(struct na_init_info));
     if (na_test_info->busy_wait) {
         na_init_info.progress_mode = NA_NO_BLOCK;
         printf("# Initializing NA in busy wait mode\n");
-    } else
-        na_init_info.progress_mode = NA_DEFAULT;
+    }
     na_init_info.auth_key = na_test_info->key;
     na_init_info.max_contexts = na_test_info->max_contexts;
 
@@ -453,20 +451,20 @@ NA_Test_init(int argc, char *argv[], struct na_test_info *na_test_info)
 
             na_test_set_config(addr_string);
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
             /* If static client must wait for server to write config file */
             if (na_test_info->mpi_static)
                 MPI_Barrier(MPI_COMM_WORLD);
 #endif
 
             /* Used by CTest Test Driver to know when to launch clients */
-            MERCURY_TESTING_READY_MSG();
+            HG_TEST_READY_MSG();
         }
         /* Get config from file if self option is not passed */
         else if (!na_test_info->self_send) {
             char test_addr_name[NA_TEST_MAX_ADDR_NAME] = { '\0' };
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
             /* If static client must wait for server to write config file */
             if (na_test_info->mpi_static)
                 MPI_Barrier(MPI_COMM_WORLD);
@@ -475,7 +473,7 @@ NA_Test_init(int argc, char *argv[], struct na_test_info *na_test_info)
                 na_test_get_config(test_addr_name, NA_TEST_MAX_ADDR_NAME);
             }
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
             /* Broadcast addr name */
             MPI_Bcast(test_addr_name, NA_TEST_MAX_ADDR_NAME, MPI_BYTE, 0,
                 na_test_info->mpi_comm);
@@ -510,7 +508,7 @@ NA_Test_finalize(struct na_test_info *na_test_info)
     free(na_test_info->hostname);
     free(na_test_info->key);
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     na_test_mpi_finalize(na_test_info);
 #endif
 
@@ -522,7 +520,7 @@ done:
 void
 NA_Test_barrier(struct na_test_info *na_test_info)
 {
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     MPI_Barrier(na_test_info->mpi_comm);
 #else
     (void) na_test_info;
@@ -533,7 +531,7 @@ NA_Test_barrier(struct na_test_info *na_test_info)
 void
 NA_Test_bcast(char *buf, int count, int root, struct na_test_info *na_test_info)
 {
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     MPI_Bcast(buf, count, MPI_BYTE, root, na_test_info->mpi_comm);
 #else
     (void) na_test_info;
diff --git a/Testing/na/na_test.h b/Testing/na/na_test.h
index 8290198..67023f7 100644
--- a/Testing/na/na_test.h
+++ b/Testing/na/na_test.h
@@ -15,7 +15,7 @@
 #include "na.h"
 #include "na_error.h"
 
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
 # include <mpi.h>
 #endif
 
@@ -40,7 +40,7 @@ struct na_test_info {
     na_uint8_t max_contexts;    /* Max contexts */
     na_bool_t verbose;          /* Verbose mode */
     int max_number_of_peers;    /* Max number of peers */
-#ifdef MERCURY_HAS_PARALLEL_TESTING
+#ifdef HG_TEST_HAS_PARALLEL
     MPI_Comm mpi_comm;          /* MPI comm */
     na_bool_t mpi_no_finalize;  /* Prevent from finalizing MPI */
 #endif
diff --git a/Testing/na/test_lat_client.c b/Testing/na/test_lat_client.c
index 7ef42b1..cd03c5e 100644
--- a/Testing/na/test_lat_client.c
+++ b/Testing/na/test_lat_client.c
@@ -278,7 +278,7 @@ again:
 
         hg_request_reset(recv_request);
 
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
     /* Check recv buf */
     const char *recv_buf_ptr = (const char*) recv_buf;
 
@@ -294,7 +294,7 @@ again:
 #endif
 
     /* At this point we have received everything so work out the bandwidth */
-#ifdef MERCURY_TESTING_PRINT_PARTIAL
+#ifdef HG_TEST_PRINT_PARTIAL
         read_lat = time_read * 1.0e6
             / (double) ((avg_iter + 1) * 2 *
                 (unsigned int) na_test_lat_info->na_test_info.mpi_comm_size);
@@ -303,7 +303,7 @@ again:
                 NDIGITS, read_lat);
 #endif
     }
-#ifndef MERCURY_TESTING_PRINT_PARTIAL
+#ifndef HG_TEST_PRINT_PARTIAL
     read_lat = time_read * 1.0e6
         / (double) (loop * 2 *
             (unsigned int) na_test_lat_info->na_test_info.mpi_comm_size);
@@ -411,7 +411,7 @@ main(int argc, char *argv[])
         fprintf(stdout, "# %s v%s\n", BENCHMARK_NAME, VERSION_NAME);
         fprintf(stdout, "# Loop %d times from size %d to %zu byte(s)\n",
             na_test_lat_info.na_test_info.loop, 1, max_size);
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
         fprintf(stdout, "# WARNING verifying data, output will be slower\n");
 #endif
         fprintf(stdout, "%-*s%*s\n", 10, "# Size", NWIDTH,
diff --git a/Testing/na/test_lat_server.c b/Testing/na/test_lat_server.c
index cd52b2e..c54f3bb 100644
--- a/Testing/na/test_lat_server.c
+++ b/Testing/na/test_lat_server.c
@@ -112,7 +112,7 @@ na_test_recv_unexpected_cb(const struct na_cb_info *na_cb_info)
     na_return_t ret;
 
     na_test_source_recv_arg->tag = na_cb_info->info.recv_unexpected.tag;
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
     if (na_test_source_recv_arg->tag != NA_TEST_TAG_DONE) {
         /* Check recv buf */
         const char *recv_buf_ptr = (const char*) na_test_source_recv_arg->recv_buf;
diff --git a/Testing/script/travis_build.sh b/Testing/script/travis_build.sh
index 61217bc..1fe5559 100755
--- a/Testing/script/travis_build.sh
+++ b/Testing/script/travis_build.sh
@@ -2,9 +2,8 @@
 
 BMI_VERSION=master
 CMAKE_VERSION_MAJOR=3.16
-CMAKE_VERSION_MINOR=1
+CMAKE_VERSION_MINOR=4
 MPI_VERSION=3.3.2
-CCI_VERSION=2.1
 OFI_VERSION=1.9.0
 PREFIX=$HOME/install
 
@@ -52,16 +51,6 @@ if [[ $TRAVIS_OS_NAME == 'linux' ]]; then
     echo "Using cached directory for MPI";
   fi
 
-  # CCI
-  if [ ! -f "$PREFIX/bin/cci_info" ]; then
-    cd $HOME && wget http://cci-forum.com/wp-content/uploads/2017/05/cci-${CCI_VERSION}.tar.gz
-    tar -xzf cci-${CCI_VERSION}.tar.gz && cd cci-${CCI_VERSION};
-    patch -p1 < ${TRAVIS_BUILD_DIR}/Testing/script/cci_20170918.patch
-    ./configure --disable-silent-rules --disable-static --prefix=$PREFIX && make -j2 -s && make install;
-  else
-    echo "Using cached directory for CCI";
-  fi
-
   # OFI
   if [ -f "$PREFIX/ofi_version.txt" ]; then
     OFI_INSTALLED_VERSION=`cat $PREFIX/ofi_version.txt`;
diff --git a/Testing/script/travis_script.cmake b/Testing/script/travis_script.cmake
index 4a9d46f..391f21a 100644
--- a/Testing/script/travis_script.cmake
+++ b/Testing/script/travis_script.cmake
@@ -54,7 +54,7 @@ set(CTEST_TEST_TIMEOUT 180) # 180s timeout
 set(MERCURY_DO_COVERAGE $ENV{MERCURY_DO_COVERAGE})
 if(MERCURY_DO_COVERAGE)
   message("Enabling Coverage")
-  set(CTEST_COVERAGE_COMMAND "/usr/bin/gcov-8")
+  set(CTEST_COVERAGE_COMMAND "/usr/bin/$ENV{COV}")
   # don't run parallel coverage tests, no matter what.
   set(CTEST_TEST_ARGS PARALLEL_LEVEL 1)
 
@@ -118,14 +118,12 @@ if(APPLE)
   set(PROC_NAME_OPT -c)
   set(USE_BMI OFF)
   set(USE_MPI OFF)
-  set(USE_CCI OFF)
   set(USE_SM OFF)
 else()
   set(SOEXT so)
   set(PROC_NAME_OPT -r)
   set(USE_BMI ON)
   set(USE_MPI ON)
-  set(USE_CCI ON)
   set(USE_SM ON)
   set(CMAKE_FIND_ROOT_PATH $ENV{HOME}/install ${CMAKE_FIND_ROOT_PATH})
 endif()
@@ -147,7 +145,6 @@ MEMORYCHECK_SUPPRESSIONS_FILE:FILEPATH=${CTEST_MEMORYCHECK_SUPPRESSIONS_FILE}
 COVERAGE_COMMAND:FILEPATH=${CTEST_COVERAGE_COMMAND}
 
 MERCURY_ENABLE_COVERAGE:BOOL=${dashboard_do_coverage}
-MERCURY_ENABLE_PARALLEL_TESTING:BOOL=${USE_MPI}
 MERCURY_USE_BOOST_PP:BOOL=OFF
 MERCURY_USE_SELF_FORWARD:BOOL=ON
 MERCURY_USE_XDR:BOOL=OFF
@@ -155,14 +152,16 @@ NA_USE_BMI:BOOL=${USE_BMI}
 BMI_INCLUDE_DIR:PATH=$ENV{HOME}/install/include
 BMI_LIBRARY:FILEPATH=$ENV{HOME}/install/lib/libbmi.${SOEXT}
 NA_USE_MPI:BOOL=${USE_MPI}
-NA_USE_CCI:BOOL=${USE_CCI}
-NA_CCI_TESTING_PROTOCOL:STRING=
+NA_USE_CCI:BOOL=OFF
 NA_USE_SM:BOOL=${USE_SM}
 NA_USE_OFI:BOOL=ON
 NA_OFI_TESTING_PROTOCOL:STRING=sockets;tcp
 MPIEXEC_MAX_NUMPROCS:STRING=4
 
-MERCURY_TEST_INIT_COMMAND:STRING=killall -9 ${PROC_NAME_OPT} hg_test_client;killall -9 ${PROC_NAME_OPT} hg_test_server;
+MERCURY_TESTING_ENABLE_PARALLEL:BOOL=${USE_MPI}
+MERCURY_TESTING_INIT_COMMAND:STRING=killall -9 ${PROC_NAME_OPT} hg_test_server;
+MERCURY_TESTING_BUFFER_SIZE:STRING=1
+MERCURY_TESTING_MAX_HANDLES:STRING=1
 MERCURY_TESTING_CORESIDENT:BOOL=ON
 ")
 
diff --git a/Testing/test_bulk.c b/Testing/test_bulk.c
index 541bae3..cbbb630 100644
--- a/Testing/test_bulk.c
+++ b/Testing/test_bulk.c
@@ -17,7 +17,7 @@
 /* Local Macros */
 /****************/
 
-#define BUFSIZE (MERCURY_TESTING_BUFFER_SIZE * 1024 * 1024)
+#define BUFSIZE (HG_TEST_BUFFER_SIZE * 1024 * 1024)
 
 /************************************/
 /* Local Type and Struct Definition */
@@ -36,7 +36,6 @@ struct forward_cb_args {
 static hg_return_t
 hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info);
 
-
 /*******************/
 /* Local Variables */
 /*******************/
diff --git a/Testing/test_perf.c b/Testing/test_perf.c
index 7da5abe..bc9e2db 100644
--- a/Testing/test_perf.c
+++ b/Testing/test_perf.c
@@ -171,7 +171,7 @@ measure_rpc2(struct hg_test_info *hg_test_info)
     hg_request_t *request;
     struct hg_test_perf_args args;
     double time_read = 0, min_time_read = -1, max_time_read = 0;
-    unsigned int nhandles = MERCURY_TESTING_NUM_THREADS_DEFAULT * 2;
+    unsigned int nhandles = HG_TEST_NUM_THREADS_DEFAULT * 2;
     hg_return_t ret = HG_SUCCESS;
     size_t i;
     unsigned int op_count = 0;
@@ -478,7 +478,7 @@ main(int argc, char *argv[])
 {
     struct hg_test_info hg_test_info = { 0 };
     size_t size_small = 1024; /* Use small values for eager message */
-    size_t size_big = (1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE);
+    size_t size_big = (1024 * 1024 * HG_TEST_BUFFER_SIZE);
 
     HG_Test_init(argc, argv, &hg_test_info);
 
diff --git a/Testing/test_posix.c b/Testing/test_posix.c
index 267cefb..5d40abb 100644
--- a/Testing/test_posix.c
+++ b/Testing/test_posix.c
@@ -350,7 +350,7 @@ main(int argc, char *argv[])
     addr = hg_test_info.target_addr;
     rank = hg_test_info.na_test_info.mpi_comm_rank;
 #endif
-    sprintf(filename, MERCURY_TESTING_TEMP_DIRECTORY "/posix_test%d", rank);
+    sprintf(filename, HG_TEST_TEMP_DIRECTORY "/posix_test%d", rank);
 
     /* Prepare buffers */
     write_buf = (int*) malloc(sizeof(int) * n_ints);
diff --git a/Testing/test_read_bw.c b/Testing/test_read_bw.c
index 37a5648..b2c7727 100644
--- a/Testing/test_read_bw.c
+++ b/Testing/test_read_bw.c
@@ -15,26 +15,32 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+/****************/
+/* Local Macros */
+/****************/
+
 #define BENCHMARK_NAME "Read BW (server bulk push)"
 #define STRING(s) #s
 #define XSTRING(s) STRING(s)
-#define VERSION_NAME \
-    XSTRING(HG_VERSION_MAJOR) \
-    "." \
-    XSTRING(HG_VERSION_MINOR) \
-    "." \
+#define VERSION_NAME            \
+    XSTRING(HG_VERSION_MAJOR)   \
+    "."                         \
+    XSTRING(HG_VERSION_MINOR)   \
+    "."                         \
     XSTRING(HG_VERSION_PATCH)
 
-#define SMALL_SKIP 20
-#define LARGE_SKIP 10
-#define LARGE_SIZE 8192
+#define SMALL_SKIP      20
+#define LARGE_SKIP      10
+#define LARGE_SIZE      8192
 
-#define NDIGITS 2
-#define NWIDTH 20
-#define MAX_MSG_SIZE (MERCURY_TESTING_BUFFER_SIZE * 1024 * 1024)
-#define MAX_HANDLES 16
+#define NDIGITS         2
+#define NWIDTH          20
+#define MAX_MSG_SIZE    (HG_TEST_BUFFER_SIZE * 1024 * 1024)
+#define MAX_HANDLES     (HG_TEST_MAX_HANDLES)
 
-extern hg_id_t hg_test_perf_bulk_read_id_g;
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
 
 struct hg_test_perf_args {
     hg_request_t *request;
@@ -42,6 +48,23 @@ struct hg_test_perf_args {
     hg_atomic_int32_t op_completed_count;
 };
 
+/********************/
+/* Local Prototypes */
+/********************/
+
+static hg_return_t
+hg_test_perf_forward_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
+    unsigned int nhandles);
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+extern hg_id_t hg_test_perf_bulk_read_id_g;
+
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -49,13 +72,13 @@ hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
         (struct hg_test_perf_args *) callback_info->arg;
 
     if ((unsigned int) hg_atomic_incr32(&args->op_completed_count)
-        == args->op_count) {
+        == args->op_count)
         hg_request_complete(args->request);
-    }
 
     return HG_SUCCESS;
 }
 
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
     unsigned int nhandles)
@@ -80,6 +103,8 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Prepare bulk_buf */
     bulk_buf = malloc(nbytes);
+    HG_TEST_CHECK_ERROR(bulk_buf == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate bulk buf");
     for (i = 0; i < nbytes; i++)
         bulk_buf[i] = 1;
     buf_ptrs = (void **) &bulk_buf;
@@ -87,13 +112,14 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Create handles */
     handles = malloc(nhandles * sizeof(hg_handle_t));
+    HG_TEST_CHECK_ERROR(handles == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate handles");
+
     for (i = 0; i < nhandles; i++) {
         ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
             hg_test_perf_bulk_read_id_g, &handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not start call\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     request = hg_request_create(hg_test_info->request_class);
@@ -104,10 +130,8 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
     /* Register memory */
     ret = HG_Bulk_create(hg_test_info->hg_class, 1, buf_ptrs,
         (hg_size_t *) buf_sizes, HG_BULK_READWRITE, &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     in_struct.fildes = 0;
@@ -118,11 +142,10 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         unsigned int j;
 
         for (j = 0; j < nhandles; j++) {
-            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args, &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
-            }
+            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
+                &in_struct);
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -140,11 +163,10 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         hg_time_get_current(&t1);
 
         for (j = 0; j < nhandles; j++) {
-            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args, &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
-            }
+            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
+                &in_struct);
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -155,7 +177,7 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         hg_request_reset(request);
         hg_atomic_set32(&args.op_completed_count, 0);
 
-#ifdef MERCURY_TESTING_PRINT_PARTIAL
+#ifdef HG_TEST_PRINT_PARTIAL
         read_bandwidth = nmbytes
             * (double) (nhandles * (avg_iter + 1) *
                 (unsigned int) hg_test_info->na_test_info.mpi_comm_size)
@@ -166,7 +188,7 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
             fprintf(stdout, "%-*d%*.*f\r", 10, (int) nbytes, NWIDTH,
                 NDIGITS, read_bandwidth);
 #endif
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
         for (i = 0; i < nbytes; i++) {
             if (bulk_buf[i] != (char) i) {
                 printf("Error detected in bulk transfer, buf[%d] = %d, "
@@ -177,7 +199,7 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         }
 #endif
     }
-#ifndef MERCURY_TESTING_PRINT_PARTIAL
+#ifndef HG_TEST_PRINT_PARTIAL
     read_bandwidth = nmbytes
         * (double) (nhandles * loop *
             (unsigned int) hg_test_info->na_test_info.mpi_comm_size)
@@ -192,19 +214,15 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Complete */
     hg_request_destroy(request);
     for (i = 0; i < nhandles; i++) {
         ret = HG_Destroy(handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not complete\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
 done:
@@ -220,8 +238,12 @@ main(int argc, char *argv[])
     struct hg_test_info hg_test_info = { 0 };
     unsigned int nhandles;
     size_t size;
+    hg_return_t hg_ret;
+    int ret = EXIT_SUCCESS;
 
-    HG_Test_init(argc, argv, &hg_test_info);
+    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
     for (nhandles = 1; nhandles <= MAX_HANDLES; nhandles *= 2) {
         if (hg_test_info.na_test_info.mpi_comm_rank == 0) {
@@ -229,7 +251,7 @@ main(int argc, char *argv[])
             fprintf(stdout, "# Loop %d times from size %d to %d byte(s) with "
                 "%u handle(s)\n",
                 hg_test_info.na_test_info.loop, 1, MAX_MSG_SIZE, nhandles);
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
             fprintf(stdout, "# WARNING verifying data, output will be slower\n");
 #endif
             fprintf(stdout, "%-*s%*s\n", 10, "# Size", NWIDTH,
@@ -237,13 +259,18 @@ main(int argc, char *argv[])
             fflush(stdout);
         }
 
-        for (size = 1; size <= MAX_MSG_SIZE; size *= 2)
-            measure_bulk_transfer(&hg_test_info, size, nhandles);
+        for (size = 1; size <= MAX_MSG_SIZE; size *= 2) {
+            hg_ret = measure_bulk_transfer(&hg_test_info, size, nhandles);
+            HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+                "measure_bulk_transfer() failed");
+        }
 
         fprintf(stdout, "\n");
     }
 
-    HG_Test_finalize(&hg_test_info);
+done:
+    hg_ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
 
-    return EXIT_SUCCESS;
+    return ret;
 }
diff --git a/Testing/test_rpc.c b/Testing/test_rpc.c
index 2146b0e..04f597a 100644
--- a/Testing/test_rpc.c
+++ b/Testing/test_rpc.c
@@ -9,7 +9,6 @@
  */
 
 #include "mercury_test.h"
-#include "mercury_hl.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -18,7 +17,7 @@
 /* Local Macros */
 /****************/
 
-#define NINFLIGHT 32
+#define NINFLIGHT   (HG_TEST_MAX_HANDLES)
 
 /************************************/
 /* Local Type and Struct Definition */
@@ -29,6 +28,11 @@ struct forward_cb_args {
     rpc_handle_t *rpc_handle;
 };
 
+struct lookup_cb_args {
+    hg_request_t *request;
+    hg_addr_t *addr_ptr;
+};
+
 /********************/
 /* Local Prototypes */
 /********************/
@@ -38,6 +42,8 @@ hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info);
 static hg_return_t
 hg_test_rpc_forward_no_resp_cb(const struct hg_cb_info *callback_info);
 static hg_return_t
+hg_test_rpc_lookup_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
 hg_test_rpc_forward_reset_cb(const struct hg_cb_info *callback_info);
 static hg_return_t
 hg_test_rpc_forward_overflow_cb(const struct hg_cb_info *callback_info);
@@ -64,7 +70,6 @@ static hg_return_t
 hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
 
-
 /*******************/
 /* Local Variables */
 /*******************/
@@ -132,6 +137,20 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
+hg_test_rpc_lookup_cb(const struct hg_cb_info *callback_info)
+{
+    struct lookup_cb_args *request_args =
+        (struct lookup_cb_args *) callback_info->arg;
+
+    *request_args->addr_ptr = callback_info->info.lookup.addr;
+
+    hg_request_complete(request_args->request);
+
+    return HG_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
 hg_test_rpc_forward_reset_cb(const struct hg_cb_info *callback_info)
 {
     struct forward_cb_args *args = (struct forward_cb_args *) callback_info->arg;
@@ -210,7 +229,7 @@ hg_test_rpc(hg_context_t *context, hg_request_class_t *request_class,
     hg_handle_t handle = HG_HANDLE_NULL;
     hg_return_t ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    hg_const_string_t rpc_open_path = HG_TEST_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
     rpc_open_in_t rpc_open_in_struct;
 
@@ -263,21 +282,36 @@ hg_test_rpc_lookup(hg_context_t *context, hg_request_class_t *request_class,
     hg_handle_t handle = HG_HANDLE_NULL;
     hg_return_t ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    hg_const_string_t rpc_open_path = HG_TEST_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
     rpc_open_in_t rpc_open_in_struct;
     hg_addr_t target_addr = HG_ADDR_NULL;
     int i;
 
     for (i = 0; i < 32; i++) {
+        struct lookup_cb_args lookup_args;
+        unsigned int flag = 0;
+
         request = hg_request_create(request_class);
 
         /* Look up target addr using target name info */
-        ret = HG_Hl_addr_lookup_wait(context, request_class, target_name,
-            &target_addr, HG_MAX_IDLE_TIME);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_addr_lookup_wait() failed (%s)",
+        lookup_args.addr_ptr = &target_addr;
+        lookup_args.request = request;
+
+        /* Forward call to remote addr and get a new request */
+        ret = HG_Addr_lookup(context, hg_test_rpc_lookup_cb,
+            &lookup_args, target_name, HG_OP_ID_IGNORE);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_lookup() failed (%s)",
             HG_Error_to_string(ret));
 
+        /* Wait for request to be marked completed */
+        hg_request_wait(request, HG_MAX_IDLE_TIME, &flag);
+        HG_TEST_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
+            "Operation did not complete");
+
+        /* Reset request */
+        hg_request_reset(request);
+
         /* Create RPC request */
         ret = HG_Create(context, target_addr, rpc_id, &handle);
         HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
@@ -332,7 +366,7 @@ hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
     hg_handle_t handle = HG_HANDLE_NULL;
     hg_return_t ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    hg_const_string_t rpc_open_path = HG_TEST_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
     rpc_open_in_t rpc_open_in_struct;
 
@@ -383,7 +417,7 @@ hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
     hg_handle_t handle = HG_HANDLE_NULL;
     hg_return_t ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    hg_const_string_t rpc_open_path = HG_TEST_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
     rpc_open_in_t  rpc_open_in_struct;
 
@@ -434,7 +468,7 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     struct forward_cb_args forward_cb_args1, forward_cb_args2;
     hg_return_t ret = HG_SUCCESS;
     rpc_open_in_t rpc_open_in_struct;
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    hg_const_string_t rpc_open_path = HG_TEST_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle1, rpc_open_handle2;
     /* Used for multiple in-flight RPCs */
     hg_request_t *request_m[NINFLIGHT];
@@ -526,8 +560,13 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
         HG_TEST_LOG_DEBUG(" %d Forwarding rpc_open, op id: %u...", i, rpc_id);
         forward_cb_args_m[i].request = request_m[i];
         forward_cb_args_m[i].rpc_handle = &rpc_open_handle_m[i];
+again:
         ret = HG_Forward(handle_m[i], callback, &forward_cb_args_m[i],
             &rpc_open_in_struct);
+        if (ret == HG_AGAIN) {
+            hg_request_wait(request_m[i], 0, NULL);
+            goto again;
+        }
         HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
             HG_Error_to_string(ret));
     }
@@ -648,6 +687,10 @@ main(int argc, char *argv[])
     /* RPC test with lookup/free */
     if (!hg_test_info.na_test_info.self_send &&
         strcmp(HG_Class_get_name(hg_test_info.hg_class), "mpi")) {
+        hg_request_t *request = NULL;
+        struct lookup_cb_args lookup_args;
+        unsigned int flag = 0;
+
         HG_Addr_free(hg_test_info.hg_class, hg_test_info.target_addr);
         hg_test_info.target_addr = HG_ADDR_NULL;
 
@@ -659,12 +702,26 @@ main(int argc, char *argv[])
             "lookup test failed");
         HG_PASSED();
 
+        request = hg_request_create(hg_test_info.request_class);
+
         /* Look up target addr using target name info */
-        hg_ret = HG_Hl_addr_lookup_wait(hg_test_info.context,
-            hg_test_info.request_class, hg_test_info.na_test_info.target_name,
-            &hg_test_info.target_addr, HG_MAX_IDLE_TIME);
+        lookup_args.addr_ptr = &hg_test_info.target_addr;
+        lookup_args.request = request;
+
+        /* Forward call to remote addr and get a new request */
+        hg_ret = HG_Addr_lookup(hg_test_info.context, hg_test_rpc_lookup_cb,
+            &lookup_args, hg_test_info.na_test_info.target_name,
+            HG_OP_ID_IGNORE);
         HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-            "HG_Hl_addr_lookup_wait() failed (%s)", HG_Error_to_string(hg_ret));
+            "HG_Addr_lookup() failed (%s)", HG_Error_to_string(hg_ret));
+
+        /* Wait for request to be marked completed */
+        hg_request_wait(request, HG_MAX_IDLE_TIME, &flag);
+        HG_TEST_CHECK_ERROR(flag == 0, done, ret, EXIT_FAILURE,
+            "Operation did not complete");
+
+        /* Destroy request */
+        hg_request_destroy(request);
     }
 
     /* RPC reset test */
@@ -710,18 +767,20 @@ main(int argc, char *argv[])
         "unregistered RPC test failed");
     HG_PASSED();
 
-    /* RPC test with invalid ID (not registered on server) */
-    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "inv_id", void, void,
-        NULL);
-    HG_TEST_CHECK_ERROR(inv_id == 0, done, ret, EXIT_FAILURE,
-        "HG_Register() failed");
-
-    HG_TEST("invalid RPC");
-    hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
-        hg_test_info.target_addr, inv_id, hg_test_rpc_forward_cb);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "invalid RPC test failed");
-    HG_PASSED();
+    if (!hg_test_info.na_test_info.self_send) {
+        /* RPC test with invalid ID (not registered on server) */
+        inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "inv_id", void, void,
+            NULL);
+        HG_TEST_CHECK_ERROR(inv_id == 0, done, ret, EXIT_FAILURE,
+            "HG_Register() failed");
+
+        HG_TEST("invalid RPC");
+        hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
+            hg_test_info.target_addr, inv_id, hg_test_rpc_forward_cb);
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "invalid RPC test failed");
+        HG_PASSED();
+    }
 
     /* RPC test with reset */
     HG_TEST("reset RPC");
diff --git a/Testing/test_rpc.h b/Testing/test_rpc.h
index 6f14eaa..9f457b7 100644
--- a/Testing/test_rpc.h
+++ b/Testing/test_rpc.h
@@ -134,7 +134,7 @@ hg_proc_perf_rpc_lat_in_t(hg_proc_t proc, void *data)
                 return ret;
         }
 
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
         if (hg_proc_get_op(proc) == HG_DECODE) {
             hg_size_t i;
             char *buf_ptr = struct_data->buf;
diff --git a/Testing/test_rpc_lat.c b/Testing/test_rpc_lat.c
index 2ddc1bc..9e7a04f 100644
--- a/Testing/test_rpc_lat.c
+++ b/Testing/test_rpc_lat.c
@@ -15,27 +15,32 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+/****************/
+/* Local Macros */
+/****************/
+
 #define BENCHMARK_NAME "RPC latency"
 #define STRING(s) #s
 #define XSTRING(s) STRING(s)
-#define VERSION_NAME \
-    XSTRING(HG_VERSION_MAJOR) \
-    "." \
-    XSTRING(HG_VERSION_MINOR) \
-    "." \
+#define VERSION_NAME            \
+    XSTRING(HG_VERSION_MAJOR)   \
+    "."                         \
+    XSTRING(HG_VERSION_MINOR)   \
+    "."                         \
     XSTRING(HG_VERSION_PATCH)
 
-#define SMALL_SKIP 100
-#define LARGE_SKIP 10
-#define LARGE_SIZE 8192
+#define SMALL_SKIP      100
+#define LARGE_SKIP      10
+#define LARGE_SIZE      8192
 
-#define NDIGITS 2
-#define NWIDTH 20
-#define MAX_MSG_SIZE (MERCURY_TESTING_BUFFER_SIZE * 1024 * 1024)
-#define MAX_HANDLES 16
+#define NDIGITS         2
+#define NWIDTH          20
+#define MAX_MSG_SIZE    (HG_TEST_BUFFER_SIZE * 1024 * 1024)
+#define MAX_HANDLES     (HG_TEST_MAX_HANDLES)
 
-extern hg_id_t hg_test_perf_rpc_id_g;
-extern hg_id_t hg_test_perf_rpc_lat_id_g;
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
 
 struct hg_test_perf_args {
     hg_request_t *request;
@@ -43,6 +48,24 @@ struct hg_test_perf_args {
     hg_atomic_int32_t op_completed_count;
 };
 
+/********************/
+/* Local Prototypes */
+/********************/
+
+static hg_return_t
+hg_test_perf_forward_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
+    unsigned int nhandles);
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+extern hg_id_t hg_test_perf_rpc_id_g;
+extern hg_id_t hg_test_perf_rpc_lat_id_g;
+
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -50,13 +73,13 @@ hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
         (struct hg_test_perf_args *) callback_info->arg;
 
     if ((unsigned int) hg_atomic_incr32(&args->op_completed_count)
-        == args->op_count) {
+        == args->op_count)
         hg_request_complete(args->request);
-    }
 
     return HG_SUCCESS;
 }
 
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
     unsigned int nhandles)
@@ -115,8 +138,13 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
         unsigned int j;
 
         for (j = 0; j < nhandles; j++) {
+again:
             ret = HG_Forward(handles[j], hg_test_perf_forward_cb,
                 &args, &in_struct);
+            if (ret == HG_AGAIN) {
+                hg_request_wait(request, 0, NULL);
+                goto again;
+            }
             HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
                 HG_Error_to_string(ret));
         }
@@ -159,7 +187,7 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
         hg_atomic_set32(&args.op_completed_count, 0);
 
 	/* We have received everything so calculate the bandwidth */
-#ifdef MERCURY_TESTING_PRINT_PARTIAL
+#ifdef HG_TEST_PRINT_PARTIAL
         read_lat = time_read * 1.0e6 / (double) (nhandles * (avg_iter + 1) *
             (unsigned int) hg_test_info->na_test_info.mpi_comm_size);
         if (hg_test_info->na_test_info.mpi_comm_rank == 0)
@@ -167,7 +195,7 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
                 NDIGITS, (read_lat), NWIDTH, (int) (1.0e6 / read_lat));
 #endif
     }
-#ifndef MERCURY_TESTING_PRINT_PARTIAL
+#ifndef HG_TEST_PRINT_PARTIAL
     read_lat = time_read * 1.0e6 / (double) (nhandles * loop *
         (unsigned int) hg_test_info->na_test_info.mpi_comm_size);
     if (hg_test_info->na_test_info.mpi_comm_rank == 0)
@@ -190,7 +218,7 @@ done:
     return ret;
 }
 
-/*****************************************************************************/
+/*---------------------------------------------------------------------------*/
 int
 main(int argc, char *argv[])
 {
@@ -210,7 +238,7 @@ main(int argc, char *argv[])
             fprintf(stdout, "# Loop %d times from size %d to %d byte(s) with "
                 "%u handle(s)\n",
                 hg_test_info.na_test_info.loop, 1, MAX_MSG_SIZE, nhandles);
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
             fprintf(stdout, "# WARNING verifying data, output will be slower\n");
 #endif
             fprintf(stdout, "%-*s%*s%*s\n", 10, "# Size", NWIDTH,
diff --git a/Testing/test_server.c b/Testing/test_server.c
index 8023c04..b210bcc 100644
--- a/Testing/test_server.c
+++ b/Testing/test_server.c
@@ -13,12 +13,46 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+/****************/
+/* Local Macros */
+/****************/
+
 #define HG_TEST_PROGRESS_TIMEOUT    100
 #define HG_TEST_TRIGGER_TIMEOUT     HG_MAX_IDLE_TIME
 
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+struct hg_test_worker {
+    struct hg_thread_work thread_work;
+    hg_class_t *hg_class;
+    hg_context_t *context;
+    hg_uint8_t context_id;
+};
+#endif
+
+/********************/
+/* Local Prototypes */
+/********************/
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+static HG_INLINE HG_THREAD_RETURN_TYPE
+hg_test_progress_thread(void *arg);
 static HG_INLINE HG_THREAD_RETURN_TYPE
-hg_progress_thread(void *arg)
+hg_test_progress_work(void *arg);
+#endif
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+/*---------------------------------------------------------------------------*/
+#ifdef HG_TEST_HAS_THREAD_POOL
+
+static HG_INLINE HG_THREAD_RETURN_TYPE
+hg_test_progress_thread(void *arg)
 {
     hg_context_t *context = (hg_context_t *) arg;
     struct hg_test_context_info *hg_test_context_info =
@@ -32,27 +66,57 @@ hg_progress_thread(void *arg)
 
         ret = HG_Progress(context, HG_TEST_PROGRESS_TIMEOUT);
     } while (ret == HG_SUCCESS || ret == HG_TIMEOUT);
+    HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        tret, (HG_THREAD_RETURN_TYPE) 0, "HG_Progress() failed (%s)",
+        HG_Error_to_string(ret));
 
+done:
     printf("Exiting\n");
     hg_thread_exit(tret);
     return tret;
 }
 
+/*---------------------------------------------------------------------------*/
 static HG_INLINE HG_THREAD_RETURN_TYPE
-hg_progress_work(void *arg)
+hg_test_progress_work(void *arg)
 {
-    hg_context_t *context = (hg_context_t *) arg;
-    struct hg_test_context_info *hg_test_context_info =
-        (struct hg_test_context_info *) HG_Context_get_data(context);
+    struct hg_test_worker *worker = (struct hg_test_worker *) arg;
+    hg_context_t *context = NULL;
+    struct hg_test_context_info *hg_test_context_info = NULL;
     HG_THREAD_RETURN_TYPE tret = (HG_THREAD_RETURN_TYPE) 0;
     hg_return_t ret = HG_SUCCESS;
 
+    if (!worker->context) {
+        HG_TEST_LOG_DEBUG("Creating context with ID %d",
+            (int) worker->context_id);
+        context = HG_Context_create_id(worker->hg_class, worker->context_id);
+        HG_TEST_CHECK_ERROR(context == NULL, done, ret, HG_FAULT,
+            "HG_Context_create_id() failed");
+
+        /* Attach context info to context */
+        hg_test_context_info = malloc(sizeof(struct hg_test_context_info));
+        HG_TEST_CHECK_ERROR(hg_test_context_info == NULL, done, ret,
+            HG_NOMEM_ERROR, "Could not allocate HG test context info");
+
+        hg_atomic_init32(&hg_test_context_info->finalizing, 0);
+        ret = HG_Context_set_data(context, hg_test_context_info, free);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_set_data() failed"
+            " (%s)", HG_Error_to_string(ret));
+    } else {
+        context = worker->context;
+        hg_test_context_info =
+            (struct hg_test_context_info *) HG_Context_get_data(context);
+    }
+
     do {
         unsigned int actual_count = 0;
 
         do {
             ret = HG_Trigger(context, 0, 1, &actual_count);
         } while ((ret == HG_SUCCESS) && actual_count);
+        HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+            tret, (HG_THREAD_RETURN_TYPE) 0, "HG_Trigger() failed (%s)",
+            HG_Error_to_string(ret));
 
         if (hg_atomic_get32(&hg_test_context_info->finalizing)) {
             /* Make sure everything was progressed/triggered */
@@ -66,20 +130,28 @@ hg_progress_work(void *arg)
         /* Use same value as HG_TEST_TRIGGER_TIMEOUT for convenience */
         ret = HG_Progress(context, HG_TEST_TRIGGER_TIMEOUT);
     } while (ret == HG_SUCCESS || ret == HG_TIMEOUT);
+    HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        tret, (HG_THREAD_RETURN_TYPE) 0, "HG_Progress() failed (%s)",
+        HG_Error_to_string(ret));
+
+    if (!worker->context) {
+        ret = HG_Context_destroy(context);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_destroy() failed"
+            " (%s)", HG_Error_to_string(ret));
+    }
 
+done:
     return tret;
 }
 #endif
 
-/**
- *
- */
+/*---------------------------------------------------------------------------*/
 int
 main(int argc, char *argv[])
 {
     struct hg_test_info hg_test_info = { 0 };
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
-    struct hg_thread_work *progress_workers = NULL;
+#ifdef HG_TEST_HAS_THREAD_POOL
+    struct hg_test_worker *progress_workers = NULL;
 #endif
     struct hg_test_context_info *hg_test_context_info;
     hg_return_t ret = HG_SUCCESS;
@@ -88,53 +160,70 @@ main(int argc, char *argv[])
     /* Force to listen */
     hg_test_info.na_test_info.listen = NA_TRUE;
     ret = HG_Test_init(argc, argv, &hg_test_info);
-    if (ret != HG_SUCCESS) {
-        rc = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(ret != HG_SUCCESS, done, rc, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
-    hg_test_context_info =
-        (struct hg_test_context_info *) HG_Context_get_data(
-            hg_test_info.context);
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
-    if (!hg_test_info.secondary_contexts) {
+    hg_test_context_info = (struct hg_test_context_info *) HG_Context_get_data(
+        hg_test_info.context);
+
+#ifdef HG_TEST_HAS_THREAD_POOL
+    if (hg_test_info.na_test_info.max_contexts > 1) {
+        hg_uint8_t context_count = (hg_uint8_t)
+            (hg_test_info.na_test_info.max_contexts);
+        hg_uint8_t i;
+
+        progress_workers = malloc(
+            sizeof(struct hg_test_worker) * context_count);
+        HG_TEST_CHECK_ERROR(progress_workers == NULL, done, rc, EXIT_FAILURE,
+            "Could not allocate progress_workers");
+
+        progress_workers[0].thread_work.func = hg_test_progress_work;
+        progress_workers[0].thread_work.args = &progress_workers[0];
+        progress_workers[0].hg_class = hg_test_info.hg_class;
+        progress_workers[0].context = hg_test_info.context;
+        progress_workers[0].context_id = 0;
+
+        for (i = 0; i < context_count - 1; i++) {
+            progress_workers[i + 1].thread_work.func = hg_test_progress_work;
+            progress_workers[i + 1].thread_work.args = &progress_workers[i + 1];
+            progress_workers[i + 1].hg_class = hg_test_info.hg_class;
+            progress_workers[i + 1].context = NULL;
+            progress_workers[i + 1].context_id = (hg_uint8_t) (i + 1);
+
+            hg_thread_pool_post(hg_test_info.thread_pool,
+                &progress_workers[i + 1].thread_work);
+        }
+        /* Use main thread for progress on main context */
+        hg_test_progress_work(&progress_workers[0]);
+    } else {
         hg_thread_t progress_thread;
 
-        hg_thread_create(&progress_thread, hg_progress_thread, hg_test_info.context);
+        hg_thread_create(&progress_thread, hg_test_progress_thread,
+            hg_test_info.context);
 
         do {
             if (hg_atomic_get32(&hg_test_context_info->finalizing))
                 break;
 
-            ret = HG_Trigger(hg_test_info.context, HG_TEST_TRIGGER_TIMEOUT, 1, NULL);
+            ret = HG_Trigger(hg_test_info.context, HG_TEST_TRIGGER_TIMEOUT, 1,
+                NULL);
         } while (ret == HG_SUCCESS || ret == HG_TIMEOUT);
+        HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+            rc, EXIT_FAILURE, "HG_Trigger() failed (%s)",
+            HG_Error_to_string(ret));
 
         hg_thread_join(progress_thread);
-    } else {
-        hg_uint8_t context_count = (hg_uint8_t)
-            (hg_test_info.na_test_info.max_contexts);
-        hg_uint8_t i;
-
-        progress_workers = malloc(sizeof(struct hg_thread_work) * context_count);
-        progress_workers[0].func = hg_progress_work;
-        progress_workers[0].args = hg_test_info.context;
-        hg_thread_pool_post(hg_test_info.thread_pool, &progress_workers[0]);
-        for (i = 0; i < context_count - 1; i++) {
-            progress_workers[i + 1].func = hg_progress_work;
-            progress_workers[i + 1].args = hg_test_info.secondary_contexts[i];
-            hg_thread_pool_post(hg_test_info.thread_pool, &progress_workers[i + 1]);
-        }
     }
 #else
-    if (hg_test_info.secondary_contexts)
-        HG_TEST_LOG_WARNING("Secondary contexts only supported with thread pool");
-
     do {
         unsigned int actual_count = 0;
 
         do {
             ret = HG_Trigger(hg_test_info.context, 0, 1, &actual_count);
         } while ((ret == HG_SUCCESS) && actual_count);
+        HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+            rc, EXIT_FAILURE, "HG_Trigger() failed (%s)",
+            HG_Error_to_string(ret));
 
         if (hg_atomic_get32(&hg_test_context_info->finalizing))
             break;
@@ -142,11 +231,16 @@ main(int argc, char *argv[])
         /* Use same value as HG_TEST_TRIGGER_TIMEOUT for convenience */
         ret = HG_Progress(hg_test_info.context, HG_TEST_TRIGGER_TIMEOUT);
     } while (ret == HG_SUCCESS || ret == HG_TIMEOUT);
+    HG_TEST_CHECK_ERROR(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        rc, EXIT_FAILURE, "HG_Progress() failed (%s)",
+        HG_Error_to_string(ret));
 #endif
 
 done:
-    HG_Test_finalize(&hg_test_info);
-#ifdef MERCURY_TESTING_HAS_THREAD_POOL
+    ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Test_finalize() failed");
+
+#ifdef HG_TEST_HAS_THREAD_POOL
     free(progress_workers);
 #endif
 
diff --git a/Testing/test_write_bw.c b/Testing/test_write_bw.c
index 7c38896..3b0ea6c 100644
--- a/Testing/test_write_bw.c
+++ b/Testing/test_write_bw.c
@@ -15,26 +15,32 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+/****************/
+/* Local Macros */
+/****************/
+
 #define BENCHMARK_NAME "Write BW (server bulk pull)"
 #define STRING(s) #s
 #define XSTRING(s) STRING(s)
-#define VERSION_NAME \
-    XSTRING(HG_VERSION_MAJOR) \
-    "." \
-    XSTRING(HG_VERSION_MINOR) \
-    "." \
+#define VERSION_NAME            \
+    XSTRING(HG_VERSION_MAJOR)   \
+    "."                         \
+    XSTRING(HG_VERSION_MINOR)   \
+    "."                         \
     XSTRING(HG_VERSION_PATCH)
 
-#define SMALL_SKIP 20
-#define LARGE_SKIP 10
-#define LARGE_SIZE 8192
+#define SMALL_SKIP      20
+#define LARGE_SKIP      10
+#define LARGE_SIZE      8192
 
-#define NDIGITS 2
-#define NWIDTH 20
-#define MAX_MSG_SIZE (MERCURY_TESTING_BUFFER_SIZE * 1024 * 1024)
-#define MAX_HANDLES 16
+#define NDIGITS         2
+#define NWIDTH          20
+#define MAX_MSG_SIZE    (HG_TEST_BUFFER_SIZE * 1024 * 1024)
+#define MAX_HANDLES     (HG_TEST_MAX_HANDLES)
 
-extern hg_id_t hg_test_perf_bulk_write_id_g;
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
 
 struct hg_test_perf_args {
     hg_request_t *request;
@@ -42,6 +48,20 @@ struct hg_test_perf_args {
     hg_atomic_int32_t op_completed_count;
 };
 
+/********************/
+/* Local Prototypes */
+/********************/
+
+static hg_return_t
+hg_test_perf_forward_cb(const struct hg_cb_info *callback_info);
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+extern hg_id_t hg_test_perf_bulk_write_id_g;
+
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -49,13 +69,13 @@ hg_test_perf_forward_cb(const struct hg_cb_info *callback_info)
         (struct hg_test_perf_args *) callback_info->arg;
 
     if ((unsigned int) hg_atomic_incr32(&args->op_completed_count)
-        == args->op_count) {
+        == args->op_count)
         hg_request_complete(args->request);
-    }
 
     return HG_SUCCESS;
 }
 
+/*---------------------------------------------------------------------------*/
 static hg_return_t
 measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
     unsigned int nhandles)
@@ -80,6 +100,8 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Prepare bulk_buf */
     bulk_buf = malloc(nbytes);
+    HG_TEST_CHECK_ERROR(bulk_buf == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate bulk buf");
     for (i = 0; i < nbytes; i++)
         bulk_buf[i] = (char) i;
     buf_ptrs = (void **) &bulk_buf;
@@ -87,13 +109,14 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Create handles */
     handles = malloc(nhandles * sizeof(hg_handle_t));
+    HG_TEST_CHECK_ERROR(handles == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate handles");
+
     for (i = 0; i < nhandles; i++) {
         ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
             hg_test_perf_bulk_write_id_g, &handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not start call\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     request = hg_request_create(hg_test_info->request_class);
@@ -104,10 +127,8 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
     /* Register memory */
     ret = HG_Bulk_create(hg_test_info->hg_class, 1, buf_ptrs,
         (hg_size_t *) buf_sizes, HG_BULK_READ_ONLY, &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     in_struct.fildes = 0;
@@ -118,11 +139,15 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         unsigned int j;
 
         for (j = 0; j < nhandles; j++) {
-            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args, &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
+again:
+            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
+                &in_struct);
+            if (ret == HG_AGAIN) {
+                hg_request_wait(request, 0, NULL);
+                goto again;
             }
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -140,11 +165,18 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         hg_time_get_current(&t1);
 
         for (j = 0; j < nhandles; j++) {
-            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args, &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
+            /* Assign handles to multiple targets */
+            if (hg_test_info->na_test_info.max_contexts > 1) {
+                ret = HG_Set_target_id(handles[j],
+                    (hg_uint8_t) (avg_iter % hg_test_info->na_test_info.max_contexts));
+                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+                    HG_Error_to_string(ret));
             }
+
+            ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
+                &in_struct);
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -155,7 +187,7 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
         hg_request_reset(request);
         hg_atomic_set32(&args.op_completed_count, 0);
 
-#ifdef MERCURY_TESTING_PRINT_PARTIAL
+#ifdef HG_TEST_PRINT_PARTIAL
         read_bandwidth = nmbytes
             * (double) (nhandles * (avg_iter + 1) *
                 (unsigned int) hg_test_info->na_test_info.mpi_comm_size)
@@ -167,7 +199,7 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
                 NDIGITS, read_bandwidth);
 #endif
     }
-#ifndef MERCURY_TESTING_PRINT_PARTIAL
+#ifndef HG_TEST_PRINT_PARTIAL
     read_bandwidth = nmbytes
         * (double) (nhandles * loop *
             (unsigned int) hg_test_info->na_test_info.mpi_comm_size)
@@ -182,19 +214,15 @@ measure_bulk_transfer(struct hg_test_info *hg_test_info, size_t total_size,
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Complete */
     hg_request_destroy(request);
     for (i = 0; i < nhandles; i++) {
         ret = HG_Destroy(handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not complete\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
 done:
@@ -203,15 +231,19 @@ done:
     return ret;
 }
 
-/*****************************************************************************/
+/*---------------------------------------------------------------------------*/
 int
 main(int argc, char *argv[])
 {
     struct hg_test_info hg_test_info = { 0 };
     unsigned int nhandles;
     size_t size;
+    hg_return_t hg_ret;
+    int ret = EXIT_SUCCESS;
 
-    HG_Test_init(argc, argv, &hg_test_info);
+    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
     for (nhandles = 1; nhandles <= MAX_HANDLES; nhandles *= 2) {
         if (hg_test_info.na_test_info.mpi_comm_rank == 0) {
@@ -219,7 +251,7 @@ main(int argc, char *argv[])
             fprintf(stdout, "# Loop %d times from size %d to %d byte(s) with "
                 "%u handle(s)\n",
                 hg_test_info.na_test_info.loop, 1, MAX_MSG_SIZE, nhandles);
-#ifdef MERCURY_TESTING_HAS_VERIFY_DATA
+#ifdef HG_TEST_HAS_VERIFY_DATA
             fprintf(stdout, "# WARNING verifying data, output will be slower\n");
 #endif
             fprintf(stdout, "%-*s%*s\n", 10, "# Size", NWIDTH,
@@ -227,13 +259,18 @@ main(int argc, char *argv[])
             fflush(stdout);
         }
 
-        for (size = 1; size <= MAX_MSG_SIZE; size *= 2)
-            measure_bulk_transfer(&hg_test_info, size, nhandles);
+        for (size = 1; size <= MAX_MSG_SIZE; size *= 2) {
+            hg_ret = measure_bulk_transfer(&hg_test_info, size, nhandles);
+            HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+                "measure_bulk_transfer() failed");
+        }
 
         fprintf(stdout, "\n");
     }
 
-    HG_Test_finalize(&hg_test_info);
+done:
+    hg_ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
 
-    return EXIT_SUCCESS;
+    return ret;
 }
diff --git a/Testing/util/test_atomic.c b/Testing/util/test_atomic.c
index 4a96ab5..b4b0f68 100644
--- a/Testing/util/test_atomic.c
+++ b/Testing/util/test_atomic.c
@@ -1,133 +1,245 @@
 #include "mercury_atomic.h"
-#include "mercury_thread.h"
 
 #include "mercury_test_config.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 
-static HG_THREAD_RETURN_TYPE
-thread_cb_incr32(void *arg)
-{
-    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
-    hg_atomic_int32_t *atomic_int32 = (hg_atomic_int32_t *) arg;
-    hg_util_int32_t incr;
-
-    incr = hg_atomic_incr32(atomic_int32);
-    if (!incr)
-        fprintf(stderr, "Error: incr is %d\n", incr);
-    incr = hg_atomic_decr32(atomic_int32);
-    if (incr)
-        fprintf(stderr, "Error: incr is %d\n", incr);
-
-    hg_thread_exit(thread_ret);
-    return thread_ret;
-}
-
-static HG_THREAD_RETURN_TYPE
-thread_cb_cas32(void *arg)
+int
+main(void)
 {
-    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
-    hg_atomic_int32_t *atomic_int32 = (hg_atomic_int32_t *) arg;
+    hg_atomic_int32_t atomic_int32;
+    hg_util_int32_t val32, init_val32;
+    hg_atomic_int64_t atomic_int64;
+    hg_util_int64_t val64, init_val64;
+    int ret = EXIT_SUCCESS;
 
-    hg_atomic_incr32(atomic_int32);
+    /* Init32 test */
+    hg_atomic_init32(&atomic_int32, 1);
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != 1) {
+        fprintf(stderr, "Error in hg_atomic_init32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    if (HG_UTIL_TRUE == hg_atomic_cas32(atomic_int32, 2, 99)) {
-        hg_atomic_incr32(atomic_int32);
+    /* Set32 test */
+    hg_atomic_set32(&atomic_int32, 2);
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != 2) {
+        fprintf(stderr, "Error in hg_atomic_set32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
     }
 
-    hg_thread_exit(thread_ret);
-    return thread_ret;
-}
+    /* Incr32 test */
+    val32 = hg_atomic_incr32(&atomic_int32);
+    if (val32 != 3) {
+        fprintf(stderr, "Error in hg_atomic_incr32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != 3) {
+        fprintf(stderr, "Error in hg_atomic_incr32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-#ifndef HG_UTIL_HAS_OPA_PRIMITIVES_H
-static HG_THREAD_RETURN_TYPE
-thread_cb_incr64(void *arg)
-{
-    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
-    hg_atomic_int64_t *atomic_int64 = (hg_atomic_int64_t *) arg;
-    hg_util_int64_t incr;
-
-    incr = hg_atomic_incr64(atomic_int64);
-    if (!incr)
-        fprintf(stderr, "Error: incr is %ld\n", (long) incr);
-    incr = hg_atomic_decr64(atomic_int64);
-    if (incr)
-        fprintf(stderr, "Error: incr is %ld\n", (long) incr);
-
-    hg_thread_exit(thread_ret);
-    return thread_ret;
-}
+    /* Decr32 test */
+    val32 = hg_atomic_decr32(&atomic_int32);
+    if (val32 != 2) {
+        fprintf(stderr, "Error in hg_atomic_decr32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != 2) {
+        fprintf(stderr, "Error in hg_atomic_decr32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-static HG_THREAD_RETURN_TYPE
-thread_cb_cas64(void *arg)
-{
-    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
-    hg_atomic_int64_t *atomic_int64 = (hg_atomic_int64_t *) arg;
+    /* Or32 test */
+    init_val32 = hg_atomic_get32(&atomic_int32);
+    val32 = hg_atomic_or32(&atomic_int32, 8);
+    if (val32 != init_val32) {
+        fprintf(stderr, "Error in hg_atomic_or32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != (init_val32 | 8)) {
+        fprintf(stderr, "Error in hg_atomic_or32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    hg_atomic_incr64(atomic_int64);
+    /* Xor32 test */
+    init_val32 = hg_atomic_get32(&atomic_int32);
+    val32 = hg_atomic_xor32(&atomic_int32, 17);
+    if (val32 != init_val32) {
+        fprintf(stderr, "Error in hg_atomic_xor32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != (init_val32 ^ 17)) {
+        fprintf(stderr, "Error in hg_atomic_xor32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    if (HG_UTIL_TRUE == hg_atomic_cas64(atomic_int64, 2, 99)) {
-        hg_atomic_incr64(atomic_int64);
+    /* And32 test */
+    init_val32 = hg_atomic_get32(&atomic_int32);
+    val32 = hg_atomic_and32(&atomic_int32, 33);
+    if (val32 != init_val32) {
+        fprintf(stderr, "Error in hg_atomic_and32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != (init_val32 & 33)) {
+        fprintf(stderr, "Error in hg_atomic_and32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
     }
 
-    hg_thread_exit(thread_ret);
-    return thread_ret;
-}
-#endif
+    /* Cas32 test */
+    init_val32 = hg_atomic_get32(&atomic_int32);
+    val32 = 128;
+    if (hg_atomic_cas32(&atomic_int32, init_val32, val32) == HG_UTIL_FALSE) {
+        fprintf(stderr, "Error in hg_atomic_cas32: could not swap values"
+            "with %d, is %d, expected %d\n", val32,
+            hg_atomic_get32(&atomic_int32), init_val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val32 = hg_atomic_get32(&atomic_int32);
+    if (val32 != 128) {
+        fprintf(stderr, "Error in hg_atomic_cas32: atomic value is %d\n", val32);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    if (hg_atomic_cas32(&atomic_int32, 1, 0) == HG_UTIL_TRUE) {
+        fprintf(stderr, "Error in hg_atomic_cas32: should not swap values\n");
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-int
-main(int argc, char *argv[])
-{
-    hg_thread_t thread, thread1;
-    hg_atomic_int32_t atomic_int32;
-    hg_util_int32_t value32 = 0;
-#ifndef HG_UTIL_HAS_OPA_PRIMITIVES_H
-    hg_atomic_int64_t atomic_int64;
-    hg_util_int64_t value64 = 0;
-#endif
-    int ret = EXIT_SUCCESS;
+    /* Init64 test */
+    hg_atomic_init64(&atomic_int64, 1);
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != 1) {
+        fprintf(stderr, "Error in hg_atomic_init64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    (void) argc;
-    (void) argv;
+    /* Set64 test */
+    hg_atomic_set64(&atomic_int64, 2);
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != 2) {
+        fprintf(stderr, "Error in hg_atomic_set64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    /* Atomic 32 test */
-    hg_thread_init(&thread);
-    hg_atomic_set32(&atomic_int32, value32);
-    hg_thread_create(&thread, thread_cb_incr32, &atomic_int32);
-    hg_thread_join(thread);
+    /* Incr64 test */
+    val64 = hg_atomic_incr64(&atomic_int64);
+    if (val64 != 3) {
+        fprintf(stderr, "Error in hg_atomic_incr64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != 3) {
+        fprintf(stderr, "Error in hg_atomic_incr64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    hg_thread_init(&thread1);
-    hg_thread_create(&thread1, thread_cb_cas32, &atomic_int32);
-    hg_thread_create(&thread, thread_cb_cas32, &atomic_int32);
-    hg_thread_join(thread);
-    hg_thread_join(thread1);
+    /* Decr64 test */
+    val64 = hg_atomic_decr64(&atomic_int64);
+    if (val64 != 2) {
+        fprintf(stderr, "Error in hg_atomic_decr64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != 2) {
+        fprintf(stderr, "Error in hg_atomic_decr64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    value32 = hg_atomic_get32(&atomic_int32);
-    if (value32 != 100) {
-        fprintf(stderr, "Error: atomic value is %d\n", value32);
+    /* Or64 test */
+    init_val64 = hg_atomic_get64(&atomic_int64);
+    val64 = hg_atomic_or64(&atomic_int64, 8);
+    if (val64 != init_val64) {
+        fprintf(stderr, "Error in hg_atomic_or64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != (init_val64 | 8)) {
+        fprintf(stderr, "Error in hg_atomic_or64: atomic value is %ld\n", val64);
         ret = EXIT_FAILURE;
+        goto done;
     }
 
-#ifndef HG_UTIL_HAS_OPA_PRIMITIVES_H
-    /* Atomic 64 test */
-    hg_thread_init(&thread);
-    hg_atomic_set64(&atomic_int64, value64);
-    hg_thread_create(&thread, thread_cb_incr64, &atomic_int64);
-    hg_thread_join(thread);
+    /* Xor64 test */
+    init_val64 = hg_atomic_get64(&atomic_int64);
+    val64 = hg_atomic_xor64(&atomic_int64, 17);
+    if (val64 != init_val64) {
+        fprintf(stderr, "Error in hg_atomic_xor64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != (init_val64 ^ 17)) {
+        fprintf(stderr, "Error in hg_atomic_xor64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    hg_thread_init(&thread1);
-    hg_thread_create(&thread1, thread_cb_cas64, &atomic_int64);
-    hg_thread_create(&thread, thread_cb_cas64, &atomic_int64);
-    hg_thread_join(thread);
-    hg_thread_join(thread1);
+    /* And64 test */
+    init_val64 = hg_atomic_get64(&atomic_int64);
+    val64 = hg_atomic_and64(&atomic_int64, 33);
+    if (val64 != init_val64) {
+        fprintf(stderr, "Error in hg_atomic_and64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != (init_val64 & 33)) {
+        fprintf(stderr, "Error in hg_atomic_and64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
 
-    value64 = hg_atomic_get64(&atomic_int64);
-    if (value64 != 100) {
-        fprintf(stderr, "Error: atomic value is %ld\n", (long) value64);
+    /* Cas64 test */
+    init_val64 = hg_atomic_get64(&atomic_int64);
+    val64 = 128;
+    if (hg_atomic_cas64(&atomic_int64, init_val64, val64) == HG_UTIL_FALSE) {
+        fprintf(stderr, "Error in hg_atomic_cas64: could not swap values"
+            "with %ld, is %ld, expected %ld\n", val64,
+            hg_atomic_get64(&atomic_int64), init_val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    val64 = hg_atomic_get64(&atomic_int64);
+    if (val64 != 128) {
+        fprintf(stderr, "Error in hg_atomic_cas64: atomic value is %ld\n", val64);
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    if (hg_atomic_cas64(&atomic_int64, 1, 0) == HG_UTIL_TRUE) {
+        fprintf(stderr, "Error in hg_atomic_cas64: should not swap values\n");
         ret = EXIT_FAILURE;
+        goto done;
     }
-#endif
 
+done:
     return ret;
 }
diff --git a/Testing/util/test_thread_condition.c b/Testing/util/test_thread_condition.c
index aed9052..a7ad671 100644
--- a/Testing/util/test_thread_condition.c
+++ b/Testing/util/test_thread_condition.c
@@ -6,8 +6,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#define MERCURY_TESTING_NUM_THREADS 8
-
 static hg_thread_cond_t thread_cond;
 static hg_thread_mutex_t thread_mutex;
 static int working = 0;
@@ -57,26 +55,26 @@ thread_cb_cond_all(void *arg)
 int
 main(int argc, char *argv[])
 {
-    hg_thread_t thread[MERCURY_TESTING_NUM_THREADS];
+    hg_thread_t thread[HG_TEST_NUM_THREADS_DEFAULT];
     int ret = EXIT_SUCCESS;
     int i;
 
     (void) argc;
     (void) argv;
 
-    for (i = 0; i < MERCURY_TESTING_NUM_THREADS; i++)
+    for (i = 0; i < HG_TEST_NUM_THREADS_DEFAULT; i++)
         hg_thread_init(&thread[i]);
     hg_thread_mutex_init(&thread_mutex);
     hg_thread_cond_init(&thread_cond);
 
-    for (i = 0; i < MERCURY_TESTING_NUM_THREADS; i++)
+    for (i = 0; i < HG_TEST_NUM_THREADS_DEFAULT; i++)
         hg_thread_create(&thread[i], thread_cb_cond, NULL);
-    for (i = 0; i < MERCURY_TESTING_NUM_THREADS; i++)
+    for (i = 0; i < HG_TEST_NUM_THREADS_DEFAULT; i++)
         hg_thread_join(thread[i]);
 
     working = 1;
 
-    for (i = 0; i < MERCURY_TESTING_NUM_THREADS; i++)
+    for (i = 0; i < HG_TEST_NUM_THREADS_DEFAULT; i++)
         hg_thread_create(&thread[i], thread_cb_cond_all, NULL);
 
     hg_thread_mutex_lock(&thread_mutex);
@@ -84,7 +82,7 @@ main(int argc, char *argv[])
     hg_thread_cond_broadcast(&thread_cond);
     hg_thread_mutex_unlock(&thread_mutex);
 
-    for (i = 0; i < MERCURY_TESTING_NUM_THREADS; i++)
+    for (i = 0; i < HG_TEST_NUM_THREADS_DEFAULT; i++)
         hg_thread_join(thread[i]);
 
     return ret;
diff --git a/Testing/util/test_threadpool.c b/Testing/util/test_threadpool.c
index 3318ae2..d174a5c 100644
--- a/Testing/util/test_threadpool.c
+++ b/Testing/util/test_threadpool.c
@@ -6,7 +6,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#define MERCURY_TESTING_NUM_THREADS 8
 #define POOL_NUM_POSTS 32
 
 /*
@@ -55,7 +54,7 @@ main(int argc, char *argv[])
     (void) argc;
     (void) argv;
     hg_thread_mutex_init(&mymutex);
-    hg_thread_pool_init(MERCURY_TESTING_NUM_THREADS, &thread_pool);
+    hg_thread_pool_init(HG_TEST_NUM_THREADS_DEFAULT, &thread_pool);
 
     for (i = 0; i < POOL_NUM_POSTS; i++) {
         work[i].func = myfunc;
diff --git a/src/mercury.c b/src/mercury.c
index fcf0a42..4101ffe 100644
--- a/src/mercury.c
+++ b/src/mercury.c
@@ -1549,6 +1549,21 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
+hg_bool_t
+HG_Addr_cmp(hg_class_t *hg_class, hg_addr_t addr1, hg_addr_t addr2)
+{
+    hg_bool_t ret = HG_FALSE;
+
+    HG_CHECK_ERROR_NORET(hg_class == NULL, done, "NULL HG class");
+
+    ret = HG_Core_addr_cmp(hg_class->core_class, (hg_core_addr_t) addr1,
+        (hg_core_addr_t) addr2);
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
 hg_return_t
 HG_Addr_to_string(hg_class_t *hg_class, char *buf, hg_size_t *buf_size,
     hg_addr_t addr)
diff --git a/src/mercury.h b/src/mercury.h
index 91e4778..d8d385d 100644
--- a/src/mercury.h
+++ b/src/mercury.h
@@ -651,6 +651,22 @@ HG_Addr_dup(
         );
 
 /**
+ * Compare two addresses.
+ *
+ * \param hg_class [IN]         pointer to HG class
+ * \param addr1 [IN]            abstract address
+ * \param addr2 [IN]            abstract address
+ *
+ * \return HG_TRUE if addresses are determined to be equal, HG_FALSE otherwise
+ */
+HG_PUBLIC hg_bool_t
+HG_Addr_cmp(
+        hg_class_t *hg_class,
+        hg_addr_t addr1,
+        hg_addr_t addr2
+        );
+
+/**
  * Convert an addr to a string (returned string includes the terminating
  * null byte '\0'). If buf is NULL, the address is not converted and only
  * the required size of the buffer is returned. If the input value passed
diff --git a/src/mercury_bulk.c b/src/mercury_bulk.c
index 22afddd..7223bef 100644
--- a/src/mercury_bulk.c
+++ b/src/mercury_bulk.c
@@ -21,12 +21,10 @@
 /****************/
 /* Local Macros */
 /****************/
+
 #define HG_BULK_MIN(a, b) \
     (a < b) ? a : b
 
-/* Number of retries when receiving NA_AGAIN error */
-#define HG_BULK_MAX_AGAIN_RETRY     (10)
-
 /* Remove warnings when plugin does not use callback arguments */
 #if defined(__cplusplus)
 # define HG_BULK_UNUSED
@@ -255,26 +253,9 @@ hg_bulk_na_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_offset_t remote_offset, na_size_t data_size, na_addr_t remote_addr,
     na_uint8_t remote_id, na_op_id_t *op_id)
 {
-    na_return_t na_ret;
-    int retry_cnt = 0;
-
-    /* Post RMA put */
-    do {
-        na_ret = NA_Put(na_class, context, callback, arg, local_mem_handle,
-            local_offset, remote_mem_handle, remote_offset, data_size,
-            remote_addr, remote_id, op_id);
-        if (na_ret != NA_AGAIN || retry_cnt++ > HG_BULK_MAX_AGAIN_RETRY)
-            break;
-
-        /* Attempt to make progress on NA with timeout of 0 */
-        na_ret = NA_Progress(na_class, context, 0);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done,
-            na_ret, na_ret, "Could not make progress on NA (%s)",
-            NA_Error_to_string(na_ret));
-    } while (1);
-
-done:
-    return na_ret;
+    return NA_Put(na_class, context, callback, arg, local_mem_handle,
+        local_offset, remote_mem_handle, remote_offset, data_size, remote_addr,
+        remote_id, op_id);
 }
 
 /**
@@ -288,26 +269,9 @@ hg_bulk_na_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_offset_t remote_offset, na_size_t data_size, na_addr_t remote_addr,
     na_uint8_t remote_id, na_op_id_t *op_id)
 {
-    na_return_t na_ret;
-    int retry_cnt = 0;
-
-    /* Post RMA get */
-    do {
-        na_ret = NA_Get(na_class, context, callback, arg, local_mem_handle,
-            local_offset, remote_mem_handle, remote_offset, data_size,
-            remote_addr, remote_id, op_id);
-        if (na_ret != NA_AGAIN || retry_cnt++ > HG_BULK_MAX_AGAIN_RETRY)
-            break;
-
-        /* Attempt to make progress on NA with timeout of 0 */
-        na_ret = NA_Progress(na_class, context, 0);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done,
-            na_ret, na_ret, "Could not make progress on NA (%s)",
-            NA_Error_to_string(na_ret));
-    } while (1);
-
-done:
-    return na_ret;
+    return NA_Get(na_class, context, callback, arg, local_mem_handle,
+        local_offset, remote_mem_handle, remote_offset, data_size, remote_addr,
+        remote_id, op_id);
 }
 
 /**
diff --git a/src/mercury_core.c b/src/mercury_core.c
index f1e45f9..39e9bec 100644
--- a/src/mercury_core.c
+++ b/src/mercury_core.c
@@ -50,9 +50,6 @@
 # define HG_CORE_MIN(a, b)          (a < b) ? a : b /* Min macro */
 #endif
 
-/* Number of retries when receiving NA_AGAIN error */
-#define HG_CORE_MAX_AGAIN_RETRY         (10)
-
 /* Remove warnings when routine does not use arguments */
 #if defined(__cplusplus)
 # define HG_UNUSED
@@ -103,7 +100,7 @@ struct hg_core_private_class {
     hg_atomic_int32_t n_addrs;          /* Atomic used for number of addrs */
     hg_atomic_int32_t request_tag;      /* Atomic used for tag generation */
     hg_thread_spin_t func_map_lock;     /* Function map lock */
-    na_progress_mode_t progress_mode;   /* NA progress mode */
+    na_uint32_t progress_mode;          /* NA progress mode */
     hg_bool_t na_ext_init;              /* NA externally initialized */
 #ifdef HG_HAS_COLLECT_STATS
     hg_bool_t stats;                    /* (Debug) Print stats at exit */
@@ -1940,7 +1937,6 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
 {
     na_return_t na_ret;
     hg_return_t ret = HG_SUCCESS;
-    int retry_cnt = 0;
 
     /* Set operation type for trigger */
     hg_core_handle->op_type = HG_CORE_FORWARD;
@@ -1971,28 +1967,16 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
     hg_atomic_set32(&hg_core_handle->posted, HG_TRUE);
 
     /* Post send (input) */
-    do {
-        na_ret = NA_Msg_send_unexpected(hg_core_handle->na_class,
-            hg_core_handle->na_context, hg_core_send_input_cb, hg_core_handle,
-            hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_used,
-            hg_core_handle->in_buf_plugin_data,
-            hg_core_handle->core_handle.info.addr->na_addr,
-            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
-            &hg_core_handle->na_send_op_id);
-        if (na_ret != NA_AGAIN || retry_cnt++ > HG_CORE_MAX_AGAIN_RETRY)
-            break;
-
-        /* Attempt to make progress on NA with timeout of 0 */
-        na_ret = NA_Progress(hg_core_handle->na_class,
-            hg_core_handle->na_context, 0);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, cancel,
-            ret, (hg_return_t) na_ret, "Could not make progress on NA (%s)",
-            NA_Error_to_string(na_ret));
-    } while (1);
-    /* Silently return on NA_AGAIN error so that users can manually retry */
+    na_ret = NA_Msg_send_unexpected(hg_core_handle->na_class,
+        hg_core_handle->na_context, hg_core_send_input_cb, hg_core_handle,
+        hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_used,
+        hg_core_handle->in_buf_plugin_data,
+        hg_core_handle->core_handle.info.addr->na_addr,
+        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
+        &hg_core_handle->na_send_op_id);
     if (na_ret == NA_AGAIN)
+        /* Silently return on NA_AGAIN error so that users can manually retry */
         HG_GOTO_DONE(cancel, ret, HG_AGAIN);
-
     HG_CHECK_ERROR(na_ret != NA_SUCCESS, cancel, ret, (hg_return_t) na_ret,
         "Could not post send for input buffer (%s)",
         NA_Error_to_string(na_ret));
@@ -2060,7 +2044,6 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
     hg_bool_t ack_recv_posted = HG_FALSE;
-    int retry_cnt = 0;
 
     /* Increment number of expected NA operations */
     hg_core_handle->na_op_count++;
@@ -2098,24 +2081,13 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
     }
 
     /* Post expected send (output) */
-    do {
-        na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
-            hg_core_handle->na_context, hg_core_send_output_cb, hg_core_handle,
-            hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_used,
-            hg_core_handle->out_buf_plugin_data,
-            hg_core_handle->core_handle.info.addr->na_addr,
-            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
-            &hg_core_handle->na_send_op_id);
-        if (na_ret != NA_AGAIN || retry_cnt++ > HG_CORE_MAX_AGAIN_RETRY)
-            break;
-
-        /* Attempt to make progress on NA with timeout of 0 */
-        na_ret = NA_Progress(hg_core_handle->na_class,
-            hg_core_handle->na_context, 0);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, error,
-            ret, (hg_return_t) na_ret, "Could not make progress on NA (%s)",
-            NA_Error_to_string(na_ret));
-    } while (1);
+    na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
+        hg_core_handle->na_context, hg_core_send_output_cb, hg_core_handle,
+        hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_used,
+        hg_core_handle->out_buf_plugin_data,
+        hg_core_handle->core_handle.info.addr->na_addr,
+        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
+        &hg_core_handle->na_send_op_id);
     /* Expected sends should always succeed after retry */
     HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
         "Could not post send for output buffer (%s)",
@@ -2430,7 +2402,6 @@ hg_core_send_ack(hg_core_handle_t handle)
         (struct hg_core_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
-    int retry_cnt = 0;
 
     /* Increment number of expected NA operations */
     hg_core_handle->na_op_count++;
@@ -2447,24 +2418,13 @@ hg_core_send_ack(hg_core_handle_t handle)
         "Could not initialize ack buffer (%s)", NA_Error_to_string(na_ret));
 
     /* Post expected send (ack) */
-    do {
-        na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
-            hg_core_handle->na_context, hg_core_send_ack_cb, hg_core_handle,
-            hg_core_handle->ack_buf, sizeof(hg_uint8_t),
-            hg_core_handle->ack_buf_plugin_data,
-            hg_core_handle->core_handle.info.addr->na_addr,
-            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
-            &hg_core_handle->na_ack_op_id);
-        if (na_ret != NA_AGAIN || retry_cnt++ > HG_CORE_MAX_AGAIN_RETRY)
-            break;
-
-        /* Attempt to make progress on NA with timeout of 0 */
-        na_ret = NA_Progress(hg_core_handle->na_class,
-            hg_core_handle->na_context, 0);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, error,
-            ret, (hg_return_t) na_ret, "Could not make progress on NA (%s)",
-            NA_Error_to_string(na_ret));
-    } while (1);
+    na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
+        hg_core_handle->na_context, hg_core_send_ack_cb, hg_core_handle,
+        hg_core_handle->ack_buf, sizeof(hg_uint8_t),
+        hg_core_handle->ack_buf_plugin_data,
+        hg_core_handle->core_handle.info.addr->na_addr,
+        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
+        &hg_core_handle->na_ack_op_id);
     /* Expected sends should always succeed after retry */
     HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
         "Could not post send for ack buffer (%s)", NA_Error_to_string(na_ret));
@@ -2716,7 +2676,8 @@ hg_core_completion_add(struct hg_core_context *context,
 
 #ifdef HG_HAS_SELF_FORWARD
     /* TODO could prevent from self notifying if hg_poll_wait() not entered */
-    if (self_notify && private_context->completion_queue_notify) {
+    if (!(HG_CORE_CONTEXT_CLASS(private_context)->progress_mode & NA_NO_BLOCK)
+        && self_notify && private_context->completion_queue_notify) {
         int rc = hg_event_set(private_context->completion_queue_notify);
         HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_FAULT,
             "Could not signal completion queue");
@@ -2872,10 +2833,12 @@ hg_core_completion_queue_notify_cb(void *arg,
     hg_util_bool_t notified = HG_UTIL_FALSE;
     int rc = HG_UTIL_SUCCESS;
 
-    /* TODO could prevent from self notifying if hg_poll_wait() not entered */
-    rc = hg_event_get(context->completion_queue_notify, &notified);
-    HG_CHECK_ERROR_NORET(rc != HG_UTIL_SUCCESS, done,
-        "Could not get completion notification");
+    if (!(HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK)) {
+        /* TODO could prevent from self notifying if hg_poll_wait() not entered */
+        rc = hg_event_get(context->completion_queue_notify, &notified);
+        HG_CHECK_ERROR_NORET(rc != HG_UTIL_SUCCESS, done,
+            "Could not get completion notification");
+    }
 
     if (notified || !hg_atomic_queue_is_empty(context->completion_queue)
         || hg_atomic_get32(&context->backfill_queue_count)) {
@@ -3014,7 +2977,7 @@ hg_core_progress_na(struct hg_core_private_context *context,
     hg_return_t ret = HG_TIMEOUT;
 
     /* Do not block if NA_NO_BLOCK option is passed */
-    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
     } else
@@ -3100,7 +3063,7 @@ hg_core_poll_try_wait_cb(void *arg)
         (struct hg_core_private_context *) arg;
 
     /* Do not try to wait if NA_NO_BLOCK is set */
-    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK)
         return NA_FALSE;
 
     /* Something is in one of the completion queues */
@@ -3132,7 +3095,7 @@ hg_core_progress_poll(struct hg_core_private_context *context,
     hg_return_t ret = HG_TIMEOUT;
 
     /* Do not block if NA_NO_BLOCK option is passed */
-    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
     } else {
@@ -3179,7 +3142,7 @@ hg_core_trigger(struct hg_core_private_context *context, unsigned int timeout,
     hg_return_t ret = HG_SUCCESS;
 
     /* Do not block if NA_NO_BLOCK option is passed */
-    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
     } else {
@@ -3582,7 +3545,7 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
         hg_core_completion_queue_notify_cb, context);
 #endif
 
-    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
+    if (HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK)
         /* Force to use progress poll */
         na_poll_fd = 0;
     else
@@ -3605,7 +3568,7 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
         HG_CHECK_ERROR_NORET(context->progress != hg_core_progress_poll, error,
             "Auto SM mode not supported with selected plugin");
 
-        if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
+        if (HG_CORE_CONTEXT_CLASS(context)->progress_mode & NA_NO_BLOCK)
             /* Force to use progress poll */
             na_poll_fd = 0;
         else {
@@ -3722,7 +3685,7 @@ HG_Core_context_destroy(hg_core_context_t *context)
     }
 #endif
 
-    if (HG_CORE_CONTEXT_CLASS(private_context)->progress_mode == NA_NO_BLOCK)
+    if (HG_CORE_CONTEXT_CLASS(private_context)->progress_mode & NA_NO_BLOCK)
         /* Was forced to use progress poll */
         na_poll_fd = 0;
     else
@@ -3737,7 +3700,7 @@ HG_Core_context_destroy(hg_core_context_t *context)
 
 #ifdef HG_HAS_SM_ROUTING
     if (context->na_sm_context) {
-        if (HG_CORE_CONTEXT_CLASS(private_context)->progress_mode == NA_NO_BLOCK)
+        if (HG_CORE_CONTEXT_CLASS(private_context)->progress_mode & NA_NO_BLOCK)
             /* Was forced to use progress poll */
             na_poll_fd = 0;
         else
@@ -4122,6 +4085,30 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
+hg_bool_t
+HG_Core_addr_cmp(hg_core_class_t *hg_core_class, hg_core_addr_t addr1,
+    hg_core_addr_t addr2)
+{
+    hg_bool_t ret = HG_FALSE;
+
+    HG_CHECK_ERROR_NORET(hg_core_class == NULL, done, "NULL HG core class");
+
+    if (addr1 == HG_CORE_ADDR_NULL && addr2 == HG_CORE_ADDR_NULL)
+        HG_GOTO_DONE(done, ret, HG_TRUE);
+
+    if (addr1 == HG_CORE_ADDR_NULL || addr2 == HG_CORE_ADDR_NULL)
+        HG_GOTO_DONE(done, ret, HG_FALSE);
+
+    ret = NA_Addr_cmp(
+        ((struct hg_core_private_addr *) addr1)->core_addr.na_class,
+        ((struct hg_core_private_addr *) addr1)->core_addr.na_addr,
+        ((struct hg_core_private_addr *) addr2)->core_addr.na_addr);
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
 hg_return_t
 HG_Core_addr_to_string(hg_core_class_t *hg_core_class, char *buf,
     hg_size_t *buf_size, hg_core_addr_t addr)
diff --git a/src/mercury_core.h b/src/mercury_core.h
index 46ca770..ce5974b 100644
--- a/src/mercury_core.h
+++ b/src/mercury_core.h
@@ -648,6 +648,22 @@ HG_Core_addr_self(
         );
 
 /**
+ * Compare two addresses.
+ *
+ * \param hg_core_class [IN]    pointer to HG core class
+ * \param addr1 [IN]            abstract address
+ * \param addr2 [IN]            abstract address
+ *
+ * \return HG_TRUE if addresses are determined to be equal, HG_FALSE otherwise
+ */
+HG_PUBLIC hg_bool_t
+HG_Core_addr_cmp(
+        hg_core_class_t *hg_core_class,
+        hg_core_addr_t addr1,
+        hg_core_addr_t addr2
+        );
+
+/**
  * Duplicate an existing HG abstract address. The duplicated address can be
  * stored for later use and the origin address be freed safely. The duplicated
  * address must be freed with HG_Core_addr_free().
diff --git a/src/mercury_core_types.h b/src/mercury_core_types.h
index 244e0fe..e591f18 100644
--- a/src/mercury_core_types.h
+++ b/src/mercury_core_types.h
@@ -101,4 +101,8 @@ typedef enum {
 /* HG size max */
 #define HG_SIZE_MAX         UINT64_MAX
 
+/* HG init info initializer */
+#define HG_INIT_INFO_INITIALIZER \
+    { NA_INIT_INFO_INITIALIZER, NULL, HG_FALSE, HG_FALSE }
+
 #endif /* MERCURY_CORE_TYPES_H */
diff --git a/src/mercury_proc.c b/src/mercury_proc.c
index 95853ad..3d5f684 100644
--- a/src/mercury_proc.c
+++ b/src/mercury_proc.c
@@ -103,8 +103,8 @@ hg_proc_create(hg_class_t *hg_class, hg_proc_hash_t hash, hg_proc_t *proc)
             break;
     }
 
-#ifdef HG_HAS_CHECKSUMS
     if (hash_method) {
+#ifdef HG_HAS_CHECKSUMS
         int rc = mchecksum_init(hash_method, &hg_proc->checksum);
         HG_CHECK_ERROR(rc < 0, error, ret, HG_CHECKSUM_ERROR,
             "Could not initialize checksum");
@@ -113,8 +113,8 @@ hg_proc_create(hg_class_t *hg_class, hg_proc_hash_t hash, hg_proc_t *proc)
         hg_proc->checksum_hash = (char *) malloc(hg_proc->checksum_size);
         HG_CHECK_ERROR(hg_proc->checksum_hash == NULL, error, ret,
             HG_NOMEM, "Could not allocate space for checksum hash");
-    }
 #endif
+    }
 
     /* Default to proc_buf */
     hg_proc->current_buf = &hg_proc->proc_buf;
@@ -491,8 +491,8 @@ done:
 hg_return_t
 hg_proc_flush(hg_proc_t proc)
 {
-    struct hg_proc *hg_proc = (struct hg_proc *) proc;
 #ifdef HG_HAS_CHECKSUMS
+    struct hg_proc *hg_proc = (struct hg_proc *) proc;
     int rc;
 #endif
     hg_return_t ret = HG_SUCCESS;
diff --git a/src/na/na.c b/src/na/na.c
index 9cb8ecd..6a432ba 100644
--- a/src/na/na.c
+++ b/src/na/na.c
@@ -607,21 +607,22 @@ done:
 
 /*---------------------------------------------------------------------------*/
 na_return_t
-NA_Addr_self(na_class_t *na_class, na_addr_t *addr)
+NA_Addr_free(na_class_t *na_class, na_addr_t addr)
 {
     na_return_t ret = NA_SUCCESS;
 
     NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
         "NULL NA class");
-    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
-        "NULL pointer to na_addr_t");
+    if (addr == NA_ADDR_NULL)
+        /* Nothing to do */
+        goto done;
 
     NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
         "NULL NA class ops");
-    NA_CHECK_ERROR(na_class->ops->addr_self == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "addr_self plugin callback is not defined");
+    NA_CHECK_ERROR(na_class->ops->addr_free == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_free plugin callback is not defined");
 
-    ret = na_class->ops->addr_self(na_class, addr);
+    ret = na_class->ops->addr_free(na_class, addr);
 
 done:
     return ret;
@@ -629,23 +630,20 @@ done:
 
 /*---------------------------------------------------------------------------*/
 na_return_t
-NA_Addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr)
+NA_Addr_set_remove(na_class_t *na_class, na_addr_t addr)
 {
     na_return_t ret = NA_SUCCESS;
 
     NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
         "NULL NA class");
-    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
-        "NULL addr");
-    NA_CHECK_ERROR(new_addr == NULL, done, ret, NA_INVALID_ARG,
-        "NULL pointer to NA addr");
+    if (addr == NA_ADDR_NULL)
+        /* Nothing to do */
+        goto done;
 
     NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
         "NULL NA class ops");
-    NA_CHECK_ERROR(na_class->ops->addr_dup == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "addr_dup plugin callback is not defined");
-
-    ret = na_class->ops->addr_dup(na_class, addr, new_addr);
+    if (na_class->ops->addr_set_remove)
+        ret = na_class->ops->addr_set_remove(na_class, addr);
 
 done:
     return ret;
@@ -653,22 +651,21 @@ done:
 
 /*---------------------------------------------------------------------------*/
 na_return_t
-NA_Addr_free(na_class_t *na_class, na_addr_t addr)
+NA_Addr_self(na_class_t *na_class, na_addr_t *addr)
 {
     na_return_t ret = NA_SUCCESS;
 
     NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
         "NULL NA class");
-    if (addr == NA_ADDR_NULL)
-        /* Nothing to do */
-        goto done;
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to na_addr_t");
 
     NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
         "NULL NA class ops");
-    NA_CHECK_ERROR(na_class->ops->addr_free == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "addr_free plugin callback is not defined");
+    NA_CHECK_ERROR(na_class->ops->addr_self == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_self plugin callback is not defined");
 
-    ret = na_class->ops->addr_free(na_class, addr);
+    ret = na_class->ops->addr_self(na_class, addr);
 
 done:
     return ret;
@@ -676,20 +673,47 @@ done:
 
 /*---------------------------------------------------------------------------*/
 na_return_t
-NA_Addr_set_remove(na_class_t *na_class, na_addr_t addr)
+NA_Addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr)
 {
     na_return_t ret = NA_SUCCESS;
 
     NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
         "NULL NA class");
-    if (addr == NA_ADDR_NULL)
-        /* Nothing to do */
-        goto done;
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
+        "NULL addr");
+    NA_CHECK_ERROR(new_addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to NA addr");
 
     NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
         "NULL NA class ops");
-    if (na_class->ops->addr_set_remove)
-        ret = na_class->ops->addr_set_remove(na_class, addr);
+    NA_CHECK_ERROR(na_class->ops->addr_dup == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_dup plugin callback is not defined");
+
+    ret = na_class->ops->addr_dup(na_class, addr, new_addr);
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+na_bool_t
+NA_Addr_cmp(na_class_t *na_class, na_addr_t addr1, na_addr_t addr2)
+{
+    na_bool_t ret = NA_FALSE;
+
+    NA_CHECK_ERROR_NORET(na_class == NULL, done, "NULL NA class");
+
+    if (addr1 == NA_ADDR_NULL && addr2 == NA_ADDR_NULL)
+        NA_GOTO_DONE(done, ret, NA_TRUE);
+
+    if (addr1 == NA_ADDR_NULL || addr2 == NA_ADDR_NULL)
+        NA_GOTO_DONE(done, ret, NA_FALSE);
+
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, done, "NULL NA class ops");
+    NA_CHECK_ERROR_NORET(na_class->ops->addr_cmp == NULL, done,
+        "addr_cmp plugin callback is not defined");
+
+    ret = na_class->ops->addr_cmp(na_class, addr1, addr2);
 
 done:
     return ret;
@@ -1126,7 +1150,7 @@ NA_Poll_try_wait(na_class_t *na_class, na_context_t *context)
     NA_CHECK_ERROR_NORET(context == NULL, error, "NULL context");
 
     /* Do not try to wait if NA_NO_BLOCK is set */
-    if (na_class->progress_mode == NA_NO_BLOCK)
+    if (na_class->progress_mode & NA_NO_BLOCK)
         return NA_FALSE;
 
     /* Something is in one of the completion queues */
@@ -1170,7 +1194,7 @@ NA_Progress(na_class_t *na_class, na_context_t *context, unsigned int timeout)
         NA_OPNOTSUPPORTED, "progress plugin callback is not defined");
 
     /* Do not block if NA_NO_BLOCK option is passed */
-    if (na_private_class->na_class.progress_mode == NA_NO_BLOCK)
+    if (na_private_class->na_class.progress_mode & NA_NO_BLOCK)
         remaining = 0;
     else
         remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
@@ -1271,7 +1295,7 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
 
     /* Do not block if NA_NO_BLOCK option is passed */
     na_private_class = (struct na_private_class *) na_private_context->na_class;
-    if (na_private_class->na_class.progress_mode == NA_NO_BLOCK) {
+    if (na_private_class->na_class.progress_mode & NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
     } else
diff --git a/src/na/na.h b/src/na/na.h
index b3a3d7d..4849ea7 100644
--- a/src/na/na.h
+++ b/src/na/na.h
@@ -313,6 +313,22 @@ NA_Addr_dup(
         );
 
 /**
+ * Compare two addresses.
+ *
+ * \param na_class [IN/OUT]     pointer to NA class
+ * \param addr1 [IN]            abstract address
+ * \param addr2 [IN]            abstract address
+ *
+ * \return NA_TRUE if addresses are determined to be equal, NA_FALSE otherwise
+ */
+NA_PUBLIC na_bool_t
+NA_Addr_cmp(
+        na_class_t *na_class,
+        na_addr_t   addr1,
+        na_addr_t   addr2
+        );
+
+/**
  * Test whether address is self or not.
  *
  * \param na_class [IN/OUT]     pointer to NA class
@@ -1096,7 +1112,7 @@ struct na_class {
     const struct na_class_ops *ops;             /* Class operations */
     void *plugin_class;                         /* Plugin private class */
     char *protocol_name;                        /* Name of protocol */
-    na_progress_mode_t progress_mode;           /* NA progress mode */
+    na_uint32_t progress_mode;                  /* NA progress mode */
     na_bool_t listen;                           /* Listen for connections */
 };
 
@@ -1183,6 +1199,12 @@ struct na_class_ops {
             na_addr_t  *new_addr
             );
     na_bool_t
+    (*addr_cmp)(
+            na_class_t *na_class,
+            na_addr_t   addr1,
+            na_addr_t   addr2
+            );
+    na_bool_t
     (*addr_is_self)(
             na_class_t *na_class,
             na_addr_t   addr
diff --git a/src/na/na_bmi.c b/src/na/na_bmi.c
index 6eedcbe..9796bae 100644
--- a/src/na/na_bmi.c
+++ b/src/na/na_bmi.c
@@ -254,6 +254,14 @@ na_bmi_addr_dup(
         na_addr_t  *new_addr
         );
 
+/* addr_cmp */
+static na_bool_t
+na_bmi_addr_cmp(
+        na_class_t *na_class,
+        na_addr_t addr1,
+        na_addr_t addr2
+        );
+
 /* addr_is_self */
 static na_bool_t
 na_bmi_addr_is_self(
@@ -525,6 +533,7 @@ const struct na_class_ops NA_PLUGIN_OPS(bmi) = {
         NULL,                                 /* addr_set_remove */
         na_bmi_addr_self,                     /* addr_self */
         na_bmi_addr_dup,                      /* addr_dup */
+        na_bmi_addr_cmp,                      /* addr_cmp */
         na_bmi_addr_is_self,                  /* addr_is_self */
         na_bmi_addr_to_string,                /* addr_to_string */
         NULL,                                 /* addr_get_serialize_size */
@@ -1017,6 +1026,17 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static na_bool_t
+na_bmi_addr_cmp(na_class_t NA_UNUSED *na_class, na_addr_t addr1,
+    na_addr_t addr2)
+{
+    struct na_bmi_addr *na_bmi_addr1 = (struct na_bmi_addr *) addr1;
+    struct na_bmi_addr *na_bmi_addr2 = (struct na_bmi_addr *) addr2;
+
+    return (na_bmi_addr1->bmi_addr == na_bmi_addr2->bmi_addr);
+}
+
+/*---------------------------------------------------------------------------*/
+static na_bool_t
 na_bmi_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
     struct na_bmi_addr *na_bmi_addr = (struct na_bmi_addr *) addr;
diff --git a/src/na/na_cci.c b/src/na/na_cci.c
index 6ce6c9e..fabe5b1 100644
--- a/src/na/na_cci.c
+++ b/src/na/na_cci.c
@@ -384,6 +384,7 @@ const struct na_class_ops NA_PLUGIN_OPS(cci) = {
     NULL,                                   /* addr_set_remove */
     na_cci_addr_self,                       /* addr_self */
     na_cci_addr_dup,                        /* addr_dup */
+    NULL,                                   /* addr_cmp */
     na_cci_addr_is_self,                    /* addr_is_self */
     na_cci_addr_to_string,                  /* addr_to_string */
     NULL,                                   /* addr_get_serialize_size */
@@ -636,7 +637,7 @@ na_cci_initialize(na_class_t * na_class, const struct na_info *na_info,
     }
     memset(na_class->plugin_class, 0, sizeof(struct na_cci_class));
     if (na_info->na_init_info
-        && na_info->na_init_info->progress_mode == NA_NO_BLOCK)
+        && (na_info->na_init_info->progress_mode & NA_NO_BLOCK))
         fd_p = NULL;
 
     /* Create unspecified endpoint if service is set */
diff --git a/src/na/na_mpi.c b/src/na/na_mpi.c
index 03137cd..e63b8c8 100644
--- a/src/na/na_mpi.c
+++ b/src/na/na_mpi.c
@@ -307,6 +307,14 @@ na_mpi_addr_free(
         na_addr_t   addr
         );
 
+/* addr_cmp */
+static na_bool_t
+na_mpi_addr_cmp(
+        na_class_t *na_class,
+        na_addr_t addr1,
+        na_addr_t addr2
+        );
+
 /* addr_is_self */
 static na_bool_t
 na_mpi_addr_is_self(
@@ -567,6 +575,7 @@ const struct na_class_ops NA_PLUGIN_OPS(mpi) = {
         NULL,                                 /* addr_set_remove */
         na_mpi_addr_self,                     /* addr_self */
         NULL,                                 /* addr_dup */
+        na_mpi_addr_cmp,                      /* addr_cmp */
         na_mpi_addr_is_self,                  /* addr_is_self */
         na_mpi_addr_to_string,                /* addr_to_string */
         NULL,                                 /* addr_get_serialize_size */
@@ -1457,6 +1466,18 @@ na_mpi_addr_free(na_class_t *na_class, na_addr_t addr)
 
 /*---------------------------------------------------------------------------*/
 static na_bool_t
+na_mpi_addr_cmp(na_class_t NA_UNUSED *na_class, na_addr_t addr1,
+    na_addr_t addr2)
+{
+    struct na_mpi_addr *na_mpi_addr1 = (struct na_mpi_addr *) addr1;
+    struct na_mpi_addr *na_mpi_addr2 = (struct na_mpi_addr *) addr2;
+
+    return (na_mpi_addr1->comm == na_mpi_addr2->comm)
+        && (na_mpi_addr1->rank == na_mpi_addr2->rank);
+}
+
+/*---------------------------------------------------------------------------*/
+static na_bool_t
 na_mpi_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
     struct na_mpi_addr *na_mpi_addr = (struct na_mpi_addr *) addr;
diff --git a/src/na/na_ofi.c b/src/na/na_ofi.c
index 5c13067..cb292a3 100644
--- a/src/na/na_ofi.c
+++ b/src/na/na_ofi.c
@@ -74,8 +74,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#undef NDEBUG /* for assert */
-#include <assert.h>
 #include <unistd.h>
 #include <inttypes.h>
 #include <sys/uio.h> /* for struct iovec */
@@ -199,12 +197,12 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 #define NA_OFI_MEM_BLOCK_COUNT          (256)
 
 /* Max tag */
-#define NA_OFI_MAX_TAG                  ((1 << 30) -1)
+#define NA_OFI_MAX_TAG                  UINT32_MAX
 
 /* Unexpected size */
 #define NA_OFI_UNEXPECTED_SIZE          (4096)
-#define NA_OFI_EXPECTED_TAG_FLAG        (0x100000000ULL)
-#define NA_OFI_UNEXPECTED_TAG_IGNORE    (0x0FFFFFFFFULL)
+#define NA_OFI_UNEXPECTED_TAG           (0x100000000ULL)
+#define NA_OFI_TAG_MASK                 (0xFFFFFFFFULL)
 
 /* Number of CQ event provided for fi_cq_read() */
 #define NA_OFI_CQ_EVENT_NUM             (16)
@@ -219,12 +217,17 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 /* The predefined RMA KEY for MR_SCALABLE */
 #define NA_OFI_RMA_KEY                  (0x0F1B0F1BULL)
 
+/* The completion flags for PUT/GET operations */
+#define NA_OFI_PUT_COMPLETION           (FI_COMPLETION | FI_DELIVERY_COMPLETE)
+#define NA_OFI_GET_COMPLETION           (FI_COMPLETION)
+
 /* Receive context bits for SEP */
 #define NA_OFI_SEP_RX_CTX_BITS          (8)
 
 /* Op ID status bits */
 #define NA_OFI_OP_COMPLETED             (1 << 0)
 #define NA_OFI_OP_CANCELED              (1 << 1)
+#define NA_OFI_OP_QUEUED                (1 << 2)
 
 /* Private data access */
 #define NA_OFI_CLASS(na_class)      \
@@ -245,7 +248,6 @@ struct na_ofi_addr {
     fi_addr_t fi_addr;                      /* FI address               */
     na_uint64_t ht_key;                     /* Key in hash-table        */
     hg_atomic_int32_t refcount;             /* Reference counter        */
-    na_bool_t self;                         /* Boolean for self         */
     na_bool_t remove;                       /* Remove from AV on free   */
 };
 
@@ -293,56 +295,55 @@ struct na_ofi_mem_handle {
     struct fid_mr *fi_mr;                   /* FI MR handle             */
 };
 
-/* Lookup info */
-struct na_ofi_info_lookup {
-    na_addr_t addr;
-};
-
-/* Unexpected recv info */
-struct na_ofi_info_recv_unexpected {
-    void *buf;
-    na_size_t buf_size;
-    na_size_t msg_size;
+/* Msg info */
+struct na_ofi_msg_info {
+    union {
+        const void *const_ptr;
+        void *ptr;
+    } buf;
+    struct fid_mr *fi_mr;
+    size_t buf_size;
+    na_size_t actual_buf_size;
+    fi_addr_t fi_addr;
     na_tag_t tag;
 };
 
-/* Expected recv info */
-struct na_ofi_info_recv_expected {
-    void *buf;
-    na_size_t buf_size;
-    na_size_t msg_size;
-    na_tag_t tag;
+/* RMA info */
+struct na_ofi_rma_info {
+    struct fi_msg_rma fi_rma;
+    struct fi_rma_iov remote_iov;
+    struct iovec local_iov;
+    void *local_desc;
 };
 
 /* Operation ID */
 struct na_ofi_op_id {
     struct na_cb_completion_data completion_data; /* Completion data    */
     union {
-        struct na_ofi_info_lookup lookup;
-        struct na_ofi_info_recv_unexpected recv_unexpected;
-        struct na_ofi_info_recv_expected recv_expected;
+        struct na_ofi_msg_info msg;
+        struct na_ofi_rma_info rma;
     } info;                                 /* Op info                  */
+    HG_QUEUE_ENTRY(na_ofi_op_id) entry;     /* Entry in queue           */
     struct fi_context fi_ctx;               /* Context handle           */
     na_context_t *context;                  /* NA context associated    */
     struct na_ofi_addr *addr;               /* Address associated       */
-    HG_QUEUE_ENTRY(na_ofi_op_id) entry;     /* Entry in queue           */
     hg_atomic_int32_t status;               /* Operation status         */
     hg_atomic_int32_t refcount;             /* Refcount                 */
 };
 
 /* Op queue */
 struct na_ofi_queue {
+    hg_thread_mutex_t mutex;
     HG_QUEUE_HEAD(na_ofi_op_id) queue;
-    hg_thread_spin_t lock;
 };
 
 /* Context */
 struct na_ofi_context {
-    struct fid_ep *fi_tx;                    /* Transmit context handle  */
-    struct fid_ep *fi_rx;                    /* Receive context handle   */
-    struct fid_cq *fi_cq;                    /* CQ handle                */
-    struct fid_wait *fi_wait;                /* Wait set handle          */
-    struct na_ofi_queue *unexpected_op_queue;/* Unexpected op queue     */
+    struct fid_ep *fi_tx;                   /* Transmit context handle  */
+    struct fid_ep *fi_rx;                   /* Receive context handle   */
+    struct fid_cq *fi_cq;                   /* CQ handle                */
+    struct fid_wait *fi_wait;               /* Wait set handle          */
+    struct na_ofi_queue *retry_op_queue;    /* Retry op queue           */
     na_uint8_t idx;                         /* Context index            */
 };
 
@@ -353,7 +354,7 @@ struct na_ofi_endpoint {
     struct fid_ep *fi_ep;                   /* Endpoint handle          */
     struct fid_wait *fi_wait;               /* Wait set handle          */
     struct fid_cq *fi_cq;                   /* CQ handle                */
-    struct na_ofi_queue *unexpected_op_queue;/* Unexpected op queue     */
+    struct na_ofi_queue *retry_op_queue;    /* Retry op queue           */
     na_bool_t sep;                          /* Scalable endpoint        */
 };
 
@@ -407,8 +408,8 @@ struct na_ofi_class {
     hg_thread_spin_t buf_pool_lock;         /* Buf pool lock            */
     na_uint8_t contexts;                    /* Number of context        */
     na_uint8_t max_contexts;                /* Max number of contexts   */
-    na_bool_t listen;                       /* Listening flag           */
     na_bool_t no_wait;                      /* Ignore wait object       */
+    na_bool_t no_retry;                     /* Do not retry operations  */
 };
 
 /********************/
@@ -671,20 +672,6 @@ static NA_INLINE void
 na_ofi_op_id_decref(struct na_ofi_op_id *na_ofi_op_id);
 
 /**
- * Push OP ID to unexpected queue.
- */
-static NA_INLINE void
-na_ofi_msg_unexpected_op_push(na_context_t *context,
-    struct na_ofi_op_id *na_ofi_op_id);
-
-/**
- * Remove OP ID from unexpected queue.
- */
-static NA_INLINE void
-na_ofi_msg_unexpected_op_remove(na_context_t *context,
-    struct na_ofi_op_id *na_ofi_op_id);
-
-/**
  * Read from CQ.
  */
 static na_return_t
@@ -696,7 +683,7 @@ na_ofi_cq_read(na_context_t *context, size_t max_count,
  * Process event from CQ.
  */
 static na_return_t
-na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
+na_ofi_cq_process_event(na_class_t *na_class,
     const struct fi_cq_tagged_entry *cq_event, fi_addr_t src_addr,
     void *err_addr, size_t err_addrlen);
 
@@ -711,7 +698,7 @@ na_ofi_cq_process_send_event(struct na_ofi_op_id *na_ofi_op_id);
  */
 static na_return_t
 na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
-    na_context_t *context, struct na_ofi_op_id *na_ofi_op_id,
+    struct na_ofi_op_id *na_ofi_op_id,
     fi_addr_t src_addr, void *src_err_addr, size_t src_err_addrlen,
     uint64_t tag, size_t len);
 
@@ -729,10 +716,16 @@ static NA_INLINE na_return_t
 na_ofi_cq_process_rma_event(struct na_ofi_op_id *na_ofi_op_id);
 
 /**
+ * Process retries.
+ */
+static na_return_t
+na_ofi_cq_process_retries(na_context_t *context);
+
+/**
  * Complete operation ID.
  */
 static na_return_t
-na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id, na_return_t ret);
+na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id);
 
 /**
  * Release OP ID resources.
@@ -782,6 +775,14 @@ na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
 static na_return_t
 na_ofi_addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr);
 
+/* addr_free */
+static NA_INLINE na_return_t
+na_ofi_addr_free(na_class_t *na_class, na_addr_t addr);
+
+/* addr_set_remove */
+static NA_INLINE na_return_t
+na_ofi_addr_set_remove(na_class_t *na_class, na_addr_t addr);
+
 /* addr_self */
 static NA_INLINE na_return_t
 na_ofi_addr_self(na_class_t *na_class, na_addr_t *addr);
@@ -790,13 +791,9 @@ na_ofi_addr_self(na_class_t *na_class, na_addr_t *addr);
 static NA_INLINE na_return_t
 na_ofi_addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr);
 
-/* addr_free */
-static NA_INLINE na_return_t
-na_ofi_addr_free(na_class_t *na_class, na_addr_t addr);
-
-/* addr_set_remove */
-static NA_INLINE na_return_t
-na_ofi_addr_set_remove(na_class_t *na_class, na_addr_t addr);
+/* addr_dup */
+static na_bool_t
+na_ofi_addr_cmp(na_class_t *na_class, na_addr_t addr1, na_addr_t addr2);
 
 /* addr_is_self */
 static NA_INLINE na_bool_t
@@ -956,6 +953,7 @@ const struct na_class_ops NA_PLUGIN_OPS(ofi) = {
     na_ofi_addr_set_remove,                 /* addr_set_remove */
     na_ofi_addr_self,                       /* addr_self */
     na_ofi_addr_dup,                        /* addr_dup */
+    na_ofi_addr_cmp,                        /* addr_cmp */
     na_ofi_addr_is_self,                    /* addr_is_self */
     na_ofi_addr_to_string,                  /* addr_to_string */
     na_ofi_addr_get_serialize_size,         /* addr_get_serialize_size */
@@ -1197,18 +1195,27 @@ na_ofi_addr_to_key(na_uint32_t addr_format, const void *addr, na_size_t len)
 {
     switch (addr_format) {
         case FI_SOCKADDR_IN:
-            assert(len == sizeof(struct na_ofi_sin_addr));
+            NA_CHECK_ERROR_NORET(len != sizeof(struct na_ofi_sin_addr), out,
+                "Addr len (%zu) does not match for FI_SOCKADDR_IN (%zu)",
+                len, sizeof(struct na_ofi_sin_addr));
             return na_ofi_sin_to_key((const struct na_ofi_sin_addr *) addr);
         case FI_ADDR_PSMX2:
-            assert(len == sizeof(struct na_ofi_psm2_addr));
+            NA_CHECK_ERROR_NORET(len != sizeof(struct na_ofi_psm2_addr), out,
+                "Addr len (%zu) does not match for FI_ADDR_PSMX2 (%zu)",
+                len, sizeof(struct na_ofi_psm2_addr));
             return na_ofi_psm2_to_key((const struct na_ofi_psm2_addr *) addr);
         case FI_ADDR_GNI:
-            assert(len == sizeof(struct na_ofi_gni_addr));
+            NA_CHECK_ERROR_NORET(len != sizeof(struct na_ofi_gni_addr), out,
+                "Addr len (%zu) does not match for FI_ADDR_GNI (%zu)",
+                len, sizeof(struct na_ofi_gni_addr));
             return na_ofi_gni_to_key((const struct na_ofi_gni_addr *) addr);
         default:
             NA_LOG_ERROR("Unsupported address format");
-            return 0;
+            break;
     }
+
+out:
+    return 0;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2003,11 +2010,11 @@ na_ofi_basic_ep_open(const struct na_ofi_domain *na_ofi_domain,
         "fi_endpoint() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Initialize queue / mutex */
-    na_ofi_endpoint->unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
-    NA_CHECK_ERROR(na_ofi_endpoint->unexpected_op_queue == NULL, out,
-        ret, NA_NOMEM, "Could not allocate unexpected_op_queue");
-    HG_QUEUE_INIT(&na_ofi_endpoint->unexpected_op_queue->queue);
-    hg_thread_spin_init(&na_ofi_endpoint->unexpected_op_queue->lock);
+    na_ofi_endpoint->retry_op_queue = malloc(sizeof(struct na_ofi_queue));
+    NA_CHECK_ERROR(na_ofi_endpoint->retry_op_queue == NULL, out,
+        ret, NA_NOMEM, "Could not allocate retry_op_queue");
+    HG_QUEUE_INIT(&na_ofi_endpoint->retry_op_queue->queue);
+    hg_thread_mutex_init(&na_ofi_endpoint->retry_op_queue->mutex);
 
     if (!no_wait) {
         if (na_ofi_prov_flags[na_ofi_domain->prov_type] & NA_OFI_WAIT_FD)
@@ -2097,14 +2104,14 @@ na_ofi_endpoint_close(struct na_ofi_endpoint *na_ofi_endpoint)
         goto out;
 
     /* When not using SEP */
-    if (na_ofi_endpoint->unexpected_op_queue) {
+    if (na_ofi_endpoint->retry_op_queue) {
         /* Check that unexpected op queue is empty */
         na_bool_t empty = HG_QUEUE_IS_EMPTY(
-            &na_ofi_endpoint->unexpected_op_queue->queue);
+            &na_ofi_endpoint->retry_op_queue->queue);
         NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_BUSY,
-            "Unexpected op queue should be empty");
-        hg_thread_spin_destroy(&na_ofi_endpoint->unexpected_op_queue->lock);
-        free(na_ofi_endpoint->unexpected_op_queue);
+            "Retry op queue should be empty");
+        hg_thread_mutex_destroy(&na_ofi_endpoint->retry_op_queue->mutex);
+        free(na_ofi_endpoint->retry_op_queue);
     }
 
     /* Close endpoint */
@@ -2180,7 +2187,6 @@ retry:
 
     na_ofi_addr->addr = addr;
     na_ofi_addr->addrlen = addrlen;
-    na_ofi_addr->self = NA_TRUE;
 
     /* Get URI from address */
     ret = na_ofi_get_uri(na_class, na_ofi_addr->addr, &na_ofi_addr->uri);
@@ -2268,7 +2274,6 @@ out:
 static NA_INLINE void
 na_ofi_addr_addref(struct na_ofi_addr *na_ofi_addr)
 {
-    assert(hg_atomic_get32(&na_ofi_addr->refcount));
     hg_atomic_incr32(&na_ofi_addr->refcount);
 }
 
@@ -2276,8 +2281,6 @@ na_ofi_addr_addref(struct na_ofi_addr *na_ofi_addr)
 static NA_INLINE void
 na_ofi_addr_decref(struct na_ofi_addr *na_ofi_addr)
 {
-    assert(hg_atomic_get32(&na_ofi_addr->refcount) > 0);
-
     /* If there are more references, return */
     if (hg_atomic_decr32(&na_ofi_addr->refcount))
         return;
@@ -2470,11 +2473,7 @@ na_ofi_mem_pool_free(na_class_t *na_class, void *mem_ptr, struct fid_mr *mr_hdl)
 static NA_INLINE void
 na_ofi_op_id_addref(struct na_ofi_op_id *na_ofi_op_id)
 {
-    /* init as 1 when op_create */
-    assert(hg_atomic_get32(&na_ofi_op_id->refcount));
     hg_atomic_incr32(&na_ofi_op_id->refcount);
-
-    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2484,41 +2483,12 @@ na_ofi_op_id_decref(struct na_ofi_op_id *na_ofi_op_id)
     if (na_ofi_op_id == NULL)
         return;
 
-    assert(hg_atomic_get32(&na_ofi_op_id->refcount) > 0);
-
     /* If there are more references, return */
     if (hg_atomic_decr32(&na_ofi_op_id->refcount))
         return;
 
     /* No more references, cleanup */
     free(na_ofi_op_id);
-
-    return;
-}
-
-/*---------------------------------------------------------------------------*/
-static NA_INLINE void
-na_ofi_msg_unexpected_op_push(na_context_t *context,
-    struct na_ofi_op_id *na_ofi_op_id)
-{
-    struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-
-    hg_thread_spin_lock(&ctx->unexpected_op_queue->lock);
-    HG_QUEUE_PUSH_TAIL(&ctx->unexpected_op_queue->queue, na_ofi_op_id, entry);
-    hg_thread_spin_unlock(&ctx->unexpected_op_queue->lock);
-}
-
-/*---------------------------------------------------------------------------*/
-static NA_INLINE void
-na_ofi_msg_unexpected_op_remove(na_context_t *context,
-    struct na_ofi_op_id *na_ofi_op_id)
-{
-    struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-
-    hg_thread_spin_lock(&ctx->unexpected_op_queue->lock);
-    HG_QUEUE_REMOVE(&ctx->unexpected_op_queue->queue, na_ofi_op_id,
-        na_ofi_op_id, entry);
-    hg_thread_spin_unlock(&ctx->unexpected_op_queue->lock);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2572,14 +2542,8 @@ na_ofi_cq_read(na_context_t *context, size_t max_count,
                 !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_CANCELED),
                 out, ret, NA_FAULT, "Operation ID was not canceled");
 
-            if (na_ofi_op_id->completion_data.callback_info.type
-                == NA_CB_RECV_UNEXPECTED) {
-                /* Remove OP ID from OP queue if canceled */
-                na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
-            }
-
             /* Complete operation in canceled state */
-            ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
+            ret = na_ofi_complete(na_ofi_op_id);
             NA_CHECK_NA_ERROR(out, ret, "Unable to complete operation");
          }
             break;
@@ -2607,7 +2571,7 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
+na_ofi_cq_process_event(na_class_t *na_class,
     const struct fi_cq_tagged_entry *cq_event, fi_addr_t src_addr,
     void *src_err_addr, size_t src_err_addrlen)
 {
@@ -2625,17 +2589,17 @@ na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
         ret = na_ofi_cq_process_send_event(na_ofi_op_id);
         NA_CHECK_NA_ERROR(out, ret, "Could not process send event");
     } else if (cq_event->flags & FI_RECV) {
-        if (cq_event->tag & ~NA_OFI_UNEXPECTED_TAG_IGNORE) {
-            ret = na_ofi_cq_process_recv_expected_event(na_ofi_op_id,
+        if (cq_event->tag & NA_OFI_UNEXPECTED_TAG) {
+            ret = na_ofi_cq_process_recv_unexpected_event(na_class,
+                na_ofi_op_id, src_addr, src_err_addr, src_err_addrlen,
                 cq_event->tag, cq_event->len);
             NA_CHECK_NA_ERROR(out, ret,
-                "Could not process expected recv event");
+                "Could not process unexpected recv event");
         } else {
-            ret = na_ofi_cq_process_recv_unexpected_event(na_class, context,
-                na_ofi_op_id, src_addr, src_err_addr, src_err_addrlen,
+            ret = na_ofi_cq_process_recv_expected_event(na_ofi_op_id,
                 cq_event->tag, cq_event->len);
             NA_CHECK_NA_ERROR(out, ret,
-                "Could not process unexpected recv event");
+                "Could not process expected recv event");
         }
     } else if (cq_event->flags & FI_RMA) {
         ret = na_ofi_cq_process_rma_event(na_ofi_op_id);
@@ -2645,7 +2609,7 @@ na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
             "Unsupported CQ event flags: 0x%x.", cq_event->flags);
 
     /* Complete operation */
-    ret = na_ofi_complete(na_ofi_op_id, ret);
+    ret = na_ofi_complete(na_ofi_op_id);
     NA_CHECK_NA_ERROR(out, ret, "Unable to complete operation");
 
 out:
@@ -2670,9 +2634,8 @@ out:
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
-    na_context_t *context, struct na_ofi_op_id *na_ofi_op_id,
-    fi_addr_t src_addr, void *src_err_addr, size_t src_err_addrlen,
-    uint64_t tag, size_t len)
+    struct na_ofi_op_id *na_ofi_op_id, fi_addr_t src_addr, void *src_err_addr,
+    size_t src_err_addrlen, uint64_t tag, size_t len)
 {
     struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
@@ -2682,8 +2645,8 @@ na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
     NA_CHECK_ERROR(cb_type != NA_CB_RECV_UNEXPECTED, out, ret,
         NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_RECV_UNEXPECTED",
         cb_type);
-    NA_CHECK_ERROR(tag > NA_OFI_MAX_TAG, out, ret, NA_OVERFLOW,
-        "Invalid tag value");
+    NA_CHECK_ERROR((tag & ~NA_OFI_UNEXPECTED_TAG) > NA_OFI_MAX_TAG, out, ret,
+        NA_OVERFLOW, "Invalid tag value %llu", tag);
 
     /* Allocate new address */
     na_ofi_addr = na_ofi_addr_alloc(domain);
@@ -2704,19 +2667,19 @@ na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
     } else if (na_ofi_with_msg_hdr(na_class)) { /* addr from msg header */
         /* We do not need to keep a copy of msg header */
         ret = na_ofi_addr_ht_lookup(domain, FI_SOCKADDR_IN,
-            na_ofi_op_id->info.recv_unexpected.buf,
-            sizeof(struct na_ofi_sin_addr), &na_ofi_addr->fi_addr,
-            &na_ofi_addr->ht_key);
+            na_ofi_op_id->info.msg.buf.ptr, sizeof(struct na_ofi_sin_addr),
+            &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
         NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
     } else
         NA_GOTO_ERROR(error, ret, NA_PROTONOSUPPORT,
             "Insufficient address information");
 
-    na_ofi_addr_addref(na_ofi_addr); /* decref in addr_free() */
     na_ofi_op_id->addr = na_ofi_addr;
-    na_ofi_op_id->info.recv_unexpected.tag = (na_tag_t) tag;
-    na_ofi_op_id->info.recv_unexpected.msg_size = len;
-    na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
+    na_ofi_op_id->info.msg.tag = tag & NA_OFI_TAG_MASK;
+    na_ofi_op_id->info.msg.actual_buf_size = len;
+
+    NA_LOG_DEBUG("Received unexpected message with tag=%llu, len=%zu",
+        tag, len);
 
 out:
     return ret;
@@ -2737,13 +2700,12 @@ na_ofi_cq_process_recv_expected_event(struct na_ofi_op_id *na_ofi_op_id,
     NA_CHECK_ERROR(cb_type != NA_CB_RECV_EXPECTED, out, ret,
         NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_RECV_EXPECTED",
         cb_type);
-    NA_CHECK_ERROR(na_ofi_op_id->info.recv_expected.tag
-        != (tag & ~NA_OFI_EXPECTED_TAG_FLAG), out, ret, NA_INVALID_ARG,
-        "Invalid tag 0x%x, expected 0x%x",
-        na_ofi_op_id->info.recv_expected.tag,
-        tag & ~NA_OFI_EXPECTED_TAG_FLAG);
+    NA_CHECK_ERROR(tag > NA_OFI_MAX_TAG, out, ret, NA_OVERFLOW,
+        "Invalid tag value");
 
-    na_ofi_op_id->info.recv_expected.msg_size = len;
+    na_ofi_op_id->info.msg.actual_buf_size = len;
+
+    NA_LOG_DEBUG("Received expected message with tag=%llu, len=%zu", tag, len);
 
 out:
     return ret;
@@ -2766,55 +2728,151 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id, na_return_t op_ret)
+na_ofi_cq_process_retries(na_context_t *context)
 {
-    struct na_ofi_addr *na_ofi_addr = na_ofi_op_id->addr;
-    struct na_cb_info *callback_info = NULL;
-#if defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
-    hg_util_int32_t status;
-#endif
+    struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     na_return_t ret = NA_SUCCESS;
 
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
-    /* Mark op id as completed before checking for cancelation */
-    hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
-#else
     do {
-        status = hg_atomic_get32(&na_ofi_op_id->status);
-    } while (!hg_atomic_cas32(&na_ofi_op_id->status, status,
-        (status | NA_OFI_OP_COMPLETED)));
-#endif
+        struct na_ofi_op_id *na_ofi_op_id = NULL;
+        ssize_t rc = 0;
 
-    /* If it was canceled while being processed, set callback ret accordingly */
-    if (hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_CANCELED) {
+        hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+
+        na_ofi_op_id = HG_QUEUE_FIRST(&ctx->retry_op_queue->queue);
+        if (!na_ofi_op_id)
+            break;
+
+        NA_LOG_DEBUG("Attempting to retry %p", na_ofi_op_id);
+        NA_CHECK_ERROR(
+            hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_CANCELED,
+            out, ret, NA_FAULT, "Operation ID was canceled");
+
+        /* Dequeue OP ID */
+        HG_QUEUE_POP_HEAD(&ctx->retry_op_queue->queue, entry);
+        hg_atomic_and32(&na_ofi_op_id->status, ~NA_OFI_OP_QUEUED);
+
+        /* Retry operation */
+        switch (na_ofi_op_id->completion_data.callback_info.type) {
+            case NA_CB_SEND_UNEXPECTED:
+                rc = fi_tsend(ctx->fi_tx, na_ofi_op_id->info.msg.buf.const_ptr,
+                    na_ofi_op_id->info.msg.buf_size,
+                    na_ofi_op_id->info.msg.fi_mr,
+                    na_ofi_op_id->info.msg.fi_addr,
+                    na_ofi_op_id->info.msg.tag | NA_OFI_UNEXPECTED_TAG,
+                    &na_ofi_op_id->fi_ctx);
+                break;
+            case NA_CB_RECV_UNEXPECTED:
+                rc = fi_trecv(ctx->fi_rx, na_ofi_op_id->info.msg.buf.ptr,
+                    na_ofi_op_id->info.msg.buf_size,
+                    na_ofi_op_id->info.msg.fi_mr,
+                    na_ofi_op_id->info.msg.fi_addr,
+                    NA_OFI_UNEXPECTED_TAG, NA_OFI_TAG_MASK,
+                    &na_ofi_op_id->fi_ctx);
+                break;
+            case NA_CB_SEND_EXPECTED:
+                rc = fi_tsend(ctx->fi_tx, na_ofi_op_id->info.msg.buf.const_ptr,
+                    na_ofi_op_id->info.msg.buf_size,
+                    na_ofi_op_id->info.msg.fi_mr,
+                    na_ofi_op_id->info.msg.fi_addr, na_ofi_op_id->info.msg.tag,
+                    &na_ofi_op_id->fi_ctx);
+                break;
+            case NA_CB_RECV_EXPECTED:
+                rc = fi_trecv(ctx->fi_rx, na_ofi_op_id->info.msg.buf.ptr,
+                    na_ofi_op_id->info.msg.buf_size,
+                    na_ofi_op_id->info.msg.fi_mr,
+                    na_ofi_op_id->info.msg.fi_addr, na_ofi_op_id->info.msg.tag,
+                    0, &na_ofi_op_id->fi_ctx);
+                break;
+            case NA_CB_PUT:
+                rc = fi_writemsg(ctx->fi_tx, &na_ofi_op_id->info.rma.fi_rma,
+                    NA_OFI_PUT_COMPLETION);
+                break;
+            case NA_CB_GET:
+                rc = fi_readmsg(ctx->fi_tx, &na_ofi_op_id->info.rma.fi_rma,
+                    NA_OFI_GET_COMPLETION);
+                break;
+            case NA_CB_LOOKUP:
+            default:
+                NA_GOTO_ERROR(out, ret, NA_INVALID_ARG,
+                    "Operation type %d not supported",
+                    na_ofi_op_id->completion_data.callback_info.type);
+        }
+
+        if (unlikely(rc == -FI_EAGAIN)) {
+            NA_LOG_DEBUG("Re-pushing %p for retry", na_ofi_op_id);
+
+            /* Re-push op ID to retry queue */
+            HG_QUEUE_PUSH_TAIL(&NA_OFI_CONTEXT(context)->retry_op_queue->queue,
+                na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+
+            /* Do not attempt to retry again and continue making progress */
+            break;
+        } else
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_tsend() unexpected failed, rc: %d(%s)", rc,
+                fi_strerror((int ) -rc));
+
+        hg_thread_mutex_unlock(&NA_OFI_CONTEXT(context)->retry_op_queue->mutex);
+
+    } while (1);
+
+out:
+    hg_thread_mutex_unlock(&NA_OFI_CONTEXT(context)->retry_op_queue->mutex);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id)
+{
+    struct na_cb_info *callback_info = NULL;
+    na_bool_t canceled = NA_FALSE;
+    na_return_t ret = NA_SUCCESS;
+
+    /* Mark op id as completed before checking for cancelation */
+    if (hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED)
+        & NA_OFI_OP_CANCELED) {
+        /* If it was canceled while being processed, set callback ret accordingly */
         NA_LOG_DEBUG("Operation ID %p was canceled", na_ofi_op_id);
-        op_ret = (op_ret == NA_SUCCESS) ? NA_CANCELED : op_ret;
+        canceled = NA_TRUE;
     }
 
     /* Init callback info */
     callback_info = &na_ofi_op_id->completion_data.callback_info;
-    callback_info->ret = op_ret;
+    callback_info->ret = (canceled) ? NA_CANCELED : ret;
 
     switch (callback_info->type) {
         case NA_CB_LOOKUP:
-            callback_info->info.lookup.addr =
-                na_ofi_op_id->info.lookup.addr;
+            callback_info->info.lookup.addr = (na_addr_t) na_ofi_op_id->addr;
             break;
         case NA_CB_RECV_UNEXPECTED:
-            /* Fill callback info */
-            callback_info->info.recv_unexpected.actual_buf_size =
-                na_ofi_op_id->info.recv_unexpected.msg_size;
-            callback_info->info.recv_unexpected.source =
-                na_ofi_op_id->addr;
-            callback_info->info.recv_unexpected.tag =
-                na_ofi_op_id->info.recv_unexpected.tag;
+            if (canceled) {
+                /* In case of cancellation where no recv'd data */
+                callback_info->info.recv_unexpected.actual_buf_size = 0;
+                callback_info->info.recv_unexpected.source = NA_ADDR_NULL;
+                callback_info->info.recv_unexpected.tag = 0;
+            } else {
+                /* Increment addr ref count */
+                na_ofi_addr_addref(na_ofi_op_id->addr);
+
+                /* Fill callback info */
+                callback_info->info.recv_unexpected.actual_buf_size =
+                    na_ofi_op_id->info.msg.actual_buf_size;
+                callback_info->info.recv_unexpected.source =
+                    (na_addr_t) na_ofi_op_id->addr;
+                callback_info->info.recv_unexpected.tag =
+                    na_ofi_op_id->info.msg.tag;
+            }
             break;
         case NA_CB_RECV_EXPECTED:
             /* Check buf_size and msg_size */
             NA_CHECK_ERROR(
-                na_ofi_op_id->info.recv_expected.msg_size >
-            na_ofi_op_id->info.recv_expected.buf_size, out, ret,
-            NA_MSGSIZE, "Expected recv msg size too large for buffer");
+                na_ofi_op_id->info.msg.actual_buf_size
+                    > na_ofi_op_id->info.msg.buf_size, out, ret, NA_MSGSIZE,
+                "Expected recv msg size too large for buffer");
             break;
         case NA_CB_SEND_UNEXPECTED:
         case NA_CB_SEND_EXPECTED:
@@ -2830,12 +2888,9 @@ na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id, na_return_t op_ret)
     /* Add OP to NA completion queue */
     ret = na_cb_completion_add(na_ofi_op_id->context,
         &na_ofi_op_id->completion_data);
-    NA_CHECK_NA_ERROR(out, ret,
-        "Could not add callback to completion queue");
+    NA_CHECK_NA_ERROR(out, ret, "Could not add callback to completion queue");
 
 out:
-    if (na_ofi_addr)
-        na_ofi_addr_decref(na_ofi_addr);
     return ret;
 }
 
@@ -2849,6 +2904,10 @@ na_ofi_release(void *arg)
         (!(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED)),
         "Releasing resources from an uncompleted operation");
 
+    if (na_ofi_op_id->addr) {
+        na_ofi_addr_decref(na_ofi_op_id->addr);
+        na_ofi_op_id->addr = NULL;
+    }
     na_ofi_op_id_decref(na_ofi_op_id);
 }
 
@@ -2895,7 +2954,7 @@ out:
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
-    na_bool_t listen)
+    na_bool_t NA_UNUSED listen)
 {
     struct na_ofi_class *priv;
     void *src_addr = NULL;
@@ -2907,7 +2966,7 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     char node[NA_OFI_MAX_URI_LEN] = {'\0'};
     char *domain_name_ptr = NULL;
     char domain_name[NA_OFI_MAX_URI_LEN] = {'\0'};
-    na_bool_t no_wait = NA_FALSE;
+    na_bool_t no_wait = NA_FALSE, no_retry = NA_FALSE;
     na_uint8_t max_contexts = 1; /* Default */
     const char *auth_key = NULL;
     na_return_t ret = NA_SUCCESS;
@@ -3007,8 +3066,10 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     /* Get init info */
     if (na_info->na_init_info) {
         /* Progress mode */
-        if (na_info->na_init_info->progress_mode == NA_NO_BLOCK)
+        if (na_info->na_init_info->progress_mode & NA_NO_BLOCK)
             no_wait = NA_TRUE;
+        if (na_info->na_init_info->progress_mode & NA_NO_RETRY)
+            no_retry = NA_TRUE;
         /* Max contexts */
         max_contexts = na_info->na_init_info->max_contexts;
         /* Auth key */
@@ -3023,7 +3084,7 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     memset(na_class->plugin_class, 0, sizeof(struct na_ofi_class));
     priv = NA_OFI_CLASS(na_class);
     priv->no_wait = no_wait;
-    priv->listen = listen;
+    priv->no_retry = no_retry;
     priv->max_contexts = max_contexts;
     priv->contexts = 0;
 
@@ -3131,15 +3192,15 @@ na_ofi_context_create(na_class_t *na_class, void **context, na_uint8_t id)
         ctx->fi_rx = ep->fi_ep;
         ctx->fi_cq = ep->fi_cq;
         ctx->fi_wait = ep->fi_wait;
-        ctx->unexpected_op_queue = ep->unexpected_op_queue;
+        ctx->retry_op_queue = ep->retry_op_queue;
     } else {
-        ctx->unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
-        NA_CHECK_ERROR(ctx->unexpected_op_queue == NULL, error, ret,
-            NA_NOMEM, "Could not allocate unexpected_op_queue/_lock");
+        ctx->retry_op_queue = malloc(sizeof(struct na_ofi_queue));
+        NA_CHECK_ERROR(ctx->retry_op_queue == NULL, error, ret,
+            NA_NOMEM, "Could not allocate retry_op_queue/_lock");
 
         /* Initialize queue / mutex */
-        HG_QUEUE_INIT(&ctx->unexpected_op_queue->queue);
-        hg_thread_spin_init(&ctx->unexpected_op_queue->lock);
+        HG_QUEUE_INIT(&ctx->retry_op_queue->queue);
+        hg_thread_mutex_init(&ctx->retry_op_queue->mutex);
 
         NA_CHECK_ERROR(priv->contexts >= priv->max_contexts ||
             id >= priv->max_contexts, error, ret, NA_OPNOTSUPPORTED,
@@ -3204,9 +3265,9 @@ out:
 
 error:
     hg_thread_mutex_unlock(&priv->mutex);
-    if (na_ofi_with_sep(na_class) && ctx->unexpected_op_queue) {
-        hg_thread_spin_destroy(&ctx->unexpected_op_queue->lock);
-        free(ctx->unexpected_op_queue);
+    if (na_ofi_with_sep(na_class) && ctx->retry_op_queue) {
+        hg_thread_mutex_destroy(&ctx->retry_op_queue->mutex);
+        free(ctx->retry_op_queue);
     }
     free(ctx);
     return ret;
@@ -3221,14 +3282,14 @@ na_ofi_context_destroy(na_class_t *na_class, void *context)
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    /* Check that unexpected op queue is empty */
     if (na_ofi_with_sep(na_class)) {
-        na_bool_t empty = HG_QUEUE_IS_EMPTY(&ctx->unexpected_op_queue->queue);
+        na_bool_t empty;
+
+        /* Check that retry op queue is empty */
+        empty = HG_QUEUE_IS_EMPTY(&ctx->retry_op_queue->queue);
         NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_BUSY,
-            "Unexpected op queue should be empty");
-    }
+            "Retry op queue should be empty");
 
-    if (na_ofi_with_sep(na_class)) {
         if (ctx->fi_tx) {
             rc = fi_close(&ctx->fi_tx->fid);
             NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
@@ -3259,8 +3320,8 @@ na_ofi_context_destroy(na_class_t *na_class, void *context)
             ctx->fi_cq = NULL;
         }
 
-        hg_thread_spin_destroy(&ctx->unexpected_op_queue->lock);
-        free(ctx->unexpected_op_queue);
+        hg_thread_mutex_destroy(&ctx->retry_op_queue->mutex);
+        free(ctx->retry_op_queue);
     }
 
     hg_thread_mutex_lock(&priv->mutex);
@@ -3320,24 +3381,30 @@ na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
         out, ret, NA_INVALID_ARG, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-    na_ofi_op_id_addref(na_ofi_op_id);
+    NA_CHECK_ERROR(
+        !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED), out,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_ofi_op_id->context = context;
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_LOOKUP;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
+    na_ofi_op_id->addr = NULL;
     hg_atomic_set32(&na_ofi_op_id->status, 0);
 
     /* Lookup addr */
     ret = na_ofi_addr_lookup2(na_class, name, (na_addr_t *) &na_ofi_addr);
     NA_CHECK_NA_ERROR(error, ret, "Could not lookup %s", name);
 
-    /* One extra refcount to be decref in na_ofi_complete(). */
+    /* One extra refcount to be decref in na_ofi_complete() */
     na_ofi_addr_addref(na_ofi_addr);
     na_ofi_op_id->addr = na_ofi_addr;
-    na_ofi_op_id->info.lookup.addr = (na_addr_t) na_ofi_addr;
 
     /* As the fi_av_insert is blocking, always complete here */
-    ret = na_ofi_complete(na_ofi_op_id, ret);
+    ret = na_ofi_complete(na_ofi_op_id);
     NA_CHECK_NA_ERROR(error, ret, "Could not complete operation");
 
 out:
@@ -3399,10 +3466,27 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_return_t
+na_ofi_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t addr)
+{
+    na_ofi_addr_decref((struct na_ofi_addr *) addr);
+
+    return NA_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
+na_ofi_addr_set_remove(na_class_t NA_UNUSED *na_class, na_addr_t addr)
+{
+    ((struct na_ofi_addr *) addr)->remove = NA_TRUE;
+
+    return NA_SUCCESS;
+}
+
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
 na_ofi_addr_self(na_class_t *na_class, na_addr_t *addr)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_endpoint *ep = priv->endpoint;
+    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->endpoint;
 
     na_ofi_addr_addref(ep->src_addr); /* decref in na_ofi_addr_free() */
     *addr = ep->src_addr;
@@ -3424,28 +3508,56 @@ na_ofi_addr_dup(na_class_t NA_UNUSED *na_class, na_addr_t addr,
 }
 
 /*---------------------------------------------------------------------------*/
-static NA_INLINE na_return_t
-na_ofi_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t addr)
+static na_bool_t
+na_ofi_addr_cmp(na_class_t NA_UNUSED *na_class, na_addr_t addr1,
+    na_addr_t addr2)
 {
-    na_ofi_addr_decref((struct na_ofi_addr *) addr);
+    struct na_ofi_addr *na_ofi_addr1 = (struct na_ofi_addr *) addr1;
+    struct na_ofi_addr *na_ofi_addr2 = (struct na_ofi_addr *) addr2;
 
-    return NA_SUCCESS;
-}
+    if ((na_ofi_addr1 == na_ofi_addr2)
+        || (na_ofi_addr1->fi_addr == na_ofi_addr2->fi_addr))
+        return NA_TRUE;
 
-/*---------------------------------------------------------------------------*/
-static NA_INLINE na_return_t
-na_ofi_addr_set_remove(na_class_t NA_UNUSED *na_class, na_addr_t addr)
-{
-    ((struct na_ofi_addr *) addr)->remove = NA_TRUE;
+    /* If we don't have the addr, look it up from AV */
+    if (!na_ofi_addr1->addr) {
+        na_return_t na_ret = na_ofi_av_lookup(na_ofi_addr1->domain,
+            na_ofi_addr1->fi_addr, &na_ofi_addr1->addr, &na_ofi_addr1->addrlen);
+        NA_CHECK_NA_ERROR(out, na_ret, "Could not get addr from AV");
+    }
+    if (!na_ofi_addr2->addr) {
+        na_return_t na_ret = na_ofi_av_lookup(na_ofi_addr2->domain,
+            na_ofi_addr2->fi_addr, &na_ofi_addr2->addr, &na_ofi_addr2->addrlen);
+        NA_CHECK_NA_ERROR(out, na_ret, "Could not get addr from AV");
+    }
 
-    return NA_SUCCESS;
+    if ((na_ofi_addr1->addrlen == na_ofi_addr2->addrlen)
+        && (memcmp(na_ofi_addr1->addr, na_ofi_addr2->addr,
+            na_ofi_addr1->addrlen) == 0))
+        return NA_TRUE;
+
+out:
+    return NA_FALSE;
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
-na_ofi_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
+na_ofi_addr_is_self(na_class_t *na_class, na_addr_t addr)
 {
-    return ((struct na_ofi_addr *) addr)->self;
+    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->endpoint;
+    struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) addr;
+
+    if (ep->src_addr == na_ofi_addr)
+        goto done;
+
+    if (ep->src_addr->addrlen != na_ofi_addr->addrlen)
+        return NA_FALSE;
+
+    if (memcmp(ep->src_addr->addr, na_ofi_addr->addr, na_ofi_addr->addrlen))
+        return NA_FALSE;
+
+done:
+    return NA_TRUE;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3518,6 +3630,7 @@ na_ofi_addr_serialize(na_class_t NA_UNUSED *na_class, void *buf,
     na_size_t buf_size, na_addr_t addr)
 {
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) addr;
+    na_uint8_t *p = buf;
     na_size_t len;
     na_return_t ret = NA_SUCCESS;
 
@@ -3536,9 +3649,9 @@ na_ofi_addr_serialize(na_class_t NA_UNUSED *na_class, void *buf,
         "Buffer size too small for serializing address");
 
     /* TODO could skip the addrlen but include it for sanity check */
-    memcpy(buf, &na_ofi_addr->addrlen, sizeof(na_ofi_addr->addrlen));
-    memcpy((na_uint8_t *) buf + sizeof(na_ofi_addr->addrlen), na_ofi_addr->addr,
-        na_ofi_addr->addrlen);
+    memcpy(p, &na_ofi_addr->addrlen, sizeof(na_ofi_addr->addrlen));
+    p += sizeof(na_ofi_addr->addrlen);
+    memcpy(p, na_ofi_addr->addr, na_ofi_addr->addrlen);
 
 out:
     return ret;
@@ -3551,20 +3664,20 @@ na_ofi_addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
 {
     struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     struct na_ofi_addr *na_ofi_addr = NULL;
+    const na_uint8_t *p = buf;
     na_return_t ret = NA_SUCCESS;
 
     /* Allocate addr */
     na_ofi_addr = na_ofi_addr_alloc(domain);
     NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM,
         "na_ofi_addr_alloc() failed");
-    memcpy(&na_ofi_addr->addrlen, buf, sizeof(na_ofi_addr->addrlen));
+    memcpy(&na_ofi_addr->addrlen, p, sizeof(na_ofi_addr->addrlen));
+    p += sizeof(na_ofi_addr->addrlen);
 
     na_ofi_addr->addr = malloc(na_ofi_addr->addrlen);
     NA_CHECK_ERROR(na_ofi_addr->addr == NULL, error, ret, NA_NOMEM,
         "Could not allocate %zu bytes for address", na_ofi_addr->addrlen);
-    memcpy(na_ofi_addr->addr,
-        (const na_uint8_t *) buf + sizeof(na_ofi_addr->addrlen),
-        na_ofi_addr->addrlen);
+    memcpy(na_ofi_addr->addr, p, na_ofi_addr->addrlen);
 
     /* Skip URI generation, URI will only be generated when needed */
 
@@ -3680,6 +3793,8 @@ na_ofi_msg_buf_free(na_class_t *na_class, void *buf, void *plugin_data)
 static na_return_t
 na_ofi_msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
 {
+    na_return_t ret = NA_SUCCESS;
+
     /*
      * For those providers that don't support FI_SOURCE/FI_SOURCE_ERR, insert
      * the msg header to piggyback the source address for unexpected message.
@@ -3689,26 +3804,25 @@ na_ofi_msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
         struct na_ofi_sin_addr *na_ofi_sin_addr =
             (struct na_ofi_sin_addr *) priv->endpoint->src_addr->addr;
 
-        assert(buf_size > sizeof(*na_ofi_sin_addr));
+        NA_CHECK_ERROR(buf_size < sizeof(*na_ofi_sin_addr), out, ret,
+            NA_OVERFLOW, "Buffer size too small to copy addr");
         memcpy(buf, na_ofi_sin_addr, sizeof(*na_ofi_sin_addr));
     }
 
-    return NA_SUCCESS;
+out:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
-    na_context_t *context, na_cb_t callback, void *arg, const void *buf,
-    na_size_t buf_size, void *plugin_data, na_addr_t dest_addr,
-    na_uint8_t dest_id, na_tag_t tag, na_op_id_t *op_id)
+na_ofi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
+    void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
+    na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) dest_addr;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
-    struct fid_mr *mr_hdl = plugin_data;
-    fi_addr_t fi_addr;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
@@ -3718,31 +3832,54 @@ na_ofi_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
         out, ret, NA_INVALID_ARG, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-    na_ofi_op_id_addref(na_ofi_op_id);
+    NA_CHECK_ERROR(
+        !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED), out,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_ofi_op_id->context = context;
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_SEND_UNEXPECTED;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
-    na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
+    na_ofi_addr_addref(na_ofi_addr);
     na_ofi_op_id->addr = na_ofi_addr;
     hg_atomic_set32(&na_ofi_op_id->status, 0);
-
+    /* We assume buf remains valid (safe because we pre-allocate buffers) */
+    na_ofi_op_id->info.msg.buf.const_ptr = buf;
+    na_ofi_op_id->info.msg.buf_size = buf_size;
+    na_ofi_op_id->info.msg.actual_buf_size = buf_size;
     /* Specify target receive context */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.msg.fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id,
+        NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.msg.fi_mr = plugin_data;
+    na_ofi_op_id->info.msg.tag = tag;
+
+    NA_LOG_DEBUG("Sending unexpected msg with tag=%llu",
+        tag | NA_OFI_UNEXPECTED_TAG);
 
     /* Post the FI unexpected send request */
-    do {
-        rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr, tag,
-            &na_ofi_op_id->fi_ctx);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
-        "fi_tsend() unexpected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+    rc = fi_tsend(ctx->fi_tx, buf, buf_size, na_ofi_op_id->info.msg.fi_mr,
+        na_ofi_op_id->info.msg.fi_addr, tag | NA_OFI_UNEXPECTED_TAG,
+        &na_ofi_op_id->fi_ctx);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_tsend() unexpected failed, rc: %d(%s)", rc,
+            fi_strerror((int ) -rc));
 
 out:
     return ret;
@@ -3756,14 +3893,12 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_recv_unexpected(na_class_t NA_UNUSED *na_class,
-    na_context_t *context, na_cb_t callback, void *arg, void *buf,
-    na_size_t buf_size, void *plugin_data, na_op_id_t *op_id)
+na_ofi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
+    void *plugin_data, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->fi_rx;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
-    struct fid_mr *mr_hdl = plugin_data;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
@@ -3773,37 +3908,53 @@ na_ofi_msg_recv_unexpected(na_class_t NA_UNUSED *na_class,
         out, ret, NA_INVALID_ARG, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-    na_ofi_op_id_addref(na_ofi_op_id);
+    NA_CHECK_ERROR(
+        !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED), out,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_ofi_op_id->context = context;
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_RECV_UNEXPECTED;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
-    na_ofi_op_id->addr = NULL; /* Make sure the addr is reset */
+    na_ofi_op_id->addr = NULL;
     hg_atomic_set32(&na_ofi_op_id->status, 0);
-    na_ofi_op_id->info.recv_unexpected.buf = buf;
-    na_ofi_op_id->info.recv_unexpected.buf_size = buf_size;
-
-    na_ofi_msg_unexpected_op_push(context, na_ofi_op_id);
+    /* We assume buf remains valid (safe because we pre-allocate buffers) */
+    na_ofi_op_id->info.msg.buf.ptr = buf;
+    na_ofi_op_id->info.msg.buf_size = buf_size;
+    na_ofi_op_id->info.msg.actual_buf_size = 0;
+    na_ofi_op_id->info.msg.fi_addr = FI_ADDR_UNSPEC;
+    na_ofi_op_id->info.msg.fi_mr = plugin_data;
+    na_ofi_op_id->info.msg.tag = 0;
 
     /* Post the FI unexpected recv request */
-    do {
-        rc = fi_trecv(ep_hdl, buf, buf_size, mr_hdl, FI_ADDR_UNSPEC,
-            1 /* tag */, NA_OFI_UNEXPECTED_TAG_IGNORE, &na_ofi_op_id->fi_ctx);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
-        "fi_trecv() unexpected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+    rc = fi_trecv(ctx->fi_rx, buf, buf_size, na_ofi_op_id->info.msg.fi_mr,
+        na_ofi_op_id->info.msg.fi_addr, NA_OFI_UNEXPECTED_TAG,
+        NA_OFI_TAG_MASK, &na_ofi_op_id->fi_ctx);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_trecv() unexpected failed, rc: %d(%s)", rc,
+            fi_strerror((int ) -rc));
 
 out:
     return ret;
 
 error:
-    na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
     na_ofi_op_id_decref(na_ofi_op_id);
 
     return ret;
@@ -3811,17 +3962,14 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
+na_ofi_msg_send_expected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
     void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) dest_addr;
-    struct fid_mr *mr_hdl = plugin_data;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
-    fi_addr_t fi_addr;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
@@ -3831,31 +3979,52 @@ na_ofi_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
         out, ret, NA_INVALID_ARG, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-    na_ofi_op_id_addref(na_ofi_op_id);
+    NA_CHECK_ERROR(
+        !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED), out,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_ofi_op_id->context = context;
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_SEND_EXPECTED;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
-    na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
+    na_ofi_addr_addref(na_ofi_addr);
     na_ofi_op_id->addr = na_ofi_addr;
     hg_atomic_set32(&na_ofi_op_id->status, 0);
-
+    /* We assume buf remains valid (safe because we pre-allocate buffers) */
+    na_ofi_op_id->info.msg.buf.const_ptr = buf;
+    na_ofi_op_id->info.msg.buf_size = buf_size;
+    na_ofi_op_id->info.msg.actual_buf_size = buf_size;
     /* Specify target receive context */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
+     na_ofi_op_id->info.msg.fi_addr =
+         fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.msg.fi_mr = plugin_data;
+    na_ofi_op_id->info.msg.tag = tag;
+
+    NA_LOG_DEBUG("Sending expected msg with tag=%llu", tag);
 
     /* Post the FI expected send request */
-    do {
-        rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-            NA_OFI_EXPECTED_TAG_FLAG | tag, &na_ofi_op_id->fi_ctx);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
-        "fi_tsend() expected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+    rc = fi_tsend(ctx->fi_tx, buf, buf_size, na_ofi_op_id->info.msg.fi_mr,
+        na_ofi_op_id->info.msg.fi_addr, tag, &na_ofi_op_id->fi_ctx);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_tsend() expected failed, rc: %d(%s)", rc,
+            fi_strerror((int ) -rc));
 
 out:
     return ret;
@@ -3869,17 +4038,14 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_recv_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
+na_ofi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
     void *plugin_data, na_addr_t source_addr, na_uint8_t source_id,
     na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->fi_rx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) source_addr;
-    struct fid_mr *mr_hdl = plugin_data;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
-    fi_addr_t fi_addr;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
@@ -3889,34 +4055,49 @@ na_ofi_msg_recv_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
         out, ret, NA_INVALID_ARG, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-    na_ofi_op_id_addref(na_ofi_op_id);
+    NA_CHECK_ERROR(
+        !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED), out,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_ofi_op_id->context = context;
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_RECV_EXPECTED;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->status, 0);
-    na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
+    na_ofi_addr_addref(na_ofi_addr);
     na_ofi_op_id->addr = na_ofi_addr;
-    na_ofi_op_id->info.recv_expected.buf = buf;
-    na_ofi_op_id->info.recv_expected.buf_size = buf_size;
-    na_ofi_op_id->info.recv_expected.tag = tag;
-
-    /* Specify target receive context */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, source_id, NA_OFI_SEP_RX_CTX_BITS);
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    na_ofi_op_id->info.msg.buf.ptr = buf;
+    na_ofi_op_id->info.msg.buf_size = buf_size;
+    na_ofi_op_id->info.msg.actual_buf_size = 0;
+    /* Specify target source context */
+    na_ofi_op_id->info.msg.fi_addr =
+        fi_rx_addr(na_ofi_addr->fi_addr, source_id, NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.msg.fi_mr = plugin_data;
+    na_ofi_op_id->info.msg.tag = tag;
 
     /* Post the FI expected recv request */
-    do {
-        rc = fi_trecv(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-            NA_OFI_EXPECTED_TAG_FLAG | tag, 0 /* ignore */, &na_ofi_op_id->fi_ctx);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
-        "fi_trecv() expected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+    rc = fi_trecv(ctx->fi_rx, buf, buf_size, na_ofi_op_id->info.msg.fi_mr,
+        na_ofi_op_id->info.msg.fi_addr, tag, 0, &na_ofi_op_id->fi_ctx);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_trecv() expected failed, rc: %d(%s)", rc,
+            fi_strerror((int ) -rc));
 
 out:
     return ret;
@@ -4093,40 +4274,22 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_put(na_class_t NA_UNUSED *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, na_mem_handle_t local_mem_handle,
-    na_offset_t local_offset, na_mem_handle_t remote_mem_handle,
-    na_offset_t remote_offset, na_size_t length, na_addr_t remote_addr,
-    na_uint8_t remote_id, na_op_id_t *op_id)
+na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
+    void *arg, na_mem_handle_t local_mem_handle, na_offset_t local_offset,
+    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset,
+    na_size_t length, na_addr_t remote_addr, na_uint8_t remote_id,
+    na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_mem_handle *ofi_local_mem_handle =
         (struct na_ofi_mem_handle *) local_mem_handle;
     struct na_ofi_mem_handle *ofi_remote_mem_handle =
         (struct na_ofi_mem_handle *) remote_mem_handle;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) remote_addr;
-    void *local_desc = fi_mr_desc(ofi_local_mem_handle->fi_mr);
-    struct iovec local_iov = {
-        .iov_base = (char *)ofi_local_mem_handle->desc.base + local_offset,
-        .iov_len = length
-    };
-    struct fi_rma_iov remote_iov = {
-        .addr = (na_uint64_t)ofi_remote_mem_handle->desc.base + remote_offset,
-        .len = length,
-        .key = ofi_remote_mem_handle->desc.fi_mr_key
-    };
-    struct fi_msg_rma msg_rma = {
-        .msg_iov = &local_iov,
-        .desc = &local_desc,
-        .iov_count = 1,
-        .addr = fi_rx_addr(na_ofi_addr->fi_addr, remote_id, NA_OFI_SEP_RX_CTX_BITS),
-        .rma_iov = &remote_iov,
-        .rma_iov_count = 1,
-        .context = NULL,
-        .data = 0
-    };
     struct na_ofi_op_id *na_ofi_op_id = NULL;
+    const struct fi_msg_rma na_ofi_msg_rma_initializer = {.msg_iov = NULL,
+        .desc = NULL, .iov_count = 1, .addr = 0, .rma_iov = NULL,
+        .rma_iov_count = 1, .context = NULL, .data = 0};
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
@@ -4136,32 +4299,65 @@ na_ofi_put(na_class_t NA_UNUSED *na_class, na_context_t *context,
         out, ret, NA_INVALID_ARG, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-    na_ofi_op_id_addref(na_ofi_op_id);
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED),
+        out, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_ofi_op_id->context = context;
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_PUT;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->status, 0);
-    na_ofi_addr_addref(na_ofi_addr); /* for na_ofi_complete() */
+    na_ofi_addr_addref(na_ofi_addr);
     na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
 
-    /* Assign context */
-    msg_rma.context = &na_ofi_op_id->fi_ctx;
+    /* Set local desc */
+    na_ofi_op_id->info.rma.local_desc = fi_mr_desc(ofi_local_mem_handle->fi_mr);
+
+    /* Set local IOV */
+    na_ofi_op_id->info.rma.local_iov.iov_base =
+        (char *) ofi_local_mem_handle->desc.base + local_offset;
+    na_ofi_op_id->info.rma.local_iov.iov_len = length;
+
+    /* Set remote IOV */
+    na_ofi_op_id->info.rma.remote_iov.addr =
+        (na_uint64_t) ofi_remote_mem_handle->desc.base + remote_offset;
+    na_ofi_op_id->info.rma.remote_iov.len = length;
+    na_ofi_op_id->info.rma.remote_iov.key =
+        ofi_remote_mem_handle->desc.fi_mr_key;
+
+    /* Set RMA msg */
+    na_ofi_op_id->info.rma.fi_rma = na_ofi_msg_rma_initializer;
+    na_ofi_op_id->info.rma.fi_rma.msg_iov = &na_ofi_op_id->info.rma.local_iov;
+    na_ofi_op_id->info.rma.fi_rma.desc = &na_ofi_op_id->info.rma.local_desc;
+    na_ofi_op_id->info.rma.fi_rma.addr = fi_rx_addr(na_ofi_addr->fi_addr,
+        remote_id, NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.rma.fi_rma.rma_iov = &na_ofi_op_id->info.rma.remote_iov;
+    na_ofi_op_id->info.rma.fi_rma.context = &na_ofi_op_id->fi_ctx;
 
     /* Post the OFI RMA write.
      * For writes, FI_DELIVERY_COMPLETE guarantees that the operation
      * has been processed by the destination */
-    do {
-        rc = fi_writemsg(ep_hdl, &msg_rma, FI_COMPLETION | FI_DELIVERY_COMPLETE);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
-        "fi_writemsg() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+    rc = fi_writemsg(ctx->fi_tx, &na_ofi_op_id->info.rma.fi_rma,
+        NA_OFI_PUT_COMPLETION);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_writemsg() failed, rc: %d(%s)", rc, fi_strerror((int ) -rc));
 
 out:
     return ret;
@@ -4175,11 +4371,11 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_get(na_class_t NA_UNUSED *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, na_mem_handle_t local_mem_handle,
-    na_offset_t local_offset, na_mem_handle_t remote_mem_handle,
-    na_offset_t remote_offset, na_size_t length, na_addr_t remote_addr,
-    na_uint8_t remote_id, na_op_id_t *op_id)
+na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
+    void *arg, na_mem_handle_t local_mem_handle, na_offset_t local_offset,
+    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset,
+    na_size_t length, na_addr_t remote_addr, na_uint8_t remote_id,
+    na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     struct fid_ep *ep_hdl = ctx->fi_tx;
@@ -4188,27 +4384,10 @@ na_ofi_get(na_class_t NA_UNUSED *na_class, na_context_t *context,
     struct na_ofi_mem_handle *ofi_remote_mem_handle =
         (struct na_ofi_mem_handle *) remote_mem_handle;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) remote_addr;
-    void *local_desc = fi_mr_desc(ofi_local_mem_handle->fi_mr);
-    struct iovec local_iov = {
-        .iov_base = (void *)(ofi_local_mem_handle->desc.base + local_offset),
-        .iov_len = length
-    };
-    struct fi_rma_iov remote_iov = {
-        .addr = (uint64_t)(ofi_remote_mem_handle->desc.base + remote_offset),
-        .len = length,
-        .key = ofi_remote_mem_handle->desc.fi_mr_key
-    };
-    struct fi_msg_rma msg_rma = {
-        .msg_iov = &local_iov,
-        .desc = &local_desc,
-        .iov_count = 1,
-        .addr = fi_rx_addr(na_ofi_addr->fi_addr, remote_id, NA_OFI_SEP_RX_CTX_BITS),
-        .rma_iov = &remote_iov,
-        .rma_iov_count = 1,
-        .context = NULL,
-        .data = 0
-    };
     struct na_ofi_op_id *na_ofi_op_id = NULL;
+    const struct fi_msg_rma na_ofi_msg_rma_initializer = {.msg_iov = NULL,
+        .desc = NULL, .iov_count = 1, .addr = 0, .rma_iov = NULL,
+        .rma_iov_count = 1, .context = NULL, .data = 0};
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
@@ -4218,30 +4397,63 @@ na_ofi_get(na_class_t NA_UNUSED *na_class, na_context_t *context,
         out, ret, NA_INVALID_ARG, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-    na_ofi_op_id_addref(na_ofi_op_id);
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED),
+        out, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_ofi_op_id->refcount, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_ofi_op_id->context = context;
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_GET;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->status, 0);
-    na_ofi_addr_addref(na_ofi_addr); /* for na_ofi_complete() */
+    na_ofi_addr_addref(na_ofi_addr);
     na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
 
-    /* Assign context */
-    msg_rma.context = &na_ofi_op_id->fi_ctx;
+    /* Set local desc */
+    na_ofi_op_id->info.rma.local_desc = fi_mr_desc(ofi_local_mem_handle->fi_mr);
+
+    /* Set local IOV */
+    na_ofi_op_id->info.rma.local_iov.iov_base =
+        (char *) ofi_local_mem_handle->desc.base + local_offset;
+    na_ofi_op_id->info.rma.local_iov.iov_len = length;
+
+    /* Set remote IOV */
+    na_ofi_op_id->info.rma.remote_iov.addr =
+        (na_uint64_t) ofi_remote_mem_handle->desc.base + remote_offset;
+    na_ofi_op_id->info.rma.remote_iov.len = length;
+    na_ofi_op_id->info.rma.remote_iov.key =
+        ofi_remote_mem_handle->desc.fi_mr_key;
+
+    /* Set RMA msg */
+    na_ofi_op_id->info.rma.fi_rma = na_ofi_msg_rma_initializer;
+    na_ofi_op_id->info.rma.fi_rma.msg_iov = &na_ofi_op_id->info.rma.local_iov;
+    na_ofi_op_id->info.rma.fi_rma.desc = &na_ofi_op_id->info.rma.local_desc;
+    na_ofi_op_id->info.rma.fi_rma.addr = fi_rx_addr(na_ofi_addr->fi_addr,
+        remote_id, NA_OFI_SEP_RX_CTX_BITS);
+    na_ofi_op_id->info.rma.fi_rma.rma_iov = &na_ofi_op_id->info.rma.remote_iov;
+    na_ofi_op_id->info.rma.fi_rma.context = &na_ofi_op_id->fi_ctx;
 
     /* Post the OFI RMA read */
-    do {
-        rc = fi_readmsg(ep_hdl, &msg_rma, FI_COMPLETION);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
-        if (rc == -FI_EAGAIN)
-            na_ofi_progress(na_class, context, 0);
-        else
-            break;
-    } while (1);
-    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
-        "fi_readmsg() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+    rc = fi_readmsg(ep_hdl, &na_ofi_op_id->info.rma.fi_rma,
+        NA_OFI_GET_COMPLETION);
+    if (unlikely(rc == -FI_EAGAIN)) {
+        if (NA_OFI_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_ofi_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+            HG_QUEUE_PUSH_TAIL(&ctx->retry_op_queue->queue, na_ofi_op_id, entry);
+            hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_QUEUED);
+            hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        }
+    } else
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_readmsg() failed, rc: %d(%s)", rc, fi_strerror((int ) -rc));
 
 out:
     return ret;
@@ -4287,6 +4499,14 @@ na_ofi_poll_try_wait(na_class_t *na_class, na_context_t *context)
     if (priv->no_wait)
         return NA_FALSE;
 
+    /* Keep making progress if retry queue is not empty */
+    hg_thread_mutex_lock(&ctx->retry_op_queue->mutex);
+    if (!HG_QUEUE_IS_EMPTY(&ctx->retry_op_queue->queue)) {
+        hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+        return NA_FALSE;
+    }
+    hg_thread_mutex_unlock(&ctx->retry_op_queue->mutex);
+
     /* Assume it is safe to block if provider is using wait set */
     if ((na_ofi_prov_flags[priv->domain->prov_type] & NA_OFI_WAIT_SET)
         /* PSM2 shows very slow performance with fi_trywait() */
@@ -4351,6 +4571,10 @@ na_ofi_progress(na_class_t *na_class, na_context_t *context,
         NA_CHECK_NA_ERROR(out, ret,
             "Could not read events from context CQ");
 
+        /* Attempt to process retries */
+        ret = na_ofi_cq_process_retries(context);
+        NA_CHECK_NA_ERROR(out, ret, "Could not process retries");
+
         if (timeout) {
             hg_time_get_current(&t2);
             remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
@@ -4362,15 +4586,12 @@ na_ofi_progress(na_class_t *na_class, na_context_t *context,
                 break;
             continue;
         }
-        /* Got at least one completion event */
-        assert(actual_count > 0);
 
         for (i = 0; i < actual_count; i++) {
-           ret = na_ofi_cq_process_event(na_class, context, &cq_events[i],
-               src_addrs[i], src_err_addr_ptr, src_err_addrlen);
-           NA_CHECK_NA_ERROR(out, ret, "Could not process event");
+            ret = na_ofi_cq_process_event(na_class, &cq_events[i], src_addrs[i],
+                src_err_addr_ptr, src_err_addrlen);
+            NA_CHECK_NA_ERROR(out, ret, "Could not process event");
         }
-
     } while (remaining > 0 && ret != NA_SUCCESS);
 
 out:
@@ -4385,10 +4606,12 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context,
     struct na_ofi_op_id *na_ofi_op_id = (struct na_ofi_op_id *) op_id;
     struct fid_ep *fi_ep = NULL;
     na_return_t ret = NA_SUCCESS;
+    na_bool_t canceled = NA_FALSE;
     ssize_t rc;
 
     /* Exit if op has already completed */
-    if (!hg_atomic_cas32(&na_ofi_op_id->status, 0, NA_OFI_OP_CANCELED))
+    if (hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_CANCELED)
+        & NA_OFI_OP_COMPLETED)
         goto out;
 
     NA_LOG_DEBUG("Canceling operation ID %p", na_ofi_op_id);
@@ -4412,15 +4635,28 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context,
             break;
     }
 
-    /* fi_cancel() is an asynchronous operation, either the operation
-     * will be canceled and an FI_ECANCELED event will be generated
-     * or it will show up in the regular completion queue.
-     */
-    rc = fi_cancel(&fi_ep->fid, &na_ofi_op_id->fi_ctx);
-    NA_LOG_DEBUG("fi_cancel() rc: %d(%s)", (int) rc,
-        fi_strerror((int) -rc));
-//    NA_CHECK_ERROR(rc == -FI_ENOENT, out, ret, NA_OPNOTSUPPORTED,
-//        "fi_cancel() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+    /* Check if op_id is in retry queue */
+    hg_thread_mutex_lock(&NA_OFI_CONTEXT(context)->retry_op_queue->mutex);
+    if (hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_QUEUED) {
+        HG_QUEUE_REMOVE(&NA_OFI_CONTEXT(context)->retry_op_queue->queue,
+            na_ofi_op_id, na_ofi_op_id, entry);
+        hg_atomic_and32(&na_ofi_op_id->status, ~NA_OFI_OP_QUEUED);
+        canceled = NA_TRUE;
+    }
+    hg_thread_mutex_unlock(&NA_OFI_CONTEXT(context)->retry_op_queue->mutex);
+
+    if (canceled) {
+        ret = na_ofi_complete(na_ofi_op_id);
+        NA_CHECK_NA_ERROR(out, ret, "Could not complete operation");
+    } else {
+        /* fi_cancel() is an asynchronous operation, either the operation
+         * will be canceled and an FI_ECANCELED event will be generated
+         * or it will show up in the regular completion queue.
+         */
+        rc = fi_cancel(&fi_ep->fid, &na_ofi_op_id->fi_ctx);
+        NA_LOG_DEBUG("fi_cancel() rc: %d(%s)", (int) rc,
+            fi_strerror((int) -rc));
+    }
 
     /* Work around segfault on fi_cq_signal() in some providers */
     if (!(na_ofi_prov_flags[NA_OFI_CLASS(na_class)->domain->prov_type]
diff --git a/src/na/na_sm.c b/src/na/na_sm.c
index 38463ea..b6c5b95 100644
--- a/src/na/na_sm.c
+++ b/src/na/na_sm.c
@@ -24,35 +24,30 @@
 #include <stdio.h>
 
 #ifdef _WIN32
-#include <process.h>
+# include <process.h>
 #else
-#include <pwd.h>
-#include <ftw.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#if defined(NA_SM_HAS_CMA)
-#include <sys/uio.h>
-#elif defined(__APPLE__)
-#include <mach/mach.h>
-#include <mach/mach_vm.h>
-#endif
+# include <pwd.h>
+# include <ftw.h>
+# include <unistd.h>
+# include <sys/types.h>
+# include <sys/mman.h>
+# include <sys/stat.h>
+# include <fcntl.h>
+# include <sys/socket.h>
+# include <sys/un.h>
+# if defined(NA_SM_HAS_CMA)
+#  include <sys/uio.h>
+#  include <limits.h>
+# elif defined(__APPLE__)
+#  include <mach/mach.h>
+#  include <mach/mach_vm.h>
+# endif
 #endif
 
 /****************/
 /* Local Macros */
 /****************/
 
-/* Error compat */
-#define NA_INVALID_PARAM    NA_INVALID_ARG
-#define NA_SIZE_ERROR       NA_MSGSIZE
-#define NA_NOMEM_ERROR      NA_NOMEM
-#define NA_PERMISSION_ERROR NA_PERMISSION
-
 /* Plugin constants */
 #define NA_SM_MAX_FILENAME      64
 #define NA_SM_NUM_BUFS          64
@@ -72,6 +67,11 @@
 /* Max tag */
 #define NA_SM_MAX_TAG           NA_TAG_UB
 
+/* Op ID status bits */
+#define NA_SM_OP_COMPLETED      (1 << 0)
+#define NA_SM_OP_CANCELED       (1 << 1)
+#define NA_SM_OP_QUEUED         (1 << 2)
+
 /* Private data access */
 #define NA_SM_CLASS(na_class) \
     ((struct na_sm_class *)(na_class->plugin_class))
@@ -84,7 +84,7 @@
 #define NA_SM_MSGHDR_INITIALIZER {NULL, 0, NULL, 0, NULL, 0, 0}
 
 /* Default filenames/paths */
-#define NA_SM_SHM_PATH "/dev/shm"
+#define NA_SM_SHM_PATH          "/dev/shm"
 
 #define NA_SM_GEN_SHM_NAME(filename, username, na_sm_addr)      \
     do {                                                        \
@@ -164,8 +164,8 @@ typedef enum na_sm_poll_type {
 /* Poll data */
 struct na_sm_poll_data {
     na_class_t *na_class;
-    na_sm_poll_type_t type;  /* Type of operation */
     struct na_sm_addr *addr; /* Address */
+    na_sm_poll_type_t type;  /* Type of operation */
 };
 
 /* Sock progress type */
@@ -177,30 +177,23 @@ typedef enum {
 
 /* Address */
 struct na_sm_addr {
-    pid_t pid;                              /* PID */
-    unsigned int id;                        /* SM ID */
-    unsigned int conn_id;                   /* Connection ID */
+    HG_QUEUE_ENTRY(na_sm_addr) entry;       /* Next queue entry */
+    HG_QUEUE_ENTRY(na_sm_addr) poll_entry;  /* Next poll queue entry */
     struct na_sm_ring_buf *na_sm_send_ring_buf; /* Shared send ring buffer */
     struct na_sm_ring_buf *na_sm_recv_ring_buf; /* Shared recv ring buffer */
     struct na_sm_copy_buf *na_sm_copy_buf;  /* Shared copy buffer */
-    na_bool_t accepted;                     /* Created on accept */
-    na_bool_t self;                         /* Self address */
-    int sock;                               /* Sock fd */
-    na_sm_sock_progress_t sock_progress;    /* Current sock progress state */
     struct na_sm_poll_data *sock_poll_data; /* Sock poll data */
-    int local_notify;                       /* Local notify fd */
     struct na_sm_poll_data *local_notify_poll_data; /* Notify poll data */
+    pid_t pid;                              /* PID */
+    na_sm_sock_progress_t sock_progress;    /* Current sock progress state */
+    unsigned int id;                        /* SM ID */
+    unsigned int conn_id;                   /* Connection ID */
+    int sock;                               /* Sock fd */
+    int local_notify;                       /* Local notify fd */
     int remote_notify;                      /* Remote notify fd */
     hg_atomic_int32_t ref_count;            /* Ref count */
-    HG_QUEUE_ENTRY(na_sm_addr) entry;       /* Next queue entry */
-    HG_QUEUE_ENTRY(na_sm_addr) poll_entry;  /* Next poll queue entry */
-};
-
-/* Unexpected message info */
-struct na_sm_unexpected_info {
-    struct na_sm_addr *na_sm_addr;
-    na_sm_cacheline_hdr_t na_sm_hdr;
-    HG_QUEUE_ENTRY(na_sm_unexpected_info) entry;
+    na_bool_t accepted;                     /* Created on accept */
+    na_bool_t self;                         /* Self address */
 };
 
 /* Memory handle */
@@ -211,71 +204,64 @@ struct na_sm_mem_handle {
     size_t len;
 };
 
-/* Lookup info */
-struct na_sm_info_lookup {
-    struct na_sm_addr *na_sm_addr;
-};
 
-/* Send unexpected and expected */
-struct na_sm_info_send {
-    void *buf;
-    size_t buf_size;
+/* Unexpected message info */
+struct na_sm_unexpected_info {
+    HG_QUEUE_ENTRY(na_sm_unexpected_info) entry;
     struct na_sm_addr *na_sm_addr;
-    na_tag_t tag;
-};
-
-/* Unexpected recv info */
-struct na_sm_info_recv_unexpected {
     void *buf;
-    size_t buf_size;
-    struct na_sm_unexpected_info unexpected_info;
+    na_size_t buf_size;
+    na_tag_t tag;
 };
 
-/* Expected recv info */
-struct na_sm_info_recv_expected {
-    void *buf;
+/* Msg info */
+struct na_sm_msg_info {
+    union {
+        const void *const_ptr;
+        void *ptr;
+    } buf;
     size_t buf_size;
-    struct na_sm_addr *na_sm_addr;
+    na_size_t actual_buf_size;
     na_tag_t tag;
 };
 
 /* Operation ID */
 struct na_sm_op_id {
-    na_class_t *na_class;
-    na_context_t *context;
-    struct na_cb_completion_data completion_data;
-    hg_atomic_int32_t completed;    /* Operation completed */
-    hg_atomic_int32_t canceled;     /* Operation canceled */
+    struct na_cb_completion_data completion_data; /* Completion data */
     union {
-        struct na_sm_info_lookup lookup;
-        struct na_sm_info_send send;
-        struct na_sm_info_recv_unexpected recv_unexpected;
-        struct na_sm_info_recv_expected recv_expected;
-    } info;
-    hg_atomic_int32_t ref_count;    /* Ref count */
-    HG_QUEUE_ENTRY(na_sm_op_id) entry;
+        struct na_sm_msg_info msg;
+    } info;                             /* Op info                  */
+    HG_QUEUE_ENTRY(na_sm_op_id) entry;  /* Entry in queue           */
+    na_class_t *na_class;               /* NA class associated      */
+    na_context_t *context;              /* NA context associated    */
+    struct na_sm_addr *na_sm_addr;      /* Address associated       */
+    hg_atomic_int32_t status;           /* Operation status         */
+    hg_atomic_int32_t ref_count;        /* Refcount                 */
 };
 
 /* Private data */
 struct na_sm_class {
-    char *username;
-    struct na_sm_addr *self_addr;
-    hg_poll_set_t *poll_set;
     HG_QUEUE_HEAD(na_sm_addr) accepted_addr_queue;
     HG_QUEUE_HEAD(na_sm_addr) poll_addr_queue;
     HG_QUEUE_HEAD(na_sm_unexpected_info) unexpected_msg_queue;
     HG_QUEUE_HEAD(na_sm_op_id) lookup_op_queue;
     HG_QUEUE_HEAD(na_sm_op_id) unexpected_op_queue;
     HG_QUEUE_HEAD(na_sm_op_id) expected_op_queue;
+    HG_QUEUE_HEAD(na_sm_op_id) retry_op_queue;
+    hg_time_t last_accept_time;
+    char *username;
+    struct na_sm_addr *self_addr;
+    hg_poll_set_t *poll_set;
     hg_thread_spin_t accepted_addr_queue_lock;
     hg_thread_spin_t poll_addr_queue_lock;
     hg_thread_spin_t unexpected_msg_queue_lock;
     hg_thread_spin_t lookup_op_queue_lock;
     hg_thread_spin_t unexpected_op_queue_lock;
     hg_thread_spin_t expected_op_queue_lock;
+    hg_thread_spin_t retry_op_queue_lock;
     hg_thread_spin_t copy_buf_lock;
-    hg_time_t last_accept_time;
     na_bool_t no_wait;
+    na_bool_t no_retry;
 };
 
 /********************/
@@ -284,6 +270,7 @@ struct na_sm_class {
 
 /**
  * utility function: wrapper around getlogin().
+ * Allows graceful handling of directory name generation.
  */
 static char *
 getlogin_safe(void);
@@ -497,7 +484,7 @@ na_sm_reserve_and_copy_buf(
     );
 
 /**
- * Free shared copy buf.
+ * Free and copy buf.
  */
 static NA_INLINE void
 na_sm_copy_and_free_buf(
@@ -509,6 +496,25 @@ na_sm_copy_and_free_buf(
     );
 
 /**
+ * Release shared copy buf.
+ */
+static NA_INLINE void
+na_sm_release_buf(
+    struct na_sm_copy_buf *na_sm_copy_buf,
+    unsigned int idx_reserved
+    );
+
+/**
+ * Insert message header into ring buffer.
+ */
+static na_return_t
+na_sm_msg_insert(
+    na_class_t *na_class,
+    struct na_sm_op_id *na_sm_op_id,
+    unsigned int idx_reserved
+    );
+
+/**
  * Translate offset from mem_handle into usable iovec.
  */
 static void
@@ -536,8 +542,7 @@ na_sm_progress_cb(
 static na_return_t
 na_sm_progress_error(
     na_class_t *na_class,
-    struct na_sm_addr *poll_addr,
-    int error
+    struct na_sm_addr *poll_addr
     );
 
 /**
@@ -591,6 +596,14 @@ na_sm_progress_expected(
     );
 
 /**
+ * Progress retries.
+ */
+static na_return_t
+na_sm_progress_retries(
+    na_class_t *na_class
+    );
+
+/**
  * Complete operation.
  */
 static na_return_t
@@ -678,6 +691,14 @@ na_sm_addr_dup(
     na_addr_t  *new_addr
     );
 
+/* addr_cmp */
+static na_bool_t
+na_sm_addr_cmp(
+    na_class_t *na_class,
+    na_addr_t   addr1,
+    na_addr_t   addr2
+    );
+
 /* addr_is_self */
 static NA_INLINE na_bool_t
 na_sm_addr_is_self(
@@ -911,6 +932,7 @@ const struct na_class_ops NA_PLUGIN_OPS(sm) = {
     NULL,                                   /* addr_set_remove */
     na_sm_addr_self,                        /* addr_self */
     na_sm_addr_dup,                         /* addr_dup */
+    na_sm_addr_cmp,                         /* addr_cmp */
     na_sm_addr_is_self,                     /* addr_is_self */
     na_sm_addr_to_string,                   /* addr_to_string */
     NULL,                                   /* addr_get_serialize_size */
@@ -955,35 +977,20 @@ const struct na_class_ops NA_PLUGIN_OPS(sm) = {
 /* Plugin callbacks */
 /********************/
 
-/*
-static char*
+/* Debug information */
+static char *
 itoa(uint64_t val, int base)
 {
     static char buf[64] = {0};
     int i = 62;
 
-    for (; val && i; --i, val /= base)
-        buf[i] = "0123456789abcdef"[val % base];
+    for (; val && i; --i, val /= (uint64_t) base)
+        buf[i] = "0123456789abcdef"[val % (uint64_t) base];
 
     return &buf[i + 1];
 }
-*/
-
-/*
-static void
-na_sm_print_addr(struct na_sm_addr *na_sm_addr)
-{
-    NA_LOG_DEBUG("pid=%d, id=%d, copy_buf=0x%lX, sock=%d, local_notify=%d, "
-        "remote_notify=%d", na_sm_addr->pid, na_sm_addr->id,
-        (uint64_t)na_sm_addr->na_sm_copy_buf, na_sm_addr->sock,
-        na_sm_addr->local_notify, na_sm_addr->remote_notify);
-}
-*/
 
-/* Wrapper to get login information and return a dummy string if the glibc call
- * fails for some reason.  Allows graceful handling of directory name
- * generation.
- */
+/*---------------------------------------------------------------------------*/
 static char *
 getlogin_safe(void)
 {
@@ -999,20 +1006,16 @@ getlogin_safe(void)
 static void *
 na_sm_open_shared_buf(const char *name, size_t buf_size, na_bool_t create)
 {
-//    na_size_t page_size = (na_size_t) hg_mem_get_page_size();
+    na_size_t page_size = (na_size_t) hg_mem_get_page_size();
     void *ret = NULL;
 
     /* Check alignment */
-//    if (buf_size / page_size * page_size != buf_size) {
-//        NA_LOG_ERROR(
-//            "Not aligned properly, page size=%zu bytes, buf size=%zu bytes",
-//            page_size, buf_size);
-//        goto done;
-//    }
+    NA_CHECK_WARNING(buf_size / page_size * page_size != buf_size,
+        "Not aligned properly, page size=%zu bytes, buf size=%zu bytes",
+        page_size, buf_size);
 
     ret = hg_mem_shm_map(name, buf_size, create);
 
-//done:
     return ret;
 }
 
@@ -1028,8 +1031,9 @@ static na_return_t
 na_sm_create_sock(const char *pathname, na_bool_t na_listen, int *sock)
 {
     struct sockaddr_un addr;
+    char *dup_path = NULL;
     na_return_t ret = NA_SUCCESS;
-    int fd;
+    int fd = -1, rc;
 
     /* Create a non-blocking socket so that we can poll for incoming connections */
 #ifdef SOCK_NONBLOCK
@@ -1037,33 +1041,30 @@ na_sm_create_sock(const char *pathname, na_bool_t na_listen, int *sock)
 #else
     fd = socket(AF_UNIX, SOCK_STREAM, 0);
 #endif
-    if (fd == -1) {
-        NA_LOG_ERROR("socket() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(fd == -1, error, ret, NA_PROTOCOL_ERROR,
+        "socket() failed (%s)", strerror(errno));
+
 #ifndef SOCK_NONBLOCK
-    if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {
-        NA_LOG_ERROR("fcntl() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    };
+    rc = fcntl(fd, F_SETFL, O_NONBLOCK);
+    NA_CHECK_ERROR(rc == -1, error, ret, NA_PROTOCOL_ERROR,
+        "fcntl() failed (%s)", strerror(errno));
 #endif
 
     memset(&addr, 0, sizeof(struct sockaddr_un));
     addr.sun_family = AF_UNIX;
-    if (strlen(pathname) + strlen("/sock") > sizeof(addr.sun_path) - 1) {
-        NA_LOG_ERROR("Exceeds maximum AF UNIX socket path length");
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(strlen(pathname) + strlen("/sock") > sizeof(addr.sun_path) - 1,
+        error, ret, NA_OVERFLOW, "Exceeds maximum AF UNIX socket path length");
     strcpy(addr.sun_path, pathname);
     strcat(addr.sun_path, "/sock");
 
     if (na_listen) {
-        char *dup_path = strdup(pathname);
         char stat_path[NA_SM_MAX_FILENAME];
-        char *path_ptr = dup_path;
+        char *path_ptr;
+
+        dup_path = strdup(pathname);
+        NA_CHECK_ERROR(dup_path == NULL, error, ret, NA_NOMEM,
+            "Could not dup pathname");
+        path_ptr = dup_path;
 
         memset(stat_path, '\0', NA_SM_MAX_FILENAME);
         if (dup_path[0] == '/') {
@@ -1075,47 +1076,47 @@ na_sm_create_sock(const char *pathname, na_bool_t na_listen, int *sock)
         while (path_ptr) {
             struct stat sb;
             char *current = strtok_r(path_ptr, "/", &path_ptr);
-            if (!current) break;
+            if (!current)
+                break;
 
             strcat(stat_path, current);
             if (stat(stat_path, &sb) == -1) {
-                if (mkdir(stat_path, 0775) == -1 && errno != EEXIST) {
-                    NA_LOG_ERROR("Could not create directory: %s (%s)",
-                        stat_path, strerror(errno));
-                    ret = NA_PROTOCOL_ERROR;
-                    free(dup_path);
-                    goto done;
-                }
+                rc = mkdir(stat_path, 0775);
+                NA_CHECK_ERROR(rc == -1 && errno != EEXIST, error, ret,
+                    NA_PROTOCOL_ERROR, "Could not create directory: %s (%s)",
+                    stat_path, strerror(errno));
             }
             strcat(stat_path, "/");
         }
-        free(dup_path);
 
         /* Bind */
-        if (bind(fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1) {
-            NA_LOG_ERROR("bind() socket (%s)", strerror(errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = bind(fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un));
+        NA_CHECK_ERROR(rc == -1, error, ret, NA_PROTOCOL_ERROR,
+            "bind() failed (%s)", strerror(errno));
 
         /* Listen */
-        if (listen(fd, NA_SM_LISTEN_BACKLOG) == -1) {
-            NA_LOG_ERROR("listen() failed (%s)", strerror(errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = listen(fd, NA_SM_LISTEN_BACKLOG);
+        NA_CHECK_ERROR(rc == -1, error, ret, NA_PROTOCOL_ERROR,
+            "listen() failed (%s)", strerror(errno));
     } else {
         /* Connect */
-        if (connect(fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1) {
-            NA_LOG_ERROR("connect() failed (%s)", strerror(errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = connect(fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un));
+        NA_CHECK_ERROR(rc == -1, error, ret, NA_PROTOCOL_ERROR,
+            "connect() failed (%s)", strerror(errno));
     }
 
     *sock = fd;
 
-done:
+    free(dup_path);
+    return ret;
+
+error:
+    if (fd != -1) {
+        rc = close(fd);
+        NA_CHECK_ERROR_DONE(rc == -1, "close() failed (%s)", strerror(errno));
+    }
+    free(dup_path);
+
     return ret;
 }
 
@@ -1124,12 +1125,11 @@ static na_return_t
 na_sm_close_sock(int sock, const char *pathname)
 {
     na_return_t ret = NA_SUCCESS;
+    int rc;
 
-    if (close(sock) == -1) {
-        NA_LOG_ERROR("close() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = close(sock);
+    NA_CHECK_ERROR(rc == -1, done, ret, NA_PROTOCOL_ERROR,
+        "close() failed (%s)", strerror(errno));
 
     if (pathname) {
         char dup_path[NA_SM_MAX_FILENAME];
@@ -1138,11 +1138,9 @@ na_sm_close_sock(int sock, const char *pathname)
         strcpy(dup_path, pathname);
         strcat(dup_path, "/sock");
 
-        if (unlink(dup_path) == -1) {
-            NA_LOG_ERROR("unlink() failed (%s)", strerror(errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = unlink(dup_path);
+        NA_CHECK_ERROR(rc == -1, done, ret, NA_PROTOCOL_ERROR,
+            "unlink() failed (%s)", strerror(errno));
 
         /* Delete path */
         path_ptr = strrchr(dup_path, '/');
@@ -1194,30 +1192,31 @@ static int
 na_sm_event_create(const char *filename)
 {
     int fd = -1;
+    int rc;
 
     /* Create FIFO */
-    if (mkfifo(filename, S_IRUSR | S_IWUSR) == - 1) {
-        NA_LOG_ERROR("mkfifo() failed (%s)", strerror(errno));
-        goto done;
-    }
+    rc = mkfifo(filename, S_IRUSR | S_IWUSR);
+    NA_CHECK_ERROR_NORET(rc == -1, error, "mkfifo() failed (%s)",
+        strerror(errno));
 
     /* Open FIFO (RDWR for convenience) */
     fd = open(filename, O_RDWR);
-    if (fd == -1) {
-        NA_LOG_ERROR("open() failed (%s)", strerror(errno));
-        goto done;
-    }
+    NA_CHECK_ERROR_NORET(fd == -1, error, "open() failed (%s)", strerror(errno));
 
     /* Set FIFO to be non-blocking */
-    if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {
-        NA_LOG_ERROR("fcntl() failed (%s)", strerror(errno));
-        close(fd);
-        fd = -1;
-        goto done;
-    };
+    rc = fcntl(fd, F_SETFL, O_NONBLOCK);
+    NA_CHECK_ERROR_NORET(rc == -1, error, "fcntl() failed (%s)",
+        strerror(errno));
 
-done:
     return fd;
+
+error:
+    if (fd != -1) {
+        rc = close(fd);
+        NA_CHECK_ERROR_DONE(rc == -1, "close() failed (%s)", strerror(errno));
+    }
+
+    return -1;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1225,18 +1224,18 @@ na_return_t
 na_sm_event_destroy(const char *filename, int fd)
 {
     na_return_t ret = NA_SUCCESS;
+    int rc;
 
-    if (close(fd) == -1) {
-        NA_LOG_ERROR("close() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = close(fd);
+    NA_CHECK_ERROR(rc == -1, done, ret, NA_PROTOCOL_ERROR,
+        "close() failed (%s)", strerror(errno));
 
-    if (filename && unlink(filename) == -1) {
-        NA_LOG_ERROR("unlink() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+    if (filename) {
+        rc = unlink(filename);
+        NA_CHECK_ERROR(rc == -1, done, ret, NA_PROTOCOL_ERROR,
+            "unlink() failed (%s)", strerror(errno));
     }
+
 done:
     return ret;
 }
@@ -1250,11 +1249,8 @@ na_sm_event_set(int fd)
     ssize_t s;
 
     s = write(fd, &count, sizeof(uint64_t));
-    if (s != sizeof(uint64_t)) {
-        NA_LOG_ERROR("write() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(s != sizeof(uint64_t), done, ret, NA_PROTOCOL_ERROR,
+        "write() failed (%s)", strerror(errno));
 
 done:
     return ret;
@@ -1265,21 +1261,20 @@ na_return_t
 na_sm_event_get(int fd, na_bool_t *signaled)
 {
     na_return_t ret = NA_SUCCESS;
-    na_bool_t event_signal = NA_FALSE;
     uint64_t count = 1;
     ssize_t s;
 
     s = read(fd, &count, sizeof(uint64_t));
     if (s != sizeof(uint64_t)) {
-        if (errno == EAGAIN)
+        if (likely(errno == EAGAIN)) {
+            *signaled = NA_FALSE;
             goto done;
-        NA_LOG_ERROR("read() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+        } else
+            NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR, "read() failed (%s)",
+                strerror(errno));
     }
-    event_signal = NA_TRUE;
 
-    if (signaled) *signaled = event_signal;
+    *signaled = NA_TRUE;
 
 done:
     return ret;
@@ -1295,7 +1290,7 @@ na_sm_poll_register(na_class_t *na_class, na_sm_poll_type_t poll_type,
     struct na_sm_poll_data *na_sm_poll_data = NULL;
     struct na_sm_poll_data **na_sm_poll_data_ptr = NULL;
     unsigned int flags = HG_POLLIN;
-    int fd;
+    int fd, rc;
     na_return_t ret = NA_SUCCESS;
 
     switch (poll_type) {
@@ -1312,30 +1307,30 @@ na_sm_poll_register(na_class_t *na_class, na_sm_poll_type_t poll_type,
             na_sm_poll_data_ptr = &na_sm_addr->local_notify_poll_data;
             break;
         default:
-            NA_LOG_ERROR("Invalid poll type");
-            ret = NA_INVALID_PARAM;
-            goto done;
+            NA_GOTO_ERROR(error, ret, NA_INVALID_ARG, "Invalid poll type");
     }
 
-    na_sm_poll_data = (struct na_sm_poll_data *) malloc(sizeof(struct na_sm_poll_data));
-    if (!na_sm_poll_data) {
-        NA_LOG_ERROR("Could not allocate NA SM poll data");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_sm_poll_data =
+        (struct na_sm_poll_data *) malloc(sizeof(struct na_sm_poll_data));
+    NA_CHECK_ERROR(na_sm_poll_data == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA SM poll data");
     na_sm_poll_data->na_class = na_class;
     na_sm_poll_data->type = poll_type;
     na_sm_poll_data->addr = na_sm_addr;
     *na_sm_poll_data_ptr = na_sm_poll_data;
 
-    if (hg_poll_add(NA_SM_CLASS(na_class)->poll_set, fd, flags,
-        na_sm_progress_cb, na_sm_poll_data) != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_poll_add failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_poll_add(NA_SM_CLASS(na_class)->poll_set, fd, flags,
+        na_sm_progress_cb, na_sm_poll_data);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_PROTOCOL_ERROR,
+        "hg_poll_add() failed");
+
+    return ret;
+
+error:
+    free(na_sm_poll_data);
+    if (na_sm_poll_data_ptr)
+        *na_sm_poll_data_ptr = NULL;
 
-done:
     return ret;
 }
 
@@ -1344,7 +1339,7 @@ static na_return_t
 na_sm_poll_deregister(na_class_t *na_class, na_sm_poll_type_t poll_type,
     struct na_sm_addr *na_sm_addr)
 {
-    int fd;
+    int fd, rc;
     struct na_sm_poll_data *na_sm_poll_data = NULL;
     na_return_t ret = NA_SUCCESS;
 
@@ -1362,17 +1357,12 @@ na_sm_poll_deregister(na_class_t *na_class, na_sm_poll_type_t poll_type,
             fd = na_sm_addr->local_notify;
             break;
         default:
-            NA_LOG_ERROR("Invalid poll type");
-            ret = NA_INVALID_PARAM;
-            goto done;
+            NA_GOTO_ERROR(done, ret, NA_INVALID_ARG, "Invalid poll type");
     }
 
-    if (hg_poll_remove(NA_SM_CLASS(na_class)->poll_set,
-        fd) != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_poll_remove failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_poll_remove(NA_SM_CLASS(na_class)->poll_set, fd);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+        "hg_poll_remove() failed");
     free(na_sm_poll_data);
 
 done:
@@ -1385,18 +1375,16 @@ na_sm_setup_shm(na_class_t *na_class, struct na_sm_addr *na_sm_addr)
 {
     char filename[NA_SM_MAX_FILENAME], pathname[NA_SM_MAX_FILENAME];
     struct na_sm_copy_buf *na_sm_copy_buf = NULL;
-    int listen_sock;
+    int listen_sock = -1;
     na_return_t ret = NA_SUCCESS;
 
     /* Create SHM buffer */
     NA_SM_GEN_SHM_NAME(filename, NA_SM_CLASS(na_class)->username, na_sm_addr);
     na_sm_copy_buf = (struct na_sm_copy_buf *) na_sm_open_shared_buf(
         filename, sizeof(struct na_sm_copy_buf), NA_TRUE);
-    if (!na_sm_copy_buf) {
-        NA_LOG_ERROR("Could not create copy buffer");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_copy_buf == NULL, error, ret, NA_PROTOCOL_ERROR,
+        "Could not create copy buffer");
+
     /* Initialize copy buf, store 1111111111...1111 */
     hg_atomic_init64(&na_sm_copy_buf->available.val, ~((hg_util_int64_t)0));
     na_sm_addr->na_sm_copy_buf = na_sm_copy_buf;
@@ -1404,20 +1392,25 @@ na_sm_setup_shm(na_class_t *na_class, struct na_sm_addr *na_sm_addr)
     /* Create SHM sock */
     NA_SM_GEN_SOCK_PATH(pathname, NA_SM_CLASS(na_class)->username, na_sm_addr);
     ret = na_sm_create_sock(pathname, NA_TRUE, &listen_sock);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not create sock");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not create sock");
     na_sm_addr->sock = listen_sock;
 
     /* Add listen_sock to poll set */
     ret = na_sm_poll_register(na_class, NA_SM_ACCEPT, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add listen_sock to poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not add listen_sock to poll set");
 
-done:
+    return ret;
+
+error:
+    if (listen_sock != -1) {
+        na_sm_close_sock(listen_sock, pathname);
+        na_sm_addr->sock = -1;
+    }
+    if (na_sm_copy_buf) {
+        na_sm_close_shared_buf(filename, na_sm_copy_buf,
+            sizeof(struct na_sm_copy_buf));
+        na_sm_addr->na_sm_copy_buf = NULL;
+    }
     return ret;
 }
 
@@ -1439,11 +1432,8 @@ na_sm_send_addr_info(na_class_t *na_class, struct na_sm_addr *na_sm_addr)
     msg.msg_iovlen = 2;
 
     nsend = sendmsg(na_sm_addr->sock, &msg, 0);
-    if (nsend == -1) {
-        NA_LOG_ERROR("sendmsg() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(nsend == -1, done, ret, NA_PROTOCOL_ERROR,
+        "sendmsg() failed (%s)", strerror(errno));
 
 done:
     return ret;
@@ -1468,14 +1458,14 @@ na_sm_recv_addr_info(struct na_sm_addr *na_sm_addr, na_bool_t *received)
 
     nrecv = recvmsg(na_sm_addr->sock, &msg, 0);
     if (nrecv == -1) {
-        if (errno == EAGAIN) {
+        if (likely(errno == EAGAIN)) {
             *received = NA_FALSE;
             goto done;
-        }
-        NA_LOG_ERROR("recvmsg() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+        } else
+            NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR, "recvmsg() failed (%s)",
+                strerror(errno));
     }
+
     *received = NA_TRUE;
 
 done:
@@ -1520,11 +1510,8 @@ na_sm_send_conn_id(struct na_sm_addr *na_sm_addr)
     memcpy(fdptr, fds, sizeof(fds));
 
     nsend = sendmsg(na_sm_addr->sock, &msg, 0);
-    if (nsend == -1) {
-        NA_LOG_ERROR("sendmsg() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(nsend == -1, done, ret, NA_PROTOCOL_ERROR,
+        "sendmsg() failed (%s)", strerror(errno));
 
 done:
     return ret;
@@ -1560,23 +1547,20 @@ na_sm_recv_conn_id(struct na_sm_addr *na_sm_addr, na_bool_t *received)
 
     nrecv = recvmsg(na_sm_addr->sock, &msg, 0);
     if (nrecv == -1) {
-        if (errno == EAGAIN) {
+        if (likely(errno == EAGAIN)) {
             *received = NA_FALSE;
             goto done;
-        }
-        NA_LOG_ERROR("recvmsg() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+        } else
+            NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR, "recvmsg() failed (%s)",
+                strerror(errno));
     }
+
     *received = NA_TRUE;
 
     /* Retrieve ancillary data */
     cmsg = CMSG_FIRSTHDR(&msg);
-    if (cmsg == NULL) {
-        NA_LOG_ERROR("NULL cmsg");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(cmsg == NULL, done, ret, NA_PROTOCOL_ERROR, "NULL cmsg");
+
     fdptr = (int *) CMSG_DATA(cmsg);
     memcpy(fds, fdptr ,sizeof(fds));
     /* Invert descriptors so that local is remote and remote is local */
@@ -1607,13 +1591,10 @@ static NA_INLINE na_bool_t
 na_sm_ring_buf_push(struct na_sm_ring_buf *na_sm_ring_buf,
     na_sm_cacheline_hdr_t na_sm_hdr)
 {
-    na_bool_t ret = NA_TRUE;
-
-    if (hg_atomic_queue_push(&na_sm_ring_buf->queue,
-        (void *) na_sm_hdr.val) == HG_UTIL_FAIL)
-        ret = NA_FALSE;
+    int rc = hg_atomic_queue_push(&na_sm_ring_buf->queue,
+        (void *) na_sm_hdr.val);
 
-    return ret;
+    return (likely(rc == HG_UTIL_SUCCESS)) ? NA_TRUE : NA_FALSE;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1621,20 +1602,10 @@ static NA_INLINE na_bool_t
 na_sm_ring_buf_pop(struct na_sm_ring_buf *na_sm_ring_buf,
     na_sm_cacheline_hdr_t *na_sm_hdr_ptr)
 {
-    na_sm_cacheline_hdr_t na_sm_hdr;
-    na_bool_t ret = NA_TRUE;
-
-    na_sm_hdr.val = (na_uint64_t) hg_atomic_queue_pop_mc(&na_sm_ring_buf->queue);
-    if (!na_sm_hdr.val) {
-        /* Empty */
-        ret = NA_FALSE;
-        goto done;
-    }
+    na_sm_hdr_ptr->val = (na_uint64_t) hg_atomic_queue_pop_mc(
+        &na_sm_ring_buf->queue);
 
-    *na_sm_hdr_ptr = na_sm_hdr;
-
-done:
-    return ret;
+    return (likely(na_sm_hdr_ptr->val)) ? NA_TRUE : NA_FALSE;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1651,7 +1622,7 @@ na_sm_reserve_and_copy_buf(na_class_t *na_class,
     unsigned int *idx_reserved)
 {
     hg_util_int64_t bits = 1LL;
-    na_return_t ret = NA_SIZE_ERROR;
+    na_return_t ret = NA_AGAIN;
     unsigned int i = 0;
 
     hg_thread_spin_lock(&NA_SM_CLASS(na_class)->copy_buf_lock);
@@ -1659,9 +1630,10 @@ na_sm_reserve_and_copy_buf(na_class_t *na_class,
     do {
         hg_util_int64_t available = hg_atomic_get64(
             &na_sm_copy_buf->available.val);
-        if (!available)
+        if (!available) {
             /* Nothing available */
             break;
+        }
         if ((available & bits) != bits) {
             /* Already reserved */
             hg_atomic_fence();
@@ -1675,8 +1647,8 @@ na_sm_reserve_and_copy_buf(na_class_t *na_class,
             /* Reservation succeeded, copy buffer */
             memcpy(na_sm_copy_buf->buf[i], buf, buf_size);
             *idx_reserved = i;
-//            NA_LOG_DEBUG("Reserved %u is:\n%s", i,
-//                itoa(hg_atomic_get64(&na_sm_copy_buf->available.val), 2));
+            NA_LOG_DEBUG("Reserved bit index %u:\n%s", i, itoa((hg_util_uint64_t)
+                hg_atomic_get64(&na_sm_copy_buf->available.val), 2));
             ret = NA_SUCCESS;
             break;
         }
@@ -1685,6 +1657,7 @@ na_sm_reserve_and_copy_buf(na_class_t *na_class,
     } while (i < (NA_SM_NUM_BUFS - 1));
 
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->copy_buf_lock);
+
     return ret;
 }
 
@@ -1694,78 +1667,60 @@ na_sm_copy_and_free_buf(na_class_t *na_class,
     struct na_sm_copy_buf *na_sm_copy_buf, void *buf, size_t buf_size,
     unsigned int idx_reserved)
 {
-    hg_util_int64_t bits = 1LL << idx_reserved;
-#if defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
-    hg_util_int64_t available;
-#endif
-
     hg_thread_spin_lock(&NA_SM_CLASS(na_class)->copy_buf_lock);
-
     memcpy(buf, na_sm_copy_buf->buf[idx_reserved], buf_size);
-
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
-    hg_atomic_or64(&na_sm_copy_buf->available.val, bits);
-#else
-    do {
-        available = hg_atomic_get64(&na_sm_copy_buf->available.val);
-    } while (!hg_atomic_cas64(&na_sm_copy_buf->available.val, available,
-        (available | bits)));
-#endif
-
+    hg_atomic_or64(&na_sm_copy_buf->available.val, 1LL << idx_reserved);
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->copy_buf_lock);
 }
 
 /*---------------------------------------------------------------------------*/
+static NA_INLINE void
+na_sm_release_buf(struct na_sm_copy_buf *na_sm_copy_buf,
+    unsigned int idx_reserved)
+{
+    hg_atomic_or64(&na_sm_copy_buf->available.val, 1LL << idx_reserved);
+}
+
+/*---------------------------------------------------------------------------*/
 static na_return_t
 na_sm_msg_insert(na_class_t *na_class, struct na_sm_op_id *na_sm_op_id,
-    na_cb_type_t cb_type, struct na_sm_addr *na_sm_addr,
-    unsigned int idx_reserved, na_size_t buf_size, na_tag_t tag)
+    unsigned int idx_reserved)
 {
     na_sm_cacheline_hdr_t na_sm_hdr;
     na_return_t ret = NA_SUCCESS;
+    int rc;
 
     /* Post the SM send request */
-    na_sm_hdr.hdr.type = cb_type;
+    na_sm_hdr.hdr.type = na_sm_op_id->completion_data.callback_info.type;
     na_sm_hdr.hdr.buf_idx = idx_reserved & 0xff;
-    na_sm_hdr.hdr.buf_size = buf_size & 0xffff;
-    na_sm_hdr.hdr.tag = tag;
-    if (!na_sm_ring_buf_push(na_sm_addr->na_sm_send_ring_buf, na_sm_hdr)) {
-        NA_LOG_ERROR("Full ring buffer");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    /* Immediate completion, add directly to completion queue. */
-    ret = na_sm_complete(na_sm_op_id);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    na_sm_hdr.hdr.buf_size = na_sm_op_id->info.msg.buf_size & 0xffff;
+    na_sm_hdr.hdr.tag = na_sm_op_id->info.msg.tag;
+    rc = (int) na_sm_ring_buf_push(na_sm_op_id->na_sm_addr->na_sm_send_ring_buf,
+        na_sm_hdr);
+    NA_CHECK_ERROR(rc == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Full ring buffer");
 
-    /* Notify remote */
     if (!NA_SM_CLASS(na_class)->no_wait) {
+        /* Notify remote */
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
-        if (hg_event_set(na_sm_addr->remote_notify) != HG_UTIL_SUCCESS) {
-            NA_LOG_ERROR("Could not send completion notification");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_event_set(na_sm_op_id->na_sm_addr->remote_notify);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "Could not send completion notification");
 #else
-        if (na_sm_event_set(na_sm_addr->remote_notify) != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not send completion notification");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        ret = na_sm_event_set(na_sm_op_id->na_sm_addr->remote_notify);
+        NA_CHECK_NA_ERROR(done, ret, "Could not send completion notification");
 #endif
     }
 
-    /* Notify local completion */
-    if (!NA_SM_CLASS(na_class)->no_wait
-        && (hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify)
-        != HG_UTIL_SUCCESS)) {
-        NA_LOG_ERROR("Could not signal local completion");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+    /* Immediate completion, add directly to completion queue. */
+    ret = na_sm_complete(na_sm_op_id);
+    NA_CHECK_NA_ERROR(done, ret, "Could not complete operation");
+
+    if (!NA_SM_CLASS(na_class)->no_wait) {
+        /* Notify local completion */
+        rc = hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "Could not signal local completion");
     }
 
 done:
@@ -1816,74 +1771,59 @@ na_sm_progress_cb(void *arg, int error, hg_util_bool_t *progressed)
 {
     na_class_t *na_class;
     struct na_sm_poll_data *na_sm_poll_data = (struct na_sm_poll_data *) arg;
-    na_return_t na_ret;
+    na_return_t ret;
+
+    NA_CHECK_ERROR_NORET(na_sm_poll_data == NULL, error, "NULL SM poll data");
 
-    if (!na_sm_poll_data) {
-        NA_LOG_ERROR("NULL SM poll data");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
     na_class = na_sm_poll_data->na_class;
 
     if (error) {
-        na_ret = na_sm_progress_error(na_class, na_sm_poll_data->addr, error);
-        if (na_ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not process error");
-            goto done;
-        }
+        ret = na_sm_progress_error(na_class, na_sm_poll_data->addr);
+        NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, error,
+            "Could not process error");
     } else switch (na_sm_poll_data->type) {
         case NA_SM_ACCEPT:
-            na_ret = na_sm_progress_accept(na_class, na_sm_poll_data->addr,
+            ret = na_sm_progress_accept(na_class, na_sm_poll_data->addr,
                 (hg_util_bool_t *) progressed);
-            if (na_ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not make progress on accept");
-                goto done;
-            }
+            NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, error,
+                "Could not make progress on accept");
             break;
         case NA_SM_SOCK:
-            na_ret = na_sm_progress_sock(na_class, na_sm_poll_data->addr,
-                (hg_util_bool_t *) progressed);
-            if (na_ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not make progress on sock");
-                goto done;
+            if (na_sm_poll_data->addr != NA_SM_CLASS(na_class)->self_addr) {
+                ret = na_sm_progress_sock(na_class, na_sm_poll_data->addr,
+                    (hg_util_bool_t *) progressed);
+                NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, error,
+                    "Could not make progress on sock");
             }
             break;
         case NA_SM_NOTIFY:
-            na_ret = na_sm_progress_notify(na_class, na_sm_poll_data->addr,
+            ret = na_sm_progress_notify(na_class, na_sm_poll_data->addr,
                 (hg_util_bool_t *) progressed);
-            if (na_ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not make progress on notify");
-                goto done;
-            }
+            NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, error,
+                "Could not make progress on notify");
             break;
         default:
             NA_LOG_ERROR("Unknown poll data type");
-            na_ret = NA_PROTOCOL_ERROR;
-            goto done;
-            break;
+            goto error;
     }
 
-done:
-    return (na_ret == NA_SUCCESS) ? HG_UTIL_SUCCESS : HG_UTIL_FAIL;
+    return HG_UTIL_SUCCESS;
+
+error:
+    return HG_UTIL_FAIL;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_sm_progress_error(na_class_t *na_class, struct na_sm_addr *poll_addr,
-    int error)
+na_sm_progress_error(na_class_t *na_class, struct na_sm_addr *poll_addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (poll_addr == NA_SM_CLASS(na_class)->self_addr) {
-        NA_LOG_ERROR("Unsupported error occurred");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(poll_addr == NA_SM_CLASS(na_class)->self_addr,
+        done, ret, NA_PROTOCOL_ERROR, "Unsupported error occurred");
 
     /* Handle case of peer disconnection */
-    if (error) {
-        ret = na_sm_addr_free(na_class, poll_addr);
-    }
+    ret = na_sm_addr_free(na_class, poll_addr);
 
 done:
     return ret;
@@ -1901,12 +1841,12 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     hg_time_t now;
     double elapsed_ms;
     na_return_t ret = NA_SUCCESS;
+#ifndef SOCK_NONBLOCK
+    int rc;
+#endif
 
-    if (poll_addr != NA_SM_CLASS(na_class)->self_addr) {
-        NA_LOG_ERROR("Unrecognized poll addr");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(poll_addr != NA_SM_CLASS(na_class)->self_addr,
+        done, ret, NA_PROTOCOL_ERROR, "Unrecognized poll addr");
 
     /* Prevent from entering accept too often */
     hg_time_get_current(&now);
@@ -1924,29 +1864,24 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     conn_sock = accept(poll_addr->sock, NULL, NULL);
 #endif
     if (conn_sock == -1) {
-        if (errno == EAGAIN) {
+        if (likely(errno == EAGAIN)) {
             *progressed = NA_FALSE;
             goto done;
-        }
-        NA_LOG_ERROR("accept() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+        } else
+            NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR, "accept() failed (%s)",
+                strerror(errno));
     }
 #ifndef SOCK_NONBLOCK
-    if (fcntl(conn_sock, F_SETFL, O_NONBLOCK) == -1) {
-        NA_LOG_ERROR("fcntl() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    };
+    rc = fcntl(conn_sock, F_SETFL, O_NONBLOCK);
+    NA_CHECK_ERROR(rc == -1, done, ret, NA_PROTOCOL_ERROR,
+        "fcntl() failed (%s)", strerror(errno));
 #endif
 
     /* Allocate new addr and pass it to poll set */
     na_sm_addr = (struct na_sm_addr *) malloc(sizeof(struct na_sm_addr));
-    if (!na_sm_addr) {
-        NA_LOG_ERROR("Could not allocate NA SM addr");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_addr == NULL, done, ret, NA_NOMEM,
+        "Could not allocate NA SM addr");
+
     memset(na_sm_addr, 0, sizeof(struct na_sm_addr));
     hg_atomic_init32(&na_sm_addr->ref_count, 1);
     na_sm_addr->accepted = NA_TRUE;
@@ -1957,10 +1892,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
     /* Add conn_sock to poll set */
     ret = na_sm_poll_register(na_class, NA_SM_SOCK, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add conn_sock to poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not add conn_sock to poll set");
 
     /* Set up ring buffer pair (send/recv) for connection IDs */
     na_sm_addr->conn_id = NA_SM_CLASS(na_class)->self_addr->conn_id;
@@ -1968,11 +1900,9 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
         NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(filename,
         NA_SM_RING_BUF_SIZE, NA_TRUE);
-    if (!na_sm_ring_buf) {
-        NA_LOG_ERROR("Could not open ring buf");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_ring_buf == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "Could not open ring buf");
+
     /* Initialize ring buffer */
     na_sm_ring_buf_init(na_sm_ring_buf);
     na_sm_addr->na_sm_send_ring_buf = na_sm_ring_buf;
@@ -1981,11 +1911,9 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
         NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(filename,
         NA_SM_RING_BUF_SIZE, NA_TRUE);
-    if (!na_sm_ring_buf) {
-        NA_LOG_ERROR("Could not open ring buf");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_ring_buf == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "Could not open ring buf");
+
     /* Initialize ring buffer */
     na_sm_ring_buf_init(na_sm_ring_buf);
     na_sm_addr->na_sm_recv_ring_buf = na_sm_ring_buf;
@@ -1993,11 +1921,8 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     /* Create local signal event */
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
     local_notify = hg_event_create();
-    if (local_notify == HG_UTIL_FAIL) {
-        NA_LOG_ERROR("hg_event_create() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(local_notify == -1, done, ret, NA_PROTOCOL_ERROR,
+        "hg_event_create() failed");
 #else
     /**
      * If eventfd is not supported, we need to explicitly use named pipes in
@@ -2007,22 +1932,16 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     NA_SM_GEN_FIFO_NAME(filename, NA_SM_RECV_NAME,
         NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     local_notify = na_sm_event_create(filename);
-    if (local_notify == -1) {
-        NA_LOG_ERROR("na_sm_event_create() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(local_notify == -1, done, ret, NA_PROTOCOL_ERROR,
+        "na_sm_event_create() failed");
 #endif
     na_sm_addr->local_notify = local_notify;
 
     /* Create remote signal event */
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
     remote_notify = hg_event_create();
-    if (remote_notify == HG_UTIL_FAIL) {
-        NA_LOG_ERROR("hg_event_create() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(remote_notify == -1, done, ret, NA_PROTOCOL_ERROR,
+        "hg_event_create() failed");
 #else
     /**
      * If eventfd is not supported, we need to explicitly use named pipes in
@@ -2032,27 +1951,18 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     NA_SM_GEN_FIFO_NAME(filename, NA_SM_SEND_NAME,
         NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     remote_notify = na_sm_event_create(filename);
-    if (remote_notify == -1) {
-        NA_LOG_ERROR("na_sm_event_create() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(remote_notify == -1, done, ret, NA_PROTOCOL_ERROR,
+        "na_sm_event_create() failed");
 #endif
     na_sm_addr->remote_notify = remote_notify;
 
     /* Add local notify to poll set */
     ret = na_sm_poll_register(na_class, NA_SM_NOTIFY, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add notify to poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not add notify to poll set");
 
     /* Send connection ID / event IDs */
     ret = na_sm_send_conn_id(na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not send connection ID");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not send connection ID");
 
     /* Increment connection ID */
     NA_SM_CLASS(na_class)->self_addr->conn_id++;
@@ -2067,6 +1977,10 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
 done:
     return ret;
+
+//error:
+// TODO
+//    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2076,10 +1990,8 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (poll_addr == NA_SM_CLASS(na_class)->self_addr) {
-        *progressed = NA_FALSE;
-        goto done;
-    }
+    NA_CHECK_ERROR(poll_addr == NA_SM_CLASS(na_class)->self_addr,
+        done, ret, NA_PROTOCOL_ERROR, "Unrecognized poll addr");
 
     switch (poll_addr->sock_progress) {
         case NA_SM_ADDR_INFO: {
@@ -2087,11 +1999,7 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
             /* Receive addr info (PID / ID) */
             ret = na_sm_recv_addr_info(poll_addr, &received);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not recv addr info");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_NA_ERROR(done, ret, "Could not recv addr info");
             if (!received) {
                 *progressed = NA_FALSE;
                 goto done;
@@ -2117,11 +2025,7 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
             /* Receive connection ID / event IDs */
             ret = na_sm_recv_conn_id(poll_addr, &received);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not recv connection ID");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_NA_ERROR(done, ret, "Could not recv connection ID");
             if (!received) {
                 *progressed = NA_FALSE;
                 goto done;
@@ -2132,7 +2036,7 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
             hg_thread_spin_lock(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
             HG_QUEUE_FOREACH(na_sm_op_id,
                 &NA_SM_CLASS(na_class)->lookup_op_queue, entry) {
-                if (na_sm_op_id->info.lookup.na_sm_addr == poll_addr) {
+                if (na_sm_op_id->na_sm_addr == poll_addr) {
                     HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->lookup_op_queue,
                         na_sm_op_id, na_sm_op_id, entry);
                     break;
@@ -2140,12 +2044,9 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
             }
             hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
 
-            if (!na_sm_op_id) {
-                NA_LOG_ERROR("Could not find lookup op ID, conn ID=%u, PID=%u",
-                    poll_addr->conn_id, (unsigned int) poll_addr->pid);
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_ERROR(na_sm_op_id == NULL, done, ret, NA_PROTOCOL_ERROR,
+                "Could not find lookup op ID, conn ID=%u, PID=%u",
+                poll_addr->conn_id, (unsigned int) poll_addr->pid);
 
             /* Open remote ring buf pair (send and recv names correspond to
              * remote ring buffer pair) */
@@ -2153,30 +2054,21 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
                 NA_SM_CLASS(na_class)->username, poll_addr);
             na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(
                 filename, NA_SM_RING_BUF_SIZE, NA_FALSE);
-            if (!na_sm_ring_buf) {
-                NA_LOG_ERROR("Could not open ring buf");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_ERROR(na_sm_ring_buf == NULL, done, ret, NA_PROTOCOL_ERROR,
+                "Could not open ring buf");
             poll_addr->na_sm_send_ring_buf = na_sm_ring_buf;
 
             NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME,
                 NA_SM_CLASS(na_class)->username, poll_addr);
             na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(
                 filename, NA_SM_RING_BUF_SIZE, NA_FALSE);
-            if (!na_sm_ring_buf) {
-                NA_LOG_ERROR("Could not open ring buf");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
+            NA_CHECK_ERROR(na_sm_ring_buf == NULL, done, ret, NA_PROTOCOL_ERROR,
+                "Could not open ring buf");
             poll_addr->na_sm_recv_ring_buf = na_sm_ring_buf;
 
             /* Add received local notify to poll set */
             ret = na_sm_poll_register(na_class, NA_SM_NOTIFY, poll_addr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not add notify to poll set");
-                goto done;
-            }
+            NA_CHECK_NA_ERROR(done, ret, "Could not add notify to poll set");
 
             /* Add addr to poll addr queue */
             hg_thread_spin_lock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
@@ -2186,10 +2078,7 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
             /* Completion */
             ret = na_sm_complete(na_sm_op_id);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not complete operation");
-                goto done;
-            }
+            NA_CHECK_NA_ERROR(done, ret, "Could not complete operation");
 
             /* Progressed */
             *progressed = NA_TRUE;
@@ -2203,6 +2092,10 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
 done:
     return ret;
+
+//error:
+// TODO
+//    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2211,42 +2104,33 @@ na_sm_progress_notify(na_class_t *na_class, struct na_sm_addr *poll_addr,
     na_bool_t *progressed)
 {
     na_sm_cacheline_hdr_t na_sm_hdr;
-    na_bool_t notified = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
+    int rc;
 
     if (poll_addr == NA_SM_CLASS(na_class)->self_addr) {
         /* Local notification */
-        if (!NA_SM_CLASS(na_class)->no_wait
-            && (hg_event_get(poll_addr->local_notify, (hg_util_bool_t *) &notified)
-            != HG_UTIL_SUCCESS)) {
-            NA_LOG_ERROR("Could not get completion notification");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
-
-        if (!notified) {
+        if (!NA_SM_CLASS(na_class)->no_wait) {
+            rc = hg_event_get(poll_addr->local_notify,
+                (hg_util_bool_t *) progressed);
+            NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+                "Could not get completion notification");
+        } else
             *progressed = NA_FALSE;
-            goto done;
-        }
-        *progressed = NA_TRUE;
         goto done;
     }
 
     /* Remote notification */
     if (!NA_SM_CLASS(na_class)->no_wait) {
+        na_bool_t notified = NA_FALSE;
+
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
-        if (hg_event_get(poll_addr->local_notify, (hg_util_bool_t *) &notified)
-            != HG_UTIL_SUCCESS) {
-            NA_LOG_ERROR("Could not get completion notification");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_event_get(poll_addr->local_notify,
+            (hg_util_bool_t *) &notified);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "Could not get completion notification");
 #else
-        if (na_sm_event_get(poll_addr->local_notify, &notified) != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not get completion notification");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        ret = na_sm_event_get(poll_addr->local_notify, &notified);
+        NA_CHECK_NA_ERROR(done, ret, "Could not get completion notification");
 #endif
         if (!notified) {
             *progressed = NA_FALSE;
@@ -2259,24 +2143,29 @@ na_sm_progress_notify(na_class_t *na_class, struct na_sm_addr *poll_addr,
         goto done;
     }
 
+    /* Progress expected and unexpected messages */
     switch (na_sm_hdr.hdr.type) {
-        case NA_CB_RECV_UNEXPECTED:
+        case NA_CB_SEND_UNEXPECTED:
             ret = na_sm_progress_unexpected(na_class, poll_addr, na_sm_hdr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not make progress on unexpected msg");
-            }
+            NA_CHECK_NA_ERROR(done, ret,
+                "Could not make progress on unexpected msg");
             break;
-        case NA_CB_RECV_EXPECTED:
+        case NA_CB_SEND_EXPECTED:
             ret = na_sm_progress_expected(na_class, poll_addr, na_sm_hdr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not make progress on expected msg");
-            }
+            NA_CHECK_NA_ERROR(done, ret,
+                "Could not make progress on expected msg");
             break;
         default:
-            NA_LOG_ERROR("Unknown type of operation");
-            ret = NA_PROTOCOL_ERROR;
-            break;
+            NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR,
+                "Unknown type of operation");
     }
+
+    /* Progress retries */
+    if (!NA_SM_CLASS(na_class)->no_retry) {
+        ret = na_sm_progress_retries(na_class);
+        NA_CHECK_NA_ERROR(done, ret, "Could not make progress on retried msgs");
+    }
+
     *progressed = NA_TRUE;
 
 done:
@@ -2288,7 +2177,6 @@ static na_return_t
 na_sm_progress_unexpected(na_class_t *na_class, struct na_sm_addr *poll_addr,
     na_sm_cacheline_hdr_t na_sm_hdr)
 {
-    struct na_sm_unexpected_info *na_sm_unexpected_info = NULL;
     struct na_sm_op_id *na_sm_op_id = NULL;
     na_return_t ret = NA_SUCCESS;
 
@@ -2296,31 +2184,48 @@ na_sm_progress_unexpected(na_class_t *na_class, struct na_sm_addr *poll_addr,
     hg_thread_spin_lock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
     na_sm_op_id = HG_QUEUE_FIRST(&NA_SM_CLASS(na_class)->unexpected_op_queue);
     HG_QUEUE_POP_HEAD(&NA_SM_CLASS(na_class)->unexpected_op_queue, entry);
+    hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
 
-    if (na_sm_op_id) {
-        /* If an op id was pushed, associate unexpected info to this
-         * operation ID and complete operation */
-        na_sm_op_id->info.recv_unexpected.unexpected_info.na_sm_addr = poll_addr;
-        na_sm_op_id->info.recv_unexpected.unexpected_info.na_sm_hdr = na_sm_hdr;
+    if (likely(na_sm_op_id)) {
+        /* Fill info */
+        na_sm_op_id->na_sm_addr = poll_addr;
+        hg_atomic_incr32(&na_sm_op_id->na_sm_addr->ref_count);
+        na_sm_op_id->info.msg.actual_buf_size =
+            (na_size_t) na_sm_hdr.hdr.buf_size;
+        na_sm_op_id->info.msg.tag = (na_tag_t) na_sm_hdr.hdr.tag;
 
+        /* Copy and free buffer atomically */
+        na_sm_copy_and_free_buf(na_class, poll_addr->na_sm_copy_buf,
+            na_sm_op_id->info.msg.buf.ptr, na_sm_hdr.hdr.buf_size,
+            na_sm_hdr.hdr.buf_idx);
+
+        /* Complete operation */
         ret = na_sm_complete(na_sm_op_id);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not complete operation");
     } else {
+        struct na_sm_unexpected_info *na_sm_unexpected_info = NULL;
+
         /* If no error and message arrived, keep a copy of the struct in
          * the unexpected message queue (should rarely happen) */
         na_sm_unexpected_info = (struct na_sm_unexpected_info *) malloc(
             sizeof(struct na_sm_unexpected_info));
-        if (!na_sm_unexpected_info) {
-            NA_LOG_ERROR("Could not allocate unexpected info");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_sm_unexpected_info == NULL, done, ret, NA_NOMEM,
+            "Could not allocate unexpected info");
+
         na_sm_unexpected_info->na_sm_addr = poll_addr;
-        na_sm_unexpected_info->na_sm_hdr = na_sm_hdr;
+        na_sm_unexpected_info->buf_size = (na_size_t) na_sm_hdr.hdr.buf_size;
+        na_sm_unexpected_info->tag = (na_tag_t) na_sm_hdr.hdr.tag;
+
+        /* Allocate buf */
+        na_sm_unexpected_info->buf = malloc(na_sm_unexpected_info->buf_size);
+        NA_CHECK_ERROR(na_sm_unexpected_info->buf == NULL, done, ret, NA_NOMEM,
+            "Could not allocate na_sm_unexpected_info buf");
+
+        /* Copy and free buffer atomically */
+        na_sm_copy_and_free_buf(na_class, poll_addr->na_sm_copy_buf,
+            na_sm_unexpected_info->buf, na_sm_hdr.hdr.buf_size,
+            na_sm_hdr.hdr.buf_idx);
 
         /* Otherwise push the unexpected message into our unexpected queue so
          * that we can treat it later when a recv_unexpected is posted */
@@ -2347,34 +2252,31 @@ na_sm_progress_expected(na_class_t *na_class, struct na_sm_addr *poll_addr,
         &NA_SM_CLASS(na_class)->expected_op_queue_lock);
     HG_QUEUE_FOREACH(na_sm_op_id,
         &NA_SM_CLASS(na_class)->expected_op_queue, entry) {
-        if (na_sm_op_id->info.recv_expected.na_sm_addr == poll_addr &&
-            na_sm_op_id->info.recv_expected.tag == na_sm_hdr.hdr.tag) {
+        if (na_sm_op_id->na_sm_addr == poll_addr
+            && na_sm_op_id->info.msg.tag == na_sm_hdr.hdr.tag) {
             HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->expected_op_queue,
                 na_sm_op_id, na_sm_op_id, entry);
+            hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
             break;
         }
     }
     hg_thread_spin_unlock(
         &NA_SM_CLASS(na_class)->expected_op_queue_lock);
 
-    if (!na_sm_op_id) {
-        /* No match if either the message was not pre-posted or it was canceled */
-        NA_LOG_WARNING("Ignored expected message received (canceled?)");
-//        NA_LOG_DEBUG("Expected: pid=%d, tag=%d", poll_addr->pid,
-//            na_sm_hdr.hdr.tag);
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_op_id == NULL, done, ret, NA_INVALID_ARG,
+        "Invalid operation ID");
+    /* Cannot have an already completed operation ID, TODO add sanity check */
+
+    na_sm_op_id->info.msg.actual_buf_size = na_sm_hdr.hdr.buf_size;
 
     /* Copy and free buffer atomically */
     na_sm_copy_and_free_buf(na_class, poll_addr->na_sm_copy_buf,
-        na_sm_op_id->info.recv_expected.buf, na_sm_hdr.hdr.buf_size,
+        na_sm_op_id->info.msg.buf.ptr, na_sm_hdr.hdr.buf_size,
         na_sm_hdr.hdr.buf_idx);
 
+    /* Complete operation */
     ret = na_sm_complete(na_sm_op_id);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not complete operation");
 
 done:
     return ret;
@@ -2382,12 +2284,77 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
+na_sm_progress_retries(na_class_t *na_class)
+{
+    struct na_sm_op_id *na_sm_op_id = NULL;
+    unsigned int idx_reserved;
+    na_return_t ret = NA_SUCCESS;
+
+    do {
+        na_bool_t canceled = NA_FALSE;
+
+        hg_thread_spin_lock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+        na_sm_op_id = HG_QUEUE_FIRST(&NA_SM_CLASS(na_class)->retry_op_queue);
+        hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+
+        if (!na_sm_op_id)
+            break;
+
+        NA_LOG_DEBUG("Attempting to retry %p", na_sm_op_id);
+
+        /* Try to reserve buffer atomically */
+        if (na_sm_reserve_and_copy_buf(na_class,
+            na_sm_op_id->na_sm_addr->na_sm_copy_buf,
+            na_sm_op_id->info.msg.buf.const_ptr,
+            na_sm_op_id->info.msg.buf_size, &idx_reserved) == NA_AGAIN)
+            break;
+
+        /* Successfully reserved a buffer */
+        hg_thread_spin_lock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+        if ((hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_CANCELED)) {
+            canceled = NA_TRUE;
+            na_sm_release_buf(na_sm_op_id->na_sm_addr->na_sm_copy_buf,
+                idx_reserved);
+        } else {
+            HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->retry_op_queue,
+                na_sm_op_id, na_sm_op_id, entry);
+            hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
+        }
+        hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+
+        if (!canceled) {
+            /* Insert message into ring buffer (complete OP ID) */
+            ret = na_sm_msg_insert(na_class, na_sm_op_id, idx_reserved);
+            NA_CHECK_NA_ERROR(error, ret, "Could not insert message");
+        }
+    } while (1);
+
+    return ret;
+
+error:
+    na_sm_release_buf(na_sm_op_id->na_sm_addr->na_sm_copy_buf, idx_reserved);
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
 na_sm_complete(struct na_sm_op_id *na_sm_op_id)
 {
     struct na_cb_info *callback_info = NULL;
-    na_bool_t canceled = (na_bool_t) hg_atomic_get32(&na_sm_op_id->canceled);
+    na_bool_t canceled = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
 
+    /* Mark op id as completed before checking for cancelation */
+    if (hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_COMPLETED)
+        & NA_SM_OP_CANCELED) {
+        /* If it was canceled while being processed, set callback ret accordingly */
+        NA_LOG_DEBUG("Operation ID %p was canceled", na_sm_op_id);
+        canceled = NA_TRUE;
+    }
+
     /* Init callback info */
     callback_info = &na_sm_op_id->completion_data.callback_info;
     callback_info->ret = (canceled) ? NA_CANCELED : ret;
@@ -2395,42 +2362,29 @@ na_sm_complete(struct na_sm_op_id *na_sm_op_id)
     switch (callback_info->type) {
         case NA_CB_LOOKUP:
             callback_info->info.lookup.addr =
-                (na_addr_t) na_sm_op_id->info.lookup.na_sm_addr;
+                (na_addr_t) na_sm_op_id->na_sm_addr;
             break;
         case NA_CB_SEND_UNEXPECTED:
             break;
-        case NA_CB_RECV_UNEXPECTED: {
-            struct na_sm_unexpected_info *na_sm_unexpected_info =
-                &na_sm_op_id->info.recv_unexpected.unexpected_info;
-            struct na_sm_copy_buf *na_sm_copy_buf;
-
+        case NA_CB_RECV_UNEXPECTED:
             if (canceled) {
                 /* In case of cancellation where no recv'd data */
                 callback_info->info.recv_unexpected.actual_buf_size = 0;
                 callback_info->info.recv_unexpected.source = NA_ADDR_NULL;
                 callback_info->info.recv_unexpected.tag = 0;
-                break;
+            } else {
+                /* Increment addr ref count */
+                hg_atomic_incr32(&na_sm_op_id->na_sm_addr->ref_count);
+
+                /* Fill callback info */
+                callback_info->info.recv_unexpected.actual_buf_size =
+                    na_sm_op_id->info.msg.actual_buf_size;
+                callback_info->info.recv_unexpected.source =
+                    (na_addr_t) na_sm_op_id->na_sm_addr;
+                callback_info->info.recv_unexpected.tag =
+                    na_sm_op_id->info.msg.tag;
             }
-
-            /* Increment addr ref count */
-            hg_atomic_incr32(&na_sm_unexpected_info->na_sm_addr->ref_count);
-
-            /* Fill callback info */
-            callback_info->info.recv_unexpected.actual_buf_size =
-                (na_size_t) na_sm_unexpected_info->na_sm_hdr.hdr.buf_size;
-            callback_info->info.recv_unexpected.source =
-                (na_addr_t) na_sm_unexpected_info->na_sm_addr;
-            callback_info->info.recv_unexpected.tag =
-                (na_tag_t) na_sm_unexpected_info->na_sm_hdr.hdr.tag;
-
-            /* Copy and free buffer atomically */
-            na_sm_copy_buf = na_sm_unexpected_info->na_sm_addr->na_sm_copy_buf;
-            na_sm_copy_and_free_buf(na_sm_op_id->na_class, na_sm_copy_buf,
-                na_sm_op_id->info.recv_unexpected.buf,
-                na_sm_unexpected_info->na_sm_hdr.hdr.buf_size,
-                na_sm_unexpected_info->na_sm_hdr.hdr.buf_idx);
             break;
-        }
         case NA_CB_SEND_EXPECTED:
             break;
         case NA_CB_RECV_EXPECTED:
@@ -2440,20 +2394,14 @@ na_sm_complete(struct na_sm_op_id *na_sm_op_id)
         case NA_CB_GET:
             break;
         default:
-            NA_LOG_ERROR("Operation not supported");
-            ret = NA_INVALID_PARAM;
-            break;
+            NA_GOTO_ERROR(done, ret, NA_INVALID_ARG,
+                "Operation type %d not supported", callback_info->type);
     }
 
-    /* Mark op id as completed */
-    hg_atomic_set32(&na_sm_op_id->completed, NA_TRUE);
-
+    /* Add OP to NA completion queue */
     ret = na_cb_completion_add(na_sm_op_id->context,
         &na_sm_op_id->completion_data);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add callback to completion queue");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not add callback to completion queue");
 
 done:
     return ret;
@@ -2465,13 +2413,21 @@ na_sm_release(void *arg)
 {
     struct na_sm_op_id *na_sm_op_id = (struct na_sm_op_id *) arg;
 
-    if (na_sm_op_id && !hg_atomic_get32(&na_sm_op_id->completed)) {
-        NA_LOG_ERROR("Releasing resources from an uncompleted operation");
+    NA_CHECK_WARNING(na_sm_op_id
+        && (!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED)),
+        "Releasing resources from an uncompleted operation");
+
+    if (na_sm_op_id->na_sm_addr) {
+        na_sm_addr_free(na_sm_op_id->na_class, na_sm_op_id->na_sm_addr);
+        na_sm_op_id->na_sm_addr = NULL;
     }
-    na_sm_op_destroy(NULL, na_sm_op_id);
+    na_sm_op_destroy(na_sm_op_id->na_class, na_sm_op_id);
 }
 
-/*---------------------------------------------------------------------------*/
+/********************/
+/* Plugin callbacks */
+/********************/
+
 static na_bool_t
 na_sm_check_protocol(const char *protocol_name)
 {
@@ -2493,7 +2449,7 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     pid_t pid;
     char *username = NULL;
     hg_poll_set_t *poll_set;
-    na_bool_t no_wait = NA_FALSE;
+    na_bool_t no_wait = NA_FALSE, no_retry = NA_FALSE;
     int local_notify;
     na_return_t ret = NA_SUCCESS;
 
@@ -2502,8 +2458,10 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     /* Get init info */
     if (na_info->na_init_info) {
         /* Progress mode */
-        if (na_info->na_init_info->progress_mode == NA_NO_BLOCK)
+        if (na_info->na_init_info->progress_mode & NA_NO_BLOCK)
             no_wait = NA_TRUE;
+        if (na_info->na_init_info->progress_mode & NA_NO_RETRY)
+            no_retry = NA_TRUE;
     }
 
     /* Get PID */
@@ -2511,49 +2469,35 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
 
     /* Get username */
     username = getlogin_safe();
-    if (!username) {
-        NA_LOG_ERROR("Could not query login name");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(username == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "Could not query login name");
 
     /* Initialize errno */
     errno = 0;
 
     /* Initialize private data */
     na_class->plugin_class = malloc(sizeof(struct na_sm_class));
-    if (!na_class->plugin_class) {
-        NA_LOG_ERROR("Could not allocate NA private data class");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class->plugin_class == NULL, done, ret, NA_NOMEM,
+        "Could not allocate NA private data class");
     memset(na_class->plugin_class, 0, sizeof(struct na_sm_class));
     NA_SM_CLASS(na_class)->no_wait = no_wait;
+    NA_SM_CLASS(na_class)->no_retry = no_retry;
 
     /* Copy username */
     NA_SM_CLASS(na_class)->username = strdup(username);
-    if (!NA_SM_CLASS(na_class)->username) {
-        NA_LOG_ERROR("Could not dup username");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(NA_SM_CLASS(na_class)->username == NULL, done, ret, NA_NOMEM,
+        "Could not dup username");
 
     /* Create poll set to wait for events */
     poll_set = hg_poll_create();
-    if (!poll_set) {
-        NA_LOG_ERROR("cannot create poll set");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(poll_set == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "Cannot create poll set");
     NA_SM_CLASS(na_class)->poll_set = poll_set;
 
     /* Create self addr */
     na_sm_addr = (struct na_sm_addr *) malloc(sizeof(struct na_sm_addr));
-    if (!na_sm_addr) {
-        NA_LOG_ERROR("Could not allocate NA SM addr");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_addr == NULL, done, ret, NA_NOMEM,
+        "Could not allocate NA SM addr");
     memset(na_sm_addr, 0, sizeof(struct na_sm_addr));
     na_sm_addr->pid = pid;
     na_sm_addr->id = (unsigned int) hg_atomic_incr32(&id) - 1;
@@ -2562,26 +2506,17 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     /* If we're listening, create a new shm region */
     if (listen) {
         ret = na_sm_setup_shm(na_class, na_sm_addr);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not setup shm");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not setup shm");
     }
     /* Create local signal event on self address */
     local_notify = hg_event_create();
-    if (local_notify == HG_UTIL_FAIL) {
-        NA_LOG_ERROR("hg_event_create() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(local_notify == -1, done, ret, NA_PROTOCOL_ERROR,
+        "hg_event_create() failed");
     na_sm_addr->local_notify = local_notify;
 
     /* Add local notify to poll set */
     ret = na_sm_poll_register(na_class, NA_SM_NOTIFY, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add notify to poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not add notify to poll set");
     NA_SM_CLASS(na_class)->self_addr = na_sm_addr;
 
     /* Initialize queues */
@@ -2591,6 +2526,7 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->lookup_op_queue);
     HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->unexpected_op_queue);
     HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->expected_op_queue);
+    HG_QUEUE_INIT(&NA_SM_CLASS(na_class)->retry_op_queue);
 
     /* Initialize mutexes */
     hg_thread_spin_init(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
@@ -2599,10 +2535,15 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     hg_thread_spin_init(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
     hg_thread_spin_init(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
     hg_thread_spin_init(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
+    hg_thread_spin_init(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
     hg_thread_spin_init(&NA_SM_CLASS(na_class)->copy_buf_lock);
 
 done:
     return ret;
+
+//error:
+// TODO
+//    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2610,63 +2551,53 @@ static na_return_t
 na_sm_finalize(na_class_t *na_class)
 {
     na_return_t ret = NA_SUCCESS;
+    na_bool_t empty;
+    int rc;
 
-    if (!na_class->plugin_class) {
+    if (!na_class->plugin_class)
         goto done;
-    }
 
     /* Check that lookup op queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->lookup_op_queue)) {
-        NA_LOG_ERROR("Lookup op queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->lookup_op_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Lookup op queue should be empty");
 
     /* Check that unexpected op queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->unexpected_op_queue)) {
-        NA_LOG_ERROR("Unexpected op queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->unexpected_op_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Unexpected op queue should be empty");
 
     /* Check that unexpected message queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->unexpected_msg_queue)) {
-        NA_LOG_ERROR("Unexpected msg queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->unexpected_msg_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Unexpected msg queue should be empty");
 
     /* Check that expected op queue is empty */
-    if (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->expected_op_queue)) {
-        NA_LOG_ERROR("Expected op queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->expected_op_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Expected op queue should be empty");
+
+    /* Check that retry op queue is empty */
+    empty = HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->retry_op_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
+        "Retry op queue should be empty");
 
     /* Check that accepted addr queue is empty */
     while (!HG_QUEUE_IS_EMPTY(&NA_SM_CLASS(na_class)->accepted_addr_queue)) {
         struct na_sm_addr *na_sm_addr = HG_QUEUE_FIRST(
             &NA_SM_CLASS(na_class)->accepted_addr_queue);
         ret = na_sm_addr_free(na_class, na_sm_addr);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not free accepted addr");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not free accepted addr");
     }
 
     /* Free self addr */
     ret = na_sm_addr_free(na_class, NA_SM_CLASS(na_class)->self_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not free self addr");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not free self addr");
 
     /* Close poll set */
-    if (hg_poll_destroy(NA_SM_CLASS(na_class)->poll_set) != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_poll_destroy() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_poll_destroy(NA_SM_CLASS(na_class)->poll_set);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+        "hg_poll_destroy() failed");
 
     /* Destroy mutexes */
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
@@ -2675,6 +2606,7 @@ na_sm_finalize(na_class_t *na_class)
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
+    hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->copy_buf_lock);
 
     free(NA_SM_CLASS(na_class)->username);
@@ -2699,15 +2631,13 @@ na_sm_cleanup(void)
      * directories */
     ret = nftw(pathname, na_sm_cleanup_file, NA_SM_CLEANUP_NFDS,
         FTW_PHYS | FTW_DEPTH);
-    if (ret != 0 && errno != ENOENT) {
-        NA_LOG_WARNING("nftw() failed (%s)", strerror(errno));
-    }
+    NA_CHECK_WARNING(ret != 0 && errno != ENOENT, "nftw() failed (%s)",
+        strerror(errno));
 
     ret = nftw(NA_SM_SHM_PATH, na_sm_cleanup_shm, NA_SM_CLEANUP_NFDS,
         FTW_PHYS);
-    if (ret != 0 && errno != ENOENT) {
-        NA_LOG_WARNING("nftw() failed (%s)", strerror(errno));
-    }
+    NA_CHECK_WARNING(ret != 0 && errno != ENOENT, "nftw() failed (%s)",
+        strerror(errno));
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2717,14 +2647,13 @@ na_sm_op_create(na_class_t *na_class)
     struct na_sm_op_id *na_sm_op_id = NULL;
 
     na_sm_op_id = (struct na_sm_op_id *) malloc(sizeof(struct na_sm_op_id));
-    if (!na_sm_op_id) {
-        NA_LOG_ERROR("Could not allocate NA SM operation ID");
-        goto done;
-    }
+    NA_CHECK_ERROR_NORET(na_sm_op_id == NULL, done,
+        "Could not allocate NA SM operation ID");
     memset(na_sm_op_id, 0, sizeof(struct na_sm_op_id));
     na_sm_op_id->na_class = na_class;
     hg_atomic_init32(&na_sm_op_id->ref_count, 1);
-    hg_atomic_init32(&na_sm_op_id->completed, NA_TRUE); /* Completed by default */
+    /* Completed by default */
+    hg_atomic_init32(&na_sm_op_id->status, NA_SM_OP_COMPLETED);
 
     /* Set op ID release callbacks */
     na_sm_op_id->completion_data.plugin_callback = na_sm_release;
@@ -2765,48 +2694,42 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
     char *name_string = NULL, *short_name = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_LOOKUP;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
+    na_sm_op_id->na_sm_addr = NULL;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
 
     /* Allocate addr */
     na_sm_addr = (struct na_sm_addr *) malloc(sizeof(struct na_sm_addr));
-    if (!na_sm_addr) {
-        NA_LOG_ERROR("Could not allocate NA SM addr");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_addr == NULL, done, ret, NA_NOMEM,
+        "Could not allocate NA SM addr");
     memset(na_sm_addr, 0, sizeof(struct na_sm_addr));
-    hg_atomic_init32(&na_sm_addr->ref_count, 1);
-    na_sm_op_id->info.lookup.na_sm_addr = na_sm_addr;
+    hg_atomic_init32(&na_sm_addr->ref_count, 2); /* Extra refcount */
+
+    na_sm_op_id->na_sm_addr = na_sm_addr;
 
     /**
      * Clean up name, strings can be of the format:
      *   <protocol>://<host string>
      */
     name_string = strdup(name);
-    if (!name_string) {
-        NA_LOG_ERROR("Could not duplicate string");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM,
+        "Could not duplicate string");
+
     if (strstr(name_string, ":") != NULL) {
          strtok_r(name_string, ":", &short_name);
          short_name += 2;
@@ -2820,20 +2743,14 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
     NA_SM_GEN_SHM_NAME(filename, NA_SM_CLASS(na_class)->username, na_sm_addr);
     na_sm_copy_buf = (struct na_sm_copy_buf *) na_sm_open_shared_buf(
         filename, sizeof(struct na_sm_copy_buf), NA_FALSE);
-    if (!na_sm_copy_buf) {
-        NA_LOG_ERROR("Could not open copy buf");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_copy_buf == NULL, done, ret, NA_PROTOCOL_ERROR,
+        "Could not open copy buffer");
     na_sm_addr->na_sm_copy_buf = na_sm_copy_buf;
 
     /* Open SHM sock */
     NA_SM_GEN_SOCK_PATH(pathname, NA_SM_CLASS(na_class)->username, na_sm_addr);
     ret = na_sm_create_sock(pathname, NA_FALSE, &conn_sock);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not create sock");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not create sock");
     na_sm_addr->sock = conn_sock;
     /* We only need to receive conn ID in sock progress */
     na_sm_addr->sock_progress = NA_SM_CONN_ID;
@@ -2844,30 +2761,17 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
         entry);
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->lookup_op_queue_lock);
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
-
     /* Add conn_sock to poll set */
     ret = na_sm_poll_register(na_class, NA_SM_SOCK, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add conn_sock to poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not add conn_sock to poll set");
 
     /* Send addr info (PID / ID) */
     ret = na_sm_send_addr_info(na_class, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not send addr info");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not send addr info");
 
 done:
-    if (ret != NA_SUCCESS) {
-        free(na_sm_addr);
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
     free(name_string);
+
     return ret;
 }
 
@@ -2883,17 +2787,14 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
         na_sm_recv_ring_buf_name[NA_SM_MAX_FILENAME],
         na_sock_name[NA_SM_MAX_FILENAME];
     na_return_t ret = NA_SUCCESS;
+    int rc;
 
-    if (!na_sm_addr) {
-        NA_LOG_ERROR("NULL SM addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL SM addr");
 
-    if (hg_atomic_decr32(&na_sm_addr->ref_count)) {
+    if (hg_atomic_decr32(&na_sm_addr->ref_count))
         /* Cannot free yet */
         goto done;
-    }
 
     if (na_sm_addr->accepted) { /* Created by accept */
         hg_thread_spin_lock(&NA_SM_CLASS(na_class)->accepted_addr_queue_lock);
@@ -2905,20 +2806,16 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 
     /* Deregister event file descriptors from poll set */
     ret = na_sm_poll_deregister(na_class, NA_SM_NOTIFY, na_sm_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not delete notify from poll set");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not delete notify from poll set");
 
     /* Destroy local event */
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
-    if (hg_event_destroy(na_sm_addr->local_notify) == HG_UTIL_FAIL) {
-        NA_LOG_ERROR("hg_event_destroy() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_event_destroy(na_sm_addr->local_notify);
+    NA_CHECK_ERROR(rc == HG_UTIL_FAIL, done, ret, NA_PROTOCOL_ERROR,
+        "hg_event_destroy() failed");
 #endif
 
+    // TODO cleanup
     if (!na_sm_addr->self) { /* Created by lookup/connect or accept */
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
         char na_sm_local_event_name[NA_SM_MAX_FILENAME],
@@ -2928,10 +2825,7 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 
         /* Deregister sock file descriptor */
         ret = na_sm_poll_deregister(na_class, NA_SM_SOCK, na_sm_addr);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not delete sock from poll set");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not delete sock from poll set");
 
         /* Remove addr from poll addr queue */
         hg_thread_spin_lock(&NA_SM_CLASS(na_class)->poll_addr_queue_lock);
@@ -2974,41 +2868,27 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 
         /* Destroy events */
 #ifdef HG_UTIL_HAS_SYSEVENTFD_H
-        if (hg_event_destroy(na_sm_addr->remote_notify) == HG_UTIL_FAIL) {
-            NA_LOG_ERROR("hg_event_destroy() failed");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_event_destroy(na_sm_addr->remote_notify);
+        NA_CHECK_ERROR(rc == HG_UTIL_FAIL, done, ret, NA_PROTOCOL_ERROR,
+            "hg_event_destroy() failed");
 #else
-        if (na_sm_event_destroy(local_event_name, na_sm_addr->local_notify)
-            != NA_SUCCESS) {
-            NA_LOG_ERROR("na_sm_event_destroy() failed");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        ret = na_sm_event_destroy(local_event_name, na_sm_addr->local_notify);
+        NA_CHECK_NA_ERROR(done, ret, "na_sm_event_destroy() failed");
 
-        if (na_sm_event_destroy(remote_event_name, na_sm_addr->remote_notify)
-            != NA_SUCCESS) {
-            NA_LOG_ERROR("na_sm_event_destroy() failed");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        ret = na_sm_event_destroy(remote_event_name, na_sm_addr->remote_notify);
+        NA_CHECK_NA_ERROR(done, ret, "na_sm_event_destroy() failed");
 #endif
     } else {
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
         /* Destroy local event */
-        if (hg_event_destroy(na_sm_addr->local_notify) == HG_UTIL_FAIL) {
-            NA_LOG_ERROR("hg_event_destroy() failed");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_event_destroy(na_sm_addr->local_notify);
+        NA_CHECK_ERROR(rc == HG_UTIL_FAIL, done, ret, NA_PROTOCOL_ERROR,
+            "hg_event_destroy() failed");
 #endif
         if (na_sm_addr->na_sm_copy_buf) { /* Self addr and listen */
             ret = na_sm_poll_deregister(na_class, NA_SM_ACCEPT, na_sm_addr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not delete listen from poll set");
-                goto done;
-            }
+            NA_CHECK_NA_ERROR(done, ret,
+                "Could not delete listen from poll set");
 
             NA_SM_GEN_SHM_NAME(na_sm_copy_buf_name,
                 NA_SM_CLASS(na_class)->username, na_sm_addr);
@@ -3021,35 +2901,23 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 
     /* Close sock (delete also tmp dir if pathname is set) */
     ret = na_sm_close_sock(na_sm_addr->sock, pathname);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not close sock");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not close sock");
 
     /* Close ring buf (send) */
     ret = na_sm_close_shared_buf(send_ring_buf_name,
         na_sm_addr->na_sm_send_ring_buf, sizeof(struct na_sm_ring_buf));
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not close send ring buffer");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not close send ring buffer");
 
     /* Close ring buf (recv) */
     ret = na_sm_close_shared_buf(recv_ring_buf_name,
         na_sm_addr->na_sm_recv_ring_buf, sizeof(struct na_sm_ring_buf));
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not close recv ring buffer");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(done, ret, "Could not close recv ring buffer");
 
     /* Close copy buf */
     if (!na_sm_addr->accepted) { /* Created by accept */
         ret = na_sm_close_shared_buf(copy_buf_name, na_sm_addr->na_sm_copy_buf,
             sizeof(struct na_sm_copy_buf));
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not close copy buffer");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not close copy buffer");
     }
 
     free(na_sm_addr);
@@ -3090,6 +2958,17 @@ na_sm_addr_dup(na_class_t NA_UNUSED *na_class, na_addr_t addr,
 }
 
 /*---------------------------------------------------------------------------*/
+static na_bool_t
+na_sm_addr_cmp(na_class_t NA_UNUSED *na_class, na_addr_t addr1, na_addr_t addr2)
+{
+    struct na_sm_addr *na_sm_addr1 = (struct na_sm_addr *) addr1;
+    struct na_sm_addr *na_sm_addr2 = (struct na_sm_addr *) addr2;
+
+    return (na_sm_addr1->pid == na_sm_addr2->pid)
+        && (na_sm_addr1->id == na_sm_addr2->id);
+}
+
+/*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
 na_sm_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
@@ -3109,17 +2988,13 @@ na_sm_addr_to_string(na_class_t NA_UNUSED *na_class, char *buf,
     na_return_t ret = NA_SUCCESS;
 
     sprintf(addr_string, "sm://%d/%u", na_sm_addr->pid, na_sm_addr->id);
+
     string_len = strlen(addr_string);
     if (buf) {
-        if (string_len >= *buf_size) {
-            NA_LOG_ERROR("Buffer size too small to copy addr");
-            ret = NA_SIZE_ERROR;
-            goto done;
-        } else {
-            strcpy(buf, addr_string);
-        }
+        NA_CHECK_ERROR(string_len >= *buf_size, done, ret, NA_OVERFLOW,
+            "Buffer size too small to copy addr");
+        strcpy(buf, addr_string);
     }
-
     *buf_size = string_len + 1;
 
 done:
@@ -3157,68 +3032,75 @@ na_sm_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     struct na_sm_op_id *na_sm_op_id = NULL;
     struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) dest_addr;
     unsigned int idx_reserved;
+    na_bool_t reserved = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size > NA_SM_UNEXPECTED_SIZE) {
-        NA_LOG_ERROR("Exceeds unexpected size");
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size > NA_SM_UNEXPECTED_SIZE, done, ret, NA_OVERFLOW,
+        "Exceeds unexpected size, %d", buf_size);
+
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_SEND_UNEXPECTED;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    hg_atomic_incr32(&na_sm_addr->ref_count);
+    na_sm_op_id->na_sm_addr = na_sm_addr;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
+    /* TODO we assume that buf remains valid (safe because we pre-allocate buffers) */
+    na_sm_op_id->info.msg.buf.const_ptr = buf;
+    na_sm_op_id->info.msg.buf_size = buf_size;
+    na_sm_op_id->info.msg.actual_buf_size = buf_size;
+    na_sm_op_id->info.msg.tag = tag;
 
     /* Try to reserve buffer atomically */
-    do {
-        ret = na_sm_reserve_and_copy_buf(na_class, na_sm_addr->na_sm_copy_buf,
-            buf, buf_size, &idx_reserved);
-        if (ret != NA_SUCCESS) {
-            na_return_t progress_ret = na_sm_progress(na_class, context, 0);
-
-            if (progress_ret != NA_SUCCESS && progress_ret != NA_TIMEOUT) {
-                NA_LOG_ERROR("Could not make progress");
-                ret = progress_ret;
-                goto done;
-            }
-            continue;
+    ret = na_sm_reserve_and_copy_buf(na_class, na_sm_addr->na_sm_copy_buf,
+        buf, buf_size, &idx_reserved);
+    if (unlikely(ret == NA_AGAIN)) {
+        if (NA_SM_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_sm_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_spin_lock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+            HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->retry_op_queue,
+                na_sm_op_id, entry);
+            hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_QUEUED);
+            hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+
+            ret = NA_SUCCESS;
         }
-        break;
-    } while (1);
+    } else {
+        /* Successfully reserved a buffer */
+        reserved = NA_TRUE;
 
-    /* Insert message into ring buffer (complete OP ID) */
-    ret = na_sm_msg_insert(na_class, na_sm_op_id, NA_CB_RECV_UNEXPECTED,
-        na_sm_addr, idx_reserved, buf_size, tag);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not insert message");
-        goto done;
+        /* Insert message into ring buffer (complete OP ID) */
+        ret = na_sm_msg_insert(na_class, na_sm_op_id, idx_reserved);
+        NA_CHECK_NA_ERROR(error, ret, "Could not insert message");
     }
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
+    return ret;
+
+error:
+    if (reserved)
+        na_sm_release_buf(na_sm_op_id->na_sm_addr->na_sm_copy_buf,
+            idx_reserved);
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
     return ret;
 }
 
@@ -3232,40 +3114,29 @@ na_sm_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
     struct na_sm_op_id *na_sm_op_id = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size > NA_SM_UNEXPECTED_SIZE) {
-        NA_LOG_ERROR("Exceeds unexpected size, %d", buf_size);
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size > NA_SM_UNEXPECTED_SIZE, done, ret, NA_OVERFLOW,
+        "Exceeds unexpected size, %d", buf_size);
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
 
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_RECV_UNEXPECTED;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-    na_sm_op_id->info.recv_unexpected.buf = buf;
-    na_sm_op_id->info.recv_unexpected.buf_size = buf_size;
-    na_sm_op_id->info.recv_unexpected.unexpected_info.na_sm_addr = NULL;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    na_sm_op_id->na_sm_addr = NULL;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
+    na_sm_op_id->info.msg.buf.ptr = buf;
+    na_sm_op_id->info.msg.buf_size = buf_size;
 
     /* Look for an unexpected message already received */
     hg_thread_spin_lock(&NA_SM_CLASS(na_class)->unexpected_msg_queue_lock);
@@ -3273,28 +3144,40 @@ na_sm_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
         &NA_SM_CLASS(na_class)->unexpected_msg_queue);
     HG_QUEUE_POP_HEAD(&NA_SM_CLASS(na_class)->unexpected_msg_queue, entry);
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->unexpected_msg_queue_lock);
-    if (na_sm_unexpected_info) {
-        na_sm_op_id->info.recv_unexpected.unexpected_info =
-            *na_sm_unexpected_info;
+    if (unlikely(na_sm_unexpected_info)) {
+        na_sm_op_id->na_sm_addr = na_sm_unexpected_info->na_sm_addr;
+        hg_atomic_incr32(&na_sm_op_id->na_sm_addr->ref_count);
+        na_sm_op_id->info.msg.actual_buf_size = na_sm_unexpected_info->buf_size;
+        na_sm_op_id->info.msg.tag = na_sm_unexpected_info->tag;
+
+        /* Copy buffers */
+        memcpy(na_sm_op_id->info.msg.buf.ptr, na_sm_unexpected_info->buf,
+            na_sm_unexpected_info->buf_size);
+
+        free(na_sm_unexpected_info->buf);
         free(na_sm_unexpected_info);
 
         ret = na_sm_complete(na_sm_op_id);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(error, ret, "Could not complete operation");
     } else {
+        na_sm_op_id->info.msg.actual_buf_size = 0;
+        na_sm_op_id->info.msg.tag = 0;
+
         /* Nothing has been received yet so add op_id to progress queue */
         hg_thread_spin_lock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
         HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->unexpected_op_queue,
             na_sm_op_id, entry);
+        hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_QUEUED);
         hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
     }
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
+    return ret;
+
+error:
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
     return ret;
 }
 
@@ -3308,68 +3191,75 @@ na_sm_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
     struct na_sm_op_id *na_sm_op_id = NULL;
     struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) dest_addr;
     unsigned int idx_reserved;
+    na_bool_t reserved = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size > NA_SM_EXPECTED_SIZE) {
-        NA_LOG_ERROR("Exceeds expected size");
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size > NA_SM_EXPECTED_SIZE, done, ret, NA_OVERFLOW,
+        "Exceeds expected size, %d", buf_size);
+
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_SEND_EXPECTED;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    hg_atomic_incr32(&na_sm_addr->ref_count);
+    na_sm_op_id->na_sm_addr = na_sm_addr;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
+    /* TODO we assume that buf remains valid (safe because we pre-allocate buffers) */
+    na_sm_op_id->info.msg.buf.const_ptr = buf;
+    na_sm_op_id->info.msg.buf_size = buf_size;
+    na_sm_op_id->info.msg.actual_buf_size = buf_size;
+    na_sm_op_id->info.msg.tag = tag;
 
     /* Try to reserve buffer atomically */
-    do {
-        ret = na_sm_reserve_and_copy_buf(na_class, na_sm_addr->na_sm_copy_buf,
-            buf, buf_size, &idx_reserved);
-        if (ret != NA_SUCCESS) {
-            na_return_t progress_ret = na_sm_progress(na_class, context, 0);
-
-            if (progress_ret != NA_SUCCESS && progress_ret != NA_TIMEOUT) {
-                NA_LOG_ERROR("Could not make progress");
-                ret = progress_ret;
-                goto done;
-            }
-            continue;
+    ret = na_sm_reserve_and_copy_buf(na_class, na_sm_addr->na_sm_copy_buf,
+        buf, buf_size, &idx_reserved);
+    if (unlikely(ret == NA_AGAIN)) {
+        if (NA_SM_CLASS(na_class)->no_retry)
+            /* Do not attempt to retry */
+            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        else {
+            NA_LOG_DEBUG("Pushing %p for retry", na_sm_op_id);
+
+            /* Push op ID to retry queue */
+            hg_thread_spin_lock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+            HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->retry_op_queue,
+                na_sm_op_id, entry);
+            hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_QUEUED);
+            hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+
+            ret = NA_SUCCESS;
         }
-        break;
-    } while (1);
+    } else {
+        /* Successfully reserved a buffer */
+        reserved = NA_TRUE;
 
-    /* Insert message into ring buffer (complete OP ID) */
-    ret = na_sm_msg_insert(na_class, na_sm_op_id, NA_CB_RECV_EXPECTED,
-        na_sm_addr, idx_reserved, buf_size, tag);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not insert message");
-        goto done;
+        /* Insert message into ring buffer (complete OP ID) */
+        ret = na_sm_msg_insert(na_class, na_sm_op_id, idx_reserved);
+        NA_CHECK_NA_ERROR(error, ret, "Could not insert message");
     }
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
+    return ret;
+
+error:
+    if (reserved)
+        na_sm_release_buf(na_sm_op_id->na_sm_addr->na_sm_copy_buf,
+            idx_reserved);
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
     return ret;
 }
 
@@ -3381,42 +3271,35 @@ na_sm_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     na_uint8_t NA_UNUSED source_id, na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_sm_op_id *na_sm_op_id = NULL;
+    struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) source_addr;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size > NA_SM_EXPECTED_SIZE) {
-        NA_LOG_ERROR("Exceeds expected size");
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size > NA_SM_EXPECTED_SIZE, done, ret, NA_OVERFLOW,
+        "Exceeds expected size, %d", buf_size);
+
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_RECV_EXPECTED;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-    na_sm_op_id->info.recv_expected.buf = buf;
-    na_sm_op_id->info.recv_expected.buf_size = buf_size;
-    na_sm_op_id->info.recv_expected.na_sm_addr = (struct na_sm_addr *) source_addr;
-    na_sm_op_id->info.recv_expected.tag = tag;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    hg_atomic_incr32(&na_sm_addr->ref_count);
+    na_sm_op_id->na_sm_addr = na_sm_addr;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
+    na_sm_op_id->info.msg.buf.ptr = buf;
+    na_sm_op_id->info.msg.buf_size = buf_size;
+    na_sm_op_id->info.msg.actual_buf_size = 0;
+    na_sm_op_id->info.msg.tag = tag;
 
     /* Expected messages must always be pre-posted, therefore a message should
      * never arrive before that call returns (not completes), simply add
@@ -3424,12 +3307,10 @@ na_sm_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     hg_thread_spin_lock(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
     HG_QUEUE_PUSH_TAIL(&NA_SM_CLASS(na_class)->expected_op_queue, na_sm_op_id,
         entry);
+    hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_QUEUED);
     hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
     return ret;
 }
 
@@ -3443,18 +3324,13 @@ na_sm_mem_handle_create(na_class_t NA_UNUSED *na_class, void *buf,
 
     na_sm_mem_handle = (struct na_sm_mem_handle *) malloc(
         sizeof(struct na_sm_mem_handle));
-    if (!na_sm_mem_handle) {
-        NA_LOG_ERROR("Could not allocate NA SM memory handle");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA SM memory handle");
+
     na_sm_mem_handle->iov = (struct iovec *) malloc(sizeof(struct iovec));
-    if (!na_sm_mem_handle->iov) {
-        NA_LOG_ERROR("Could not allocate iovec");
-        ret = NA_NOMEM_ERROR;
-        free(na_sm_mem_handle);
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle->iov == NULL, error, ret, NA_NOMEM,
+        "Could not allocate iovec");
+
     na_sm_mem_handle->iov->iov_base = buf;
     na_sm_mem_handle->iov->iov_len = buf_size;
     na_sm_mem_handle->iovcnt = 1;
@@ -3463,7 +3339,13 @@ na_sm_mem_handle_create(na_class_t NA_UNUSED *na_class, void *buf,
 
     *mem_handle = (na_mem_handle_t) na_sm_mem_handle;
 
-done:
+    return ret;
+
+error:
+    if (na_sm_mem_handle) {
+        free(na_sm_mem_handle->iov);
+        free(na_sm_mem_handle);
+    }
     return ret;
 }
 
@@ -3480,26 +3362,19 @@ na_sm_mem_handle_create_segments(na_class_t NA_UNUSED *na_class,
 
     /* Check that we do not exceed IOV_MAX */
     iov_max = (na_size_t) sysconf(_SC_IOV_MAX);
-    if (segment_count > iov_max) {
-        NA_LOG_ERROR("Segment count exceeds IOV_MAX limit");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(segment_count > iov_max, error, ret, NA_INVALID_ARG,
+        "Segment count exceeds IOV_MAX limit");
 
     na_sm_mem_handle = (struct na_sm_mem_handle *) malloc(
         sizeof(struct na_sm_mem_handle));
-    if (!na_sm_mem_handle) {
-        NA_LOG_ERROR("Could not allocate NA SM memory handle");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA SM memory handle");
+
     na_sm_mem_handle->iov = (struct iovec *) malloc(
         segment_count * sizeof(struct iovec));
-    if (!na_sm_mem_handle->iov) {
-        NA_LOG_ERROR("Could not allocate iovec");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle->iov == NULL, error, ret, NA_NOMEM,
+        "Could not allocate iovec");
+
     na_sm_mem_handle->len = 0;
     for (i = 0; i < segment_count; i++) {
         na_sm_mem_handle->iov[i].iov_base = (void *) segments[i].address;
@@ -3511,7 +3386,13 @@ na_sm_mem_handle_create_segments(na_class_t NA_UNUSED *na_class,
 
     *mem_handle = (na_mem_handle_t) na_sm_mem_handle;
 
-done:
+    return ret;
+
+error:
+    if (na_sm_mem_handle) {
+        free(na_sm_mem_handle->iov);
+        free(na_sm_mem_handle);
+    }
     return ret;
 }
 #endif
@@ -3541,9 +3422,8 @@ na_sm_mem_handle_get_serialize_size(na_class_t NA_UNUSED *na_class,
     unsigned long i;
     na_size_t ret = 2 * sizeof(unsigned long) + sizeof(size_t);
 
-    for (i = 0; i < na_sm_mem_handle->iovcnt; i++) {
+    for (i = 0; i < na_sm_mem_handle->iovcnt; i++)
         ret += sizeof(void *) + sizeof(size_t);
-    }
 
     return ret;
 }
@@ -3594,21 +3474,15 @@ na_sm_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
 
     na_sm_mem_handle = (struct na_sm_mem_handle *) malloc(
         sizeof(struct na_sm_mem_handle));
-    if (!na_sm_mem_handle) {
-          NA_LOG_ERROR("Could not allocate NA SM memory handle");
-          ret = NA_NOMEM_ERROR;
-          goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA SM memory handle");
+    na_sm_mem_handle->iov = NULL;
 
     /* Number of segments */
     memcpy(&na_sm_mem_handle->iovcnt, buf_ptr, sizeof(unsigned long));
     buf_ptr += sizeof(unsigned long);
-    if (!na_sm_mem_handle->iovcnt) {
-        NA_LOG_ERROR("NULL segment count");
-        ret = NA_SIZE_ERROR;
-        free(na_sm_mem_handle);
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle->iovcnt == 0, error, ret, NA_FAULT,
+        "NULL segment count");
 
     /* Flags */
     memcpy(&na_sm_mem_handle->flags, buf_ptr, sizeof(unsigned long));
@@ -3621,12 +3495,9 @@ na_sm_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
     /* Segments */
     na_sm_mem_handle->iov = (struct iovec *) malloc(na_sm_mem_handle->iovcnt *
         sizeof(struct iovec));
-    if (!na_sm_mem_handle->iov) {
-        NA_LOG_ERROR("Could not allocate iovec");
-        ret = NA_NOMEM_ERROR;
-        free(na_sm_mem_handle);
-        goto done;
-    }
+    NA_CHECK_ERROR(na_sm_mem_handle->iov == NULL, error, ret, NA_NOMEM,
+        "Could not allocate iovec");
+
     for (i = 0; i < na_sm_mem_handle->iovcnt; i++) {
         memcpy(&na_sm_mem_handle->iov[i].iov_base, buf_ptr, sizeof(void *));
         buf_ptr += sizeof(void *);
@@ -3636,7 +3507,13 @@ na_sm_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
 
     *mem_handle = (na_mem_handle_t) na_sm_mem_handle;
 
-done:
+    return ret;
+
+error:
+    if (na_sm_mem_handle) {
+        free(na_sm_mem_handle->iov);
+        free(na_sm_mem_handle);
+    }
     return ret;
 }
 
@@ -3655,6 +3532,8 @@ na_sm_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
         (struct na_sm_mem_handle *) remote_mem_handle;
     struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) remote_addr;
     struct iovec *local_iov, *remote_iov;
+    struct iovec *local_iovs[IOV_MAX] = {NULL, 0};
+    struct iovec *remote_iovs[IOV_MAX] = {NULL, 0};
     unsigned long liovcnt, riovcnt;
     na_return_t ret = NA_SUCCESS;
 #if defined(NA_SM_HAS_CMA)
@@ -3665,58 +3544,49 @@ na_sm_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 #endif
 
 #if !defined(NA_SM_HAS_CMA) && !defined(__APPLE__)
-    (void) na_sm_addr;
-    NA_LOG_ERROR("Not implemented for this platform");
-    ret = NA_PROTOCOL_ERROR;
-    goto done;
+    NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR,
+        "Not implemented for this platform");
 #endif
 
     switch (na_sm_mem_handle_remote->flags) {
         case NA_MEM_READ_ONLY:
-            NA_LOG_ERROR("Registered memory requires write permission");
-            ret = NA_PERMISSION_ERROR;
-            goto done;
+            NA_GOTO_ERROR(done, ret, NA_PERMISSION,
+                "Registered memory requires write permission");
+            break;
         case NA_MEM_WRITE_ONLY:
         case NA_MEM_READWRITE:
             break;
         default:
-            NA_LOG_ERROR("Invalid memory access flag");
-            ret = NA_INVALID_PARAM;
-            goto done;
+            NA_GOTO_ERROR(done, ret, NA_INVALID_ARG,
+                "Invalid memory access flag");
     }
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        done, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_PUT;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    hg_atomic_incr32(&na_sm_addr->ref_count);
+    na_sm_op_id->na_sm_addr = na_sm_addr;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
 
     /* Translate local offset, skip this step if not necessary */
     if (local_offset || length != na_sm_mem_handle_local->len) {
-        /* TODO fix allocation */
-        local_iov = (struct iovec *) alloca(
-            na_sm_mem_handle_local->iovcnt * sizeof(struct iovec));
+        local_iov = (struct iovec *) local_iovs;
         na_sm_offset_translate(na_sm_mem_handle_local, local_offset, length,
             local_iov, &liovcnt);
+        NA_LOG_DEBUG("Translated local offsets into %lu segment(s)", liovcnt);
     } else {
         local_iov = na_sm_mem_handle_local->iov;
         liovcnt = na_sm_mem_handle_local->iovcnt;
@@ -3724,11 +3594,10 @@ na_sm_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
     /* Translate remote offset, skip this step if not necessary */
     if (remote_offset || length != na_sm_mem_handle_remote->len) {
-        /* TODO fix allocation */
-        remote_iov = (struct iovec *) alloca(
-            na_sm_mem_handle_remote->iovcnt * sizeof(struct iovec));
+        remote_iov = (struct iovec *) remote_iovs;
         na_sm_offset_translate(na_sm_mem_handle_remote, remote_offset, length,
             remote_iov, &riovcnt);
+        NA_LOG_DEBUG("Translated remote offsets into %lu segment(s)", riovcnt);
     } else {
         remote_iov = na_sm_mem_handle_remote->iov;
         riovcnt = na_sm_mem_handle_remote->iovcnt;
@@ -3737,62 +3606,45 @@ na_sm_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 #if defined(NA_SM_HAS_CMA)
     nwrite = process_vm_writev(na_sm_addr->pid, local_iov, liovcnt, remote_iov,
         riovcnt, /* unused */0);
-    if (nwrite < 0) {
-        NA_LOG_ERROR("process_vm_writev() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-    if ((na_size_t)nwrite != length) {
-        NA_LOG_ERROR("Wrote %ld bytes, was expecting %lu bytes", nwrite, length);
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(nwrite < 0, error, ret, NA_PROTOCOL_ERROR,
+        "process_vm_writev() failed (%s)", strerror(errno));
+    NA_CHECK_ERROR((na_size_t)nwrite != length, error, ret, NA_MSGSIZE,
+        "Wrote %ld bytes, was expecting %lu bytes", nwrite, length);
 #elif defined(__APPLE__)
     kret = task_for_pid(mach_task_self(), na_sm_addr->pid, &remote_task);
-    if (kret != KERN_SUCCESS) {
-        NA_LOG_ERROR("task_for_pid() failed (%s)\n"
-                     "Permission must be set to access remote memory, please refer to the documentation for instructions.", mach_error_string(kret));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    if (liovcnt > 1 || riovcnt > 1) {
-        NA_LOG_ERROR("Non-contiguous transfers are not supported");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(kret != KERN_SUCCESS, error, ret, NA_PROTOCOL_ERROR,
+        "task_for_pid() failed (%s)\n"
+        "Permission must be set to access remote memory, please refer to the "
+        "documentation for instructions.", mach_error_string(kret));
+    NA_CHECK_ERROR(liovcnt > 1 || riovcnt > 1, error, ret, NA_PROTOCOL_ERROR,
+        "Non-contiguous transfers are not supported");
 
     kret = mach_vm_write(remote_task,
         (mach_vm_address_t) remote_iov->iov_base,
         (mach_vm_address_t) local_iov->iov_base,
         (mach_msg_type_number_t) length);
-    if (kret != KERN_SUCCESS) {
-        NA_LOG_ERROR("mach_vm_write() failed (%s)", mach_error_string(kret));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(kret != KERN_SUCCESS, error, ret, NA_PROTOCOL_ERROR,
+        "mach_vm_write() failed (%s)", mach_error_string(kret));
 #endif
 
     /* Immediate completion */
     ret = na_sm_complete(na_sm_op_id);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not complete operation");
 
     /* Notify local completion */
-    if (!NA_SM_CLASS(na_class)->no_wait
-        && (hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify)
-        != HG_UTIL_SUCCESS)) {
-        NA_LOG_ERROR("Could not signal local completion");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+    if (!NA_SM_CLASS(na_class)->no_wait) {
+        int rc = hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "Could not signal local completion");
     }
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
+    return ret;
+
+error:
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
     return ret;
 }
 
@@ -3811,6 +3663,8 @@ na_sm_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
         (struct na_sm_mem_handle *) remote_mem_handle;
     struct na_sm_addr *na_sm_addr = (struct na_sm_addr *) remote_addr;
     struct iovec *local_iov, *remote_iov;
+    struct iovec *local_iovs[IOV_MAX] = {NULL, 0};
+    struct iovec *remote_iovs[IOV_MAX] = {NULL, 0};
     unsigned long liovcnt, riovcnt;
     na_return_t ret = NA_SUCCESS;
 #if defined(NA_SM_HAS_CMA)
@@ -3822,58 +3676,44 @@ na_sm_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 #endif
 
 #if !defined(NA_SM_HAS_CMA) && !defined(__APPLE__)
-    (void) na_sm_addr;
-    NA_LOG_ERROR("Not implemented for this platform");
-    ret = NA_PROTOCOL_ERROR;
-    goto done;
+    NA_GOTO_ERROR(done, ret, NA_PROTOCOL_ERROR,
+        "Not implemented for this platform");
 #endif
 
     switch (na_sm_mem_handle_remote->flags) {
         case NA_MEM_WRITE_ONLY:
-            NA_LOG_ERROR("Registered memory requires read permission");
-            ret = NA_PERMISSION_ERROR;
-            goto done;
+            NA_GOTO_ERROR(done, ret, NA_PERMISSION,
+                "Registered memory requires write permission");
+            break;
         case NA_MEM_READ_ONLY:
         case NA_MEM_READWRITE:
             break;
         default:
-            NA_LOG_ERROR("Invalid memory access flag");
-            ret = NA_INVALID_PARAM;
-            goto done;
+            NA_GOTO_ERROR(done, ret, NA_INVALID_ARG,
+                "Invalid memory access flag");
     }
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_sm_op_id = (struct na_sm_op_id *) *op_id;
-        /* Make sure op ID can be safely re-used */
-        while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
-            cpu_spinwait();
-    } else {
-        na_sm_op_id = (struct na_sm_op_id *) na_sm_op_create(na_class);
-        if (!na_sm_op_id) {
-            NA_LOG_ERROR("Could not allocate NA SM operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
-    }
+    na_sm_op_id = (struct na_sm_op_id *) *op_id;
+    NA_CHECK_ERROR(!(hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_COMPLETED),
+        done, ret, NA_BUSY, "Attempting to use OP ID that was not completed");
+    /* Make sure op ID is fully released before re-using it */
+    while (hg_atomic_cas32(&na_sm_op_id->ref_count, 1, 2) != HG_UTIL_TRUE)
+        cpu_spinwait();
+
     na_sm_op_id->context = context;
     na_sm_op_id->completion_data.callback_info.type = NA_CB_GET;
     na_sm_op_id->completion_data.callback = callback;
     na_sm_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_sm_op_id->completed, NA_FALSE);
-    hg_atomic_set32(&na_sm_op_id->canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = na_sm_op_id;
+    hg_atomic_incr32(&na_sm_addr->ref_count);
+    na_sm_op_id->na_sm_addr = na_sm_addr;
+    hg_atomic_set32(&na_sm_op_id->status, 0);
 
     /* Translate local offset, skip this step if not necessary */
     if (local_offset || length != na_sm_mem_handle_local->len) {
-        /* TODO fix allocation */
-        local_iov = (struct iovec *) alloca(
-            na_sm_mem_handle_local->iovcnt * sizeof(struct iovec));
+        local_iov = (struct iovec *) local_iovs;
         na_sm_offset_translate(na_sm_mem_handle_local, local_offset, length,
             local_iov, &liovcnt);
+        NA_LOG_DEBUG("Translated local offsets into %lu segment(s)", liovcnt);
     } else {
         local_iov = na_sm_mem_handle_local->iov;
         liovcnt = na_sm_mem_handle_local->iovcnt;
@@ -3881,11 +3721,10 @@ na_sm_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
     /* Translate remote offset, skip this step if not necessary */
     if (remote_offset || length != na_sm_mem_handle_remote->len) {
-        /* TODO fix allocation */
-        remote_iov = (struct iovec *) alloca(
-            na_sm_mem_handle_remote->iovcnt * sizeof(struct iovec));
+        remote_iov = (struct iovec *) remote_iovs;
         na_sm_offset_translate(na_sm_mem_handle_remote, remote_offset, length,
             remote_iov, &riovcnt);
+        NA_LOG_DEBUG("Translated remote offsets into %lu segment(s)", riovcnt);
     } else {
         remote_iov = na_sm_mem_handle_remote->iov;
         riovcnt = na_sm_mem_handle_remote->iovcnt;
@@ -3894,63 +3733,46 @@ na_sm_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 #if defined(NA_SM_HAS_CMA)
     nread = process_vm_readv(na_sm_addr->pid, local_iov, liovcnt, remote_iov,
         riovcnt, /* unused */0);
-    if (nread < 0) {
-        NA_LOG_ERROR("process_vm_readv() failed (%s)", strerror(errno));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(nread < 0, error, ret, NA_PROTOCOL_ERROR,
+        "process_vm_readv() failed (%s)", strerror(errno));
 #elif defined(__APPLE__)
     kret = task_for_pid(mach_task_self(), na_sm_addr->pid, &remote_task);
-    if (kret != KERN_SUCCESS) {
-        NA_LOG_ERROR("task_for_pid() failed (%s)\n"
-                     "Permission must be set to access remote memory, please refer to the documentation for instructions.", mach_error_string(kret));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
-
-    if (liovcnt > 1 || riovcnt > 1) {
-        NA_LOG_ERROR("Non-contiguous transfers are not supported");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(kret != KERN_SUCCESS, error, ret, NA_PROTOCOL_ERROR,
+        "task_for_pid() failed (%s)\n"
+        "Permission must be set to access remote memory, please refer to the "
+        "documentation for instructions.", mach_error_string(kret));
+    NA_CHECK_ERROR(liovcnt > 1 || riovcnt > 1, error, ret, NA_PROTOCOL_ERROR,
+        "Non-contiguous transfers are not supported");
 
     kret = mach_vm_read_overwrite(remote_task,
         (mach_vm_address_t) remote_iov->iov_base, length,
         (mach_vm_address_t) local_iov->iov_base, &nread);
-    if (kret != KERN_SUCCESS) {
-        NA_LOG_ERROR("mach_vm_read_overwrite() failed (%s)", mach_error_string(kret));
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(kret != KERN_SUCCESS, error, ret, NA_PROTOCOL_ERROR,
+        "mach_vm_read_overwrite() failed (%s)", mach_error_string(kret));
 #endif
 #if defined(NA_SM_HAS_CMA) || defined(__APPLE__)
-    if ((na_size_t)nread != length) {
-        NA_LOG_ERROR("Read %ld bytes, was expecting %lu bytes", nread, length);
-        ret = NA_SIZE_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR((na_size_t)nread != length, error, ret, NA_MSGSIZE,
+        "Read %ld bytes, was expecting %lu bytes", nread, length);
 #endif
 
     /* Immediate completion */
     ret = na_sm_complete(na_sm_op_id);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not complete operation");
 
     /* Notify local completion */
-    if (!NA_SM_CLASS(na_class)->no_wait
-        && (hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify)
-        != HG_UTIL_SUCCESS)) {
-        NA_LOG_ERROR("Could not signal local completion");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
+    if (!NA_SM_CLASS(na_class)->no_wait) {
+        int rc = hg_event_set(NA_SM_CLASS(na_class)->self_addr->local_notify);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "Could not signal local completion");
     }
 
 done:
-    if (ret != NA_SUCCESS) {
-        na_sm_op_destroy(na_class, (na_op_id_t) na_sm_op_id);
-    }
+    return ret;
+
+error:
+    hg_atomic_decr32(&na_sm_op_id->na_sm_addr->ref_count);
+    hg_atomic_decr32(&na_sm_op_id->ref_count);
+
     return ret;
 }
 
@@ -3958,13 +3780,12 @@ done:
 static NA_INLINE int
 na_sm_poll_get_fd(na_class_t *na_class, na_context_t NA_UNUSED *context)
 {
-    int fd;
+    int fd = -1;
 
     fd = hg_poll_get_fd(NA_SM_CLASS(na_class)->poll_set);
-    if (fd == HG_UTIL_FAIL) {
-        NA_LOG_ERROR("Could not get poll fd from poll set");
-    }
+    NA_CHECK_ERROR_NORET(fd == -1, done, "Could not get poll fd from poll set");
 
+ done:
     return fd;
 }
 
@@ -4000,16 +3821,15 @@ na_sm_progress(na_class_t *na_class, na_context_t NA_UNUSED *context,
     do {
         hg_time_t t1, t2;
         hg_util_bool_t progressed;
+        int rc;
 
         if (timeout)
             hg_time_get_current(&t1);
 
-        if (hg_poll_wait(NA_SM_CLASS(na_class)->poll_set,
-            (unsigned int) (remaining * 1000.0), &progressed) != HG_UTIL_SUCCESS) {
-            NA_LOG_ERROR("hg_poll_wait() failed");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_poll_wait(NA_SM_CLASS(na_class)->poll_set,
+            (unsigned int) (remaining * 1000.0), &progressed);
+        NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, NA_PROTOCOL_ERROR,
+            "hg_poll_wait() failed");
 
         /* We progressed, return success */
         if (progressed) {
@@ -4034,74 +3854,55 @@ na_sm_cancel(na_class_t *na_class, na_context_t NA_UNUSED *context,
 {
     struct na_sm_op_id *na_sm_op_id = (struct na_sm_op_id *) op_id;
     na_return_t ret = NA_SUCCESS;
+    na_bool_t canceled = NA_FALSE;
 
-    if (hg_atomic_get32(&na_sm_op_id->completed))
+    /* Exit if op has already completed */
+    if (hg_atomic_or32(&na_sm_op_id->status, NA_SM_OP_CANCELED)
+        & NA_SM_OP_COMPLETED)
         goto done;
 
+    NA_LOG_DEBUG("Canceling operation ID %p", na_sm_op_id);
+
     switch (na_sm_op_id->completion_data.callback_info.type) {
         case NA_CB_LOOKUP:
             /* Nothing */
             break;
-        case NA_CB_SEND_UNEXPECTED:
-            /* Nothing */
-            break;
-        case NA_CB_RECV_UNEXPECTED: {
-            struct na_sm_op_id *na_sm_var_op_id = NULL;
-
+        case NA_CB_RECV_UNEXPECTED:
             /* Must remove op_id from unexpected op_id queue */
             hg_thread_spin_lock(
                 &NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
-            HG_QUEUE_FOREACH(na_sm_var_op_id,
-                &NA_SM_CLASS(na_class)->unexpected_op_queue, entry) {
-                if (na_sm_var_op_id == na_sm_op_id) {
-                    HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->unexpected_op_queue,
-                        na_sm_var_op_id, na_sm_op_id, entry);
-                    break;
-                }
+            if (hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_QUEUED) {
+                HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->unexpected_op_queue,
+                    na_sm_op_id, na_sm_op_id, entry);
+                hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
+                canceled = NA_TRUE;
             }
             hg_thread_spin_unlock(
                 &NA_SM_CLASS(na_class)->unexpected_op_queue_lock);
-
-            /* Cancel op id */
-            if (na_sm_var_op_id == na_sm_op_id) {
-                hg_atomic_set32(&na_sm_op_id->canceled, NA_TRUE);
-                ret = na_sm_complete(na_sm_op_id);
-                if (ret != NA_SUCCESS) {
-                    NA_LOG_ERROR("Could not complete operation");
-                    goto done;
-                }
-            }
-        }
-            break;
-        case NA_CB_SEND_EXPECTED:
-            /* Nothing */
             break;
-        case NA_CB_RECV_EXPECTED: {
-            struct na_sm_op_id *na_sm_var_op_id = NULL;
-
+        case NA_CB_RECV_EXPECTED:
             /* Must remove op_id from unexpected op_id queue */
             hg_thread_spin_lock(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
-            HG_QUEUE_FOREACH(na_sm_var_op_id,
-                &NA_SM_CLASS(na_class)->expected_op_queue, entry) {
-                if (na_sm_var_op_id == na_sm_op_id) {
-                    HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->expected_op_queue,
-                        na_sm_var_op_id, na_sm_op_id, entry);
-                    break;
-                }
+            if (hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_QUEUED) {
+                HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->expected_op_queue,
+                    na_sm_op_id, na_sm_op_id, entry);
+                hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
+                canceled = NA_TRUE;
             }
             hg_thread_spin_unlock(
                 &NA_SM_CLASS(na_class)->expected_op_queue_lock);
-
-            /* Cancel op id */
-            if (na_sm_var_op_id == na_sm_op_id) {
-                hg_atomic_set32(&na_sm_op_id->canceled, NA_TRUE);
-                ret = na_sm_complete(na_sm_op_id);
-                if (ret != NA_SUCCESS) {
-                    NA_LOG_ERROR("Could not complete operation");
-                    goto done;
-                }
+            break;
+        case NA_CB_SEND_UNEXPECTED:
+        case NA_CB_SEND_EXPECTED:
+            /* Must remove op_id from retry op_id queue */
+            hg_thread_spin_lock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
+            if (hg_atomic_get32(&na_sm_op_id->status) & NA_SM_OP_QUEUED) {
+                HG_QUEUE_REMOVE(&NA_SM_CLASS(na_class)->retry_op_queue,
+                    na_sm_op_id, na_sm_op_id, entry);
+                hg_atomic_and32(&na_sm_op_id->status, ~NA_SM_OP_QUEUED);
+                canceled = NA_TRUE;
             }
-        }
+            hg_thread_spin_unlock(&NA_SM_CLASS(na_class)->retry_op_queue_lock);
             break;
         case NA_CB_PUT:
             /* Nothing */
@@ -4110,9 +3911,15 @@ na_sm_cancel(na_class_t *na_class, na_context_t NA_UNUSED *context,
             /* Nothing */
             break;
         default:
-            NA_LOG_ERROR("Operation not supported");
-            ret = NA_INVALID_PARAM;
-            break;
+            NA_GOTO_ERROR(done, ret, NA_INVALID_ARG,
+                "Operation type %d not supported",
+                na_sm_op_id->completion_data.callback_info.type);
+    }
+
+    /* Cancel op id */
+    if (canceled) {
+        ret = na_sm_complete(na_sm_op_id);
+        NA_CHECK_NA_ERROR(done, ret, "Could not complete operation");
     }
 
 done:
diff --git a/src/na/na_types.h b/src/na/na_types.h
index 1f32ee2..cc3e79b 100644
--- a/src/na/na_types.h
+++ b/src/na/na_types.h
@@ -29,16 +29,10 @@ typedef void *na_op_id_t;               /* Abstract operation id */
 typedef void *na_mem_handle_t;          /* Abstract memory handle */
 typedef na_uint64_t na_offset_t;        /* Offset */
 
-/* Progress mode */
-typedef enum na_progress_mode {
-    NA_DEFAULT,     /*!< blocking progress, depending on timeout value */
-    NA_NO_BLOCK     /*!< no blocking progress, independent of timeout value */
-} na_progress_mode_t;
-
 /* Init info */
 struct na_init_info {
     const char *auth_key;               /* Authorization key */
-    na_progress_mode_t progress_mode;   /* Progress mode */
+    na_uint32_t progress_mode;          /* Progress mode */
     na_uint8_t max_contexts;            /* Max contexts */
 };
 
@@ -136,4 +130,12 @@ typedef int (*na_cb_t)(const struct na_cb_info *callback_info);
 #define NA_MEM_WRITE_ONLY   0x02
 #define NA_MEM_READWRITE    0x03
 
+/* Progress modes */
+#define NA_NO_BLOCK         0x01    /*!< no blocking progress, independent of timeout value */
+#define NA_NO_RETRY         0x02    /*!< no retry of operations in progress */
+
+/* NA init info initializer */
+#define NA_INIT_INFO_INITIALIZER \
+    { NULL, 0, 1 }
+
 #endif /* NA_TYPES_H */
diff --git a/src/util/mercury_atomic.h b/src/util/mercury_atomic.h
index 4533532..6ece1d7 100644
--- a/src/util/mercury_atomic.h
+++ b/src/util/mercury_atomic.h
@@ -25,13 +25,8 @@ typedef OPA_ptr_t hg_atomic_int64_t; /* OPA has only limited 64-bit support */
 # define HG_ATOMIC_VAR_INIT(x) OPA_PTR_T_INITIALIZER(x)
 #elif defined(HG_UTIL_HAS_STDATOMIC_H)
 # include <stdatomic.h>
-# ifdef __INTEL_COMPILER
 typedef atomic_int hg_atomic_int32_t;
 typedef atomic_llong hg_atomic_int64_t;
-# else
-typedef _Atomic hg_util_int32_t hg_atomic_int32_t;
-typedef _Atomic hg_util_int64_t hg_atomic_int64_t;
-# endif
 # define HG_ATOMIC_VAR_INIT(x) ATOMIC_VAR_INIT(x)
 #elif defined(__APPLE__)
 # include <libkern/OSAtomic.h>
@@ -94,7 +89,6 @@ hg_atomic_incr32(hg_atomic_int32_t *ptr);
 static HG_UTIL_INLINE hg_util_int32_t
 hg_atomic_decr32(hg_atomic_int32_t *ptr);
 
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
 /**
  * OR atomic value (32-bit integer).
  *
@@ -127,7 +121,6 @@ hg_atomic_xor32(hg_atomic_int32_t *ptr, hg_util_int32_t value);
  */
 static HG_UTIL_INLINE hg_util_int32_t
 hg_atomic_and32(hg_atomic_int32_t *ptr, hg_util_int32_t value);
-#endif
 
 /**
  * Compare and swap values (32-bit integer).
@@ -171,7 +164,6 @@ hg_atomic_set64(hg_atomic_int64_t *ptr, hg_util_int64_t value);
 static HG_UTIL_INLINE hg_util_int64_t
 hg_atomic_get64(hg_atomic_int64_t *ptr);
 
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
 /**
  * Increment atomic value (64-bit integer).
  *
@@ -192,7 +184,6 @@ hg_atomic_incr64(hg_atomic_int64_t *ptr);
 static HG_UTIL_INLINE hg_util_int64_t
 hg_atomic_decr64(hg_atomic_int64_t *ptr);
 
-#if defined(_WIN32) || defined(HG_UTIL_HAS_STDATOMIC_H)
 /**
  * OR atomic value (64-bit integer).
  *
@@ -226,9 +217,6 @@ hg_atomic_xor64(hg_atomic_int64_t *ptr, hg_util_int64_t value);
 static HG_UTIL_INLINE hg_util_int64_t
 hg_atomic_and64(hg_atomic_int64_t *ptr, hg_util_int64_t value);
 
-#endif /* defined(_WIN32) || defined(HG_UTIL_HAS_STDATOMIC_H) */
-#endif /* !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H) */
-
 /**
  * Compare and swap values (64-bit integer).
  *
@@ -341,7 +329,6 @@ hg_atomic_decr32(hg_atomic_int32_t *ptr)
     return ret;
 }
 
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_int32_t
 hg_atomic_or32(hg_atomic_int32_t *ptr, hg_util_int32_t value)
@@ -350,12 +337,14 @@ hg_atomic_or32(hg_atomic_int32_t *ptr, hg_util_int32_t value)
 
 #if defined(_WIN32)
     ret = InterlockedOrNoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_or_explicit(ptr, value, memory_order_acq_rel);
 #elif defined(__APPLE__)
     ret = OSAtomicOr32Orig((uint32_t) value, (volatile uint32_t *) &ptr->value);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get32(ptr);
+    } while (!hg_atomic_cas32(ptr, ret, (ret | value)));
 #endif
 
     return ret;
@@ -369,12 +358,14 @@ hg_atomic_xor32(hg_atomic_int32_t *ptr, hg_util_int32_t value)
 
 #if defined(_WIN32)
     ret = InterlockedXorNoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_xor_explicit(ptr, value, memory_order_acq_rel);
 #elif defined(__APPLE__)
     ret = OSAtomicXor32Orig((uint32_t) value, (volatile uint32_t *) &ptr->value);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get32(ptr);
+    } while (!hg_atomic_cas32(ptr, ret, (ret ^ value)));
 #endif
 
     return ret;
@@ -388,17 +379,18 @@ hg_atomic_and32(hg_atomic_int32_t *ptr, hg_util_int32_t value)
 
 #if defined(_WIN32)
     ret = InterlockedAndNoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_and_explicit(ptr, value, memory_order_acq_rel);
 #elif defined(__APPLE__)
     ret = OSAtomicAnd32Orig((uint32_t) value, (volatile uint32_t *) &ptr->value);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get32(ptr);
+    } while (!hg_atomic_cas32(ptr, ret, (ret & value)));
 #endif
 
     return ret;
 }
-#endif /* !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H) */
 
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_bool_t
@@ -473,7 +465,6 @@ hg_atomic_get64(hg_atomic_int64_t *ptr)
     return ret;
 }
 
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_int64_t
 hg_atomic_incr64(hg_atomic_int64_t *ptr)
@@ -482,12 +473,15 @@ hg_atomic_incr64(hg_atomic_int64_t *ptr)
 
 #if defined(_WIN32)
     ret = InterlockedIncrementNoFence64(&ptr->value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_add_explicit(ptr, 1, memory_order_acq_rel) + 1;
 #elif defined(__APPLE__)
     ret = OSAtomicIncrement64(&ptr->value);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get64(ptr);
+    } while (!hg_atomic_cas64(ptr, ret, ret + 1));
+    ret++;
 #endif
 
     return ret;
@@ -501,18 +495,20 @@ hg_atomic_decr64(hg_atomic_int64_t *ptr)
 
 #if defined(_WIN32)
     ret = InterlockedDecrementNoFence64(&ptr->value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_sub_explicit(ptr, 1, memory_order_acq_rel) - 1;
 #elif defined(__APPLE__)
     ret = OSAtomicDecrement64(&ptr->value);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get64(ptr);
+    } while (!hg_atomic_cas64(ptr, ret, ret - 1));
+    ret--;
 #endif
 
     return ret;
 }
 
-#if defined(_WIN32) || defined(HG_UTIL_HAS_STDATOMIC_H)
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_int64_t
 hg_atomic_or64(hg_atomic_int64_t *ptr, hg_util_int64_t value)
@@ -521,10 +517,12 @@ hg_atomic_or64(hg_atomic_int64_t *ptr, hg_util_int64_t value)
 
 #if defined(_WIN32)
     ret = InterlockedOr64NoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_or_explicit(ptr, value, memory_order_acq_rel);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get64(ptr);
+    } while (!hg_atomic_cas64(ptr, ret, (ret | value)));
 #endif
 
     return ret;
@@ -538,10 +536,12 @@ hg_atomic_xor64(hg_atomic_int64_t *ptr, hg_util_int64_t value)
 
 #if defined(_WIN32)
     ret = InterlockedXor64NoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_xor_explicit(ptr, value, memory_order_acq_rel);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get64(ptr);
+    } while (!hg_atomic_cas64(ptr, ret, (ret ^ value)));
 #endif
 
     return ret;
@@ -555,16 +555,16 @@ hg_atomic_and64(hg_atomic_int64_t *ptr, hg_util_int64_t value)
 
 #if defined(_WIN32)
     ret = InterlockedAnd64NoFence(&ptr->value, value);
-#elif defined(HG_UTIL_HAS_STDATOMIC_H)
+#elif defined(HG_UTIL_HAS_STDATOMIC_H) && !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
     ret = atomic_fetch_and_explicit(ptr, value, memory_order_acq_rel);
 #else
-    #error "Not supported on this platform."
+    do {
+        ret = hg_atomic_get64(ptr);
+    } while (!hg_atomic_cas64(ptr, ret, (ret & value)));
 #endif
 
     return ret;
 }
-#endif /* defined(_WIN32) || defined(HG_UTIL_HAS_STDATOMIC_H) */
-#endif /* !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H) */
 
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE hg_util_bool_t
