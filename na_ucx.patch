diff --git a/src/na/na_ucx.c b/src/na/na_ucx.c
index 4234f57..ee44d4e 100644
--- a/src/na/na_ucx.c
+++ b/src/na/na_ucx.c
@@ -1,6 +1,6 @@
 /**
  * Copyright (c) 2013-2022 UChicago Argonne, LLC and The HDF Group.
- * Copyright (c) 2022-2023 Intel Corporation.
+ * Copyright (c) 2022 Intel Corporation.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -13,18 +13,17 @@
 #include "mercury_mem.h"
 #include "mercury_mem_pool.h"
 #include "mercury_queue.h"
-#include "mercury_thread_mutex.h"
 #include "mercury_thread_rwlock.h"
 #include "mercury_thread_spin.h"
 
 #include <ucp/api/ucp.h>
 
 #include <stdalign.h>
-#include <stdlib.h>
 #include <string.h>
 
 #include <netdb.h>
 #include <sys/socket.h>
+#include <arpa/inet.h>
 
 /****************/
 /* Local Macros */
@@ -44,14 +43,13 @@
 #define NA_UCX_HAS_ADDR_POOL
 #define NA_UCX_ADDR_POOL_SIZE (64)
 
+#define NA_UCX_CONN_RETRY_MAX (1024)
+
 /* Memory pool (enabled by default, comment out to disable) */
 #define NA_UCX_HAS_MEM_POOL
 #define NA_UCX_MEM_CHUNK_COUNT (256)
 #define NA_UCX_MEM_BLOCK_COUNT (2)
 
-/* Addr status bits */
-#define NA_UCX_ADDR_RESOLVED (1 << 0)
-
 /* Max tag */
 #define NA_UCX_MAX_TAG UINT32_MAX
 
@@ -59,6 +57,9 @@
 #define NA_UCX_AM_MSG_ID (0)
 #define NA_UCX_TAG_MASK  ((uint64_t) 0x00000000FFFFFFFF)
 
+/* Maximum number of pre-allocated IOV entries */
+#define NA_UCX_IOV_STATIC_MAX (8)
+
 /* Op ID status bits */
 #define NA_UCX_OP_COMPLETED (1 << 0)
 #define NA_UCX_OP_CANCELING (1 << 1)
@@ -78,10 +79,11 @@
         _op->context = _context;                                               \
         _op->completion_data = (struct na_cb_completion_data){                 \
             .callback_info =                                                   \
-                (struct na_cb_info){                                           \
-                    .info.recv_unexpected =                                    \
-                        (struct na_cb_info_recv_unexpected){                   \
-                            .actual_buf_size = 0, .source = NULL, .tag = 0},   \
+                (struct na_cb_info){.info.recv_unexpected =                    \
+                                        (struct na_cb_info_recv_unexpected){   \
+                                            .actual_buf_size = 0,              \
+                                            .source = NA_ADDR_NULL,            \
+                                            .tag = 0},                         \
                     .arg = _arg,                                               \
                     .type = _cb_type,                                          \
                     .ret = NA_SUCCESS},                                        \
@@ -133,7 +135,7 @@ struct na_ucx_addr {
     bool worker_addr_alloc;            /* Worker addr was allocated by us */
     ucp_ep_h ucp_ep;                   /* Currently only one EP per address */
     hg_atomic_int32_t refcount;        /* Reference counter */
-    hg_atomic_int32_t status;          /* Connection state */
+    bool connected;                    /* Connection state */
 };
 
 /* Map (used to cache addresses) */
@@ -242,15 +244,16 @@ struct na_ucx_class {
     struct na_ucx_addr_pool addr_pool;          /* Addr pool */
     ucp_context_h ucp_context;                  /* UCP context */
     ucp_worker_h ucp_worker;                    /* Shared UCP worker */
-    ucp_listener_h ucp_listener;   /* Listener handle if listening */
-    struct na_ucx_addr *self_addr; /* Self address */
-    struct hg_mem_pool *mem_pool;  /* Msg buf pool */
-    size_t ucp_request_size;       /* Size of UCP requests */
-    char *protocol_name;           /* Protocol used */
-    size_t unexpected_size_max;    /* Max unexpected size */
-    size_t expected_size_max;      /* Max expected size */
-    hg_atomic_int32_t ncontexts;   /* Number of contexts */
-    bool no_wait;                  /* Wait disabled */
+    ucp_listener_h ucp_listener;                /* Listener handle if listening */
+    struct na_ucx_addr *self_addr;              /* Self address */
+    struct sockaddr_storage *origin_addr;       /* Origin address, port: 0 */
+    struct hg_mem_pool *mem_pool;               /* Msg buf pool */
+    size_t ucp_request_size;                    /* Size of UCP requests */
+    char *protocol_name;                        /* Protocol used */
+    size_t unexpected_size_max;                 /* Max unexpected size */
+    size_t expected_size_max;                   /* Max expected size */
+    hg_atomic_int32_t ncontexts;                /* Number of contexts */
+    bool no_wait;                               /* Wait disabled */
 };
 
 /* Datatype used for printing info */
@@ -264,12 +267,6 @@ enum na_ucp_type { NA_UCP_CONFIG, NA_UCP_CONTEXT, NA_UCP_WORKER };
 /* NA UCP helpers                                                            */
 /*---------------------------------------------------------------------------*/
 
-/**
- * Convert UCX status to NA return values.
- */
-static na_return_t
-na_ucs_status_to_na(ucs_status_t status);
-
 /**
  * Print debug info.
  */
@@ -278,6 +275,12 @@ static char *
 na_ucp_tostr(void *data, enum na_ucp_type datatype);
 #endif
 
+/**
+ * Convert UCX status to NA return values.
+ */
+static na_return_t
+na_ucx_status_to_na(ucs_status_t status);
+
 /**
  * Init config.
  */
@@ -363,9 +366,11 @@ na_ucp_accept(ucp_worker_h worker, ucp_conn_request_h conn_request,
  * Establish connection.
  */
 static na_return_t
-na_ucp_connect(ucp_worker_h worker, const struct sockaddr *src_addr,
-    const struct sockaddr *dst_addr, socklen_t addrlen,
-    ucp_err_handler_cb_t err_handler_cb, void *err_handler_arg, ucp_ep_h *ep_p);
+na_ucp_connect(ucp_worker_h worker, const struct sockaddr *addr,
+    socklen_t addrlen,
+    const struct sockaddr_storage* local_addr,
+    ucp_err_handler_cb_t err_handler_cb,
+    void *err_handler_arg, ucp_ep_h *ep_p);
 
 /**
  * Create endpoint to worker using worker address (unconnected).
@@ -387,12 +392,6 @@ na_ucp_ep_create(ucp_worker_h worker, ucp_ep_params_t *ep_params,
 static void
 na_ucp_ep_error_cb(void *arg, ucp_ep_h ep, ucs_status_t status);
 
-/**
- * Close endpoint.
- */
-static void
-na_ucp_ep_close(ucp_ep_h ep);
-
 #ifndef NA_UCX_HAS_MEM_POOL
 /**
  * Allocate and register memory.
@@ -411,8 +410,7 @@ na_ucp_mem_free(ucp_context_h context, ucp_mem_h mem);
  * Register memory buffer.
  */
 static int
-na_ucp_mem_buf_register(const void *buf, size_t len, unsigned long flags,
-    void **handle_p, void *arg);
+na_ucp_mem_buf_register(const void *buf, size_t len, void **handle, void *arg);
 
 /**
  * Deregister memory buffer.
@@ -513,12 +511,19 @@ na_ucx_class_alloc(void);
 static void
 na_ucx_class_free(struct na_ucx_class *na_ucx_class);
 
+/**
+ * Set origin address in na_ucx_class.
+ */
+static struct sockaddr_storage *
+na_ucx_set_origin_addr(const char *hostaddr);
+
 /**
  * Parse hostname info.
  */
 static na_return_t
 na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
-    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p);
+    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p,
+    struct sockaddr_storage **origin_addr_p);
 
 /**
  * Hash address key.
@@ -548,11 +553,10 @@ na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
     ucp_conn_request_h conn_request, struct na_ucx_addr **na_ucx_addr_p);
 
 /**
- * Update addr with new EP information.
+ * Replace addr in ep map using new ep.
  */
-static na_return_t
-na_ucx_addr_map_update(struct na_ucx_class *na_ucx_class,
-    struct na_ucx_map *na_ucx_map, struct na_ucx_addr *na_ucx_addr);
+static void
+na_ucx_ep_map_replace(struct na_ucx_addr *na_ucx_addr, ucp_ep_h old_ep);
 
 /**
  * Remove addr from map using addr_key.
@@ -660,6 +664,12 @@ na_ucx_complete(struct na_ucx_op_id *na_ucx_op_id, na_return_t cb_ret);
 static NA_INLINE void
 na_ucx_release(void *arg);
 
+/**
+ * Close end point.
+ */
+static void
+na_ucx_ep_close(ucp_ep_h ep, uint64_t flags);
+
 /********************/
 /* Plugin callbacks */
 /********************/
@@ -679,54 +689,54 @@ na_ucx_finalize(na_class_t *na_class);
 
 /* op_create */
 static na_op_id_t *
-na_ucx_op_create(na_class_t *na_class, unsigned long flags);
+na_ucx_op_create(na_class_t *na_class);
 
 /* op_destroy */
-static void
+static na_return_t
 na_ucx_op_destroy(na_class_t *na_class, na_op_id_t *op_id);
 
 /* addr_lookup */
 static na_return_t
-na_ucx_addr_lookup(na_class_t *na_class, const char *name, na_addr_t **addr_p);
+na_ucx_addr_lookup(na_class_t *na_class, const char *name, na_addr_t *addr_p);
 
 /* addr_free */
-static NA_INLINE void
-na_ucx_addr_free(na_class_t *na_class, na_addr_t *addr);
+static NA_INLINE na_return_t
+na_ucx_addr_free(na_class_t *na_class, na_addr_t addr);
 
 /* addr_self */
 static NA_INLINE na_return_t
-na_ucx_addr_self(na_class_t *na_class, na_addr_t **addr_p);
+na_ucx_addr_self(na_class_t *na_class, na_addr_t *addr);
 
 /* addr_dup */
 static NA_INLINE na_return_t
-na_ucx_addr_dup(na_class_t *na_class, na_addr_t *addr, na_addr_t **new_addr_p);
+na_ucx_addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr);
 
 /* addr_dup */
 static bool
-na_ucx_addr_cmp(na_class_t *na_class, na_addr_t *addr1, na_addr_t *addr2);
+na_ucx_addr_cmp(na_class_t *na_class, na_addr_t addr1, na_addr_t addr2);
 
 /* addr_is_self */
 static NA_INLINE bool
-na_ucx_addr_is_self(na_class_t *na_class, na_addr_t *addr);
+na_ucx_addr_is_self(na_class_t *na_class, na_addr_t addr);
 
 /* addr_to_string */
 static na_return_t
 na_ucx_addr_to_string(
-    na_class_t *na_class, char *buf, size_t *buf_size, na_addr_t *addr);
+    na_class_t *na_class, char *buf, size_t *buf_size, na_addr_t addr);
 
 /* addr_get_serialize_size */
 static NA_INLINE size_t
-na_ucx_addr_get_serialize_size(na_class_t *na_class, na_addr_t *addr);
+na_ucx_addr_get_serialize_size(na_class_t *na_class, na_addr_t addr);
 
 /* addr_serialize */
 static na_return_t
 na_ucx_addr_serialize(
-    na_class_t *na_class, void *buf, size_t buf_size, na_addr_t *addr);
+    na_class_t *na_class, void *buf, size_t buf_size, na_addr_t addr);
 
 /* addr_deserialize */
 static na_return_t
 na_ucx_addr_deserialize(
-    na_class_t *na_class, na_addr_t **addr_p, const void *buf, size_t buf_size);
+    na_class_t *na_class, na_addr_t *addr_p, const void *buf, size_t buf_size);
 
 /* msg_get_max_unexpected_size */
 static NA_INLINE size_t
@@ -742,18 +752,17 @@ na_ucx_msg_get_max_tag(const na_class_t *na_class);
 
 /* msg_buf_alloc */
 static void *
-na_ucx_msg_buf_alloc(na_class_t *na_class, size_t size, unsigned long flags,
-    void **plugin_data_p);
+na_ucx_msg_buf_alloc(na_class_t *na_class, size_t size, void **plugin_data);
 
 /* msg_buf_free */
-static void
+static na_return_t
 na_ucx_msg_buf_free(na_class_t *na_class, void *buf, void *plugin_data);
 
 /* msg_send_unexpected */
 static na_return_t
 na_ucx_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const void *buf, size_t buf_size,
-    void *plugin_data, na_addr_t *dest_addr, uint8_t dest_id, na_tag_t tag,
+    void *plugin_data, na_addr_t dest_addr, uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id);
 
 /* msg_recv_unexpected */
@@ -766,61 +775,59 @@ na_ucx_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
 static na_return_t
 na_ucx_msg_send_expected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const void *buf, size_t buf_size,
-    void *plugin_data, na_addr_t *dest_addr, uint8_t dest_id, na_tag_t tag,
+    void *plugin_data, na_addr_t dest_addr, uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id);
 
 /* msg_recv_expected */
 static na_return_t
 na_ucx_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, void *buf, size_t buf_size, void *plugin_data,
-    na_addr_t *source_addr, uint8_t source_id, na_tag_t tag, na_op_id_t *op_id);
+    na_addr_t source_addr, uint8_t source_id, na_tag_t tag, na_op_id_t *op_id);
 
 /* mem_handle */
 static na_return_t
 na_ucx_mem_handle_create(na_class_t *na_class, void *buf, size_t buf_size,
-    unsigned long flags, na_mem_handle_t **mem_handle_p);
+    unsigned long flags, na_mem_handle_t *mem_handle_p);
 
-static void
-na_ucx_mem_handle_free(na_class_t *na_class, na_mem_handle_t *mem_handle);
+static na_return_t
+na_ucx_mem_handle_free(na_class_t *na_class, na_mem_handle_t mem_handle);
 
 static NA_INLINE size_t
 na_ucx_mem_handle_get_max_segments(const na_class_t *na_class);
 
 static na_return_t
-na_ucx_mem_register(na_class_t *na_class, na_mem_handle_t *mem_handle,
+na_ucx_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle,
     enum na_mem_type mem_type, uint64_t device);
 
 static na_return_t
-na_ucx_mem_deregister(na_class_t *na_class, na_mem_handle_t *mem_handle);
+na_ucx_mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle);
 
 /* mem_handle serialization */
 static NA_INLINE size_t
 na_ucx_mem_handle_get_serialize_size(
-    na_class_t *na_class, na_mem_handle_t *mem_handle);
+    na_class_t *na_class, na_mem_handle_t mem_handle);
 
 static na_return_t
 na_ucx_mem_handle_serialize(na_class_t *na_class, void *buf, size_t buf_size,
-    na_mem_handle_t *mem_handle);
+    na_mem_handle_t mem_handle);
 
 static na_return_t
 na_ucx_mem_handle_deserialize(na_class_t *na_class,
-    na_mem_handle_t **mem_handle_p, const void *buf, size_t buf_size);
+    na_mem_handle_t *mem_handle_p, const void *buf, size_t buf_size);
 
 /* put */
 static na_return_t
 na_ucx_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
-    void *arg, na_mem_handle_t *local_mem_handle, na_offset_t local_offset,
-    na_mem_handle_t *remote_mem_handle, na_offset_t remote_offset,
-    size_t length, na_addr_t *remote_addr, uint8_t remote_id,
-    na_op_id_t *op_id);
+    void *arg, na_mem_handle_t local_mem_handle, na_offset_t local_offset,
+    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset, size_t length,
+    na_addr_t remote_addr, uint8_t remote_id, na_op_id_t *op_id);
 
 /* get */
 static na_return_t
 na_ucx_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
-    void *arg, na_mem_handle_t *local_mem_handle, na_offset_t local_offset,
-    na_mem_handle_t *remote_mem_handle, na_offset_t remote_offset,
-    size_t length, na_addr_t *remote_addr, uint8_t remote_id,
-    na_op_id_t *op_id);
+    void *arg, na_mem_handle_t local_mem_handle, na_offset_t local_offset,
+    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset, size_t length,
+    na_addr_t remote_addr, uint8_t remote_id, na_op_id_t *op_id);
 
 /* poll_get_fd */
 static int
@@ -843,13 +850,12 @@ na_ucx_cancel(na_class_t *na_class, na_context_t *context, na_op_id_t *op_id);
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN const struct na_class_ops NA_PLUGIN_OPS(ucx) = {
+const struct na_class_ops NA_PLUGIN_OPS(ucx) = {
     "ucx",                                /* name */
     na_ucx_check_protocol,                /* check_protocol */
     na_ucx_initialize,                    /* initialize */
     na_ucx_finalize,                      /* finalize */
     NULL,                                 /* cleanup */
-    NULL,                                 /* has_opt_feature */
     NULL,                                 /* context_create */
     NULL,                                 /* context_destroy */
     na_ucx_op_create,                     /* op_create */
@@ -875,7 +881,6 @@ NA_PLUGIN const struct na_class_ops NA_PLUGIN_OPS(ucx) = {
     NULL,                                 /* msg_init_unexpected */
     na_ucx_msg_send_unexpected,           /* msg_send_unexpected */
     na_ucx_msg_recv_unexpected,           /* msg_recv_unexpected */
-    NULL,                                 /* msg_multi_recv_unexpected */
     NULL,                                 /* msg_init_expected */
     na_ucx_msg_send_expected,             /* msg_send_expected */
     na_ucx_msg_recv_expected,             /* msg_recv_expected */
@@ -910,87 +915,38 @@ static const char *ucs_thread_mode_names[UCS_THREAD_MODE_LAST] = {
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucs_status_to_na(ucs_status_t status)
+na_ucx_status_to_na(ucs_status_t status)
 {
     na_return_t ret;
 
     switch (status) {
         case UCS_OK:
-        case UCS_INPROGRESS:
             ret = NA_SUCCESS;
             break;
-
-        case UCS_ERR_NO_ELEM:
-            ret = NA_NOENTRY;
-            break;
-
-        case UCS_ERR_NO_PROGRESS:
-            ret = NA_AGAIN;
-            break;
-
-        case UCS_ERR_NO_MEMORY:
-            ret = NA_NOMEM;
-            break;
-
-        case UCS_ERR_BUSY:
-            ret = NA_BUSY;
+        case UCS_ERR_UNREACHABLE:
+            ret = NA_HOSTUNREACH;
             break;
-
-        case UCS_ERR_ALREADY_EXISTS:
-            ret = NA_EXIST;
+        case UCS_ERR_TIMED_OUT:
+        case UCS_ERR_ENDPOINT_TIMEOUT:
+        case UCS_ERR_NOT_CONNECTED:
+        case UCS_ERR_CONNECTION_RESET:
+            ret = NA_TIMEOUT;
             break;
-
-        case UCS_ERR_NO_RESOURCE:
-        case UCS_ERR_NO_DEVICE:
-            ret = NA_NODEV;
+        case UCS_ERR_CANCELED:
+            ret = NA_CANCELED;
             break;
-
         case UCS_ERR_INVALID_PARAM:
             ret = NA_INVALID_ARG;
             break;
-
-        case UCS_ERR_BUFFER_TOO_SMALL:
-        case UCS_ERR_EXCEEDS_LIMIT:
-        case UCS_ERR_OUT_OF_RANGE:
-            ret = NA_OVERFLOW;
-            break;
-
-        case UCS_ERR_MESSAGE_TRUNCATED:
-            ret = NA_MSGSIZE;
-            break;
-
-        case UCS_ERR_NOT_IMPLEMENTED:
-            ret = NA_PROTONOSUPPORT;
-            break;
-
         case UCS_ERR_UNSUPPORTED:
             ret = NA_OPNOTSUPPORTED;
             break;
-
-        case UCS_ERR_INVALID_ADDR:
-            ret = NA_ADDRNOTAVAIL;
-            break;
-
-        case UCS_ERR_SOME_CONNECTS_FAILED:
-        case UCS_ERR_UNREACHABLE:
-        case UCS_ERR_CONNECTION_RESET:
-        case UCS_ERR_NOT_CONNECTED:
-        case UCS_ERR_REJECTED:
-            ret = NA_HOSTUNREACH;
-            break;
-
-        case UCS_ERR_TIMED_OUT:
-        case UCS_ERR_ENDPOINT_TIMEOUT:
-            ret = NA_TIMEOUT;
+        case UCS_ERR_NO_MEMORY:
+            ret = NA_NOMEM;
             break;
-
-        case UCS_ERR_CANCELED:
-            ret = NA_CANCELED;
+        case UCS_ERR_NO_DEVICE:
+            ret = NA_NODEV;
             break;
-
-        case UCS_ERR_NO_MESSAGE:
-        case UCS_ERR_IO_ERROR:
-        case UCS_ERR_SHMEM_SEGMENT:
         default:
             ret = NA_PROTOCOL_ERROR;
             break;
@@ -1046,29 +1002,34 @@ na_ucp_config_init(
 
     /* Read UCP configuration */
     status = ucp_config_read(NULL, NULL, &config);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_config_read() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_config_read() failed (%s)", ucs_status_string(status));
+
+    /* Set mutex mode */
+    status = ucp_config_modify(config, "TLS", tls);
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_config_modify() failed (%s)", ucs_status_string(status));
 
     /* Set user-requested transport */
     status = ucp_config_modify(config, "TLS", tls);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_config_modify() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_config_modify() failed (%s)", ucs_status_string(status));
 
-    /* Disable backtrace by default */
-    if (getenv("UCX_HANDLE_ERRORS") == NULL) {
-        status = ucp_config_modify(config, "HANDLE_ERRORS", "none");
-        NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-            na_ucs_status_to_na(status), "ucp_config_modify() failed (%s)",
-            ucs_status_string(status));
-    }
+    /* Set mutex mode 
+    status = ucp_config_modify(config, "UCX_USE_MT_MUTEX", "n");
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_config_modify() failed (%s)", ucs_status_string(status));
+    */
+
+    status = ucp_config_modify(config, "UNIFIED_MODE", "n");
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_config_modify() failed (%s)", ucs_status_string(status));
 
     /* Reuse addr for tcp by default */
     if (getenv("UCX_CM_REUSEADDR") == NULL) {
         status = ucp_config_modify(config, "CM_REUSEADDR", "y");
         NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-            na_ucs_status_to_na(status), "ucp_config_modify() failed (%s)",
+            na_ucx_status_to_na(status), "ucp_config_modify() failed (%s)",
             ucs_status_string(status));
     }
 
@@ -1076,7 +1037,7 @@ na_ucp_config_init(
     if (net_devices) {
         status = ucp_config_modify(config, "NET_DEVICES", net_devices);
         NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-            na_ucs_status_to_na(status), "ucp_config_modify() failed (%s)",
+            na_ucx_status_to_na(status), "ucp_config_modify() failed (%s)",
             ucs_status_string(status));
     } else
         NA_LOG_SUBSYS_DEBUG(
@@ -1126,15 +1087,15 @@ na_ucp_context_create(const ucp_config_t *config, bool no_wait,
     if (thread_mode == UCS_THREAD_MODE_MULTI) {
         /* If the UCP context can potentially be used by more than one
          * worker / thread, then this context needs thread safety. */
+	NA_LOG_SUBSYS_DEBUG(cls, "Setting mt_workers_shared");
         context_params.field_mask |= UCP_PARAM_FIELD_MT_WORKERS_SHARED;
         context_params.mt_workers_shared = 1;
     }
 
     /* Create UCP context */
     status = ucp_init(&context_params, config, &context);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_init() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_init() failed (%s)", ucs_status_string(status));
 
     /* Print context info */
     NA_LOG_SUBSYS_DEBUG_EXT(
@@ -1142,23 +1103,22 @@ na_ucp_context_create(const ucp_config_t *config, bool no_wait,
 
     /* Query context to ensure we got what we asked for */
     status = ucp_context_query(context, &context_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_context_query() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_context_query() failed (%s)", ucs_status_string(status));
 
     /* Check that expected fields are present */
     NA_CHECK_SUBSYS_ERROR(cls,
         (context_attrs.field_mask & UCP_ATTR_FIELD_REQUEST_SIZE) == 0, error,
-        ret, NA_PROTONOSUPPORT, "context attributes contain no request size");
+        ret, na_ucx_status_to_na(status), "context attributes contain no request size");
     NA_CHECK_SUBSYS_ERROR(cls,
         (context_attrs.field_mask & UCP_ATTR_FIELD_THREAD_MODE) == 0, error,
-        ret, NA_PROTONOSUPPORT, "context attributes contain no thread mode");
+        ret, na_ucx_status_to_na(status), "context attributes contain no thread mode");
 
     /* Do not continue if thread mode is less than expected */
     NA_CHECK_SUBSYS_ERROR(cls,
         thread_mode != UCS_THREAD_MODE_SINGLE &&
             context_attrs.thread_mode < thread_mode,
-        error, ret, NA_PROTONOSUPPORT, "Context thread mode is: %s",
+        error, ret, na_ucx_status_to_na(status), "Context thread mode is: %s",
         ucs_thread_mode_names[context_attrs.thread_mode]);
 
     NA_LOG_SUBSYS_DEBUG(
@@ -1197,9 +1157,8 @@ na_ucp_worker_create(ucp_context_h context, ucs_thread_mode_t thread_mode,
 
     /* Create UCP worker */
     status = ucp_worker_create(context, &worker_params, &worker);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_worker_create() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_worker_create() failed (%s)", ucs_status_string(status));
 
     /* Print worker info */
     NA_LOG_SUBSYS_DEBUG_EXT(
@@ -1207,9 +1166,8 @@ na_ucp_worker_create(ucp_context_h context, ucs_thread_mode_t thread_mode,
 
     /* Query worker attributes */
     status = ucp_worker_query(worker, &worker_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_worker_query() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_worker_query() failed (%s)", ucs_status_string(status));
 
     /* Check max AM header size */
     NA_CHECK_SUBSYS_ERROR(cls,
@@ -1260,9 +1218,8 @@ na_ucp_worker_get_address(
     na_return_t ret = NA_SUCCESS;
 
     status = ucp_worker_get_address(worker, addr_p, addr_len_p);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret,
-        na_ucs_status_to_na(status), "ucp_worker_get_address() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, na_ucx_status_to_na(status),
+        "ucp_worker_get_address() failed (%s)", ucs_status_string(status));
 
 done:
     return ret;
@@ -1286,8 +1243,7 @@ na_ucp_set_am_handler(
     param.arg = arg;
 
     status = ucp_worker_set_am_recv_handler(worker, &param);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret,
-        na_ucs_status_to_na(status),
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, na_ucx_status_to_na(status),
         "ucp_worker_set_am_recv_handler() failed (%s)",
         ucs_status_string(status));
 
@@ -1315,15 +1271,13 @@ na_ucp_listener_create(ucp_worker_h worker, const struct sockaddr *addr,
 
     /* Create listener on worker */
     status = ucp_listener_create(worker, &listener_params, &listener);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_listener_create() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_listener_create() failed (%s)", ucs_status_string(status));
 
     /* Check sockaddr */
     status = ucp_listener_query(listener, &listener_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_listener_query() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_listener_query() failed (%s)", ucs_status_string(status));
 
     NA_CHECK_SUBSYS_ERROR(cls,
         (listener_attrs.field_mask & UCP_LISTENER_ATTR_FIELD_SOCKADDR) == 0,
@@ -1377,6 +1331,8 @@ na_ucp_listener_conn_cb(ucp_conn_request_h conn_request, void *arg)
     NA_CHECK_SUBSYS_ERROR_NORET(addr, na_ucx_addr != NULL, error,
         "An entry is already present for this address");
 
+    NA_UCX_PRINT_ADDR_KEY_INFO("Inserting new address", &addr_key);
+
     /* Insert new entry and create new address */
     na_ret = na_ucx_addr_map_insert(na_ucx_class, &na_ucx_class->addr_map,
         &addr_key, conn_request, &na_ucx_addr);
@@ -1403,26 +1359,24 @@ na_ucp_accept(ucp_worker_h worker, ucp_conn_request_h conn_request,
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucp_connect(ucp_worker_h worker, const struct sockaddr *src_addr,
-    const struct sockaddr *dst_addr, socklen_t addrlen,
-    ucp_err_handler_cb_t err_handler_cb, void *err_handler_arg, ucp_ep_h *ep_p)
+na_ucp_connect(ucp_worker_h worker, const struct sockaddr *addr,
+    socklen_t addrlen,
+    const struct sockaddr_storage* local_addr,
+    ucp_err_handler_cb_t err_handler_cb,
+    void *err_handler_arg, ucp_ep_h *ep_p)
 {
     ucp_ep_params_t ep_params = {
-        .field_mask = UCP_EP_PARAM_FIELD_FLAGS | UCP_EP_PARAM_FIELD_SOCK_ADDR,
         .flags = UCP_EP_PARAMS_FLAGS_CLIENT_SERVER,
-        .sockaddr = (ucs_sock_addr_t){.addr = dst_addr, .addrlen = addrlen},
+        .field_mask = UCP_EP_PARAM_FIELD_FLAGS | UCP_EP_PARAM_FIELD_SOCK_ADDR,
+        .sockaddr = (ucs_sock_addr_t){.addr = addr, .addrlen = addrlen},
         .conn_request = NULL};
 
-#ifdef NA_UCX_HAS_FIELD_LOCAL_SOCK_ADDR
-    if (src_addr != NULL) {
-        ep_params.field_mask |= UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR;
-        ep_params.local_sockaddr.addr = src_addr;
-        ep_params.local_sockaddr.addrlen = addrlen;
+    if (local_addr) {
+    	NA_LOG_SUBSYS_WARNING(addr, "Adding local address to end point");
+    	ep_params.field_mask |= UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR;
+        ep_params.local_sockaddr.addr = (const struct sockaddr*) local_addr;
+        ep_params.local_sockaddr.addrlen = sizeof(*local_addr);
     }
-#else
-    (void) src_addr;
-#endif
-
     return na_ucp_ep_create(
         worker, &ep_params, err_handler_cb, err_handler_arg, ep_p);
 }
@@ -1489,9 +1443,8 @@ na_ucp_mem_free(ucp_context_h context, ucp_mem_h mem)
     na_return_t ret;
 
     status = ucp_mem_unmap(context, mem);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_mem_unmap() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_mem_unmap() failed (%s)", ucs_status_string(status));
 
     return NA_SUCCESS;
 
@@ -1502,8 +1455,7 @@ error:
 #else
 /*---------------------------------------------------------------------------*/
 static int
-na_ucp_mem_buf_register(const void *buf, size_t len,
-    unsigned long NA_UNUSED flags, void **handle_p, void *arg)
+na_ucp_mem_buf_register(const void *buf, size_t len, void **handle, void *arg)
 {
     struct na_ucx_class *na_ucx_class = (struct na_ucx_class *) arg;
     union {
@@ -1520,7 +1472,7 @@ na_ucp_mem_buf_register(const void *buf, size_t len,
 
     /* Register memory */
     status = ucp_mem_map(
-        na_ucx_class->ucp_context, &mem_map_params, (ucp_mem_h *) handle_p);
+        na_ucx_class->ucp_context, &mem_map_params, (ucp_mem_h *) handle);
     NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, HG_UTIL_FAIL,
         "ucp_mem_map() failed (%s)", ucs_status_string(status));
 
@@ -1571,9 +1523,9 @@ na_ucp_ep_create(ucp_worker_h worker, ucp_ep_params_t *ep_params,
     ep_params->err_handler.arg = err_handler_arg;
 
     status = ucp_ep_create(worker, ep_params, &ep);
-    NA_CHECK_SUBSYS_ERROR(addr, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_ep_create() failed (%s)",
-        ucs_status_string(status));
+
+    NA_CHECK_SUBSYS_ERROR(addr, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_ep_create() failed (%s)", ucs_status_string(status));
 
     *ep_p = ep;
 
@@ -1590,27 +1542,16 @@ na_ucp_ep_error_cb(
 {
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) arg;
 
-    NA_LOG_SUBSYS_DEBUG(addr, "ep_err_handler() returned (%s) for address (%p)",
+    NA_LOG_SUBSYS_WARNING(addr, "ep_err_handler() returned (%s) for address (%p)",
         ucs_status_string(status), (void *) na_ucx_addr);
 
-    /* Mark addr as no longer resolved to force reconnection */
-    hg_atomic_and32(&na_ucx_addr->status, ~NA_UCX_ADDR_RESOLVED);
+    if (status ==  UCS_ERR_CONNECTION_RESET || status == UCS_ERR_NOT_CONNECTED)
+        na_ucx_addr->connected = false;
 
     /* Will schedule removal of address */
     na_ucx_addr_ref_decr(na_ucx_addr);
 }
 
-/*---------------------------------------------------------------------------*/
-static void
-na_ucp_ep_close(ucp_ep_h ep)
-{
-    ucs_status_ptr_t status_ptr = ucp_ep_close_nb(ep, UCP_EP_CLOSE_MODE_FORCE);
-    NA_CHECK_SUBSYS_ERROR_DONE(addr,
-        status_ptr != NULL && UCS_PTR_IS_ERR(status_ptr),
-        "ucp_ep_close_nb() failed (%s)",
-        ucs_status_string(UCS_PTR_STATUS(status_ptr)));
-}
-
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucp_am_send(ucp_ep_h ep, const void *buf, size_t buf_size,
@@ -1638,8 +1579,7 @@ na_ucp_am_send(ucp_ep_h ep, const void *buf, size_t buf_size,
         na_ucp_am_send_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            na_ucs_status_to_na(UCS_PTR_STATUS(status_ptr)),
-            "ucp_am_send_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_am_send_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(msg, "ucp_am_send_nbx() was posted");
@@ -1664,7 +1604,7 @@ na_ucp_am_send_cb(void *request, ucs_status_t status, void NA_UNUSED *user_data)
     if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucs_status_to_na(status),
+        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucx_status_to_na(status),
             "ucp_am_send_nbx() failed (%s)", ucs_status_string(status));
 
 done:
@@ -1696,7 +1636,7 @@ na_ucp_am_recv(
             (struct na_cb_info_recv_unexpected){
                 .tag = (na_tag_t) na_ucx_unexpected_info->tag,
                 .actual_buf_size = (size_t) na_ucx_unexpected_info->length,
-                .source = (na_addr_t *) na_ucx_unexpected_info->na_ucx_addr};
+                .source = (na_addr_t) na_ucx_unexpected_info->na_ucx_addr};
 
         ucp_am_data_release(
             na_ucx_class->ucp_worker, na_ucx_unexpected_info->data);
@@ -1760,7 +1700,7 @@ na_ucp_am_recv_cb(void *arg, const void *header, size_t header_length,
         na_ucx_op_id->completion_data.callback_info.info.recv_unexpected =
             (struct na_cb_info_recv_unexpected){.tag = (na_tag_t) tag,
                 .actual_buf_size = (size_t) length,
-                .source = (na_addr_t *) source_addr};
+                .source = (na_addr_t) source_addr};
         na_ucx_addr_ref_incr(source_addr);
 
         /* Copy buffer */
@@ -1828,8 +1768,7 @@ na_ucp_msg_send(
         na_ucp_msg_send_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            na_ucs_status_to_na(UCS_PTR_STATUS(status_ptr)),
-            "ucp_tag_send_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_tag_send_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(msg, "ucp_tag_send_nbx() was posted");
@@ -1855,7 +1794,7 @@ na_ucp_msg_send_cb(
     if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucs_status_to_na(status),
+        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucx_status_to_na(status),
             "ucp_tag_send_nbx() failed (%s)", ucs_status_string(status));
 
 done:
@@ -1890,8 +1829,7 @@ na_ucp_msg_recv(ucp_worker_h worker, void *buf, size_t buf_size, ucp_tag_t tag,
         na_ucp_msg_recv_cb(request, UCS_OK, &tag_recv_info, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            na_ucs_status_to_na(UCS_PTR_STATUS(status_ptr)),
-            "ucp_tag_recv_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_tag_recv_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(msg, "ucp_tag_recv_nbx() was posted");
@@ -1922,7 +1860,7 @@ na_ucp_msg_recv_cb(void *request, ucs_status_t status,
     else if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucs_status_to_na(status),
+        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucx_status_to_na(status),
             "ucp_tag_recv_nbx() failed (%s)", ucs_status_string(status));
 
     NA_CHECK_SUBSYS_ERROR(msg,
@@ -1966,8 +1904,7 @@ na_ucp_put(ucp_ep_h ep, void *buf, size_t buf_size, uint64_t remote_addr,
         na_ucp_rma_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(rma, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            na_ucs_status_to_na(UCS_PTR_STATUS(status_ptr)),
-            "ucp_put_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_put_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(rma, "ucp_put_nbx() was posted");
@@ -1999,8 +1936,7 @@ na_ucp_get(ucp_ep_h ep, void *buf, size_t buf_size, uint64_t remote_addr,
         na_ucp_rma_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(rma, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            na_ucs_status_to_na(UCS_PTR_STATUS(status_ptr)),
-            "ucp_get_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_get_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(rma, "ucp_get_nbx() was posted");
@@ -2026,7 +1962,7 @@ na_ucp_rma_cb(void *request, ucs_status_t status, void NA_UNUSED *user_data)
     if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(rma, done, cb_ret, na_ucs_status_to_na(status),
+        NA_GOTO_SUBSYS_ERROR(rma, done, cb_ret, na_ucx_status_to_na(status),
             "na_ucp_rma_cb() failed (%s)", ucs_status_string(status));
 
 done:
@@ -2115,22 +2051,42 @@ na_ucx_class_free(struct na_ucx_class *na_ucx_class)
     (void) hg_thread_spin_destroy(&na_ucx_class->unexpected_msg_queue.lock);
     (void) hg_thread_spin_destroy(&na_ucx_class->addr_pool.lock);
 
+    free(na_ucx_class->origin_addr);
     free(na_ucx_class->protocol_name);
     free(na_ucx_class);
 }
 
+/*---------------------------------------------------------------------------*/
+static struct sockaddr_storage *
+na_ucx_set_origin_addr(const char *hostaddr)
+{
+    struct sockaddr_storage *ss_addr = calloc(1, sizeof(*ss_addr));
+    struct sockaddr_in *sa = (struct sockaddr_in *) ss_addr;
+
+    NA_LOG_SUBSYS_WARNING(addr, "Setting origin address");
+	
+    sa->sin_family = AF_INET;
+    sa->sin_addr.s_addr = inet_addr(hostaddr);
+    sa->sin_port = 0;
+    return ss_addr;
+}
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
-    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p)
+    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p,
+    struct sockaddr_storage **origin_addr_p)
 {
     char **ifa_name_p = NULL;
     char *hostname = NULL;
     uint16_t port = 0;
+    bool multi_dev = false;
     na_return_t ret = NA_SUCCESS;
 
     /* Set hostname (use default interface name if no hostname was passed) */
+
     if (hostname_info) {
+    	NA_LOG_SUBSYS_WARNING(addr, "hostname info: %s", hostname_info);
         hostname = strdup(hostname_info);
         NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
             "strdup() of hostname failed");
@@ -2148,6 +2104,8 @@ na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
                 *net_device_p = strdup(hostname);
                 NA_CHECK_SUBSYS_ERROR(cls, *net_device_p == NULL, done, ret,
                     NA_NOMEM, "strdup() of net_device failed");
+                if (strstr(*net_device_p, ","))
+                    multi_dev = true;
             }
             if (strcmp(host_str, "") == 0)
                 hostname = NULL;
@@ -2171,6 +2129,8 @@ na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
     /* TODO add support for IPv6 wildcards */
 
     if (hostname && strcmp(hostname, "0.0.0.0") != 0) {
+	if (!multi_dev && *net_device_p != NULL)
+                *origin_addr_p = na_ucx_set_origin_addr(hostname);
         /* Try to get matching IP/device */
         ret = na_ip_check_interface(
             hostname, port, AF_UNSPEC, ifa_name_p, sockaddr_p, addrlen_p);
@@ -2273,12 +2233,13 @@ na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
     } else {
         /* Create new endpoint */
         ret = na_ucp_connect(na_ucx_class->ucp_worker,
-            na_ucx_class->self_addr->addr_key.addr, na_ucx_addr->addr_key.addr,
-            na_ucx_addr->addr_key.addrlen, na_ucp_ep_error_cb,
-            (void *) na_ucx_addr, &na_ucx_addr->ucp_ep);
+            na_ucx_addr->addr_key.addr, na_ucx_addr->addr_key.addrlen,
+            na_ucx_class->origin_addr,
+            na_ucp_ep_error_cb, (void *) na_ucx_addr, &na_ucx_addr->ucp_ep);
         NA_CHECK_SUBSYS_NA_ERROR(
             addr, error, ret, "Could not connect UCP endpoint");
     }
+    na_ucx_addr->connected = true;
     NA_LOG_SUBSYS_DEBUG(addr, "UCP ep for addr %p is %p", (void *) na_ucx_addr,
         (void *) na_ucx_addr->ucp_ep);
 
@@ -2296,8 +2257,6 @@ na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
     NA_CHECK_SUBSYS_ERROR(
         addr, rc == 0, error, ret, NA_NOMEM, "hg_hash_table_insert() failed");
 
-    hg_atomic_or32(&na_ucx_addr->status, NA_UCX_ADDR_RESOLVED);
-
 done:
     hg_thread_rwlock_release_wrlock(&na_ucx_map->lock);
 
@@ -2314,59 +2273,24 @@ error:
 }
 
 /*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucx_addr_map_update(struct na_ucx_class *na_ucx_class,
-    struct na_ucx_map *na_ucx_map, struct na_ucx_addr *na_ucx_addr)
+static void 
+na_ucx_ep_map_replace(struct na_ucx_addr *na_ucx_addr, ucp_ep_h old_ep)
 {
-    na_return_t ret = NA_SUCCESS;
-    int rc;
-
-    hg_thread_rwlock_wrlock(&na_ucx_map->lock);
-
-    /* Check again to prevent race between lock release/acquire */
-    if (hg_atomic_get32(&na_ucx_addr->status) & NA_UCX_ADDR_RESOLVED)
-        goto unlock;
-
-    NA_LOG_SUBSYS_DEBUG(
-        addr, "Attempting to reconnect addr %p", (void *) na_ucx_addr);
+    hg_thread_rwlock_wrlock(&(na_ucx_addr->na_ucx_class->addr_map.lock));
 
     /* Remove EP handle from secondary map */
-    rc = hg_hash_table_remove(
-        na_ucx_map->ep_map, (hg_hash_table_key_t) na_ucx_addr->ucp_ep);
-    NA_CHECK_SUBSYS_ERROR(addr, rc != 1, unlock, ret, NA_NOENTRY,
-        "hg_hash_table_remove() failed");
-
-    /* Close previous EP */
-    na_ucp_ep_close(na_ucx_addr->ucp_ep);
-    na_ucx_addr->ucp_ep = NULL;
-
-    /* Create new endpoint */
-    ret = na_ucp_connect(na_ucx_class->ucp_worker,
-        na_ucx_class->self_addr->addr_key.addr, na_ucx_addr->addr_key.addr,
-        na_ucx_addr->addr_key.addrlen, na_ucp_ep_error_cb, (void *) na_ucx_addr,
-        &na_ucx_addr->ucp_ep);
-    NA_CHECK_SUBSYS_NA_ERROR(
-        addr, unlock, ret, "Could not connect UCP endpoint");
-
-    NA_LOG_SUBSYS_DEBUG(addr, "UCP ep for addr %p is %p", (void *) na_ucx_addr,
-        (void *) na_ucx_addr->ucp_ep);
+    hg_hash_table_remove(
+        na_ucx_addr->na_ucx_class->addr_map.ep_map,
+        (hg_hash_table_key_t) old_ep);
 
-    /* Insert new value to secondary map to lookup by EP handle */
-    rc = hg_hash_table_insert(na_ucx_map->ep_map,
+    hg_hash_table_insert(
+        na_ucx_addr->na_ucx_class->addr_map.ep_map,
         (hg_hash_table_key_t) na_ucx_addr->ucp_ep,
         (hg_hash_table_value_t) na_ucx_addr);
-    NA_CHECK_SUBSYS_ERROR(
-        addr, rc == 0, unlock, ret, NA_NOMEM, "hg_hash_table_insert() failed");
-
-    /* Retake refcount taken away from previous disconnect */
-    na_ucx_addr_ref_incr(na_ucx_addr);
 
-    hg_atomic_or32(&na_ucx_addr->status, NA_UCX_ADDR_RESOLVED);
+    hg_thread_rwlock_release_wrlock(&(na_ucx_addr->na_ucx_class->addr_map.lock));
+    
 
-unlock:
-    hg_thread_rwlock_release_wrlock(&na_ucx_map->lock);
-
-    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2488,16 +2412,12 @@ na_ucx_addr_release(struct na_ucx_addr *na_ucx_addr)
     /* Make sure we remove from map before we close the EP */
     if (na_ucx_addr->addr_key.addr) {
         NA_UCX_PRINT_ADDR_KEY_INFO("Removing address", &na_ucx_addr->addr_key);
-
         na_ucx_addr_map_remove(
             &na_ucx_addr->na_ucx_class->addr_map, &na_ucx_addr->addr_key);
     }
 
     if (na_ucx_addr->ucp_ep != NULL) {
-        /* NB. for deserialized addresses that are not "connected" addresses, do
-         * not close the EP */
-        if (na_ucx_addr->worker_addr == NULL)
-            na_ucp_ep_close(na_ucx_addr->ucp_ep);
+        ucp_ep_close_nb(na_ucx_addr->ucp_ep, UCP_EP_CLOSE_MODE_FORCE);
         na_ucx_addr->ucp_ep = NULL;
     }
 
@@ -2518,7 +2438,6 @@ na_ucx_addr_reset(struct na_ucx_addr *na_ucx_addr, ucs_sock_addr_t *addr_key)
 {
     na_ucx_addr->ucp_ep = NULL;
     hg_atomic_init32(&na_ucx_addr->refcount, 1);
-    hg_atomic_init32(&na_ucx_addr->status, 0);
 
     if (addr_key && addr_key->addr) {
         memcpy(&na_ucx_addr->ss_addr, addr_key->addr, addr_key->addrlen);
@@ -2541,10 +2460,6 @@ na_ucx_addr_create(struct na_ucx_class *na_ucx_class, ucs_sock_addr_t *addr_key,
     struct na_ucx_addr *na_ucx_addr;
     na_return_t ret;
 
-    if (addr_key != NULL) {
-        NA_UCX_PRINT_ADDR_KEY_INFO("Creating new address", addr_key);
-    }
-
 #ifdef NA_UCX_HAS_ADDR_POOL
     na_ucx_addr = na_ucx_addr_pool_get(na_ucx_class);
 #else
@@ -2568,21 +2483,14 @@ error:
 static NA_INLINE void
 na_ucx_addr_ref_incr(struct na_ucx_addr *na_ucx_addr)
 {
-    int32_t NA_DEBUG_LOG_USED refcount =
-        hg_atomic_incr32(&na_ucx_addr->refcount);
-    NA_LOG_SUBSYS_DEBUG(addr, "Refcount for address (%p) is: %" PRId32,
-        (void *) na_ucx_addr, refcount);
+    hg_atomic_incr32(&na_ucx_addr->refcount);
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE void
 na_ucx_addr_ref_decr(struct na_ucx_addr *na_ucx_addr)
 {
-    int32_t refcount = hg_atomic_decr32(&na_ucx_addr->refcount);
-    NA_LOG_SUBSYS_DEBUG(addr, "Refcount for address (%p) is: %" PRId32,
-        (void *) na_ucx_addr, refcount);
-
-    if (refcount == 0) {
+    if (hg_atomic_decr32(&na_ucx_addr->refcount) == 0) {
 #ifdef NA_UCX_HAS_ADDR_POOL
         struct na_ucx_addr_pool *addr_pool =
             &na_ucx_addr->na_ucx_class->addr_pool;
@@ -2675,7 +2583,7 @@ na_ucx_rma_key_resolve(ucp_ep_h ep, struct na_ucx_mem_handle *na_ucx_mem_handle,
             ucs_status_t status = ucp_ep_rkey_unpack(ep,
                 na_ucx_mem_handle->rkey_buf, &na_ucx_mem_handle->ucp_mr.rkey);
             NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret,
-                na_ucs_status_to_na(status), "ucp_ep_rkey_unpack() failed (%s)",
+                na_ucx_status_to_na(status), "ucp_ep_rkey_unpack() failed (%s)",
                 ucs_status_string(status));
             /* Handle is now unpacked */
             hg_atomic_set32(
@@ -2731,6 +2639,28 @@ na_ucx_release(void *arg)
     }
 }
 
+/*---------------------------------------------------------------------------*/
+static void
+na_ucx_ep_close(ucp_ep_h ep, uint64_t flags)
+{
+    ucp_request_param_t param;
+    ucs_status_t status;
+    void *close_req;
+
+    param.op_attr_mask = UCP_OP_ATTR_FIELD_FLAGS;
+    param.flags        = flags;
+    close_req          = ucp_ep_close_nbx(ep, &param);
+
+    /* Only check status is non-blocking operation is completed */
+    if (!UCS_PTR_IS_PTR(close_req)) {
+        status = UCS_PTR_STATUS(close_req);
+        if ( status != UCS_OK) {
+	    NA_LOG_SUBSYS_DEBUG(addr, "Failed to close ep %p, status: %s\n",
+                                (void *)ep, ucs_status_string(status));
+        }
+    }
+}
+
 /********************/
 /* Plugin callbacks */
 /********************/
@@ -2777,11 +2707,12 @@ na_ucx_initialize(
     ucp_lib_attr_t ucp_lib_attrs;
 #endif
     char *net_device = NULL;
-    struct sockaddr *src_sockaddr = NULL;
-    socklen_t src_addrlen = 0;
+    struct sockaddr *listen_sockaddr = NULL;
+    socklen_t listen_addrlen = 0;
+    struct sockaddr_storage *origin_sockaddr = NULL;
     struct sockaddr_storage ucp_listener_ss_addr;
     ucs_sock_addr_t addr_key = {.addr = NULL, .addrlen = 0};
-    ucp_config_t *config = NULL;
+    ucp_config_t *config;
     bool no_wait = false;
     size_t unexpected_size_max = 0, expected_size_max = 0;
     ucs_thread_mode_t context_thread_mode = UCS_THREAD_MODE_SINGLE,
@@ -2793,7 +2724,6 @@ na_ucx_initialize(
 #ifdef NA_UCX_HAS_LIB_QUERY
     ucs_status_t status;
 #endif
-    bool multi_dev = false;
 
     if (na_info->na_init_info != NULL) {
         /* Progress mode */
@@ -2809,19 +2739,22 @@ na_ucx_initialize(
             expected_size_max = na_info->na_init_info->max_expected_size;
         /* Thread mode */
         if ((na_info->na_init_info->max_contexts > 1) &&
-            !(na_info->na_init_info->thread_mode & NA_THREAD_MODE_SINGLE))
+            !(na_info->na_init_info->thread_mode & NA_THREAD_MODE_SINGLE)) {
+            NA_LOG_SUBSYS_DEBUG(cls, "Setting context thread mode to multi");
             context_thread_mode = UCS_THREAD_MODE_MULTI;
+	}
 
-        if (na_info->na_init_info->thread_mode & NA_THREAD_MODE_SINGLE_CTX)
+        if (na_info->na_init_info->thread_mode & NA_THREAD_MODE_SINGLE_CTX) {
+            NA_LOG_SUBSYS_DEBUG(cls, "Setting worker thread mode to single");
             worker_thread_mode = UCS_THREAD_MODE_SINGLE;
+	}
     }
 
 #ifdef NA_UCX_HAS_LIB_QUERY
     ucp_lib_attrs.field_mask = UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL;
     status = ucp_lib_query(&ucp_lib_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_context_query: %s",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_context_query: %s", ucs_status_string(status));
     NA_CHECK_SUBSYS_ERROR(cls,
         (ucp_lib_attrs.field_mask & UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL) == 0,
         error, ret, NA_PROTONOSUPPORT,
@@ -2832,7 +2765,7 @@ na_ucx_initialize(
     if (worker_thread_mode != UCS_THREAD_MODE_SINGLE &&
         ucp_lib_attrs.max_thread_level == UCS_THREAD_MODE_SERIALIZED) {
         worker_thread_mode = UCS_THREAD_MODE_SERIALIZED;
-        NA_LOG_SUBSYS_WARNING(cls, "Max worker thread level is: %s",
+        NA_LOG_SUBSYS_DEBUG(cls, "Max worker thread level is: %s",
             ucs_thread_mode_names[worker_thread_mode]);
     }
 #endif
@@ -2842,19 +2775,17 @@ na_ucx_initialize(
         (na_info->na_init_info && na_info->na_init_info->ip_subnet)
             ? na_info->na_init_info->ip_subnet
             : NULL,
-        &net_device, &src_sockaddr, &src_addrlen);
+        &net_device, (listen) ? &listen_sockaddr : NULL, &listen_addrlen,
+        &origin_sockaddr);
     NA_CHECK_SUBSYS_NA_ERROR(
         cls, error, ret, "na_ucx_parse_hostname_info() failed");
 
-    /* Multi-rail */
-    if (net_device != NULL && strstr(net_device, ","))
-        multi_dev = true;
-
     /* Create new UCX class */
     na_ucx_class = na_ucx_class_alloc();
     NA_CHECK_SUBSYS_ERROR(cls, na_ucx_class == NULL, error, ret, NA_NOMEM,
         "Could not allocate NA UCX class");
 
+    na_ucx_class->origin_addr = origin_sockaddr;
     /* Keep a copy of the protocol name */
     na_ucx_class->protocol_name = (na_info->protocol_name)
                                       ? strdup(na_info->protocol_name)
@@ -2887,6 +2818,7 @@ na_ucx_initialize(
     net_device = NULL;
 
     /* Create single worker */
+    NA_LOG_SUBSYS_DEBUG(cls, "Setting work thread mode to %s", worker_thread_mode == UCS_THREAD_MODE_MULTI ? "MULTI" : "SINGLE");
     ret = na_ucp_worker_create(na_ucx_class->ucp_context, worker_thread_mode,
         &na_ucx_class->ucp_worker);
     NA_CHECK_SUBSYS_NA_ERROR(cls, error, ret, "Could not create UCX worker");
@@ -2899,8 +2831,8 @@ na_ucx_initialize(
 
     /* Create listener if we're listening */
     if (listen) {
-        ret = na_ucp_listener_create(na_ucx_class->ucp_worker, src_sockaddr,
-            src_addrlen, (void *) na_ucx_class, &na_ucx_class->ucp_listener,
+        ret = na_ucp_listener_create(na_ucx_class->ucp_worker, listen_sockaddr,
+            listen_addrlen, (void *) na_ucx_class, &na_ucx_class->ucp_listener,
             &ucp_listener_ss_addr);
         NA_CHECK_SUBSYS_NA_ERROR(
             cls, error, ret, "Could not create UCX listener");
@@ -2908,9 +2840,11 @@ na_ucx_initialize(
         addr_key = (ucs_sock_addr_t){
             .addr = (const struct sockaddr *) &ucp_listener_ss_addr,
             .addrlen = sizeof(ucp_listener_ss_addr)};
-    } else if (!multi_dev)
-        addr_key =
-            (ucs_sock_addr_t){.addr = src_sockaddr, .addrlen = src_addrlen};
+
+        /* No longer needed */
+        free(listen_sockaddr);
+        listen_sockaddr = NULL;
+    }
 
 #ifdef NA_UCX_HAS_ADDR_POOL
     /* Create pool of addresses */
@@ -2935,7 +2869,7 @@ na_ucx_initialize(
     na_ucx_class->mem_pool = hg_mem_pool_create(
         MAX(na_ucx_class->unexpected_size_max, na_ucx_class->expected_size_max),
         NA_UCX_MEM_CHUNK_COUNT, NA_UCX_MEM_BLOCK_COUNT, na_ucp_mem_buf_register,
-        0, na_ucp_mem_buf_deregister, (void *) na_ucx_class);
+        na_ucp_mem_buf_deregister, (void *) na_ucx_class);
     NA_CHECK_SUBSYS_ERROR(cls, na_ucx_class->mem_pool == NULL, error, ret,
         NA_NOMEM,
         "Could not create memory pool with %d blocks of size %d x %zu bytes",
@@ -2946,14 +2880,11 @@ na_ucx_initialize(
 
     na_class->plugin_class = (void *) na_ucx_class;
 
-    /* No longer needed */
-    free(src_sockaddr);
-
     return NA_SUCCESS;
 
 error:
     free(net_device);
-    free(src_sockaddr);
+    free(listen_sockaddr);
     if (na_ucx_class)
         na_ucx_class_free(na_ucx_class);
 
@@ -3002,7 +2933,7 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static na_op_id_t *
-na_ucx_op_create(na_class_t *na_class, unsigned long NA_UNUSED flags)
+na_ucx_op_create(na_class_t *na_class)
 {
     struct na_ucx_op_id *na_ucx_op_id = NULL;
 
@@ -3023,23 +2954,27 @@ out:
 }
 
 /*---------------------------------------------------------------------------*/
-static void
+static na_return_t
 na_ucx_op_destroy(na_class_t NA_UNUSED *na_class, na_op_id_t *op_id)
 {
     struct na_ucx_op_id *na_ucx_op_id = (struct na_ucx_op_id *) op_id;
+    na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_SUBSYS_WARNING(op,
-        !(hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_COMPLETED),
-        "Attempting to use OP ID that was not completed (%s)",
+    NA_CHECK_SUBSYS_ERROR(op,
+        !(hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_COMPLETED), done,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
         na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
 
     hg_mem_header_free(NA_UCX_CLASS(na_class)->ucp_request_size,
         alignof(struct na_ucx_op_id), na_ucx_op_id);
+
+done:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucx_addr_lookup(na_class_t *na_class, const char *name, na_addr_t **addr_p)
+na_ucx_addr_lookup(na_class_t *na_class, const char *name, na_addr_t *addr_p)
 {
     char host_string[NI_MAXHOST];
     char serv_string[NI_MAXSERV];
@@ -3100,7 +3035,7 @@ na_ucx_addr_lookup(na_class_t *na_class, const char *name, na_addr_t **addr_p)
 
     na_ucx_addr_ref_incr(na_ucx_addr);
 
-    *addr_p = (na_addr_t *) na_ucx_addr;
+    *addr_p = (na_addr_t) na_ucx_addr;
 
     return NA_SUCCESS;
 
@@ -3109,18 +3044,20 @@ error:
 }
 
 /*---------------------------------------------------------------------------*/
-static NA_INLINE void
-na_ucx_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t *addr)
+static NA_INLINE na_return_t
+na_ucx_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
     na_ucx_addr_ref_decr((struct na_ucx_addr *) addr);
+
+    return NA_SUCCESS;
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_return_t
-na_ucx_addr_self(na_class_t *na_class, na_addr_t **addr_p)
+na_ucx_addr_self(na_class_t *na_class, na_addr_t *addr_p)
 {
     na_ucx_addr_ref_incr(NA_UCX_CLASS(na_class)->self_addr);
-    *addr_p = (na_addr_t *) NA_UCX_CLASS(na_class)->self_addr;
+    *addr_p = (na_addr_t) NA_UCX_CLASS(na_class)->self_addr;
 
     return NA_SUCCESS;
 }
@@ -3128,10 +3065,10 @@ na_ucx_addr_self(na_class_t *na_class, na_addr_t **addr_p)
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_return_t
 na_ucx_addr_dup(
-    na_class_t NA_UNUSED *na_class, na_addr_t *addr, na_addr_t **new_addr_p)
+    na_class_t NA_UNUSED *na_class, na_addr_t addr, na_addr_t *new_addr)
 {
     na_ucx_addr_ref_incr((struct na_ucx_addr *) addr);
-    *new_addr_p = addr;
+    *new_addr = addr;
 
     return NA_SUCCESS;
 }
@@ -3139,14 +3076,14 @@ na_ucx_addr_dup(
 /*---------------------------------------------------------------------------*/
 static bool
 na_ucx_addr_cmp(
-    na_class_t NA_UNUSED *na_class, na_addr_t *addr1, na_addr_t *addr2)
+    na_class_t NA_UNUSED *na_class, na_addr_t addr1, na_addr_t addr2)
 {
     return addr1 == addr2;
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE bool
-na_ucx_addr_is_self(na_class_t *na_class, na_addr_t *addr)
+na_ucx_addr_is_self(na_class_t *na_class, na_addr_t addr)
 {
     return NA_UCX_CLASS(na_class)->self_addr == (struct na_ucx_addr *) addr;
 }
@@ -3154,7 +3091,7 @@ na_ucx_addr_is_self(na_class_t *na_class, na_addr_t *addr)
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_addr_to_string(
-    na_class_t *na_class, char *buf, size_t *buf_size_p, na_addr_t *addr)
+    na_class_t *na_class, char *buf, size_t *buf_size_p, na_addr_t addr)
 {
     struct na_ucx_class *na_ucx_class = NA_UCX_CLASS(na_class);
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) addr;
@@ -3194,7 +3131,7 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE size_t
-na_ucx_addr_get_serialize_size(na_class_t NA_UNUSED *na_class, na_addr_t *addr)
+na_ucx_addr_get_serialize_size(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
     return ((struct na_ucx_addr *) addr)->worker_addr_len + sizeof(uint64_t);
 }
@@ -3202,7 +3139,7 @@ na_ucx_addr_get_serialize_size(na_class_t NA_UNUSED *na_class, na_addr_t *addr)
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_addr_serialize(
-    na_class_t NA_UNUSED *na_class, void *buf, size_t buf_size, na_addr_t *addr)
+    na_class_t NA_UNUSED *na_class, void *buf, size_t buf_size, na_addr_t addr)
 {
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) addr;
     char *buf_ptr = (char *) buf;
@@ -3230,7 +3167,7 @@ done:
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_addr_deserialize(
-    na_class_t *na_class, na_addr_t **addr_p, const void *buf, size_t buf_size)
+    na_class_t *na_class, na_addr_t *addr_p, const void *buf, size_t buf_size)
 {
     struct na_ucx_class *na_ucx_class = NA_UCX_CLASS(na_class);
     struct na_ucx_addr *na_ucx_addr = NULL;
@@ -3268,9 +3205,7 @@ na_ucx_addr_deserialize(
     NA_CHECK_SUBSYS_NA_ERROR(
         addr, error, ret, "Could not connect to remote worker");
 
-    hg_atomic_or32(&na_ucx_addr->status, NA_UCX_ADDR_RESOLVED);
-
-    *addr_p = (na_addr_t *) na_ucx_addr;
+    *addr_p = (na_addr_t) na_ucx_addr;
 
     return NA_SUCCESS;
 
@@ -3306,19 +3241,18 @@ na_ucx_msg_get_max_tag(const na_class_t NA_UNUSED *na_class)
 
 /*---------------------------------------------------------------------------*/
 static void *
-na_ucx_msg_buf_alloc(na_class_t *na_class, size_t size,
-    unsigned long NA_UNUSED flags, void **plugin_data_p)
+na_ucx_msg_buf_alloc(na_class_t *na_class, size_t size, void **plugin_data)
 {
     void *mem_ptr;
 
 #ifdef NA_UCX_HAS_MEM_POOL
-    mem_ptr = hg_mem_pool_alloc(
-        NA_UCX_CLASS(na_class)->mem_pool, size, plugin_data_p);
+    mem_ptr =
+        hg_mem_pool_alloc(NA_UCX_CLASS(na_class)->mem_pool, size, plugin_data);
     NA_CHECK_SUBSYS_ERROR_NORET(
         mem, mem_ptr == NULL, done, "Could not allocate buffer from pool");
 #else
     mem_ptr = na_ucp_mem_alloc(
-        NA_UCX_CLASS(na_class)->ucp_context, size, (ucp_mem_h *) plugin_data_p);
+        NA_UCX_CLASS(na_class)->ucp_context, size, (ucp_mem_h *) plugin_data);
     NA_CHECK_SUBSYS_ERROR_NORET(
         mem, mem_ptr == NULL, done, "Could not allocate memory");
 #endif
@@ -3328,27 +3262,35 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-static void
+static na_return_t
 na_ucx_msg_buf_free(na_class_t *na_class, void *buf, void *plugin_data)
 {
+    na_return_t ret = NA_SUCCESS;
+
 #ifdef NA_UCX_HAS_MEM_POOL
     hg_mem_pool_free(NA_UCX_CLASS(na_class)->mem_pool, buf, plugin_data);
 #else
-    (void) na_ucp_mem_free(
+    ret = na_ucp_mem_free(
         NA_UCX_CLASS(na_class)->ucp_context, (ucp_mem_h) plugin_data);
+    NA_CHECK_SUBSYS_NA_ERROR(mem, done, ret, "Could not free memory");
     (void) buf;
+
+done:
 #endif
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucx_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
-    na_context_t *context, na_cb_t callback, void *arg, const void *buf,
-    size_t buf_size, void NA_UNUSED *plugin_data, na_addr_t *dest_addr,
+na_ucx_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, const void *buf,
+    size_t buf_size, void NA_UNUSED *plugin_data, na_addr_t dest_addr,
     uint8_t NA_UNUSED dest_id, na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) dest_addr;
     struct na_ucx_op_id *na_ucx_op_id = (struct na_ucx_op_id *) op_id;
+    struct na_ucx_class *na_ucx_class = NA_UCX_CLASS(na_class);
     na_return_t ret;
 
     /* Check op_id */
@@ -3359,17 +3301,20 @@ na_ucx_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
         ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
         na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
 
-    /* Check addr to ensure the EP for that addr is still valid */
-    if (!(hg_atomic_get32(&na_ucx_addr->status) & NA_UCX_ADDR_RESOLVED)) {
-        struct na_ucx_class *na_ucx_class = NA_UCX_CLASS(na_class);
-
-        ret = na_ucx_addr_map_update(
-            na_ucx_class, &na_ucx_class->addr_map, na_ucx_addr);
+    if (!na_ucx_addr->connected) {
+        ucp_ep_h old_ep = na_ucx_addr->ucp_ep;
+        na_ucx_ep_close(na_ucx_addr->ucp_ep, UCP_EP_CLOSE_MODE_FORCE);
+        na_ucx_addr->ucp_ep = NULL;
+        ret = na_ucp_connect(na_ucx_class->ucp_worker,
+            na_ucx_addr->addr_key.addr, na_ucx_addr->addr_key.addrlen,
+            na_ucx_class->origin_addr,
+            na_ucp_ep_error_cb, (void *) na_ucx_addr, &na_ucx_addr->ucp_ep);
         NA_CHECK_SUBSYS_NA_ERROR(
-            addr, error, ret, "Could not update NA UCX address");
+            addr, error, ret, "Could not connect UCP endpoint");
+        na_ucx_ep_map_replace(na_ucx_addr, old_ep);
+        na_ucx_addr_ref_incr(na_ucx_addr);
+    	na_ucx_addr->connected = true;
     }
-    NA_CHECK_SUBSYS_ERROR(msg, na_ucx_addr->ucp_ep == NULL, error, ret,
-        NA_ADDRNOTAVAIL, "UCP endpoint is NULL for that address");
 
     NA_UCX_OP_RESET(na_ucx_op_id, context, NA_CB_SEND_UNEXPECTED, callback, arg,
         na_ucx_addr);
@@ -3377,7 +3322,11 @@ na_ucx_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
     /* We assume buf remains valid (safe because we pre-allocate buffers) */
     na_ucx_op_id->info.msg = (struct na_ucx_msg_info){
         .buf.const_ptr = buf, .buf_size = buf_size, .tag = (ucp_tag_t) tag};
-
+    
+    if (!na_ucx_addr->ucp_ep) {
+        ret = NA_ADDRNOTAVAIL;
+        goto release;
+    }
     ret = na_ucp_am_send(na_ucx_addr->ucp_ep, buf, buf_size,
         &na_ucx_op_id->info.msg.tag, na_ucx_op_id);
     NA_CHECK_SUBSYS_NA_ERROR(msg, release, ret, "Could not post msg send");
@@ -3407,7 +3356,7 @@ na_ucx_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
         !(hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_COMPLETED), error,
         ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
         na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
-
+ 
     NA_UCX_OP_RESET(
         na_ucx_op_id, context, NA_CB_RECV_UNEXPECTED, callback, arg, NULL);
 
@@ -3427,8 +3376,8 @@ error:
 static na_return_t
 na_ucx_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const void *buf, size_t buf_size,
-    void NA_UNUSED *plugin_data, na_addr_t *dest_addr,
-    uint8_t NA_UNUSED dest_id, na_tag_t tag, na_op_id_t *op_id)
+    void NA_UNUSED *plugin_data, na_addr_t dest_addr, uint8_t NA_UNUSED dest_id,
+    na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) dest_addr;
     struct na_ucx_op_id *na_ucx_op_id = (struct na_ucx_op_id *) op_id;
@@ -3442,18 +3391,6 @@ na_ucx_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
         ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
         na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
 
-    /* Check addr to ensure the EP for that addr is still valid */
-    if (!(hg_atomic_get32(&na_ucx_addr->status) & NA_UCX_ADDR_RESOLVED)) {
-        struct na_ucx_class *na_ucx_class = NA_UCX_CLASS(na_class);
-
-        ret = na_ucx_addr_map_update(
-            na_ucx_class, &na_ucx_class->addr_map, na_ucx_addr);
-        NA_CHECK_SUBSYS_NA_ERROR(
-            addr, error, ret, "Could not update NA UCX address");
-    }
-    NA_CHECK_SUBSYS_ERROR(msg, na_ucx_addr->ucp_ep == NULL, error, ret,
-        NA_ADDRNOTAVAIL, "UCP endpoint is NULL for that address");
-
     NA_UCX_OP_RESET(
         na_ucx_op_id, context, NA_CB_SEND_EXPECTED, callback, arg, na_ucx_addr);
 
@@ -3478,7 +3415,7 @@ error:
 static na_return_t
 na_ucx_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, void *buf, size_t buf_size,
-    void NA_UNUSED *plugin_data, na_addr_t *source_addr,
+    void NA_UNUSED *plugin_data, na_addr_t source_addr,
     uint8_t NA_UNUSED source_id, na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) source_addr;
@@ -3517,7 +3454,7 @@ error:
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_mem_handle_create(na_class_t NA_UNUSED *na_class, void *buf,
-    size_t buf_size, unsigned long flags, na_mem_handle_t **mem_handle_p)
+    size_t buf_size, unsigned long flags, na_mem_handle_t *mem_handle_p)
 {
     struct na_ucx_mem_handle *na_ucx_mem_handle = NULL;
     na_return_t ret;
@@ -3534,7 +3471,7 @@ na_ucx_mem_handle_create(na_class_t NA_UNUSED *na_class, void *buf,
     hg_atomic_init32(&na_ucx_mem_handle->type, NA_UCX_MEM_HANDLE_LOCAL);
     hg_thread_mutex_init(&na_ucx_mem_handle->rkey_unpack_lock);
 
-    *mem_handle_p = (na_mem_handle_t *) na_ucx_mem_handle;
+    *mem_handle_p = (na_mem_handle_t) na_ucx_mem_handle;
 
     return NA_SUCCESS;
 
@@ -3543,12 +3480,13 @@ error:
 }
 
 /*---------------------------------------------------------------------------*/
-static void
+static na_return_t
 na_ucx_mem_handle_free(
-    na_class_t NA_UNUSED *na_class, na_mem_handle_t *mem_handle)
+    na_class_t NA_UNUSED *na_class, na_mem_handle_t mem_handle)
 {
     struct na_ucx_mem_handle *na_ucx_mem_handle =
         (struct na_ucx_mem_handle *) mem_handle;
+    na_return_t ret;
 
     switch (hg_atomic_get32(&na_ucx_mem_handle->type)) {
         case NA_UCX_MEM_HANDLE_LOCAL:
@@ -3561,12 +3499,17 @@ na_ucx_mem_handle_free(
             free(na_ucx_mem_handle->rkey_buf);
             break;
         default:
-            NA_LOG_SUBSYS_ERROR(mem, "Invalid memory handle type");
-            break;
+            NA_GOTO_SUBSYS_ERROR(
+                mem, error, ret, NA_INVALID_ARG, "Invalid memory handle type");
     }
 
     hg_thread_mutex_destroy(&na_ucx_mem_handle->rkey_unpack_lock);
     free(na_ucx_mem_handle);
+
+    return NA_SUCCESS;
+
+error:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3578,7 +3521,7 @@ na_ucx_mem_handle_get_max_segments(const na_class_t NA_UNUSED *na_class)
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucx_mem_register(na_class_t *na_class, na_mem_handle_t *mem_handle,
+na_ucx_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle,
     enum na_mem_type mem_type, uint64_t NA_UNUSED device)
 {
     struct na_ucx_mem_handle *na_ucx_mem_handle =
@@ -3643,18 +3586,16 @@ na_ucx_mem_register(na_class_t *na_class, na_mem_handle_t *mem_handle,
     /* Register memory */
     status = ucp_mem_map(NA_UCX_CLASS(na_class)->ucp_context, &mem_map_params,
         &na_ucx_mem_handle->ucp_mr.mem);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_mem_map() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_mem_map() failed (%s)", ucs_status_string(status));
 
     /* Keep a copy of the rkey to share with the remote */
     /* TODO that could have been a good candidate for publish */
     status = ucp_rkey_pack(NA_UCX_CLASS(na_class)->ucp_context,
         na_ucx_mem_handle->ucp_mr.mem, &na_ucx_mem_handle->rkey_buf,
         &rkey_buf_size);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_rkey_pack() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_rkey_pack() failed (%s)", ucs_status_string(status));
     na_ucx_mem_handle->desc.rkey_buf_size = (uint64_t) rkey_buf_size;
 
     return NA_SUCCESS;
@@ -3665,7 +3606,7 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucx_mem_deregister(na_class_t *na_class, na_mem_handle_t *mem_handle)
+na_ucx_mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     struct na_ucx_mem_handle *na_ucx_mem_handle =
         (struct na_ucx_mem_handle *) mem_handle;
@@ -3680,9 +3621,8 @@ na_ucx_mem_deregister(na_class_t *na_class, na_mem_handle_t *mem_handle)
     /* Deregister memory */
     status = ucp_mem_unmap(
         NA_UCX_CLASS(na_class)->ucp_context, na_ucx_mem_handle->ucp_mr.mem);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret,
-        na_ucs_status_to_na(status), "ucp_mem_unmap() failed (%s)",
-        ucs_status_string(status));
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_mem_unmap() failed (%s)", ucs_status_string(status));
     na_ucx_mem_handle->ucp_mr.mem = NULL;
 
     /* TODO that could have been a good candidate for unpublish */
@@ -3698,7 +3638,7 @@ error:
 /*---------------------------------------------------------------------------*/
 static NA_INLINE size_t
 na_ucx_mem_handle_get_serialize_size(
-    na_class_t NA_UNUSED *na_class, na_mem_handle_t *mem_handle)
+    na_class_t NA_UNUSED *na_class, na_mem_handle_t mem_handle)
 {
     struct na_ucx_mem_handle *na_ucx_mem_handle =
         (struct na_ucx_mem_handle *) mem_handle;
@@ -3710,7 +3650,7 @@ na_ucx_mem_handle_get_serialize_size(
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_mem_handle_serialize(na_class_t NA_UNUSED *na_class, void *buf,
-    size_t buf_size, na_mem_handle_t *mem_handle)
+    size_t buf_size, na_mem_handle_t mem_handle)
 {
     struct na_ucx_mem_handle *na_ucx_mem_handle =
         (struct na_ucx_mem_handle *) mem_handle;
@@ -3735,7 +3675,7 @@ error:
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
-    na_mem_handle_t **mem_handle_p, const void *buf, size_t buf_size)
+    na_mem_handle_t *mem_handle_p, const void *buf, size_t buf_size)
 {
     struct na_ucx_mem_handle *na_ucx_mem_handle = NULL;
     const char *buf_ptr = (const char *) buf;
@@ -3766,7 +3706,7 @@ na_ucx_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
     memcpy(na_ucx_mem_handle->rkey_buf, buf_ptr,
         na_ucx_mem_handle->desc.rkey_buf_size);
 
-    *mem_handle_p = (na_mem_handle_t *) na_ucx_mem_handle;
+    *mem_handle_p = (na_mem_handle_t) na_ucx_mem_handle;
 
     return NA_SUCCESS;
 
@@ -3777,10 +3717,9 @@ error:
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
-    void *arg, na_mem_handle_t *local_mem_handle, na_offset_t local_offset,
-    na_mem_handle_t *remote_mem_handle, na_offset_t remote_offset,
-    size_t length, na_addr_t *remote_addr, uint8_t NA_UNUSED remote_id,
-    na_op_id_t *op_id)
+    void *arg, na_mem_handle_t local_mem_handle, na_offset_t local_offset,
+    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset, size_t length,
+    na_addr_t remote_addr, uint8_t NA_UNUSED remote_id, na_op_id_t *op_id)
 {
     return na_ucx_rma(NA_UCX_CLASS(na_class), context, NA_CB_PUT, callback, arg,
         (struct na_ucx_mem_handle *) local_mem_handle, local_offset,
@@ -3791,10 +3730,9 @@ na_ucx_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
-    void *arg, na_mem_handle_t *local_mem_handle, na_offset_t local_offset,
-    na_mem_handle_t *remote_mem_handle, na_offset_t remote_offset,
-    size_t length, na_addr_t *remote_addr, uint8_t NA_UNUSED remote_id,
-    na_op_id_t *op_id)
+    void *arg, na_mem_handle_t local_mem_handle, na_offset_t local_offset,
+    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset, size_t length,
+    na_addr_t remote_addr, uint8_t NA_UNUSED remote_id, na_op_id_t *op_id)
 {
     return na_ucx_rma(NA_UCX_CLASS(na_class), context, NA_CB_GET, callback, arg,
         (struct na_ucx_mem_handle *) local_mem_handle, local_offset,
