diff --git a/src/na/na_ucx.c b/src/na/na_ucx.c
index db4fc75..18989ee 100644
--- a/src/na/na_ucx.c
+++ b/src/na/na_ucx.c
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-2022 UChicago Argonne, LLC and The HDF Group.
+ * Copyright (c) 2013-2021 UChicago Argonne, LLC and The HDF Group.
  * Copyright (c) 2022 Intel Corporation.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -23,6 +23,7 @@
 
 #include <netdb.h>
 #include <sys/socket.h>
+#include <arpa/inet.h>
 
 /****************/
 /* Local Macros */
@@ -134,6 +135,7 @@ struct na_ucx_addr {
     bool worker_addr_alloc;            /* Worker addr was allocated by us */
     ucp_ep_h ucp_ep;                   /* Currently only one EP per address */
     hg_atomic_int32_t refcount;        /* Reference counter */
+    bool connected;                    /* Connection state */
 };
 
 /* Map (used to cache addresses) */
@@ -242,15 +244,16 @@ struct na_ucx_class {
     struct na_ucx_addr_pool addr_pool;          /* Addr pool */
     ucp_context_h ucp_context;                  /* UCP context */
     ucp_worker_h ucp_worker;                    /* Shared UCP worker */
-    ucp_listener_h ucp_listener;   /* Listener handle if listening */
-    struct na_ucx_addr *self_addr; /* Self address */
-    struct hg_mem_pool *mem_pool;  /* Msg buf pool */
-    size_t ucp_request_size;       /* Size of UCP requests */
-    char *protocol_name;           /* Protocol used */
-    size_t unexpected_size_max;    /* Max unexpected size */
-    size_t expected_size_max;      /* Max expected size */
-    hg_atomic_int32_t ncontexts;   /* Number of contexts */
-    bool no_wait;                  /* Wait disabled */
+    ucp_listener_h ucp_listener;                /* Listener handle if listening */
+    struct na_ucx_addr *self_addr;              /* Self address */
+    struct sockaddr_storage *origin_addr;       /* Origin address, port: 0 */
+    struct hg_mem_pool *mem_pool;               /* Msg buf pool */
+    size_t ucp_request_size;                    /* Size of UCP requests */
+    char *protocol_name;                        /* Protocol used */
+    size_t unexpected_size_max;                 /* Max unexpected size */
+    size_t expected_size_max;                   /* Max expected size */
+    hg_atomic_int32_t ncontexts;                /* Number of contexts */
+    bool no_wait;                               /* Wait disabled */
 };
 
 /* Datatype used for printing info */
@@ -272,6 +275,12 @@ static char *
 na_ucp_tostr(void *data, enum na_ucp_type datatype);
 #endif
 
+/**
+ * Convert UCX status to NA return values.
+ */
+static na_return_t
+na_ucx_status_to_na(ucs_status_t status);
+
 /**
  * Init config.
  */
@@ -358,7 +367,9 @@ na_ucp_accept(ucp_worker_h worker, ucp_conn_request_h conn_request,
  */
 static na_return_t
 na_ucp_connect(ucp_worker_h worker, const struct sockaddr *addr,
-    socklen_t addrlen, ucp_err_handler_cb_t err_handler_cb,
+    socklen_t addrlen,
+    const struct sockaddr_storage* local_addr,
+    ucp_err_handler_cb_t err_handler_cb,
     void *err_handler_arg, ucp_ep_h *ep_p);
 
 /**
@@ -500,12 +511,19 @@ na_ucx_class_alloc(void);
 static void
 na_ucx_class_free(struct na_ucx_class *na_ucx_class);
 
+/**
+ * Set origin address in na_ucx_class.
+ */
+static struct sockaddr_storage *
+na_ucx_set_origin_addr(const char *hostaddr);
+
 /**
  * Parse hostname info.
  */
 static na_return_t
 na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
-    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p);
+    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p,
+    struct sockaddr_storage **origin_addr_p);
 
 /**
  * Hash address key.
@@ -534,6 +552,12 @@ na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
     struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key,
     ucp_conn_request_h conn_request, struct na_ucx_addr **na_ucx_addr_p);
 
+/**
+ * Replace addr in ep map using new ep.
+ */
+static void
+na_ucx_ep_map_replace(struct na_ucx_addr *na_ucx_addr, ucp_ep_h old_ep);
+
 /**
  * Remove addr from map using addr_key.
  */
@@ -883,6 +907,47 @@ static const char *ucs_thread_mode_names[UCS_THREAD_MODE_LAST] = {
 #    undef X
 #endif
 
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ucx_status_to_na(ucs_status_t status)
+{
+    na_return_t ret;
+
+    switch (status) {
+        case UCS_OK:
+            ret = NA_SUCCESS;
+            break;
+        case UCS_ERR_UNREACHABLE:
+            ret = NA_HOSTUNREACH;
+            break;
+        case UCS_ERR_TIMED_OUT:
+        case UCS_ERR_ENDPOINT_TIMEOUT:
+        case UCS_ERR_NOT_CONNECTED:
+            ret = NA_TIMEOUT;
+            break;
+        case UCS_ERR_CANCELED:
+            ret = NA_CANCELED;
+            break;
+        case UCS_ERR_INVALID_PARAM:
+            ret = NA_INVALID_ARG;
+            break;
+        case UCS_ERR_UNSUPPORTED:
+            ret = NA_OPNOTSUPPORTED;
+            break;
+        case UCS_ERR_NO_MEMORY:
+            ret = NA_NOMEM;
+            break;
+        case UCS_ERR_NO_DEVICE:
+            ret = NA_NODEV;
+            break;
+        default:
+            ret = NA_PROTOCOL_ERROR;
+            break;
+    }
+
+    return ret;
+}
+
 /*---------------------------------------------------------------------------*/
 #ifdef NA_HAS_DEBUG
 static char *
@@ -930,19 +995,23 @@ na_ucp_config_init(
 
     /* Read UCP configuration */
     status = ucp_config_read(NULL, NULL, &config);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_config_read() failed (%s)", ucs_status_string(status));
 
     /* Set user-requested transport */
     status = ucp_config_modify(config, "TLS", tls);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_config_modify() failed (%s)", ucs_status_string(status));
+
+    status = ucp_config_modify(config, "UNIFIED_MODE", "n");
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_config_modify() failed (%s)", ucs_status_string(status));
 
     /* Set network devices to use */
     if (net_devices) {
         status = ucp_config_modify(config, "NET_DEVICES", net_devices);
         NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-            NA_PROTOCOL_ERROR, "ucp_config_modify() failed (%s)",
+            na_ucx_status_to_na(status), "ucp_config_modify() failed (%s)",
             ucs_status_string(status));
     } else
         NA_LOG_SUBSYS_DEBUG(
@@ -998,7 +1067,7 @@ na_ucp_context_create(const ucp_config_t *config, bool no_wait,
 
     /* Create UCP context */
     status = ucp_init(&context_params, config, &context);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_init() failed (%s)", ucs_status_string(status));
 
     /* Print context info */
@@ -1007,22 +1076,22 @@ na_ucp_context_create(const ucp_config_t *config, bool no_wait,
 
     /* Query context to ensure we got what we asked for */
     status = ucp_context_query(context, &context_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_context_query() failed (%s)", ucs_status_string(status));
 
     /* Check that expected fields are present */
     NA_CHECK_SUBSYS_ERROR(cls,
         (context_attrs.field_mask & UCP_ATTR_FIELD_REQUEST_SIZE) == 0, error,
-        ret, NA_PROTOCOL_ERROR, "context attributes contain no request size");
+        ret, na_ucx_status_to_na(status), "context attributes contain no request size");
     NA_CHECK_SUBSYS_ERROR(cls,
         (context_attrs.field_mask & UCP_ATTR_FIELD_THREAD_MODE) == 0, error,
-        ret, NA_PROTOCOL_ERROR, "context attributes contain no thread mode");
+        ret, na_ucx_status_to_na(status), "context attributes contain no thread mode");
 
     /* Do not continue if thread mode is less than expected */
     NA_CHECK_SUBSYS_ERROR(cls,
         thread_mode != UCS_THREAD_MODE_SINGLE &&
             context_attrs.thread_mode < thread_mode,
-        error, ret, NA_PROTOCOL_ERROR, "Context thread mode is: %s",
+        error, ret, na_ucx_status_to_na(status), "Context thread mode is: %s",
         ucs_thread_mode_names[context_attrs.thread_mode]);
 
     NA_LOG_SUBSYS_DEBUG(
@@ -1061,7 +1130,7 @@ na_ucp_worker_create(ucp_context_h context, ucs_thread_mode_t thread_mode,
 
     /* Create UCP worker */
     status = ucp_worker_create(context, &worker_params, &worker);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_worker_create() failed (%s)", ucs_status_string(status));
 
     /* Print worker info */
@@ -1070,7 +1139,7 @@ na_ucp_worker_create(ucp_context_h context, ucs_thread_mode_t thread_mode,
 
     /* Query worker attributes */
     status = ucp_worker_query(worker, &worker_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_worker_query() failed (%s)", ucs_status_string(status));
 
     /* Check max AM header size */
@@ -1122,7 +1191,7 @@ na_ucp_worker_get_address(
     na_return_t ret = NA_SUCCESS;
 
     status = ucp_worker_get_address(worker, addr_p, addr_len_p);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, na_ucx_status_to_na(status),
         "ucp_worker_get_address() failed (%s)", ucs_status_string(status));
 
 done:
@@ -1147,7 +1216,7 @@ na_ucp_set_am_handler(
     param.arg = arg;
 
     status = ucp_worker_set_am_recv_handler(worker, &param);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, na_ucx_status_to_na(status),
         "ucp_worker_set_am_recv_handler() failed (%s)",
         ucs_status_string(status));
 
@@ -1175,12 +1244,12 @@ na_ucp_listener_create(ucp_worker_h worker, const struct sockaddr *addr,
 
     /* Create listener on worker */
     status = ucp_listener_create(worker, &listener_params, &listener);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_listener_create() failed (%s)", ucs_status_string(status));
 
     /* Check sockaddr */
     status = ucp_listener_query(listener, &listener_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_listener_query() failed (%s)", ucs_status_string(status));
 
     NA_CHECK_SUBSYS_ERROR(cls,
@@ -1264,15 +1333,22 @@ na_ucp_accept(ucp_worker_h worker, ucp_conn_request_h conn_request,
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucp_connect(ucp_worker_h worker, const struct sockaddr *addr,
-    socklen_t addrlen, ucp_err_handler_cb_t err_handler_cb,
+    socklen_t addrlen,
+    const struct sockaddr_storage* local_addr,
+    ucp_err_handler_cb_t err_handler_cb,
     void *err_handler_arg, ucp_ep_h *ep_p)
 {
     ucp_ep_params_t ep_params = {
-        .field_mask = UCP_EP_PARAM_FIELD_FLAGS | UCP_EP_PARAM_FIELD_SOCK_ADDR,
         .flags = UCP_EP_PARAMS_FLAGS_CLIENT_SERVER,
+        .field_mask = UCP_EP_PARAM_FIELD_FLAGS | UCP_EP_PARAM_FIELD_SOCK_ADDR,
         .sockaddr = (ucs_sock_addr_t){.addr = addr, .addrlen = addrlen},
         .conn_request = NULL};
 
+    if (local_addr) {
+    	ep_params.field_mask |= UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR;
+        ep_params.local_sockaddr.addr = (const struct sockaddr*) local_addr;
+        ep_params.local_sockaddr.addrlen = sizeof(*local_addr);
+    }
     return na_ucp_ep_create(
         worker, &ep_params, err_handler_cb, err_handler_arg, ep_p);
 }
@@ -1339,7 +1415,7 @@ na_ucp_mem_free(ucp_context_h context, ucp_mem_h mem)
     na_return_t ret;
 
     status = ucp_mem_unmap(context, mem);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_mem_unmap() failed (%s)", ucs_status_string(status));
 
     return NA_SUCCESS;
@@ -1419,7 +1495,8 @@ na_ucp_ep_create(ucp_worker_h worker, ucp_ep_params_t *ep_params,
     ep_params->err_handler.arg = err_handler_arg;
 
     status = ucp_ep_create(worker, ep_params, &ep);
-    NA_CHECK_SUBSYS_ERROR(addr, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+
+    NA_CHECK_SUBSYS_ERROR(addr, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_ep_create() failed (%s)", ucs_status_string(status));
 
     *ep_p = ep;
@@ -1440,6 +1517,9 @@ na_ucp_ep_error_cb(
     NA_LOG_SUBSYS_DEBUG(addr, "ep_err_handler() returned (%s) for address (%p)",
         ucs_status_string(status), (void *) na_ucx_addr);
 
+    if (status ==  UCS_ERR_CONNECTION_RESET || status == UCS_ERR_NOT_CONNECTED)
+        na_ucx_addr->connected = false;
+
     /* Will schedule removal of address */
     na_ucx_addr_ref_decr(na_ucx_addr);
 }
@@ -1471,7 +1551,7 @@ na_ucp_am_send(ucp_ep_h ep, const void *buf, size_t buf_size,
         na_ucp_am_send_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_am_send_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_am_send_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(msg, "ucp_am_send_nbx() was posted");
@@ -1496,7 +1576,7 @@ na_ucp_am_send_cb(void *request, ucs_status_t status, void NA_UNUSED *user_data)
     if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, NA_PROTOCOL_ERROR,
+        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucx_status_to_na(status),
             "ucp_am_send_nbx() failed (%s)", ucs_status_string(status));
 
 done:
@@ -1660,7 +1740,7 @@ na_ucp_msg_send(
         na_ucp_msg_send_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_tag_send_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_tag_send_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(msg, "ucp_tag_send_nbx() was posted");
@@ -1686,7 +1766,7 @@ na_ucp_msg_send_cb(
     if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, NA_PROTOCOL_ERROR,
+        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucx_status_to_na(status),
             "ucp_tag_send_nbx() failed (%s)", ucs_status_string(status));
 
 done:
@@ -1721,7 +1801,7 @@ na_ucp_msg_recv(ucp_worker_h worker, void *buf, size_t buf_size, ucp_tag_t tag,
         na_ucp_msg_recv_cb(request, UCS_OK, &tag_recv_info, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_tag_recv_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_tag_recv_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(msg, "ucp_tag_recv_nbx() was posted");
@@ -1752,7 +1832,7 @@ na_ucp_msg_recv_cb(void *request, ucs_status_t status,
     else if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, NA_PROTOCOL_ERROR,
+        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucx_status_to_na(status),
             "ucp_tag_recv_nbx() failed (%s)", ucs_status_string(status));
 
     NA_CHECK_SUBSYS_ERROR(msg,
@@ -1796,7 +1876,7 @@ na_ucp_put(ucp_ep_h ep, void *buf, size_t buf_size, uint64_t remote_addr,
         na_ucp_rma_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(rma, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_put_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_put_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(rma, "ucp_put_nbx() was posted");
@@ -1828,7 +1908,7 @@ na_ucp_get(ucp_ep_h ep, void *buf, size_t buf_size, uint64_t remote_addr,
         na_ucp_rma_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(rma, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_get_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_get_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(rma, "ucp_get_nbx() was posted");
@@ -1854,7 +1934,7 @@ na_ucp_rma_cb(void *request, ucs_status_t status, void NA_UNUSED *user_data)
     if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(rma, done, cb_ret, NA_PROTOCOL_ERROR,
+        NA_GOTO_SUBSYS_ERROR(rma, done, cb_ret, na_ucx_status_to_na(status),
             "na_ucp_rma_cb() failed (%s)", ucs_status_string(status));
 
 done:
@@ -1943,18 +2023,34 @@ na_ucx_class_free(struct na_ucx_class *na_ucx_class)
     (void) hg_thread_spin_destroy(&na_ucx_class->unexpected_msg_queue.lock);
     (void) hg_thread_spin_destroy(&na_ucx_class->addr_pool.lock);
 
+    free(na_ucx_class->origin_addr);
     free(na_ucx_class->protocol_name);
     free(na_ucx_class);
 }
 
+/*---------------------------------------------------------------------------*/
+static struct sockaddr_storage *
+na_ucx_set_origin_addr(const char *hostaddr)
+{
+    struct sockaddr_storage *ss_addr = calloc(1, sizeof(*ss_addr));
+    struct sockaddr_in *sa = (struct sockaddr_in *) ss_addr;
+
+    sa->sin_family = AF_INET;
+    sa->sin_addr.s_addr = inet_addr(hostaddr);
+    sa->sin_port = 0;
+    return ss_addr;
+}
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
-    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p)
+    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p,
+    struct sockaddr_storage **origin_addr_p)
 {
     char **ifa_name_p = NULL;
     char *hostname = NULL;
     uint16_t port = 0;
+    bool multi_dev = false;
     na_return_t ret = NA_SUCCESS;
 
     /* Set hostname (use default interface name if no hostname was passed) */
@@ -1976,6 +2072,8 @@ na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
                 *net_device_p = strdup(hostname);
                 NA_CHECK_SUBSYS_ERROR(cls, *net_device_p == NULL, done, ret,
                     NA_NOMEM, "strdup() of net_device failed");
+                if (strstr(*net_device_p, ","))
+                    multi_dev = true;
             }
             if (strcmp(host_str, "") == 0)
                 hostname = NULL;
@@ -1999,6 +2097,8 @@ na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
     /* TODO add support for IPv6 wildcards */
 
     if (hostname && strcmp(hostname, "0.0.0.0") != 0) {
+	if (!multi_dev && *net_device_p != NULL)
+                *origin_addr_p = na_ucx_set_origin_addr(hostname);
         /* Try to get matching IP/device */
         ret = na_ip_check_interface(
             hostname, port, AF_UNSPEC, ifa_name_p, sockaddr_p, addrlen_p);
@@ -2102,10 +2202,12 @@ na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
         /* Create new endpoint */
         ret = na_ucp_connect(na_ucx_class->ucp_worker,
             na_ucx_addr->addr_key.addr, na_ucx_addr->addr_key.addrlen,
+            na_ucx_class->origin_addr,
             na_ucp_ep_error_cb, (void *) na_ucx_addr, &na_ucx_addr->ucp_ep);
         NA_CHECK_SUBSYS_NA_ERROR(
             addr, error, ret, "Could not connect UCP endpoint");
     }
+    na_ucx_addr->connected = true;
     NA_LOG_SUBSYS_DEBUG(addr, "UCP ep for addr %p is %p", (void *) na_ucx_addr,
         (void *) na_ucx_addr->ucp_ep);
 
@@ -2138,6 +2240,27 @@ error:
     return ret;
 }
 
+/*---------------------------------------------------------------------------*/
+static void 
+na_ucx_ep_map_replace(struct na_ucx_addr *na_ucx_addr, ucp_ep_h old_ep)
+{
+    hg_thread_rwlock_wrlock(&(na_ucx_addr->na_ucx_class->addr_map.lock));
+
+    /* Remove EP handle from secondary map */
+    hg_hash_table_remove(
+        na_ucx_addr->na_ucx_class->addr_map.ep_map,
+        (hg_hash_table_key_t) old_ep);
+
+    hg_hash_table_insert(
+        na_ucx_addr->na_ucx_class->addr_map.ep_map,
+        (hg_hash_table_key_t) na_ucx_addr->ucp_ep,
+        (hg_hash_table_value_t) na_ucx_addr);
+
+    hg_thread_rwlock_release_wrlock(&(na_ucx_addr->na_ucx_class->addr_map.lock));
+    
+
+}
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_addr_map_remove(struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key)
@@ -2257,7 +2380,6 @@ na_ucx_addr_release(struct na_ucx_addr *na_ucx_addr)
     /* Make sure we remove from map before we close the EP */
     if (na_ucx_addr->addr_key.addr) {
         NA_UCX_PRINT_ADDR_KEY_INFO("Removing address", &na_ucx_addr->addr_key);
-
         na_ucx_addr_map_remove(
             &na_ucx_addr->na_ucx_class->addr_map, &na_ucx_addr->addr_key);
     }
@@ -2429,7 +2551,7 @@ na_ucx_rma_key_resolve(ucp_ep_h ep, struct na_ucx_mem_handle *na_ucx_mem_handle,
             ucs_status_t status = ucp_ep_rkey_unpack(ep,
                 na_ucx_mem_handle->rkey_buf, &na_ucx_mem_handle->ucp_mr.rkey);
             NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret,
-                NA_PROTOCOL_ERROR, "ucp_ep_rkey_unpack() failed (%s)",
+                na_ucx_status_to_na(status), "ucp_ep_rkey_unpack() failed (%s)",
                 ucs_status_string(status));
             /* Handle is now unpacked */
             hg_atomic_set32(
@@ -2533,6 +2655,7 @@ na_ucx_initialize(
     char *net_device = NULL;
     struct sockaddr *listen_sockaddr = NULL;
     socklen_t listen_addrlen = 0;
+    struct sockaddr_storage *origin_sockaddr = NULL;
     struct sockaddr_storage ucp_listener_ss_addr;
     ucs_sock_addr_t addr_key = {.addr = NULL, .addrlen = 0};
     ucp_config_t *config;
@@ -2572,7 +2695,7 @@ na_ucx_initialize(
 #ifdef NA_UCX_HAS_LIB_QUERY
     ucp_lib_attrs.field_mask = UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL;
     status = ucp_lib_query(&ucp_lib_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_context_query: %s", ucs_status_string(status));
     NA_CHECK_SUBSYS_ERROR(cls,
         (ucp_lib_attrs.field_mask & UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL) == 0,
@@ -2594,7 +2717,8 @@ na_ucx_initialize(
         (na_info->na_init_info && na_info->na_init_info->ip_subnet)
             ? na_info->na_init_info->ip_subnet
             : NULL,
-        &net_device, (listen) ? &listen_sockaddr : NULL, &listen_addrlen);
+        &net_device, (listen) ? &listen_sockaddr : NULL, &listen_addrlen,
+        &origin_sockaddr);
     NA_CHECK_SUBSYS_NA_ERROR(
         cls, error, ret, "na_ucx_parse_hostname_info() failed");
 
@@ -2603,6 +2727,7 @@ na_ucx_initialize(
     NA_CHECK_SUBSYS_ERROR(cls, na_ucx_class == NULL, error, ret, NA_NOMEM,
         "Could not allocate NA UCX class");
 
+    na_ucx_class->origin_addr = origin_sockaddr;
     /* Keep a copy of the protocol name */
     na_ucx_class->protocol_name = (na_info->protocol_name)
                                       ? strdup(na_info->protocol_name)
@@ -2806,7 +2931,7 @@ na_ucx_addr_lookup(na_class_t *na_class, const char *name, na_addr_t *addr_p)
         strncmp(name, "all", strlen("all")) &&
             strncmp(name, na_ucx_class->protocol_name,
                 strlen(na_ucx_class->protocol_name)),
-        error, ret, NA_PROTOCOL_ERROR,
+        error, ret, NA_PROTONOSUPPORT,
         "Protocol not supported by this class (%s)",
         na_ucx_class->protocol_name);
 
@@ -3097,15 +3222,37 @@ done:
     return ret;
 }
 
+static void
+na_ucx_ep_close(ucp_worker_h ucp_worker, ucp_ep_h ep, uint64_t flags)
+{
+    ucp_request_param_t param;
+    ucs_status_t status;
+    void *close_req;
+
+    param.op_attr_mask = UCP_OP_ATTR_FIELD_FLAGS;
+    param.flags        = flags;
+    close_req          = ucp_ep_close_nbx(ep, &param);
+
+    /* Only check status is non-blocking operation is completed */
+    if (!UCS_PTR_IS_PTR(close_req)) {
+        status = UCS_PTR_STATUS(close_req);
+        if ( status != UCS_OK) {
+	    NA_LOG_SUBSYS_ERROR(addr, "Failed to close ep %p, status: %s\n",
+                                (void *)ep, ucs_status_string(status));
+        }
+    }
+}
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucx_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
-    na_context_t *context, na_cb_t callback, void *arg, const void *buf,
+na_ucx_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, const void *buf,
     size_t buf_size, void NA_UNUSED *plugin_data, na_addr_t dest_addr,
     uint8_t NA_UNUSED dest_id, na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) dest_addr;
     struct na_ucx_op_id *na_ucx_op_id = (struct na_ucx_op_id *) op_id;
+    struct na_ucx_class *na_ucx_class = NA_UCX_CLASS(na_class);
     na_return_t ret;
 
     /* Check op_id */
@@ -3116,13 +3263,33 @@ na_ucx_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
         ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
         na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
 
+    if (!na_ucx_addr->connected) {
+        ucp_ep_h old_ep = na_ucx_addr->ucp_ep;
+        na_ucx_ep_close(na_ucx_class->ucp_worker, na_ucx_addr->ucp_ep,
+                        UCP_EP_CLOSE_MODE_FORCE);
+        na_ucx_addr->ucp_ep = NULL;
+        ret = na_ucp_connect(na_ucx_class->ucp_worker,
+            na_ucx_addr->addr_key.addr, na_ucx_addr->addr_key.addrlen,
+            na_ucx_class->origin_addr,
+            na_ucp_ep_error_cb, (void *) na_ucx_addr, &na_ucx_addr->ucp_ep);
+        NA_CHECK_SUBSYS_NA_ERROR(
+            addr, error, ret, "Could not connect UCP endpoint");
+        na_ucx_ep_map_replace(na_ucx_addr, old_ep);
+        na_ucx_addr_ref_incr(na_ucx_addr);
+    	na_ucx_addr->connected = true;
+    }
+
     NA_UCX_OP_RESET(na_ucx_op_id, context, NA_CB_SEND_UNEXPECTED, callback, arg,
         na_ucx_addr);
 
     /* We assume buf remains valid (safe because we pre-allocate buffers) */
     na_ucx_op_id->info.msg = (struct na_ucx_msg_info){
         .buf.const_ptr = buf, .buf_size = buf_size, .tag = (ucp_tag_t) tag};
-
+    
+    if (!na_ucx_addr->ucp_ep) {
+        ret = NA_ADDRNOTAVAIL;
+        goto release;
+    }
     ret = na_ucp_am_send(na_ucx_addr->ucp_ep, buf, buf_size,
         &na_ucx_op_id->info.msg.tag, na_ucx_op_id);
     NA_CHECK_SUBSYS_NA_ERROR(msg, release, ret, "Could not post msg send");
@@ -3152,7 +3319,7 @@ na_ucx_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
         !(hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_COMPLETED), error,
         ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
         na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
-
+ 
     NA_UCX_OP_RESET(
         na_ucx_op_id, context, NA_CB_RECV_UNEXPECTED, callback, arg, NULL);
 
@@ -3382,7 +3549,7 @@ na_ucx_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle,
     /* Register memory */
     status = ucp_mem_map(NA_UCX_CLASS(na_class)->ucp_context, &mem_map_params,
         &na_ucx_mem_handle->ucp_mr.mem);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_mem_map() failed (%s)", ucs_status_string(status));
 
     /* Keep a copy of the rkey to share with the remote */
@@ -3390,7 +3557,7 @@ na_ucx_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle,
     status = ucp_rkey_pack(NA_UCX_CLASS(na_class)->ucp_context,
         na_ucx_mem_handle->ucp_mr.mem, &na_ucx_mem_handle->rkey_buf,
         &rkey_buf_size);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_rkey_pack() failed (%s)", ucs_status_string(status));
     na_ucx_mem_handle->desc.rkey_buf_size = (uint64_t) rkey_buf_size;
 
@@ -3417,7 +3584,7 @@ na_ucx_mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
     /* Deregister memory */
     status = ucp_mem_unmap(
         NA_UCX_CLASS(na_class)->ucp_context, na_ucx_mem_handle->ucp_mr.mem);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_mem_unmap() failed (%s)", ucs_status_string(status));
     na_ucx_mem_handle->ucp_mr.mem = NULL;
 
