diff --git a/src/na/na_ucx.c b/src/na/na_ucx.c
index db4fc75..c176159 100644
--- a/src/na/na_ucx.c
+++ b/src/na/na_ucx.c
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-2022 UChicago Argonne, LLC and The HDF Group.
+ * Copyright (c) 2013-2021 UChicago Argonne, LLC and The HDF Group.
  * Copyright (c) 2022 Intel Corporation.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -23,6 +23,7 @@
 
 #include <netdb.h>
 #include <sys/socket.h>
+#include <arpa/inet.h>
 
 /****************/
 /* Local Macros */
@@ -242,15 +243,16 @@ struct na_ucx_class {
     struct na_ucx_addr_pool addr_pool;          /* Addr pool */
     ucp_context_h ucp_context;                  /* UCP context */
     ucp_worker_h ucp_worker;                    /* Shared UCP worker */
-    ucp_listener_h ucp_listener;   /* Listener handle if listening */
-    struct na_ucx_addr *self_addr; /* Self address */
-    struct hg_mem_pool *mem_pool;  /* Msg buf pool */
-    size_t ucp_request_size;       /* Size of UCP requests */
-    char *protocol_name;           /* Protocol used */
-    size_t unexpected_size_max;    /* Max unexpected size */
-    size_t expected_size_max;      /* Max expected size */
-    hg_atomic_int32_t ncontexts;   /* Number of contexts */
-    bool no_wait;                  /* Wait disabled */
+    ucp_listener_h ucp_listener;                /* Listener handle if listening */
+    struct na_ucx_addr *self_addr;              /* Self address */
+    struct sockaddr_storage *origin_addr;       /* Origin address, port: 0 */
+    struct hg_mem_pool *mem_pool;               /* Msg buf pool */
+    size_t ucp_request_size;                    /* Size of UCP requests */
+    char *protocol_name;                        /* Protocol used */
+    size_t unexpected_size_max;                 /* Max unexpected size */
+    size_t expected_size_max;                   /* Max expected size */
+    hg_atomic_int32_t ncontexts;                /* Number of contexts */
+    bool no_wait;                               /* Wait disabled */
 };
 
 /* Datatype used for printing info */
@@ -272,6 +274,12 @@ static char *
 na_ucp_tostr(void *data, enum na_ucp_type datatype);
 #endif
 
+/**
+ * Convert UCX status to NA return values.
+ */
+static na_return_t
+na_ucx_status_to_na(ucs_status_t status);
+
 /**
  * Init config.
  */
@@ -358,7 +366,9 @@ na_ucp_accept(ucp_worker_h worker, ucp_conn_request_h conn_request,
  */
 static na_return_t
 na_ucp_connect(ucp_worker_h worker, const struct sockaddr *addr,
-    socklen_t addrlen, ucp_err_handler_cb_t err_handler_cb,
+    socklen_t addrlen,
+    const struct sockaddr_storage* local_addr,
+    ucp_err_handler_cb_t err_handler_cb,
     void *err_handler_arg, ucp_ep_h *ep_p);
 
 /**
@@ -500,12 +510,19 @@ na_ucx_class_alloc(void);
 static void
 na_ucx_class_free(struct na_ucx_class *na_ucx_class);
 
+/**
+ * Set origin address in na_ucx_class.
+ */
+static struct sockaddr_storage *
+na_ucx_set_origin_addr(const char *hostaddr);
+
 /**
  * Parse hostname info.
  */
 static na_return_t
 na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
-    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p);
+    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p,
+    struct sockaddr_storage **origin_addr_p);
 
 /**
  * Hash address key.
@@ -883,6 +900,32 @@ static const char *ucs_thread_mode_names[UCS_THREAD_MODE_LAST] = {
 #    undef X
 #endif
 
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ucx_status_to_na(ucs_status_t status)
+{
+    na_return_t ret;
+
+    switch (status) {
+        case UCS_ERR_UNREACHABLE:
+        case UCS_ERR_NOT_CONNECTED:
+            ret = NA_HOSTUNREACH;
+            break;
+        case UCS_ERR_TIMED_OUT:
+        case UCS_ERR_ENDPOINT_TIMEOUT:
+            ret = NA_TIMEOUT;
+            break;
+        case UCS_ERR_CANCELED:
+            ret = NA_CANCELED;
+            break;
+        default:
+            ret = NA_PROTOCOL_ERROR;
+            break;
+    }
+
+    return ret;
+}
+
 /*---------------------------------------------------------------------------*/
 #ifdef NA_HAS_DEBUG
 static char *
@@ -930,19 +973,23 @@ na_ucp_config_init(
 
     /* Read UCP configuration */
     status = ucp_config_read(NULL, NULL, &config);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_config_read() failed (%s)", ucs_status_string(status));
 
     /* Set user-requested transport */
     status = ucp_config_modify(config, "TLS", tls);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
+        "ucp_config_modify() failed (%s)", ucs_status_string(status));
+
+    status = ucp_config_modify(config, "UNIFIED_MODE", "n");
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_config_modify() failed (%s)", ucs_status_string(status));
 
     /* Set network devices to use */
     if (net_devices) {
         status = ucp_config_modify(config, "NET_DEVICES", net_devices);
         NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret,
-            NA_PROTOCOL_ERROR, "ucp_config_modify() failed (%s)",
+            na_ucx_status_to_na(status), "ucp_config_modify() failed (%s)",
             ucs_status_string(status));
     } else
         NA_LOG_SUBSYS_DEBUG(
@@ -998,7 +1045,7 @@ na_ucp_context_create(const ucp_config_t *config, bool no_wait,
 
     /* Create UCP context */
     status = ucp_init(&context_params, config, &context);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_init() failed (%s)", ucs_status_string(status));
 
     /* Print context info */
@@ -1007,22 +1054,22 @@ na_ucp_context_create(const ucp_config_t *config, bool no_wait,
 
     /* Query context to ensure we got what we asked for */
     status = ucp_context_query(context, &context_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_context_query() failed (%s)", ucs_status_string(status));
 
     /* Check that expected fields are present */
     NA_CHECK_SUBSYS_ERROR(cls,
         (context_attrs.field_mask & UCP_ATTR_FIELD_REQUEST_SIZE) == 0, error,
-        ret, NA_PROTOCOL_ERROR, "context attributes contain no request size");
+        ret, na_ucx_status_to_na(status), "context attributes contain no request size");
     NA_CHECK_SUBSYS_ERROR(cls,
         (context_attrs.field_mask & UCP_ATTR_FIELD_THREAD_MODE) == 0, error,
-        ret, NA_PROTOCOL_ERROR, "context attributes contain no thread mode");
+        ret, na_ucx_status_to_na(status), "context attributes contain no thread mode");
 
     /* Do not continue if thread mode is less than expected */
     NA_CHECK_SUBSYS_ERROR(cls,
         thread_mode != UCS_THREAD_MODE_SINGLE &&
             context_attrs.thread_mode < thread_mode,
-        error, ret, NA_PROTOCOL_ERROR, "Context thread mode is: %s",
+        error, ret, na_ucx_status_to_na(status), "Context thread mode is: %s",
         ucs_thread_mode_names[context_attrs.thread_mode]);
 
     NA_LOG_SUBSYS_DEBUG(
@@ -1061,7 +1108,7 @@ na_ucp_worker_create(ucp_context_h context, ucs_thread_mode_t thread_mode,
 
     /* Create UCP worker */
     status = ucp_worker_create(context, &worker_params, &worker);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_worker_create() failed (%s)", ucs_status_string(status));
 
     /* Print worker info */
@@ -1070,7 +1117,7 @@ na_ucp_worker_create(ucp_context_h context, ucs_thread_mode_t thread_mode,
 
     /* Query worker attributes */
     status = ucp_worker_query(worker, &worker_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_worker_query() failed (%s)", ucs_status_string(status));
 
     /* Check max AM header size */
@@ -1122,7 +1169,7 @@ na_ucp_worker_get_address(
     na_return_t ret = NA_SUCCESS;
 
     status = ucp_worker_get_address(worker, addr_p, addr_len_p);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, na_ucx_status_to_na(status),
         "ucp_worker_get_address() failed (%s)", ucs_status_string(status));
 
 done:
@@ -1147,7 +1194,7 @@ na_ucp_set_am_handler(
     param.arg = arg;
 
     status = ucp_worker_set_am_recv_handler(worker, &param);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, na_ucx_status_to_na(status),
         "ucp_worker_set_am_recv_handler() failed (%s)",
         ucs_status_string(status));
 
@@ -1175,12 +1222,12 @@ na_ucp_listener_create(ucp_worker_h worker, const struct sockaddr *addr,
 
     /* Create listener on worker */
     status = ucp_listener_create(worker, &listener_params, &listener);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_listener_create() failed (%s)", ucs_status_string(status));
 
     /* Check sockaddr */
     status = ucp_listener_query(listener, &listener_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_listener_query() failed (%s)", ucs_status_string(status));
 
     NA_CHECK_SUBSYS_ERROR(cls,
@@ -1264,15 +1311,22 @@ na_ucp_accept(ucp_worker_h worker, ucp_conn_request_h conn_request,
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucp_connect(ucp_worker_h worker, const struct sockaddr *addr,
-    socklen_t addrlen, ucp_err_handler_cb_t err_handler_cb,
+    socklen_t addrlen,
+    const struct sockaddr_storage* local_addr,
+    ucp_err_handler_cb_t err_handler_cb,
     void *err_handler_arg, ucp_ep_h *ep_p)
 {
     ucp_ep_params_t ep_params = {
-        .field_mask = UCP_EP_PARAM_FIELD_FLAGS | UCP_EP_PARAM_FIELD_SOCK_ADDR,
         .flags = UCP_EP_PARAMS_FLAGS_CLIENT_SERVER,
+        .field_mask = UCP_EP_PARAM_FIELD_FLAGS | UCP_EP_PARAM_FIELD_SOCK_ADDR,
         .sockaddr = (ucs_sock_addr_t){.addr = addr, .addrlen = addrlen},
         .conn_request = NULL};
 
+    if (local_addr) {
+    	ep_params.field_mask |= UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR;
+        ep_params.local_sockaddr.addr = (const struct sockaddr*) local_addr;
+        ep_params.local_sockaddr.addrlen = sizeof(*local_addr);
+    }
     return na_ucp_ep_create(
         worker, &ep_params, err_handler_cb, err_handler_arg, ep_p);
 }
@@ -1339,7 +1393,7 @@ na_ucp_mem_free(ucp_context_h context, ucp_mem_h mem)
     na_return_t ret;
 
     status = ucp_mem_unmap(context, mem);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_mem_unmap() failed (%s)", ucs_status_string(status));
 
     return NA_SUCCESS;
@@ -1419,7 +1473,7 @@ na_ucp_ep_create(ucp_worker_h worker, ucp_ep_params_t *ep_params,
     ep_params->err_handler.arg = err_handler_arg;
 
     status = ucp_ep_create(worker, ep_params, &ep);
-    NA_CHECK_SUBSYS_ERROR(addr, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(addr, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_ep_create() failed (%s)", ucs_status_string(status));
 
     *ep_p = ep;
@@ -1471,7 +1525,7 @@ na_ucp_am_send(ucp_ep_h ep, const void *buf, size_t buf_size,
         na_ucp_am_send_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_am_send_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_am_send_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(msg, "ucp_am_send_nbx() was posted");
@@ -1496,7 +1550,7 @@ na_ucp_am_send_cb(void *request, ucs_status_t status, void NA_UNUSED *user_data)
     if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, NA_PROTOCOL_ERROR,
+        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucx_status_to_na(status),
             "ucp_am_send_nbx() failed (%s)", ucs_status_string(status));
 
 done:
@@ -1660,7 +1714,7 @@ na_ucp_msg_send(
         na_ucp_msg_send_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_tag_send_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_tag_send_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(msg, "ucp_tag_send_nbx() was posted");
@@ -1686,7 +1740,7 @@ na_ucp_msg_send_cb(
     if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, NA_PROTOCOL_ERROR,
+        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucx_status_to_na(status),
             "ucp_tag_send_nbx() failed (%s)", ucs_status_string(status));
 
 done:
@@ -1721,7 +1775,7 @@ na_ucp_msg_recv(ucp_worker_h worker, void *buf, size_t buf_size, ucp_tag_t tag,
         na_ucp_msg_recv_cb(request, UCS_OK, &tag_recv_info, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_tag_recv_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_tag_recv_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(msg, "ucp_tag_recv_nbx() was posted");
@@ -1752,7 +1806,7 @@ na_ucp_msg_recv_cb(void *request, ucs_status_t status,
     else if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, NA_PROTOCOL_ERROR,
+        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, na_ucx_status_to_na(status),
             "ucp_tag_recv_nbx() failed (%s)", ucs_status_string(status));
 
     NA_CHECK_SUBSYS_ERROR(msg,
@@ -1796,7 +1850,7 @@ na_ucp_put(ucp_ep_h ep, void *buf, size_t buf_size, uint64_t remote_addr,
         na_ucp_rma_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(rma, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_put_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_put_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(rma, "ucp_put_nbx() was posted");
@@ -1828,7 +1882,7 @@ na_ucp_get(ucp_ep_h ep, void *buf, size_t buf_size, uint64_t remote_addr,
         na_ucp_rma_cb(request, UCS_OK, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(rma, UCS_PTR_IS_ERR(status_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_get_nbx() failed (%s)",
+            na_ucx_status_to_na(UCS_PTR_STATUS(status_ptr)), "ucp_get_nbx() failed (%s)",
             ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 
     NA_LOG_SUBSYS_DEBUG(rma, "ucp_get_nbx() was posted");
@@ -1854,7 +1908,7 @@ na_ucp_rma_cb(void *request, ucs_status_t status, void NA_UNUSED *user_data)
     if (status == UCS_ERR_CANCELED)
         NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
     else
-        NA_GOTO_SUBSYS_ERROR(rma, done, cb_ret, NA_PROTOCOL_ERROR,
+        NA_GOTO_SUBSYS_ERROR(rma, done, cb_ret, na_ucx_status_to_na(status),
             "na_ucp_rma_cb() failed (%s)", ucs_status_string(status));
 
 done:
@@ -1943,18 +1997,34 @@ na_ucx_class_free(struct na_ucx_class *na_ucx_class)
     (void) hg_thread_spin_destroy(&na_ucx_class->unexpected_msg_queue.lock);
     (void) hg_thread_spin_destroy(&na_ucx_class->addr_pool.lock);
 
+    free(na_ucx_class->origin_addr);
     free(na_ucx_class->protocol_name);
     free(na_ucx_class);
 }
 
+/*---------------------------------------------------------------------------*/
+static struct sockaddr_storage *
+na_ucx_set_origin_addr(const char *hostaddr)
+{
+    struct sockaddr_storage *ss_addr = calloc(1, sizeof(*ss_addr));
+    struct sockaddr_in *sa = (struct sockaddr_in *) ss_addr;
+
+    sa->sin_family = AF_INET;
+    sa->sin_addr.s_addr = inet_addr(hostaddr);
+    sa->sin_port = 0;
+    return ss_addr;
+}
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
-    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p)
+    char **net_device_p, struct sockaddr **sockaddr_p, socklen_t *addrlen_p,
+    struct sockaddr_storage **origin_addr_p)
 {
     char **ifa_name_p = NULL;
     char *hostname = NULL;
     uint16_t port = 0;
+    bool multi_dev = false;
     na_return_t ret = NA_SUCCESS;
 
     /* Set hostname (use default interface name if no hostname was passed) */
@@ -1976,6 +2046,8 @@ na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
                 *net_device_p = strdup(hostname);
                 NA_CHECK_SUBSYS_ERROR(cls, *net_device_p == NULL, done, ret,
                     NA_NOMEM, "strdup() of net_device failed");
+                if (strstr(*net_device_p, ","))
+                    multi_dev = true;
             }
             if (strcmp(host_str, "") == 0)
                 hostname = NULL;
@@ -1999,6 +2071,8 @@ na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
     /* TODO add support for IPv6 wildcards */
 
     if (hostname && strcmp(hostname, "0.0.0.0") != 0) {
+	if (!multi_dev && *net_device_p != NULL)
+                *origin_addr_p = na_ucx_set_origin_addr(hostname);
         /* Try to get matching IP/device */
         ret = na_ip_check_interface(
             hostname, port, AF_UNSPEC, ifa_name_p, sockaddr_p, addrlen_p);
@@ -2102,6 +2176,7 @@ na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
         /* Create new endpoint */
         ret = na_ucp_connect(na_ucx_class->ucp_worker,
             na_ucx_addr->addr_key.addr, na_ucx_addr->addr_key.addrlen,
+            na_ucx_class->origin_addr,
             na_ucp_ep_error_cb, (void *) na_ucx_addr, &na_ucx_addr->ucp_ep);
         NA_CHECK_SUBSYS_NA_ERROR(
             addr, error, ret, "Could not connect UCP endpoint");
@@ -2429,7 +2504,7 @@ na_ucx_rma_key_resolve(ucp_ep_h ep, struct na_ucx_mem_handle *na_ucx_mem_handle,
             ucs_status_t status = ucp_ep_rkey_unpack(ep,
                 na_ucx_mem_handle->rkey_buf, &na_ucx_mem_handle->ucp_mr.rkey);
             NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret,
-                NA_PROTOCOL_ERROR, "ucp_ep_rkey_unpack() failed (%s)",
+                na_ucx_status_to_na(status), "ucp_ep_rkey_unpack() failed (%s)",
                 ucs_status_string(status));
             /* Handle is now unpacked */
             hg_atomic_set32(
@@ -2533,6 +2608,7 @@ na_ucx_initialize(
     char *net_device = NULL;
     struct sockaddr *listen_sockaddr = NULL;
     socklen_t listen_addrlen = 0;
+    struct sockaddr_storage *origin_sockaddr = NULL;
     struct sockaddr_storage ucp_listener_ss_addr;
     ucs_sock_addr_t addr_key = {.addr = NULL, .addrlen = 0};
     ucp_config_t *config;
@@ -2572,7 +2648,7 @@ na_ucx_initialize(
 #ifdef NA_UCX_HAS_LIB_QUERY
     ucp_lib_attrs.field_mask = UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL;
     status = ucp_lib_query(&ucp_lib_attrs);
-    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_context_query: %s", ucs_status_string(status));
     NA_CHECK_SUBSYS_ERROR(cls,
         (ucp_lib_attrs.field_mask & UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL) == 0,
@@ -2590,11 +2666,13 @@ na_ucx_initialize(
 #endif
 
     /* Parse hostname info and get device / listener IP */
+    NA_LOG_SUBSYS_WARNING(addr, "The hostname is: %s", na_info->host_name);
     ret = na_ucx_parse_hostname_info(na_info->host_name,
         (na_info->na_init_info && na_info->na_init_info->ip_subnet)
             ? na_info->na_init_info->ip_subnet
             : NULL,
-        &net_device, (listen) ? &listen_sockaddr : NULL, &listen_addrlen);
+        &net_device, (listen) ? &listen_sockaddr : NULL, &listen_addrlen,
+        &origin_sockaddr);
     NA_CHECK_SUBSYS_NA_ERROR(
         cls, error, ret, "na_ucx_parse_hostname_info() failed");
 
@@ -2603,6 +2681,7 @@ na_ucx_initialize(
     NA_CHECK_SUBSYS_ERROR(cls, na_ucx_class == NULL, error, ret, NA_NOMEM,
         "Could not allocate NA UCX class");
 
+    na_ucx_class->origin_addr = origin_sockaddr;
     /* Keep a copy of the protocol name */
     na_ucx_class->protocol_name = (na_info->protocol_name)
                                       ? strdup(na_info->protocol_name)
@@ -2806,7 +2885,7 @@ na_ucx_addr_lookup(na_class_t *na_class, const char *name, na_addr_t *addr_p)
         strncmp(name, "all", strlen("all")) &&
             strncmp(name, na_ucx_class->protocol_name,
                 strlen(na_ucx_class->protocol_name)),
-        error, ret, NA_PROTOCOL_ERROR,
+        error, ret, NA_PROTONOSUPPORT,
         "Protocol not supported by this class (%s)",
         na_ucx_class->protocol_name);
 
@@ -3382,7 +3461,7 @@ na_ucx_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle,
     /* Register memory */
     status = ucp_mem_map(NA_UCX_CLASS(na_class)->ucp_context, &mem_map_params,
         &na_ucx_mem_handle->ucp_mr.mem);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_mem_map() failed (%s)", ucs_status_string(status));
 
     /* Keep a copy of the rkey to share with the remote */
@@ -3390,7 +3469,7 @@ na_ucx_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle,
     status = ucp_rkey_pack(NA_UCX_CLASS(na_class)->ucp_context,
         na_ucx_mem_handle->ucp_mr.mem, &na_ucx_mem_handle->rkey_buf,
         &rkey_buf_size);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_rkey_pack() failed (%s)", ucs_status_string(status));
     na_ucx_mem_handle->desc.rkey_buf_size = (uint64_t) rkey_buf_size;
 
@@ -3417,7 +3496,7 @@ na_ucx_mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
     /* Deregister memory */
     status = ucp_mem_unmap(
         NA_UCX_CLASS(na_class)->ucp_context, na_ucx_mem_handle->ucp_mr.mem);
-    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
+    NA_CHECK_SUBSYS_ERROR(mem, status != UCS_OK, error, ret, na_ucx_status_to_na(status),
         "ucp_mem_unmap() failed (%s)", ucs_status_string(status));
     na_ucx_mem_handle->ucp_mr.mem = NULL;
 
