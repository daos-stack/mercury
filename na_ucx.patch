diff --git a/src/na/na_ucx.c b/src/na/na_ucx.c
index 84eb8b0..8011056 100644
--- a/src/na/na_ucx.c
+++ b/src/na/na_ucx.c
@@ -441,6 +441,12 @@ na_ucp_ep_create(ucp_worker_h worker, ucp_ep_params_t *ep_params,
 static void
 na_ucp_ep_error_cb(void *arg, ucp_ep_h ep, ucs_status_t status);
 
+/**
+  * Flush endpoint.
+  */
+static ucs_status_ptr_t
+na_ucp_ep_flush(ucp_ep_h ep);
+
 /**
  * Close endpoint.
  */
@@ -614,7 +620,7 @@ na_ucx_addr_map_update(struct na_ucx_class *na_ucx_class,
  */
 static na_return_t
 na_ucx_addr_map_remove(
-    struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key);
+    struct na_ucx_map *na_ucx_map, struct na_ucx_addr *remove_addr);
 
 /**
  * Hash connection ID.
@@ -1436,6 +1442,7 @@ na_ucp_context_create(const ucp_config_t *config, bool no_wait,
     /* Skip wakeup feature if not waiting */
     if (no_wait != true)
         context_params.features |= UCP_FEATURE_WAKEUP;
+    //context_params |= UCP_PARAM_FIELD_REQUEST_INIT | UCP_PARAM_FIELD_REQUEST_CLEANUP;
 
     if (thread_mode == UCS_THREAD_MODE_MULTI) {
         /* If the UCP context can potentially be used by more than one
@@ -1688,8 +1695,12 @@ na_ucp_listener_conn_cb(ucp_conn_request_h conn_request, void *arg)
         .addr = (const struct sockaddr *) &conn_request_attrs.client_address,
         .addrlen = sizeof(conn_request_attrs.client_address)};
     na_ucx_addr = na_ucx_addr_map_lookup(&na_ucx_class->addr_map, &addr_key);
-    NA_CHECK_SUBSYS_ERROR_NORET(addr, na_ucx_addr != NULL, error,
-        "An entry is already present for this address");
+
+    if (na_ucx_addr != NULL) {
+        NA_LOG_SUBSYS_WARNING(addr,
+            "An entry is already present for this address");
+        na_ucx_addr_map_remove(&na_ucx_class->addr_map, na_ucx_addr);
+    }
 
     /* Insert new entry and create new address */
     na_ret = na_ucx_addr_map_insert(na_ucx_class, &na_ucx_class->addr_map,
@@ -1933,14 +1944,33 @@ na_ucp_ep_error_cb(
     na_ucx_addr_ref_decr(na_ucx_addr);
 }
 
+/*---------------------------------------------------------------------------*/
+static ucs_status_ptr_t
+na_ucp_ep_flush(ucp_ep_h ep)
+{
+    const ucp_request_param_t flush_params = {
+        .op_attr_mask = 0};
+    ucs_status_ptr_t status_ptr = ucp_ep_flush_nbx(ep, &flush_params);
+
+    NA_CHECK_SUBSYS_ERROR_DONE(addr,
+        status_ptr != NULL && UCS_PTR_IS_ERR(status_ptr),
+        "ucp_ep_flush_nb() failed (%s)",
+        ucs_status_string(UCS_PTR_STATUS(status_ptr)));
+    return status_ptr;
+}
+
 /*---------------------------------------------------------------------------*/
 static void
 na_ucp_ep_close(ucp_ep_h ep)
 {
-    ucs_status_ptr_t status_ptr = ucp_ep_close_nb(ep, UCP_EP_CLOSE_MODE_FORCE);
+    const ucp_request_param_t close_params = {
+        .op_attr_mask = UCP_OP_ATTR_FIELD_FLAGS,
+        .flags = UCP_EP_CLOSE_FLAG_FORCE};
+    ucs_status_ptr_t status_ptr = ucp_ep_close_nbx(ep, &close_params);
+
     NA_CHECK_SUBSYS_ERROR_DONE(addr,
         status_ptr != NULL && UCS_PTR_IS_ERR(status_ptr),
-        "ucp_ep_close_nb() failed (%s)",
+        "ucp_ep_close_nbx() failed (%s)",
         ucs_status_string(UCS_PTR_STATUS(status_ptr)));
 }
 
@@ -2722,7 +2752,7 @@ unlock:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucx_addr_map_remove(struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key)
+na_ucx_addr_map_remove(struct na_ucx_map *na_ucx_map, struct na_ucx_addr *remove_addr)
 {
     struct na_ucx_addr *na_ucx_addr = NULL;
     na_return_t ret = NA_SUCCESS;
@@ -2731,13 +2761,14 @@ na_ucx_addr_map_remove(struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key)
     hg_thread_rwlock_wrlock(&na_ucx_map->lock);
 
     na_ucx_addr = hg_hash_table_lookup(
-        na_ucx_map->key_map, (hg_hash_table_key_t) addr_key);
-    if (na_ucx_addr == HG_HASH_TABLE_NULL)
+        na_ucx_map->key_map, (hg_hash_table_key_t) &remove_addr->addr_key);
+
+    if (na_ucx_addr == HG_HASH_TABLE_NULL || na_ucx_addr->ucp_ep != remove_addr->ucp_ep)
         goto unlock;
 
     /* Remove addr key from primary map */
     rc = hg_hash_table_remove(
-        na_ucx_map->key_map, (hg_hash_table_key_t) addr_key);
+        na_ucx_map->key_map, (hg_hash_table_key_t) &na_ucx_addr->addr_key);
     NA_CHECK_SUBSYS_ERROR(addr, rc != 1, unlock, ret, NA_NOENTRY,
         "hg_hash_table_remove() failed");
 
@@ -2841,14 +2872,29 @@ na_ucx_addr_release(struct na_ucx_addr *na_ucx_addr)
         NA_UCX_PRINT_ADDR_KEY_INFO("Removing address", &na_ucx_addr->addr_key);
 
         na_ucx_addr_map_remove(
-            &na_ucx_addr->na_ucx_class->addr_map, &na_ucx_addr->addr_key);
+            &na_ucx_addr->na_ucx_class->addr_map, na_ucx_addr);
     }
 
     if (na_ucx_addr->ucp_ep != NULL) {
         /* NB. for deserialized addresses that are not "connected" addresses, do
          * not close the EP */
-        if (na_ucx_addr->worker_addr == NULL)
+        if (na_ucx_addr->worker_addr == NULL) {
+            if (!na_ucx_addr->na_ucx_class->ucp_listener) {
+                ucs_status_ptr_t status_ptr = na_ucp_ep_flush(na_ucx_addr->ucp_ep);
+
+                if (UCS_PTR_IS_PTR(status_ptr)) {
+                    ucs_status_t status;
+
+                    do {
+                        ucp_worker_progress(na_ucx_addr->na_ucx_class->ucp_worker);
+                        status = ucp_request_check_status(status_ptr);
+                    } while (status == UCS_INPROGRESS); 
+                    ucp_request_free(status_ptr);
+                }
+            }
+
             na_ucp_ep_close(na_ucx_addr->ucp_ep);
+        }
         na_ucx_addr->ucp_ep = NULL;
     }
 
@@ -3023,6 +3069,18 @@ na_ucx_rma(struct na_ucx_class NA_UNUSED *na_ucx_class, na_context_t *context,
 
     /* There is no need to have a fully resolved address to start an RMA.
      * This is only necessary for two-sided communication. */
+    /* The above assumption is now in question, so the following will resolve
+     * the address if required. */
+
+    /* Check addr to ensure the EP for that addr is still valid */
+    if (!(hg_atomic_get32(&na_ucx_addr->status) & NA_UCX_ADDR_RESOLVED)) {
+        ret = na_ucx_addr_map_update(
+            na_ucx_class, &na_ucx_class->addr_map, na_ucx_addr);
+        NA_CHECK_SUBSYS_NA_ERROR(
+            addr, error, ret, "Could not update NA UCX address");
+    }
+    NA_CHECK_SUBSYS_ERROR(msg, na_ucx_addr->ucp_ep == NULL, error, ret,
+        NA_ADDRNOTAVAIL, "UCP endpoint is NULL for that address");
 
     /* TODO UCX requires the remote key to be bound to the origin, do we need a
      * new API? */
@@ -3061,6 +3119,9 @@ na_ucx_rma_key_resolve(ucp_ep_h ep, struct na_ucx_mem_handle *na_ucx_mem_handle,
 
     hg_thread_mutex_lock(&na_ucx_mem_handle->rkey_unpack_lock);
 
+    NA_CHECK_SUBSYS_ERROR(
+        mem, ep == NULL, error, ret, NA_INVALID_ARG, "Invalid endpoint (%p)", ep);
+
     switch (hg_atomic_get32(&na_ucx_mem_handle->type)) {
         case NA_UCX_MEM_HANDLE_REMOTE_PACKED: {
             ucs_status_t status = ucp_ep_rkey_unpack(ep,
@@ -3246,7 +3307,7 @@ na_ucx_initialize(
         unexpected_size_max = na_init_info->max_unexpected_size;
     if (na_init_info->max_expected_size)
         expected_size_max = na_init_info->max_expected_size;
-    /* Thread mode */
+   /* Thread mode */
     if ((na_init_info->max_contexts > 1) &&
         !(na_init_info->thread_mode & NA_THREAD_MODE_SINGLE))
         context_thread_mode = UCS_THREAD_MODE_MULTI;
@@ -3311,10 +3372,10 @@ na_ucx_initialize(
     ret = na_ucp_config_init(na_info->protocol_name, net_device, &config);
     NA_CHECK_SUBSYS_NA_ERROR(
         cls, error, ret, "Could not initialize UCX config");
-
     /* Create UCP context and release config */
     ret = na_ucp_context_create(config, no_wait, context_thread_mode,
         &na_ucx_class->ucp_context, &na_ucx_class->ucp_request_size);
+
     na_ucp_config_release(config);
     NA_CHECK_SUBSYS_NA_ERROR(cls, error, ret, "Could not create UCX context");
 
@@ -4309,14 +4370,6 @@ na_ucx_cancel(
     if ((status & NA_UCX_OP_COMPLETED) || (status & NA_UCX_OP_ERRORED) ||
         (status & NA_UCX_OP_CANCELED) || (status & NA_UCX_OP_CANCELING))
         return NA_SUCCESS;
-
-    cb_type = na_ucx_op_id->completion_data.callback_info.type;
-    NA_LOG_SUBSYS_DEBUG(op, "Canceling operation ID %p (%s)",
-        (void *) na_ucx_op_id, na_cb_type_to_string(cb_type));
-
-    /* Must set canceling before we check for the retry queue */
-    hg_atomic_or32(&na_ucx_op_id->status, NA_UCX_OP_CANCELING);
-
     /* Check if op_id is in unexpected op queue */
     if ((cb_type == NA_CB_RECV_UNEXPECTED) &&
         (hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_QUEUED)) {
