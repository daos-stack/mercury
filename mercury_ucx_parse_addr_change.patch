diff --git a/src/na/na_ucx.c b/src/na/na_ucx.c
index df606f9..cc74da9 100644
--- a/src/na/na_ucx.c
+++ b/src/na/na_ucx.c
@@ -1958,45 +1958,51 @@ static na_return_t
 na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
     char **net_device_p, struct sockaddr_storage **sockaddr_p)
 {
-    char **ifa_name_p = NULL;
     char *hostname = NULL;
+    //char host[64];
+    char *device_delim = NULL;
     unsigned int port = 0;
     na_return_t ret = NA_SUCCESS;
 
     /* Set hostname (use default interface name if no hostname was passed) */
     if (hostname_info) {
-        hostname = strdup(hostname_info);
-        NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
-            "strdup() of hostname failed");
+    	device_delim = strstr(hostname_info, "/");
+	if (device_delim) {
+	    char *addr_str = NULL;
+            strtok_r(hostname_info, "/", &addr_str);
+            hostname = strdup(addr_str);
+       	    NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
+                          "strdup() of hostname failed");
+            /* put NULL in hostname_info string after device name */
+	    *(++device_delim) = '\0';
+	    *net_device_p = hostname_info;
+	} else {
+            hostname = strdup(hostname_info);
+       	    NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
+                          "strdup() of hostname failed");
+	}
 
         /* TODO add support for IPv6 address parsing */
 
-        /* Extract hostname : port */
+        /* Extract hostname / port */
         if (strstr(hostname, ":")) {
             char *port_str = NULL;
             strtok_r(hostname, ":", &port_str);
             port = (unsigned int) strtoul(port_str, NULL, 10);
         }
-
-        /* Extract net_device if explicitly listed with '/' before IP */
-        if (strstr(hostname, "/")) {
-            char *host_str = NULL;
-            strtok_r(hostname, "/", &host_str);
-
-            *net_device_p = hostname;
-            hostname = strdup(host_str);
-            NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
-                "strdup() of hostname failed");
-        } else
-            ifa_name_p = net_device_p;
     }
 
     /* TODO add support for IPv6 wildcards */
 
     if (hostname && strcmp(hostname, "0.0.0.0") != 0) {
-        /* Try to get matching IP/device */
-        ret = na_ip_check_interface(hostname, port, ifa_name_p, sockaddr_p);
-        NA_CHECK_SUBSYS_NA_ERROR(cls, done, ret, "Could not check interfaces");
+	struct sockaddr_storage *ss_addr = calloc(1, sizeof(*ss_addr));
+	struct sockaddr_in *sa = (struct sockaddr_in *) ss_addr;
+	sa->sin_family = AF_INET;
+	sa->sin_addr.s_addr = inet_addr(hostname);
+	sa->sin_port = htons(port & 0xffff);
+	if (sockaddr_p != NULL) 
+		*sockaddr_p = ss_addr;
+
     } else {
         char pref_anyip[NI_MAXHOST];
         uint32_t subnet = 0, netmask = 0;
@@ -2873,9 +2879,8 @@ na_ucx_initialize(
     NA_CHECK_SUBSYS_NA_ERROR(
         cls, error, ret, "Could not initialize UCX config");
 
-    /* No longer needed */
-    free(net_device);
-    net_device = NULL;
+    //free(net_device);
+    //net_device = NULL;
 
     /* Create UCP context and release config */
     ret = na_ucp_context_create(config, no_wait, context_thread_mode,
diff --git a/src/util/mercury_time.h b/src/util/mercury_time.h
index 8fb1e74..522ac57 100644
--- a/src/util/mercury_time.h
+++ b/src/util/mercury_time.h
@@ -353,9 +353,10 @@ static HG_UTIL_INLINE unsigned int
 hg_time_to_ms(hg_time_t tv)
 {
 #if defined(HG_UTIL_HAS_TIME_H) && defined(HG_UTIL_HAS_CLOCK_GETTIME)
-    return (unsigned int) (tv.tv_sec * 1000 + tv.tv_nsec / 1000000);
+    return (
+        unsigned int) (tv.tv_sec * 1000 + ((tv.tv_nsec + 999999) / 1000000));
 #else
-    return (unsigned int) (tv.tv_sec * 1000 + tv.tv_usec / 1000);
+    return (unsigned int) (tv.tv_sec * 1000 + ((tv.tv_usec + 999) / 1000));
 #endif
 }
 
