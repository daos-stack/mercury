diff --git a/src/na/na_ucx.c b/src/na/na_ucx.c
index df606f9..ac584e2 100644
--- a/src/na/na_ucx.c
+++ b/src/na/na_ucx.c
@@ -948,12 +948,13 @@ na_ucp_config_init(
             cls, "Could not find NET_DEVICE to use, using default");
 
     /* Print UCX config */
+    /*
     NA_LOG_SUBSYS_DEBUG_FUNC(cls,
         ucp_config_print(config, hg_log_get_stream_debug(),
             "NA UCX class configuration used",
             UCS_CONFIG_PRINT_CONFIG | UCS_CONFIG_PRINT_HEADER),
         "Now using the following UCX global configuration");
-
+    */
     *config_p = config;
 
     return NA_SUCCESS;
@@ -1006,10 +1007,11 @@ na_ucp_context_create(const ucp_config_t *config, na_bool_t no_wait,
         "ucp_init() failed (%s)", ucs_status_string(status));
 
     /* Print context info */
+    /*
     NA_LOG_SUBSYS_DEBUG_FUNC(cls,
         ucp_context_print_info(context, hg_log_get_stream_debug()),
         "Context info");
-
+    */
     /* Query context to ensure we got what we asked for */
     status = ucp_context_query(context, &context_attrs);
     NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
@@ -1069,10 +1071,11 @@ na_ucp_worker_create(ucp_context_h context, ucs_thread_mode_t thread_mode,
         "ucp_worker_create() failed (%s)", ucs_status_string(status));
 
     /* Print worker info */
+    /*
     NA_LOG_SUBSYS_DEBUG_FUNC(ctx,
         ucp_worker_print_info(worker, hg_log_get_stream_debug()),
         "Worker info");
-
+    */
     /* Check thread mode */
     status = ucp_worker_query(worker, &worker_attrs);
     NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
@@ -1958,45 +1961,50 @@ static na_return_t
 na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
     char **net_device_p, struct sockaddr_storage **sockaddr_p)
 {
-    char **ifa_name_p = NULL;
     char *hostname = NULL;
+    //char host[64];
+    char *device_delim = NULL;
     unsigned int port = 0;
     na_return_t ret = NA_SUCCESS;
-
     /* Set hostname (use default interface name if no hostname was passed) */
     if (hostname_info) {
-        hostname = strdup(hostname_info);
-        NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
-            "strdup() of hostname failed");
+        device_delim = strstr(hostname_info, "/");
+	if (device_delim) {
+	    char *addr_str = NULL;
+            strtok_r(hostname_info, "/", &addr_str);
+            hostname = strdup(addr_str);
+            NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
+                          "strdup() of hostname failed");
+            /* put NULL in hostname_info string after device name */
+	    *(++device_delim) = '\0';
+	    *net_device_p = hostname_info;
+	} else {
+            hostname = strdup(hostname_info);
+            NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
+                          "strdup() of hostname failed");
+	}
 
         /* TODO add support for IPv6 address parsing */
 
-        /* Extract hostname : port */
+        /* Extract hostname / port */
         if (strstr(hostname, ":")) {
             char *port_str = NULL;
             strtok_r(hostname, ":", &port_str);
             port = (unsigned int) strtoul(port_str, NULL, 10);
         }
-
-        /* Extract net_device if explicitly listed with '/' before IP */
-        if (strstr(hostname, "/")) {
-            char *host_str = NULL;
-            strtok_r(hostname, "/", &host_str);
-
-            *net_device_p = hostname;
-            hostname = strdup(host_str);
-            NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
-                "strdup() of hostname failed");
-        } else
-            ifa_name_p = net_device_p;
     }
 
     /* TODO add support for IPv6 wildcards */
 
     if (hostname && strcmp(hostname, "0.0.0.0") != 0) {
-        /* Try to get matching IP/device */
-        ret = na_ip_check_interface(hostname, port, ifa_name_p, sockaddr_p);
-        NA_CHECK_SUBSYS_NA_ERROR(cls, done, ret, "Could not check interfaces");
+	struct sockaddr_storage *ss_addr = calloc(1, sizeof(*ss_addr));
+	struct sockaddr_in *sa = (struct sockaddr_in *) ss_addr;
+	sa->sin_family = AF_INET;
+	sa->sin_addr.s_addr = inet_addr(hostname);
+	sa->sin_port = htons(port & 0xffff);
+        if (sockaddr_p != NULL) {
+		*sockaddr_p = ss_addr;
+        }
     } else {
         char pref_anyip[NI_MAXHOST];
         uint32_t subnet = 0, netmask = 0;
@@ -2873,9 +2881,8 @@ na_ucx_initialize(
     NA_CHECK_SUBSYS_NA_ERROR(
         cls, error, ret, "Could not initialize UCX config");
 
-    /* No longer needed */
-    free(net_device);
-    net_device = NULL;
+    //free(net_device);
+    //net_device = NULL;
 
     /* Create UCP context and release config */
     ret = na_ucp_context_create(config, no_wait, context_thread_mode,
