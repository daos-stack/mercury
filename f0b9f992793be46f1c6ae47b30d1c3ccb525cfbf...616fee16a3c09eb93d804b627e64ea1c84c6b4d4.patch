diff --git a/Testing/script/travis_build.sh b/Testing/script/travis_build.sh
index 32cc97f..69001c8 100755
--- a/Testing/script/travis_build.sh
+++ b/Testing/script/travis_build.sh
@@ -2,10 +2,10 @@
 
 BMI_VERSION=master
 CMAKE_VERSION_MAJOR=3.15
-CMAKE_VERSION_MINOR=1
+CMAKE_VERSION_MINOR=3
 MPI_VERSION=3.3.1
 CCI_VERSION=2.1
-OFI_VERSION=1.8.0
+OFI_VERSION=1.8.1
 PREFIX=$HOME/install
 
 set -e
diff --git a/src/mercury.c b/src/mercury.c
index af27515..fcbf946 100644
--- a/src/mercury.c
+++ b/src/mercury.c
@@ -13,6 +13,7 @@
 #include "mercury_proc.h"
 #include "mercury_proc_bulk.h"
 
+//TESTPATCH
 #include "mercury_hash_string.h"
 #include "mercury_mem.h"
 #include "mercury_thread_spin.h"
@@ -2040,6 +2041,64 @@ done:
 
 /*---------------------------------------------------------------------------*/
 hg_return_t
+HG_Get_input_extra_buf(hg_handle_t handle, void **in_buf,
+    hg_size_t *in_buf_size)
+{
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
+    hg_return_t ret = HG_SUCCESS;
+
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!in_buf) {
+        HG_LOG_ERROR("NULL pointer");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    /* No offset if extra buffer since only the user payload is copied */
+    *in_buf = private_handle->in_extra_buf;
+    if (in_buf_size)
+        *in_buf_size = private_handle->in_extra_buf_size;
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
+HG_Get_output_extra_buf(hg_handle_t handle, void **out_buf,
+    hg_size_t *out_buf_size)
+{
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
+    hg_return_t ret = HG_SUCCESS;
+
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!out_buf) {
+        HG_LOG_ERROR("NULL pointer");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    /* No offset if extra buffer since only the user payload is copied */
+    *out_buf = private_handle->out_extra_buf;
+    if (out_buf_size)
+        *out_buf_size = private_handle->out_extra_buf_size;
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
 HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
 {
     struct hg_private_handle *private_handle =
diff --git a/src/mercury.h b/src/mercury.h
index a052735..de4705a 100644
--- a/src/mercury.h
+++ b/src/mercury.h
@@ -900,6 +900,50 @@ HG_Get_output_buf(
         );
 
 /**
+ * Get raw extra input buffer from handle that can be used for encoding and
+ * decoding parameters. This buffer is only valid if the input payload is large
+ * enough that it cannot fit into an eager buffer.
+ *
+ * \remark NULL pointer will be returned if there is no associated buffer.
+ *
+ * \remark in_buf_size argument will be ignored if NULL.
+ *
+ * \param handle [IN]           HG handle
+ * \param in_buf [OUT]          pointer to input buffer
+ * \param in_buf_size [OUT]     pointer to input buffer size
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_EXPORT hg_return_t
+HG_Get_input_extra_buf(
+        hg_handle_t handle,
+        void **in_buf,
+        hg_size_t *in_buf_size
+        );
+
+/**
+ * Get raw extra output buffer from handle that can be used for encoding and
+ * decoding parameters. This buffer is only valid if the output payload is large
+ * enough that it cannot fit into an eager buffer.
+ *
+ * \remark NULL pointer will be returned if there is no associated buffer.
+ *
+ * \remark out_buf_size argument will be ignored if NULL.
+ *
+ * \param handle [IN]           HG handle
+ * \param out_buf [OUT]         pointer to output buffer
+ * \param out_buf_size [OUT]    pointer to output buffer size
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_EXPORT hg_return_t
+HG_Get_output_extra_buf(
+        hg_handle_t handle,
+        void **out_buf,
+        hg_size_t *out_buf_size
+        );
+
+/**
  * Set target context ID that will receive and process the RPC request
  * (ID is defined on target context creation, see HG_Context_create_id()).
  *
diff --git a/src/na/na_sm.c b/src/na/na_sm.c
index 58e2a19..3343891 100644
--- a/src/na/na_sm.c
+++ b/src/na/na_sm.c
@@ -26,6 +26,7 @@
 #ifdef _WIN32
 #include <process.h>
 #else
+#include <pwd.h>
 #include <ftw.h>
 #include <unistd.h>
 #include <sys/types.h>
@@ -77,35 +78,34 @@
 #define NA_SM_MSGHDR_INITIALIZER {NULL, 0, NULL, 0, NULL, 0, 0}
 
 /* Default filenames/paths */
-#define NA_SM_SOCK_PATH NA_SM_TMP_DIRECTORY "/" NA_SM_SHM_PREFIX
 #define NA_SM_SHM_PATH "/dev/shm"
 
-#define NA_SM_GEN_SHM_NAME(filename, na_sm_addr)        \
-    do {                                                \
-        sprintf(filename, "%s-%d-%u", NA_SM_SHM_PREFIX, \
-            na_sm_addr->pid, na_sm_addr->id);           \
+#define NA_SM_GEN_SHM_NAME(filename, username, na_sm_addr)      \
+    do {                                                        \
+        sprintf(filename, "%s_%s-%d-%u", NA_SM_SHM_PREFIX,      \
+            username, na_sm_addr->pid, na_sm_addr->id);         \
     } while (0)
 
-#define NA_SM_GEN_SOCK_PATH(pathname, na_sm_addr)               \
-    do {                                                        \
-        sprintf(pathname, "%s/%s/%d/%u", NA_SM_TMP_DIRECTORY,   \
-            NA_SM_SHM_PREFIX, na_sm_addr->pid, na_sm_addr->id); \
+#define NA_SM_GEN_SOCK_PATH(pathname, username, na_sm_addr)                 \
+    do {                                                                    \
+        sprintf(pathname, "%s/%s_%s/%d/%u", NA_SM_TMP_DIRECTORY,            \
+            NA_SM_SHM_PREFIX, username, na_sm_addr->pid, na_sm_addr->id);   \
     } while (0)
 
 #define NA_SM_SEND_NAME "s" /* used for pair_name */
 #define NA_SM_RECV_NAME "r" /* used for pair_name */
-#define NA_SM_GEN_RING_NAME(filename, pair_name, na_sm_addr)            \
-    do {                                                                \
-        sprintf(filename, "%s-%d-%u-%u-" pair_name, NA_SM_SHM_PREFIX,   \
-            na_sm_addr->pid, na_sm_addr->id, na_sm_addr->conn_id);      \
+#define NA_SM_GEN_RING_NAME(filename, pair_name, username, na_sm_addr)      \
+    do {                                                                    \
+        sprintf(filename, "%s_%s-%d-%u-%u-" pair_name, NA_SM_SHM_PREFIX,    \
+            username, na_sm_addr->pid, na_sm_addr->id, na_sm_addr->conn_id);\
     } while (0)
 
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
-#define NA_SM_GEN_FIFO_NAME(filename, pair_name, na_sm_addr)            \
+#define NA_SM_GEN_FIFO_NAME(filename, pair_name, username, na_sm_addr)  \
     do {                                                                \
-        sprintf(filename, "%s/%s/%d/%u/fifo-%u-" pair_name,             \
-            NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX, na_sm_addr->pid,     \
-            na_sm_addr->id, na_sm_addr->conn_id);                       \
+        sprintf(filename, "%s/%s_%s/%d/%u/fifo-%u-" pair_name,          \
+            NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX, username,            \
+            na_sm_addr->pid, na_sm_addr->id, na_sm_addr->conn_id);      \
     } while (0)
 #endif
 
@@ -252,6 +252,7 @@ struct na_sm_op_id {
 
 /* Private data */
 struct na_sm_class {
+    char *username;
     struct na_sm_addr *self_addr;
     hg_poll_set_t *poll_set;
     HG_QUEUE_HEAD(na_sm_addr) accepted_addr_queue;
@@ -276,6 +277,13 @@ struct na_sm_class {
 /********************/
 
 /**
+ * utility function: wrapper around getlogin().
+ */
+static char *
+getlogin_safe(void);
+
+
+/**
  * Open shared buf.
  */
 static void *
@@ -964,6 +972,21 @@ na_sm_print_addr(struct na_sm_addr *na_sm_addr)
 }
 */
 
+/* Wrapper to get login information and return a dummy string if the glibc call
+ * fails for some reason.  Allows graceful handling of directory name
+ * generation.
+ */
+static char *
+getlogin_safe(void)
+{
+    struct passwd *passwd;
+
+    /* statically allocated */
+    passwd = getpwuid(getuid());
+
+    return passwd ? passwd->pw_name : "unknown";
+}
+
 /*---------------------------------------------------------------------------*/
 static void *
 na_sm_open_shared_buf(const char *name, size_t buf_size, na_bool_t create)
@@ -1141,12 +1164,16 @@ static int
 na_sm_cleanup_shm(const char *fpath, const struct stat NA_UNUSED *sb,
     int NA_UNUSED typeflag, struct FTW NA_UNUSED *ftwbuf)
 {
-    const char *prefix = NA_SM_SHM_PATH "/" NA_SM_SHM_PREFIX;
+    const char *prefix = NA_SM_SHM_PATH "/" NA_SM_SHM_PREFIX "_";
     int ret = 0;
 
     if (strncmp(fpath, prefix, strlen(prefix)) == 0) {
         const char *file = fpath + strlen(NA_SM_SHM_PATH "/");
-        ret = hg_mem_shm_unmap(file, NULL, 0);
+        char *username = getlogin_safe();
+
+        if (strncmp(file + strlen(NA_SM_SHM_PREFIX "_"),
+            username, strlen(username)) == 0)
+            ret = hg_mem_shm_unmap(file, NULL, 0);
     }
 
     return ret;
@@ -1354,7 +1381,7 @@ na_sm_setup_shm(na_class_t *na_class, struct na_sm_addr *na_sm_addr)
     na_return_t ret = NA_SUCCESS;
 
     /* Create SHM buffer */
-    NA_SM_GEN_SHM_NAME(filename, na_sm_addr);
+    NA_SM_GEN_SHM_NAME(filename, NA_SM_CLASS(na_class)->username, na_sm_addr);
     na_sm_copy_buf = (struct na_sm_copy_buf *) na_sm_open_shared_buf(
         filename, sizeof(struct na_sm_copy_buf), NA_TRUE);
     if (!na_sm_copy_buf) {
@@ -1367,7 +1394,7 @@ na_sm_setup_shm(na_class_t *na_class, struct na_sm_addr *na_sm_addr)
     na_sm_addr->na_sm_copy_buf = na_sm_copy_buf;
 
     /* Create SHM sock */
-    NA_SM_GEN_SOCK_PATH(pathname, na_sm_addr);
+    NA_SM_GEN_SOCK_PATH(pathname, NA_SM_CLASS(na_class)->username, na_sm_addr);
     ret = na_sm_create_sock(pathname, NA_TRUE, &listen_sock);
     if (ret != NA_SUCCESS) {
         NA_LOG_ERROR("Could not create sock");
@@ -1930,7 +1957,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     /* Set up ring buffer pair (send/recv) for connection IDs */
     na_sm_addr->conn_id = NA_SM_CLASS(na_class)->self_addr->conn_id;
     NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(filename,
         NA_SM_RING_BUF_SIZE, NA_TRUE);
     if (!na_sm_ring_buf) {
@@ -1943,7 +1970,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     na_sm_addr->na_sm_send_ring_buf = na_sm_ring_buf;
 
     NA_SM_GEN_RING_NAME(filename, NA_SM_RECV_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(filename,
         NA_SM_RING_BUF_SIZE, NA_TRUE);
     if (!na_sm_ring_buf) {
@@ -1970,7 +1997,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
      * ancillary data
      */
     NA_SM_GEN_FIFO_NAME(filename, NA_SM_RECV_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     local_notify = na_sm_event_create(filename);
     if (local_notify == -1) {
         NA_LOG_ERROR("na_sm_event_create() failed");
@@ -1995,7 +2022,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
      * ancillary data
      */
     NA_SM_GEN_FIFO_NAME(filename, NA_SM_SEND_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     remote_notify = na_sm_event_create(filename);
     if (remote_notify == -1) {
         NA_LOG_ERROR("na_sm_event_create() failed");
@@ -2114,7 +2141,8 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
             /* Open remote ring buf pair (send and recv names correspond to
              * remote ring buffer pair) */
-            NA_SM_GEN_RING_NAME(filename, NA_SM_RECV_NAME, poll_addr);
+            NA_SM_GEN_RING_NAME(filename, NA_SM_RECV_NAME,
+                NA_SM_CLASS(na_class)->username, poll_addr);
             na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(
                 filename, NA_SM_RING_BUF_SIZE, NA_FALSE);
             if (!na_sm_ring_buf) {
@@ -2124,7 +2152,8 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
             }
             poll_addr->na_sm_send_ring_buf = na_sm_ring_buf;
 
-            NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME, poll_addr);
+            NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME,
+                NA_SM_CLASS(na_class)->username, poll_addr);
             na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(
                 filename, NA_SM_RING_BUF_SIZE, NA_FALSE);
             if (!na_sm_ring_buf) {
@@ -2454,6 +2483,7 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     static hg_atomic_int32_t id = HG_ATOMIC_VAR_INIT(0);
     struct na_sm_addr *na_sm_addr = NULL;
     pid_t pid;
+    char *username = NULL;
     hg_poll_set_t *poll_set;
     na_bool_t no_wait = NA_FALSE;
     int local_notify;
@@ -2471,6 +2501,14 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     /* Get PID */
     pid = getpid();
 
+    /* Get username */
+    username = getlogin_safe();
+    if (!username) {
+        NA_LOG_ERROR("Could not query login name");
+        ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
+
     /* Initialize errno */
     errno = 0;
 
@@ -2484,6 +2522,14 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     memset(na_class->plugin_class, 0, sizeof(struct na_sm_class));
     NA_SM_CLASS(na_class)->no_wait = no_wait;
 
+    /* Copy username */
+    NA_SM_CLASS(na_class)->username = strdup(username);
+    if (!NA_SM_CLASS(na_class)->username) {
+        NA_LOG_ERROR("Could not dup username");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
+
     /* Create poll set to wait for events */
     poll_set = hg_poll_create();
     if (!poll_set) {
@@ -2623,6 +2669,7 @@ na_sm_finalize(na_class_t *na_class)
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->copy_buf_lock);
 
+    free(NA_SM_CLASS(na_class)->username);
     free(na_class->plugin_class);
 
 done:
@@ -2633,11 +2680,16 @@ done:
 static void
 na_sm_cleanup(void)
 {
+    char pathname[NA_SM_MAX_FILENAME] = {'\0'};
+    char *username = getlogin_safe();
     int ret;
 
+    sprintf(pathname, "%s/%s_%s", NA_SM_TMP_DIRECTORY,
+        NA_SM_SHM_PREFIX, username);
+
     /* We need to remove all files first before being able to remove the
      * directories */
-    ret = nftw(NA_SM_SOCK_PATH, na_sm_cleanup_file, NA_SM_CLEANUP_NFDS,
+    ret = nftw(pathname, na_sm_cleanup_file, NA_SM_CLEANUP_NFDS,
         FTW_PHYS | FTW_DEPTH);
     if (ret != 0 && errno != ENOENT) {
         NA_LOG_WARNING("nftw() failed (%s)", strerror(errno));
@@ -2757,7 +2809,7 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
     sscanf(short_name, "%d/%u", &na_sm_addr->pid, &na_sm_addr->id);
 
     /* Open shared copy buf */
-    NA_SM_GEN_SHM_NAME(filename, na_sm_addr);
+    NA_SM_GEN_SHM_NAME(filename, NA_SM_CLASS(na_class)->username, na_sm_addr);
     na_sm_copy_buf = (struct na_sm_copy_buf *) na_sm_open_shared_buf(
         filename, sizeof(struct na_sm_copy_buf), NA_FALSE);
     if (!na_sm_copy_buf) {
@@ -2768,7 +2820,7 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_sm_addr->na_sm_copy_buf = na_sm_copy_buf;
 
     /* Open SHM sock */
-    NA_SM_GEN_SOCK_PATH(pathname, na_sm_addr);
+    NA_SM_GEN_SOCK_PATH(pathname, NA_SM_CLASS(na_class)->username, na_sm_addr);
     ret = na_sm_create_sock(pathname, NA_FALSE, &conn_sock);
     if (ret != NA_SUCCESS) {
         NA_LOG_ERROR("Could not create sock");
@@ -2881,25 +2933,29 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 
         if (na_sm_addr->accepted) { /* Created by accept */
             /* Get file names from ring bufs / events to delete files */
-            sprintf(na_sm_send_ring_buf_name, "%s-%d-%d-%d-%s",
-                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->self_addr->pid,
+            sprintf(na_sm_send_ring_buf_name, "%s_%s-%d-%d-%d-" NA_SM_SEND_NAME,
+                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->username,
+                NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
-                na_sm_addr->conn_id, NA_SM_SEND_NAME);
-            sprintf(na_sm_recv_ring_buf_name, "%s-%d-%d-%d-%s",
-                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->self_addr->pid,
+                na_sm_addr->conn_id);
+            sprintf(na_sm_recv_ring_buf_name, "%s_%s-%d-%d-%d-" NA_SM_RECV_NAME,
+                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->username,
+                NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
-                na_sm_addr->conn_id, NA_SM_RECV_NAME);
+                na_sm_addr->conn_id);
             send_ring_buf_name = na_sm_send_ring_buf_name;
             recv_ring_buf_name = na_sm_recv_ring_buf_name;
 
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
-            sprintf(na_sm_local_event_name, "%s/%s/%d/%u/fifo-%u-%s",
+            sprintf(na_sm_local_event_name, "%s/%s_%s/%d/%u/fifo-%u-%s",
                 NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX,
+                NA_SM_CLASS(na_class)->username,
                 NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
                 na_sm_addr->conn_id, NA_SM_RECV_NAME);
-            sprintf(na_sm_remote_event_name, "%s/%s/%d/%u/fifo-%u-%s",
+            sprintf(na_sm_remote_event_name, "%s/%s_%s/%d/%u/fifo-%u-%s",
                 NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX,
+                NA_SM_CLASS(na_class)->username,
                 NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
                 na_sm_addr->conn_id, NA_SM_SEND_NAME);
@@ -2946,9 +3002,11 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
                 goto done;
             }
 
-            NA_SM_GEN_SHM_NAME(na_sm_copy_buf_name, na_sm_addr);
+            NA_SM_GEN_SHM_NAME(na_sm_copy_buf_name,
+                NA_SM_CLASS(na_class)->username, na_sm_addr);
             copy_buf_name = na_sm_copy_buf_name;
-            NA_SM_GEN_SOCK_PATH(na_sock_name, na_sm_addr);
+            NA_SM_GEN_SOCK_PATH(na_sock_name,
+                NA_SM_CLASS(na_class)->username, na_sm_addr);
             pathname = na_sock_name;
         }
     }
