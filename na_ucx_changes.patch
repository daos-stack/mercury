diff --git a/src/na/na_ucx.c b/src/na/na_ucx.c
index df606f9..e9987e1 100644
--- a/src/na/na_ucx.c
+++ b/src/na/na_ucx.c
@@ -22,6 +22,7 @@
 
 #include <netdb.h>
 #include <sys/socket.h>
+#include <arpa/inet.h>
 
 /****************/
 /* Local Macros */
@@ -30,6 +31,11 @@
 /* Default protocol */
 #define NA_UCX_PROTOCOL_DEFAULT "all"
 
+/* Default features
+ *
+ * (AM for unexpected messages and TAG for expected messages) */
+#define NA_UCX_FEATURES (UCP_FEATURE_AM | UCP_FEATURE_TAG | UCP_FEATURE_RMA)
+
 /* Default max msg size */
 #define NA_UCX_MSG_SIZE_MAX (4096)
 
@@ -40,7 +46,7 @@
 #define NA_UCX_CONN_RETRY_MAX (1024)
 
 /* Memory pool (enabled by default, comment out to disable) */
-// #define NA_UCX_HAS_MEM_POOL
+//#define NA_UCX_HAS_MEM_POOL
 #define NA_UCX_MEM_CHUNK_COUNT (256)
 #define NA_UCX_MEM_BLOCK_COUNT (2)
 
@@ -48,9 +54,8 @@
 #define NA_UCX_MAX_TAG UINT32_MAX
 
 /* Reserved tags */
-#define NA_UCX_TAG_MASK        ((uint64_t) 0x00000000FFFFFFFF)
-#define NA_UCX_TAG_UNEXPECTED  ((uint64_t) 0x0000000100000000)
-#define NA_UCX_TAG_SENDER_MASK ((uint64_t) 0xFFFFFFFE00000000)
+#define NA_UCX_AM_MSG_ID (0)
+#define NA_UCX_TAG_MASK  ((uint64_t) 0x00000000FFFFFFFF)
 
 /* Maximum number of pre-allocated IOV entries */
 #define NA_UCX_IOV_STATIC_MAX (8)
@@ -69,28 +74,26 @@
     ((struct na_ucx_context *) ((na_context)->plugin_context))
 
 /* Reset op ID */
-#define NA_UCX_OP_RESET(__op, __context, __cb_type, __cb, __arg, __addr)       \
-    do {                                                                       \
-        __op->context = __context;                                             \
-        __op->completion_data.callback_info.type = __cb_type;                  \
-        __op->completion_data.callback = __cb;                                 \
-        __op->completion_data.callback_info.arg = __arg;                       \
-        __op->addr = __addr;                                                   \
-        na_ucx_addr_ref_incr(__addr);                                          \
-        hg_atomic_set32(&__op->status, 0);                                     \
-    } while (0)
-
-#define NA_UCX_OP_RESET_UNEXPECTED_RECV(__op, __context, __cb, __arg)          \
+#define NA_UCX_OP_RESET(_op, _context, _cb_type, _cb, _arg, _addr)             \
     do {                                                                       \
-        __op->context = __context;                                             \
-        __op->completion_data.callback_info.type = NA_CB_RECV_UNEXPECTED;      \
-        __op->completion_data.callback = __cb;                                 \
-        __op->completion_data.callback_info.arg = __arg;                       \
-        __op->completion_data.callback_info.info.recv_unexpected =             \
-            (struct na_cb_info_recv_unexpected){                               \
-                .actual_buf_size = 0, .source = NA_ADDR_NULL, .tag = 0};       \
-        __op->addr = NULL;                                                     \
-        hg_atomic_set32(&__op->status, 0);                                     \
+        _op->context = _context;                                               \
+        _op->completion_data = (struct na_cb_completion_data){                 \
+            .callback_info =                                                   \
+                (struct na_cb_info){.info.recv_unexpected =                    \
+                                        (struct na_cb_info_recv_unexpected){   \
+                                            .actual_buf_size = 0,              \
+                                            .source = NA_ADDR_NULL,            \
+                                            .tag = 0},                         \
+                    .arg = _arg,                                               \
+                    .type = _cb_type,                                          \
+                    .ret = NA_SUCCESS},                                        \
+            .callback = _cb,                                                   \
+            .plugin_callback = na_ucx_release,                                 \
+            .plugin_callback_args = _op};                                      \
+        _op->addr = _addr;                                                     \
+        if (_addr)                                                             \
+            na_ucx_addr_ref_incr(_addr);                                       \
+        hg_atomic_set32(&_op->status, 0);                                      \
     } while (0)
 
 #define NA_UCX_OP_RELEASE(__op)                                                \
@@ -104,13 +107,6 @@
 /* Local Type and Struct Definition */
 /************************************/
 
-/* Address status */
-enum na_ucx_addr_status {
-    NA_UCX_ADDR_INIT,
-    NA_UCX_ADDR_RESOLVING,
-    NA_UCX_ADDR_RESOLVED
-};
-
 /* Address */
 struct na_ucx_addr {
     HG_QUEUE_ENTRY(na_ucx_addr) entry; /* Entry in addr pool */
@@ -121,16 +117,14 @@ struct na_ucx_addr {
     size_t worker_addr_len;            /* Worker addr len */
     na_bool_t worker_addr_alloc;       /* Worker addr was allocated by us */
     ucp_ep_h ucp_ep;                   /* Currently only one EP per address */
-    uint32_t conn_id;                  /* Connection ID (local) */
-    uint32_t remote_conn_id;           /* Connection ID (remote) */
     hg_atomic_int32_t refcount;        /* Reference counter */
-    hg_atomic_int32_t status;          /* Resolution status */
 };
 
 /* Map (used to cache addresses) */
 struct na_ucx_map {
     hg_thread_rwlock_t lock;
-    hg_hash_table_t *map;
+    hg_hash_table_t *key_map;
+    hg_hash_table_t *ep_map;
 };
 
 /* Memory descriptor */
@@ -202,6 +196,21 @@ struct na_ucx_addr_pool {
     hg_thread_spin_t lock;
 };
 
+/* Unexpected msg info */
+struct na_ucx_unexpected_info {
+    HG_QUEUE_ENTRY(na_ucx_unexpected_info) entry;
+    struct na_ucx_addr *na_ucx_addr;
+    void *data;
+    size_t length;
+    ucp_tag_t tag;
+};
+
+/* Msg queue */
+struct na_ucx_unexpected_msg_queue {
+    HG_QUEUE_HEAD(na_ucx_unexpected_info) queue;
+    hg_thread_spin_t lock;
+};
+
 /* Op ID queue */
 struct na_ucx_op_queue {
     HG_QUEUE_HEAD(na_ucx_op_id) queue;
@@ -210,9 +219,10 @@ struct na_ucx_op_queue {
 
 /* UCX class */
 struct na_ucx_class {
+    struct na_ucx_unexpected_msg_queue
+        unexpected_msg_queue;              /* Unexpected msg queue */
     struct na_ucx_map addr_map;            /* Address map */
-    struct na_ucx_map addr_conn;           /* Connection ID map */
-    struct na_ucx_op_queue retry_op_queue; /* Retry op queue */
+    struct na_ucx_op_queue unexpected_op_queue; /* Retry op queue */
     struct na_ucx_addr_pool addr_pool;     /* Addr pool */
     ucp_context_h ucp_context;             /* UCP context */
     ucp_worker_h ucp_worker;               /* Shared UCP worker */
@@ -223,7 +233,6 @@ struct na_ucx_class {
     char *protocol_name;                   /* Protocol used */
     na_size_t unexpected_size_max;         /* Max unexpected size */
     na_size_t expected_size_max;           /* Max expected size */
-    hg_atomic_int32_t conn_id;             /* Connection ID */
     hg_atomic_int32_t ncontexts;           /* Number of contexts */
     na_bool_t no_wait;                     /* Wait disabled */
 };
@@ -284,6 +293,13 @@ na_ucp_worker_get_address(
     ucp_worker_h worker, ucp_address_t **addr_p, size_t *addr_len_p);
 
 /**
+ *  * Set handler for receiving active messages.
+ *   */
+static na_return_t
+na_ucp_set_am_handler(
+    ucp_worker_h worker, ucp_am_recv_callback_t am_recv_cb, void *arg);
+
+/**
  * Create listener.
  */
 static na_return_t
@@ -338,44 +354,7 @@ na_ucp_ep_create(ucp_worker_h worker, ucp_ep_params_t *ep_params,
 static void
 na_ucp_ep_error_cb(void *arg, ucp_ep_h ep, ucs_status_t status);
 
-/**
- * Get next connection ID.
- */
-static uint32_t
-na_ucp_conn_id_gen(struct na_ucx_class *na_ucx_class);
-
-/**
- * Exchange (send/recv) connection IDs.
- */
-static na_return_t
-na_ucp_conn_id_exchange(ucp_ep_h ep, const uint32_t *local_conn_id,
-    uint32_t *remote_conn_id, void *arg);
-
-/**
- * Connection ID send callback.
- */
-static void
-na_ucp_conn_id_send_cb(void *request, ucs_status_t status, void *user_data);
-
-/**
- * Connection ID recv callback.
- */
-static void
-na_ucp_conn_id_recv_cb(
-    void *request, ucs_status_t status, size_t length, void *user_data);
-
-/**
- * Create a msg tag.
- */
-static NA_INLINE ucp_tag_t
-na_ucp_tag_gen(uint32_t tag, uint8_t unexpected, uint32_t conn_id);
-
-/**
- * Convert a msg tag to a connection ID.
- */
-static NA_INLINE uint32_t
-na_ucp_tag_to_conn_id(ucp_tag_t tag);
-
+#ifndef NA_UCX_HAS_MEM_POOL
 /**
  * Allocate and register memory.
  */
@@ -388,7 +367,7 @@ na_ucp_mem_alloc(ucp_context_h context, size_t len, ucp_mem_h *mem_p);
 static na_return_t
 na_ucp_mem_free(ucp_context_h context, ucp_mem_h mem);
 
-#ifdef NA_UCX_HAS_MEM_POOL
+#else
 /**
  * Register memory buffer.
  */
@@ -404,6 +383,34 @@ na_ucp_mem_buf_deregister(void *handle, void *arg);
 #endif /* NA_UCX_HAS_MEM_POOL */
 
 /**
+ *  * Send active message.
+ *   */
+static na_return_t
+na_ucp_am_send(ucp_ep_h ep, const void *buf, size_t buf_size,
+    const ucp_tag_t *tag, void *request);
+
+/**
+ *  * Send active message callback.
+ *   */
+static void
+na_ucp_am_send_cb(
+    void *request, ucs_status_t status, void NA_UNUSED *user_data);
+
+/**
+ *  * Check if we received an AM or push the op to OP queue.
+ *   */
+static void
+na_ucp_am_recv(
+    struct na_ucx_class *na_ucx_class, struct na_ucx_op_id *na_ucx_op_id);
+
+/**
+ *  * Recv active message callback.
+ *   */
+static ucs_status_t
+na_ucp_am_recv_cb(void *arg, const void *header, size_t header_length,
+    void *data, size_t length, const ucp_am_recv_param_t *param);
+
+/**
  * Send a msg.
  */
 static na_return_t
@@ -421,21 +428,13 @@ na_ucp_msg_send_cb(void *request, ucs_status_t status, void *user_data);
  */
 static na_return_t
 na_ucp_msg_recv(ucp_worker_h worker, void *buf, size_t buf_size, ucp_tag_t tag,
-    ucp_tag_t tag_mask, void *request, ucp_tag_recv_nbx_callback_t recv_cb,
-    void *user_data);
-
-/**
- * Recv unexpected msg callback.
- */
-static void
-na_ucp_msg_recv_unexpected_cb(void *request, ucs_status_t status,
-    const ucp_tag_recv_info_t *info, void *user_data);
+    void *request);
 
 /**
- * Recv expected msg callback.
+ * Recv msg callback.
  */
 static void
-na_ucp_msg_recv_expected_cb(void *request, ucs_status_t status,
+na_ucp_msg_recv_cb(void *request, ucs_status_t status,
     const ucp_tag_recv_info_t *info, void *user_data);
 
 /**
@@ -506,7 +505,7 @@ na_ucx_addr_map_lookup(
 static na_return_t
 na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
     struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key,
-    struct na_ucx_addr **na_ucx_addr_p);
+    ucp_conn_request_h conn_request, struct na_ucx_addr **na_ucx_addr_p);
 
 /**
  * Remove addr from map using addr_key.
@@ -516,35 +515,35 @@ na_ucx_addr_map_remove(
     struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key);
 
 /**
- * Hash connection ID.
+ * Hash EP.
  */
 static NA_INLINE unsigned int
-na_ucx_addr_conn_hash(hg_hash_table_key_t key);
+na_ucx_addr_ep_hash(hg_hash_table_key_t key);
 
 /**
- * Compare connection IDs.
+ * Compare EPs.
  */
 static NA_INLINE int
-na_ucx_addr_conn_equal(hg_hash_table_key_t key1, hg_hash_table_key_t key2);
+na_ucx_addr_ep_equal(hg_hash_table_key_t key1, hg_hash_table_key_t key2);
 
 /**
- * Lookup addr from connection ID.
+ * Lookup addr from EP.
  */
 static NA_INLINE struct na_ucx_addr *
-na_ucx_addr_conn_lookup(struct na_ucx_map *na_ucx_map, uint32_t *conn_id);
+na_ucx_addr_ep_lookup(struct na_ucx_map *na_ucx_map, ucp_ep_h ep);
 
 /**
- * Insert new addr using connection ID (if it does not already exist).
+ * Insert new addr using EP (if it does not already exist).
  */
 static na_return_t
-na_ucx_addr_conn_insert(
+na_ucx_addr_ep_insert(
     struct na_ucx_map *na_ucx_map, struct na_ucx_addr *na_ucx_addr);
 
 /**
- * Remove addr from map using connection ID.
+ * Remove addr from map using EP.
  */
 static na_return_t
-na_ucx_addr_conn_remove(struct na_ucx_map *na_ucx_map, uint32_t *conn_id);
+na_ucx_addr_ep_remove(struct na_ucx_map *na_ucx_map, uint64_t *conn_ep);
 
 /**
  * Allocate empty address.
@@ -598,22 +597,6 @@ static NA_INLINE void
 na_ucx_addr_ref_decr(struct na_ucx_addr *na_ucx_addr);
 
 /**
- * Resolve address.
- */
-static na_return_t
-na_ucx_addr_resolve(
-    struct na_ucx_class *na_ucx_class, struct na_ucx_addr *na_ucx_addr);
-
-/**
- * Send msg.
- */
-static na_return_t
-na_ucx_msg_send(struct na_ucx_class *na_ucx_class, na_context_t *context,
-    na_cb_type_t cb_type, na_cb_t callback, void *arg, const void *buf,
-    na_size_t buf_size, struct na_ucx_addr *na_ucx_addr, na_tag_t tag,
-    struct na_ucx_op_id *na_ucx_op_id);
-
-/**
  * Post RMA operation.
  */
 static na_return_t
@@ -632,19 +615,6 @@ na_ucx_rma_key_resolve(ucp_ep_h ep, struct na_ucx_mem_handle *na_ucx_mem_handle,
     ucp_rkey_h *rkey_p);
 
 /**
- * Push operation to retry queue.
- */
-static NA_INLINE void
-na_ucx_op_retry(
-    struct na_ucx_class *na_ucx_class, struct na_ucx_op_id *na_ucx_op_id);
-
-/**
- * Retry operations from retry queue.
- */
-static na_return_t
-na_ucx_process_retries(struct na_ucx_class *na_ucx_class);
-
-/**
  * Complete UCX operation.
  */
 static NA_INLINE void
@@ -848,7 +818,7 @@ const struct na_class_ops NA_PLUGIN_OPS(ucx) = {
     NULL,                                 /* context_destroy */
     na_ucx_op_create,                     /* op_create */
     na_ucx_op_destroy,                    /* op_destroy */
-    na_ucx_addr_lookup,                   /* addr_lookup */
+	    na_ucx_addr_lookup,                   /* addr_lookup */
     na_ucx_addr_free,                     /* addr_free */
     NULL,                                 /* addr_set_remove */
     na_ucx_addr_self,                     /* addr_self */
@@ -927,7 +897,7 @@ na_ucp_config_init(
     //     "ucp_config_modify() failed (%s)", ucs_status_string(status));
 
     /* TODO Currently assume that systems are homogeneous */
-    status = ucp_config_modify(config, "UNIFIED_MODE", "y");
+    status = ucp_config_modify(config, "UNIFIED_MODE", "n");
     NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
         "ucp_config_modify() failed (%s)", ucs_status_string(status));
 
@@ -948,11 +918,13 @@ na_ucp_config_init(
             cls, "Could not find NET_DEVICE to use, using default");
 
     /* Print UCX config */
+    /*
     NA_LOG_SUBSYS_DEBUG_FUNC(cls,
         ucp_config_print(config, hg_log_get_stream_debug(),
             "NA UCX class configuration used",
             UCS_CONFIG_PRINT_CONFIG | UCS_CONFIG_PRINT_HEADER),
         "Now using the following UCX global configuration");
+    */
 
     *config_p = config;
 
@@ -980,10 +952,7 @@ na_ucp_context_create(const ucp_config_t *config, na_bool_t no_wait,
 {
     ucp_context_h context = NULL;
     ucp_params_t context_params = {
-        .field_mask =
-            UCP_PARAM_FIELD_FEATURES | UCP_PARAM_FIELD_TAG_SENDER_MASK,
-        .features = UCP_FEATURE_TAG | UCP_FEATURE_RMA | UCP_FEATURE_STREAM,
-        .tag_sender_mask = NA_UCX_TAG_SENDER_MASK};
+        .field_mask = UCP_PARAM_FIELD_FEATURES, .features = NA_UCX_FEATURES};
     ucp_context_attr_t context_attrs = {
         .field_mask = UCP_ATTR_FIELD_REQUEST_SIZE | UCP_ATTR_FIELD_THREAD_MODE};
     ucs_status_t status;
@@ -995,7 +964,7 @@ na_ucp_context_create(const ucp_config_t *config, na_bool_t no_wait,
 
     if (thread_mode == UCS_THREAD_MODE_MULTI) {
         /* If the UCP context can potentially be used by more than one
-         * worker / thread, then this context needs thread safety. */
+ *          * worker / thread, then this context needs thread safety. */
         context_params.field_mask |= UCP_PARAM_FIELD_MT_WORKERS_SHARED;
         context_params.mt_workers_shared = 1;
     }
@@ -1005,10 +974,11 @@ na_ucp_context_create(const ucp_config_t *config, na_bool_t no_wait,
     NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
         "ucp_init() failed (%s)", ucs_status_string(status));
 
-    /* Print context info */
+    /* Print context info
     NA_LOG_SUBSYS_DEBUG_FUNC(cls,
         ucp_context_print_info(context, hg_log_get_stream_debug()),
         "Context info");
+    */
 
     /* Query context to ensure we got what we asked for */
     status = ucp_context_query(context, &context_attrs);
@@ -1059,7 +1029,8 @@ na_ucp_worker_create(ucp_context_h context, ucs_thread_mode_t thread_mode,
         .field_mask = UCP_WORKER_PARAM_FIELD_THREAD_MODE,
         .thread_mode = thread_mode};
     ucp_worker_attr_t worker_attrs = {
-        .field_mask = UCP_WORKER_ATTR_FIELD_THREAD_MODE};
+        .field_mask = UCP_WORKER_ATTR_FIELD_THREAD_MODE |
+                      UCP_WORKER_ATTR_FIELD_MAX_AM_HEADER};
     ucs_status_t status;
     na_return_t ret;
 
@@ -1068,16 +1039,28 @@ na_ucp_worker_create(ucp_context_h context, ucs_thread_mode_t thread_mode,
     NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
         "ucp_worker_create() failed (%s)", ucs_status_string(status));
 
-    /* Print worker info */
+    /* Print worker info 
     NA_LOG_SUBSYS_DEBUG_FUNC(ctx,
         ucp_worker_print_info(worker, hg_log_get_stream_debug()),
         "Worker info");
+    */
 
-    /* Check thread mode */
+    /* Query worker attributes */
     status = ucp_worker_query(worker, &worker_attrs);
     NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, error, ret, NA_PROTOCOL_ERROR,
         "ucp_worker_query() failed (%s)", ucs_status_string(status));
 
+    /* Check max AM header size */
+    NA_CHECK_SUBSYS_ERROR(cls,
+        (worker_attrs.field_mask & UCP_WORKER_ATTR_FIELD_MAX_AM_HEADER) == 0,
+        error, ret, NA_PROTONOSUPPORT,
+        "worker attributes contain no max AM header");
+    NA_CHECK_SUBSYS_ERROR(cls, worker_attrs.max_am_header < sizeof(ucp_tag_t),
+        error, ret, NA_PROTONOSUPPORT,
+        "insufficient AM header size (expected %zu, got %zu)",
+        sizeof(ucp_tag_t), worker_attrs.max_am_header);
+
+    /* Check thread mode */
     NA_CHECK_SUBSYS_ERROR(cls,
         (worker_attrs.field_mask & UCP_WORKER_ATTR_FIELD_THREAD_MODE) == 0,
         error, ret, NA_PROTONOSUPPORT,
@@ -1123,6 +1106,33 @@ done:
     return ret;
 }
 
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ucp_set_am_handler(
+    ucp_worker_h worker, ucp_am_recv_callback_t am_recv_cb, void *arg)
+{
+    ucp_am_handler_param_t param;
+    ucs_status_t status;
+    na_return_t ret = NA_SUCCESS;
+
+    param.field_mask =
+        UCP_AM_HANDLER_PARAM_FIELD_ID | UCP_AM_HANDLER_PARAM_FIELD_CB |
+        UCP_AM_HANDLER_PARAM_FIELD_ARG | UCP_AM_HANDLER_PARAM_FIELD_FLAGS;
+    param.id = NA_UCX_AM_MSG_ID;
+    param.flags = UCP_AM_FLAG_WHOLE_MSG;
+    param.cb = am_recv_cb;
+    param.arg = arg;
+
+    status = ucp_worker_set_am_recv_handler(worker, &param);
+    NA_CHECK_SUBSYS_ERROR(cls, status != UCS_OK, done, ret, NA_PROTOCOL_ERROR,
+        "ucp_worker_set_am_recv_handler() failed (%s)",
+        ucs_status_string(status));
+
+done:
+    return ret;
+}
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucp_listener_create(ucp_worker_h worker, const struct sockaddr *addr,
@@ -1184,7 +1194,6 @@ na_ucp_listener_conn_cb(ucp_conn_request_h conn_request, void *arg)
     struct na_ucx_addr *na_ucx_addr = NULL;
     ucs_sock_addr_t addr_key;
     ucs_status_t status;
-    unsigned int retry = 0;
     na_return_t na_ret;
 
     status = ucp_conn_request_query(conn_request, &conn_request_attrs);
@@ -1205,40 +1214,11 @@ na_ucp_listener_conn_cb(ucp_conn_request_h conn_request, void *arg)
         "An entry is already present for this address");
 
     /* Insert new entry and create new address */
-    na_ret = na_ucx_addr_map_insert(
-        na_ucx_class, &na_ucx_class->addr_map, &addr_key, &na_ucx_addr);
+    na_ret = na_ucx_addr_map_insert(na_ucx_class, &na_ucx_class->addr_map,
+        &addr_key, conn_request, &na_ucx_addr);
     NA_CHECK_SUBSYS_NA_ERROR(
         addr, error, na_ret, "Could not insert new address");
 
-    /* Accept connection */
-    na_ret = na_ucp_accept(na_ucx_class->ucp_worker, conn_request,
-        na_ucp_ep_error_cb, (void *) na_ucx_addr, &na_ucx_addr->ucp_ep);
-    NA_CHECK_SUBSYS_NA_ERROR(
-        addr, error, na_ret, "Could not accept connection request");
-
-    while (retry < NA_UCX_CONN_RETRY_MAX) {
-        /* Generate connection ID */
-        na_ucx_addr->conn_id = na_ucp_conn_id_gen(na_ucx_class);
-
-        /* Insert connection entry to lookup address by connection ID */
-        na_ret = na_ucx_addr_conn_insert(&na_ucx_class->addr_conn, na_ucx_addr);
-        if (na_ret == NA_SUCCESS)
-            break;
-        else if (na_ret == NA_EXIST) {
-            /* Attempt to use another connection ID */
-            retry++;
-            continue;
-        } else
-            NA_CHECK_SUBSYS_NA_ERROR(
-                addr, error, na_ret, "Could not insert new address");
-    }
-
-    /* Exchange IDs so that we can later use that ID to identify msg senders */
-    na_ret = na_ucp_conn_id_exchange(na_ucx_addr->ucp_ep, &na_ucx_addr->conn_id,
-        &na_ucx_addr->remote_conn_id, na_ucx_addr);
-    NA_CHECK_SUBSYS_NA_ERROR(
-        addr, error, na_ret, "Could not exchange connection IDs");
-
     return;
 
 error:
@@ -1290,145 +1270,6 @@ na_ucp_connect_worker(ucp_worker_h worker, ucp_address_t *address,
 }
 
 /*---------------------------------------------------------------------------*/
-static uint32_t
-na_ucp_conn_id_gen(struct na_ucx_class *na_ucx_class)
-{
-    return (hg_atomic_cas32(&na_ucx_class->conn_id, INT32_MAX, 0))
-               ? 1 /* Incremented value */
-               : (uint32_t) hg_atomic_incr32(&na_ucx_class->conn_id);
-}
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucp_conn_id_exchange(ucp_ep_h ep, const uint32_t *local_conn_id,
-    uint32_t *remote_conn_id, void *arg)
-{
-    const ucp_request_param_t recv_params = {
-        .op_attr_mask = UCP_OP_ATTR_FIELD_CALLBACK |
-                        UCP_OP_ATTR_FIELD_USER_DATA |
-                        UCP_OP_ATTR_FIELD_DATATYPE | UCP_OP_ATTR_FIELD_FLAGS,
-        .cb = {.recv_stream = na_ucp_conn_id_recv_cb},
-        .user_data = arg,
-        .datatype = ucp_dt_make_contig(sizeof(uint32_t)),
-        .flags = UCP_STREAM_RECV_FLAG_WAITALL};
-    const ucp_request_param_t send_params = {
-        .op_attr_mask = UCP_OP_ATTR_FIELD_CALLBACK |
-                        UCP_OP_ATTR_FIELD_USER_DATA |
-                        UCP_OP_ATTR_FIELD_DATATYPE,
-        .cb = {.send = na_ucp_conn_id_send_cb},
-        .user_data = arg,
-        .datatype = ucp_dt_make_contig(sizeof(uint32_t))};
-    ucs_status_ptr_t send_ptr, recv_ptr;
-    na_return_t ret;
-    size_t recv_len;
-
-    /* Recv remote conn ID */
-    recv_ptr =
-        ucp_stream_recv_nbx(ep, remote_conn_id, 1, &recv_len, &recv_params);
-    if (recv_ptr == NULL) {
-        /* Completed immediately */
-        NA_LOG_SUBSYS_DEBUG(
-            addr, "ucp_stream_recv_nbx() completed immediately");
-
-        /* Directly execute callback */
-        na_ucp_conn_id_recv_cb(NULL, UCS_OK, recv_len, arg);
-    } else
-        NA_CHECK_SUBSYS_ERROR(addr, UCS_PTR_IS_ERR(recv_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_stream_recv_nbx() failed (%s)",
-            ucs_status_string(UCS_PTR_STATUS(recv_ptr)));
-
-    /* Send local conn ID */
-    send_ptr = ucp_stream_send_nbx(ep, local_conn_id, 1, &send_params);
-    if (send_ptr == NULL) {
-        /* Completed immediately */
-        NA_LOG_SUBSYS_DEBUG(
-            addr, "ucp_stream_send_nbx() completed immediately");
-
-        /* Directly execute callback */
-        na_ucp_conn_id_send_cb(NULL, UCS_OK, arg);
-    } else
-        NA_CHECK_SUBSYS_ERROR(addr, UCS_PTR_IS_ERR(send_ptr), error, ret,
-            NA_PROTOCOL_ERROR, "ucp_stream_send_nbx() failed (%s)",
-            ucs_status_string(UCS_PTR_STATUS(send_ptr)));
-
-    return NA_SUCCESS;
-
-error:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static void
-na_ucp_conn_id_send_cb(
-    void *request, ucs_status_t status, void NA_UNUSED *user_data)
-{
-    na_return_t cb_ret;
-
-    NA_LOG_SUBSYS_DEBUG(addr, "ucp_stream_send_nbx() completed (%s)",
-        ucs_status_string(status));
-
-    if (status == UCS_OK)
-        NA_GOTO_DONE(done, cb_ret, NA_SUCCESS);
-    else if (status == UCS_ERR_CANCELED)
-        NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
-    else
-        NA_GOTO_SUBSYS_ERROR(addr, done, cb_ret, NA_PROTOCOL_ERROR,
-            "ucp_stream_send_nbx() failed (%s)", ucs_status_string(status));
-
-done:
-    if (request)
-        ucp_request_free(request);
-
-    /* TODO link request to op id */
-    (void) cb_ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static void
-na_ucp_conn_id_recv_cb(void *request, ucs_status_t status,
-    size_t NA_UNUSED length, void NA_UNUSED *user_data)
-{
-    struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) user_data;
-    na_return_t cb_ret;
-
-    NA_LOG_SUBSYS_DEBUG(addr, "ucp_stream_recv_nbx() completed (%s)",
-        ucs_status_string(status));
-
-    if (status == UCS_OK) {
-        NA_LOG_SUBSYS_DEBUG(
-            addr, "Marking addr (%p) as resolved", (void *) na_ucx_addr);
-        hg_atomic_set32(&na_ucx_addr->status, NA_UCX_ADDR_RESOLVED);
-        NA_GOTO_DONE(done, cb_ret, NA_SUCCESS);
-    } else if (status == UCS_ERR_CANCELED)
-        NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
-    else
-        NA_GOTO_SUBSYS_ERROR(addr, done, cb_ret, NA_PROTOCOL_ERROR,
-            "ucp_stream_recv_nbx() failed (%s)", ucs_status_string(status));
-
-done:
-    if (request)
-        ucp_request_free(request);
-
-    /* TODO link request to op id */
-    (void) cb_ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static NA_INLINE ucp_tag_t
-na_ucp_tag_gen(uint32_t tag, uint8_t unexpected, uint32_t conn_id)
-{
-    return (((ucp_tag_t) conn_id << 33) |
-            (((ucp_tag_t) unexpected & 0x1) << 32) | (ucp_tag_t) tag);
-}
-
-/*---------------------------------------------------------------------------*/
-static NA_INLINE uint32_t
-na_ucp_tag_to_conn_id(ucp_tag_t tag)
-{
-    return (uint32_t) ((tag & NA_UCX_TAG_SENDER_MASK) >> 33);
-}
-
-/*---------------------------------------------------------------------------*/
 static void *
 na_ucp_mem_alloc(ucp_context_h context, size_t len, ucp_mem_h *mem_p)
 {
@@ -1571,9 +1412,8 @@ na_ucp_ep_error_cb(
 {
     struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) arg;
 
-    NA_LOG_SUBSYS_DEBUG(addr,
-        "ep_err_handler() returned (%s) for address (conn_id=%d)",
-        ucs_status_string(status), na_ucx_addr->conn_id);
+    //NA_LOG_SUBSYS_WARNING(addr, "ep_err_handler() returned (%s) for address (%p)",
+     //   ucs_status_string(status), (void *) na_ucx_addr);
 
     /* Will schedule removal of address */
     na_ucx_addr_ref_decr(na_ucx_addr);
@@ -1581,6 +1421,199 @@ na_ucp_ep_error_cb(
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
+na_ucp_am_send(ucp_ep_h ep, const void *buf, size_t buf_size,
+    const ucp_tag_t *tag, void *request)
+{
+    const ucp_request_param_t send_params = {
+        .op_attr_mask = UCP_OP_ATTR_FIELD_REQUEST | UCP_OP_ATTR_FIELD_CALLBACK |
+                        UCP_OP_ATTR_FIELD_FLAGS,
+        .cb = {.send = na_ucp_am_send_cb},
+        .flags = UCP_AM_SEND_FLAG_REPLY,
+        .request = request};
+    ucs_status_ptr_t status_ptr;
+    na_return_t ret;
+
+    NA_LOG_SUBSYS_DEBUG(
+        msg, "Posting am send with buf_size=%zu, tag=%" PRIu64, buf_size, *tag);
+
+    status_ptr = ucp_am_send_nbx(
+        ep, NA_UCX_AM_MSG_ID, tag, sizeof(*tag), buf, buf_size, &send_params);
+    if (status_ptr == NULL) {
+        /* Check for immediate completion */
+        NA_LOG_SUBSYS_DEBUG(msg, "ucp_am_send_nbx() completed immediately");
+
+        /* Directly execute callback */
+        na_ucp_am_send_cb(request, UCS_OK, NULL);
+    } else
+        NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
+            NA_PROTOCOL_ERROR, "ucp_am_send_nbx() failed (%s)",
+            ucs_status_string(UCS_PTR_STATUS(status_ptr)));
+
+    NA_LOG_SUBSYS_DEBUG(msg, "ucp_am_send_nbx() was posted");
+
+    return NA_SUCCESS;
+
+error:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static void
+na_ucp_am_send_cb(void *request, ucs_status_t status, void NA_UNUSED *user_data)
+{
+    na_return_t cb_ret;
+
+    NA_LOG_SUBSYS_DEBUG(
+        msg, "ucp_am_send_nbx() completed (%s)", ucs_status_string(status));
+
+    if (status == UCS_OK)
+        NA_GOTO_DONE(done, cb_ret, NA_SUCCESS);
+    if (status == UCS_ERR_CANCELED)
+        NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
+    else
+        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, NA_PROTOCOL_ERROR,
+            "ucp_am_send_nbx() failed (%s)", ucs_status_string(status));
+
+done:
+    na_ucx_complete((struct na_ucx_op_id *) request, cb_ret);
+}
+
+/*---------------------------------------------------------------------------*/
+static void
+na_ucp_am_recv(
+    struct na_ucx_class *na_ucx_class, struct na_ucx_op_id *na_ucx_op_id)
+{
+    struct na_ucx_unexpected_msg_queue *unexpected_msg_queue =
+        &na_ucx_class->unexpected_msg_queue;
+    struct na_ucx_unexpected_info *na_ucx_unexpected_info;
+
+    /* Look for an unexpected message already received */
+    hg_thread_spin_lock(&unexpected_msg_queue->lock);
+    na_ucx_unexpected_info = HG_QUEUE_FIRST(&unexpected_msg_queue->queue);
+    HG_QUEUE_POP_HEAD(&unexpected_msg_queue->queue, entry);
+    hg_thread_spin_unlock(&unexpected_msg_queue->lock);
+
+    if (unlikely(na_ucx_unexpected_info)) {
+        /* Copy buffers */
+        memcpy(na_ucx_op_id->info.msg.buf.ptr, na_ucx_unexpected_info->data,
+            na_ucx_unexpected_info->length);
+
+        /* Fill unexpected info */
+        na_ucx_op_id->completion_data.callback_info.info.recv_unexpected =
+            (struct na_cb_info_recv_unexpected){
+                .tag = (na_tag_t) na_ucx_unexpected_info->tag,
+                .actual_buf_size = (na_size_t) na_ucx_unexpected_info->length,
+                .source = (na_addr_t) na_ucx_unexpected_info->na_ucx_addr};
+
+        ucp_am_data_release(
+            na_ucx_class->ucp_worker, na_ucx_unexpected_info->data);
+        free(na_ucx_unexpected_info);
+        na_ucx_complete(na_ucx_op_id, NA_SUCCESS);
+    } else {
+        struct na_ucx_op_queue *unexpected_op_queue =
+            &na_ucx_class->unexpected_op_queue;
+
+        /* Nothing has been received yet so add op_id to progress queue */
+        hg_thread_spin_lock(&unexpected_op_queue->lock);
+        HG_QUEUE_PUSH_TAIL(&unexpected_op_queue->queue, na_ucx_op_id, entry);
+        hg_atomic_or32(&na_ucx_op_id->status, NA_UCX_OP_QUEUED);
+        hg_thread_spin_unlock(&unexpected_op_queue->lock);
+    }
+}
+
+/*---------------------------------------------------------------------------*/
+static ucs_status_t
+na_ucp_am_recv_cb(void *arg, const void *header, size_t header_length,
+    void *data, size_t length, const ucp_am_recv_param_t *param)
+{
+    struct na_ucx_class *na_ucx_class = (struct na_ucx_class *) arg;
+    struct na_ucx_op_queue *unexpected_op_queue =
+        &na_ucx_class->unexpected_op_queue;
+    struct na_ucx_op_id *na_ucx_op_id = NULL;
+    struct na_ucx_addr *source_addr = NULL;
+    ucp_tag_t tag;
+    ucs_status_t ret;
+
+    /* Retrieve tag */
+    NA_CHECK_SUBSYS_ERROR(msg, header_length != sizeof(tag), error, ret,
+        UCS_ERR_INVALID_PARAM, "Invalid tag size (%zu)", header_length);
+    memcpy(&tag, header, sizeof(tag));
+
+    NA_CHECK_SUBSYS_ERROR(msg,
+        (param->recv_attr & UCP_AM_RECV_ATTR_FIELD_REPLY_EP) == 0, error, ret,
+        UCS_ERR_INVALID_PARAM, "recv attributes contain no reply EP");
+    NA_LOG_SUBSYS_DEBUG(msg,
+        "ucp_am_recv() completed (tag=%" PRIu64 ", reply_ep=%p)", tag,
+        (void *) param->reply_ep);
+
+    /* Look up addr */
+    source_addr =
+        na_ucx_addr_ep_lookup(&na_ucx_class->addr_map, param->reply_ep);
+    NA_CHECK_SUBSYS_ERROR(addr, source_addr == NULL, error, ret,
+        UCS_ERR_INVALID_PARAM,
+        "No entry found for previously inserted src addr: %lu", param->reply_ep);
+
+    /* Pop op ID from queue */
+    hg_thread_spin_lock(&unexpected_op_queue->lock);
+    na_ucx_op_id = HG_QUEUE_FIRST(&unexpected_op_queue->queue);
+    if (likely(na_ucx_op_id)) {
+        HG_QUEUE_POP_HEAD(&unexpected_op_queue->queue, entry);
+        hg_atomic_and32(&na_ucx_op_id->status, ~NA_UCX_OP_QUEUED);
+    }
+    hg_thread_spin_unlock(&unexpected_op_queue->lock);
+
+    if (likely(na_ucx_op_id)) {
+    	//NA_LOG_SUBSYS_WARNING(addr, "Handling recv_exp for ep: %lu, op_id: %p", param->reply_ep, na_ucx_op_id);
+        /* Fill info */
+        na_ucx_op_id->completion_data.callback_info.info.recv_unexpected =
+            (struct na_cb_info_recv_unexpected){.tag = (na_tag_t) tag,
+                .actual_buf_size = (na_size_t) length,
+                .source = (na_addr_t) source_addr};
+        na_ucx_addr_ref_incr(source_addr);
+
+        /* Copy buffer */
+        memcpy(na_ucx_op_id->info.msg.buf.ptr, data, length);
+
+        /* Complete operation */
+        na_ucx_complete(na_ucx_op_id, NA_SUCCESS);
+
+        return UCS_OK;
+    } else {
+        struct na_ucx_unexpected_msg_queue *unexpected_msg_queue =
+            &na_ucx_class->unexpected_msg_queue;
+        struct na_ucx_unexpected_info *na_ucx_unexpected_info = NULL;
+
+        /* If no error and message arrived, keep a copy of the struct in
+ *          * the unexpected message queue (should rarely happen) */
+        na_ucx_unexpected_info = (struct na_ucx_unexpected_info *) malloc(
+            sizeof(*na_ucx_unexpected_info));
+        NA_CHECK_SUBSYS_ERROR(msg, na_ucx_unexpected_info == NULL, error, ret,
+            UCS_ERR_NO_MEMORY, "Could not allocate unexpected info");
+
+        *na_ucx_unexpected_info = (struct na_ucx_unexpected_info){.data = data,
+            .length = length,
+            .tag = tag,
+            .na_ucx_addr = source_addr};
+        na_ucx_addr_ref_incr(source_addr);
+
+        /* Otherwise push the unexpected message into our unexpected queue so
+ *          * that we can treat it later when a recv_unexpected is posted */
+        hg_thread_spin_lock(&unexpected_msg_queue->lock);
+        HG_QUEUE_PUSH_TAIL(
+            &unexpected_msg_queue->queue, na_ucx_unexpected_info, entry);
+        hg_thread_spin_unlock(&unexpected_msg_queue->lock);
+
+        /* If data is going to be used outside this callback, UCS_INPROGRESS
+ *          * should be returned */
+        return UCS_INPROGRESS;
+    }
+
+error:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
 na_ucp_msg_send(
     ucp_ep_h ep, const void *buf, size_t buf_size, ucp_tag_t tag, void *request)
 {
@@ -1591,8 +1624,8 @@ na_ucp_msg_send(
     ucs_status_ptr_t status_ptr;
     na_return_t ret;
 
-    NA_LOG_SUBSYS_DEBUG(msg,
-        "Posting msg send with buf_size=%zu, tag=0x%" PRIx64, buf_size, tag);
+    NA_LOG_SUBSYS_DEBUG(
+        msg, "Posting msg send with buf_size=%zu, tag=%" PRIu64, buf_size, tag);
 
     status_ptr = ucp_tag_send_nbx(ep, buf, buf_size, tag, &send_params);
     if (status_ptr == NULL) {
@@ -1639,34 +1672,29 @@ done:
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucp_msg_recv(ucp_worker_h worker, void *buf, size_t buf_size, ucp_tag_t tag,
-    ucp_tag_t tag_mask, void *request, ucp_tag_recv_nbx_callback_t recv_cb,
-    void *user_data)
+    void *request)
 {
     ucp_tag_recv_info_t tag_recv_info;
     const ucp_request_param_t recv_params = {
         .op_attr_mask = UCP_OP_ATTR_FIELD_REQUEST | UCP_OP_ATTR_FIELD_CALLBACK |
-                        UCP_OP_ATTR_FIELD_USER_DATA |
                         UCP_OP_ATTR_FIELD_RECV_INFO,
-        .cb = {.recv = recv_cb},
+        .cb = {.recv = na_ucp_msg_recv_cb},
         .request = request,
-        .user_data = user_data,
         .recv_info.tag_info = &tag_recv_info};
     ucs_status_ptr_t status_ptr;
     na_return_t ret;
 
-    NA_LOG_SUBSYS_DEBUG(msg,
-        "Posting msg recv with buf_size=%zu, tag=0x%" PRIx64
-        ", tag_mask=0x%" PRIx64,
-        buf_size, tag, tag_mask);
+    NA_LOG_SUBSYS_DEBUG(
+        msg, "Posting msg recv with buf_size=%zu, tag=%" PRIu64, buf_size, tag);
 
-    status_ptr =
-        ucp_tag_recv_nbx(worker, buf, buf_size, tag, tag_mask, &recv_params);
+    status_ptr = ucp_tag_recv_nbx(
+        worker, buf, buf_size, tag, NA_UCX_TAG_MASK, &recv_params);
     if (status_ptr == NULL) {
         /* Check for immediate completion */
         NA_LOG_SUBSYS_DEBUG(msg, "ucp_tag_recv_nbx() completed immediately");
 
         /* Directly execute callback */
-        recv_cb(request, UCS_OK, &tag_recv_info, user_data);
+        na_ucp_msg_recv_cb(request, UCS_OK, &tag_recv_info, NULL);
     } else
         NA_CHECK_SUBSYS_ERROR(msg, UCS_PTR_IS_ERR(status_ptr), error, ret,
             NA_PROTOCOL_ERROR, "ucp_tag_recv_nbx() failed (%s)",
@@ -1683,59 +1711,7 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static void
-na_ucp_msg_recv_unexpected_cb(void *request, ucs_status_t status,
-    const ucp_tag_recv_info_t *info, void *user_data)
-{
-    struct na_ucx_class *na_ucx_class = (struct na_ucx_class *) user_data;
-    struct na_ucx_op_id *na_ucx_op_id = (struct na_ucx_op_id *) request;
-    na_cb_type_t cb_type = na_ucx_op_id->completion_data.callback_info.type;
-    struct na_cb_info_recv_unexpected *recv_unexpected_info =
-        &na_ucx_op_id->completion_data.callback_info.info.recv_unexpected;
-    struct na_ucx_addr *source_addr = NULL;
-    uint32_t conn_id;
-    na_return_t cb_ret;
-
-    NA_LOG_SUBSYS_DEBUG(
-        msg, "ucp_tag_recv_nbx() completed (%s)", ucs_status_string(status));
-
-    if (status == UCS_OK)
-        cb_ret = NA_SUCCESS;
-    else if (status == UCS_ERR_CANCELED)
-        NA_GOTO_DONE(done, cb_ret, NA_CANCELED);
-    else
-        NA_GOTO_SUBSYS_ERROR(msg, done, cb_ret, NA_PROTOCOL_ERROR,
-            "ucp_tag_recv_nbx() failed (%s)", ucs_status_string(status));
-
-    NA_CHECK_SUBSYS_ERROR(msg,
-        (info->sender_tag & NA_UCX_TAG_MASK) > NA_UCX_MAX_TAG, done, cb_ret,
-        NA_OVERFLOW, "Invalid tag value 0x%" PRIx64, info->sender_tag);
-    NA_CHECK_SUBSYS_ERROR(msg, cb_type != NA_CB_RECV_UNEXPECTED, done, cb_ret,
-        NA_INVALID_ARG, "Invalid cb_type %s, expected NA_CB_RECV_UNEXPECTED",
-        na_cb_type_to_string(cb_type));
-
-    NA_LOG_SUBSYS_DEBUG(msg, "Received msg length=%zu, sender_tag=0x%" PRIx64,
-        info->length, info->sender_tag);
-
-    /* Fill unexpected info */
-    recv_unexpected_info->tag = (na_tag_t) (info->sender_tag & NA_UCX_TAG_MASK);
-    recv_unexpected_info->actual_buf_size = (na_size_t) info->length;
-
-    /* Lookup source address */
-    conn_id = na_ucp_tag_to_conn_id(info->sender_tag);
-    source_addr = na_ucx_addr_conn_lookup(&na_ucx_class->addr_conn, &conn_id);
-    NA_CHECK_SUBSYS_ERROR(msg, source_addr == NULL, done, cb_ret,
-        NA_PROTOCOL_ERROR, "Could not find address for connection ID %" PRId32,
-        conn_id);
-    recv_unexpected_info->source = (na_addr_t) source_addr;
-    na_ucx_addr_ref_incr(source_addr);
-
-done:
-    na_ucx_complete(na_ucx_op_id, cb_ret);
-}
-
-/*---------------------------------------------------------------------------*/
-static void
-na_ucp_msg_recv_expected_cb(void *request, ucs_status_t status,
+na_ucp_msg_recv_cb(void *request, ucs_status_t status,
     const ucp_tag_recv_info_t *info, void NA_UNUSED *user_data)
 {
     struct na_ucx_op_id *na_ucx_op_id = (struct na_ucx_op_id *) request;
@@ -1757,21 +1733,14 @@ na_ucp_msg_recv_expected_cb(void *request, ucs_status_t status,
 
     NA_CHECK_SUBSYS_ERROR(msg,
         (info->sender_tag & NA_UCX_TAG_MASK) > NA_UCX_MAX_TAG, done, cb_ret,
-        NA_OVERFLOW, "Invalid tag value 0x%" PRIx64, info->sender_tag);
+        NA_OVERFLOW, "Invalid tag value %" PRIu64, info->sender_tag);
     NA_CHECK_SUBSYS_ERROR(msg, cb_type != NA_CB_RECV_EXPECTED, done, cb_ret,
         NA_INVALID_ARG, "Invalid cb_type %s, expected NA_CB_RECV_EXPECTED",
         na_cb_type_to_string(cb_type));
 
-    NA_LOG_SUBSYS_DEBUG(msg, "Received msg length=%zu, sender_tag=0x%" PRIx64,
+    NA_LOG_SUBSYS_DEBUG(msg, "Received msg length=%zu, sender_tag=%" PRIu64,
         info->length, info->sender_tag);
 
-    /* Check that this is the expected sender */
-    NA_CHECK_SUBSYS_ERROR(msg,
-        na_ucp_tag_to_conn_id(info->sender_tag) != na_ucx_op_id->addr->conn_id,
-        done, cb_ret, NA_PROTOCOL_ERROR,
-        "Invalid sender connection ID, expected %" PRId32 ", got %" PRId32,
-        na_ucx_op_id->addr->conn_id, na_ucp_tag_to_conn_id(info->sender_tag));
-
     /* Keep actual msg size */
     NA_CHECK_SUBSYS_ERROR(msg, info->length > na_ucx_op_id->info.msg.buf_size,
         done, cb_ret, NA_MSGSIZE,
@@ -1779,7 +1748,7 @@ na_ucp_msg_recv_expected_cb(void *request, ucs_status_t status,
     recv_expected_info->actual_buf_size = (na_size_t) info->length;
 
 done:
-    na_ucx_complete(na_ucx_op_id, cb_ret);
+   na_ucx_complete(na_ucx_op_id, cb_ret);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1878,23 +1847,23 @@ na_ucx_class_alloc(void)
     na_ucx_class = calloc(1, sizeof(*na_ucx_class));
     NA_CHECK_SUBSYS_ERROR_NORET(cls, na_ucx_class == NULL, error,
         "Could not allocate NA private data class");
-    hg_atomic_init32(&na_ucx_class->conn_id, 0);
 
     /* Init table lock */
     rc = hg_thread_rwlock_init(&na_ucx_class->addr_map.lock);
     NA_CHECK_SUBSYS_ERROR_NORET(
         cls, rc != HG_UTIL_SUCCESS, error, "hg_thread_rwlock_init() failed");
 
-    /* Init table lock */
-    rc = hg_thread_rwlock_init(&na_ucx_class->addr_conn.lock);
+    /* Initialize unexpected op queue */
+    rc = hg_thread_spin_init(&na_ucx_class->unexpected_op_queue.lock);
     NA_CHECK_SUBSYS_ERROR_NORET(
-        cls, rc != HG_UTIL_SUCCESS, error, "hg_thread_rwlock_init() failed");
+        cls, rc != HG_UTIL_SUCCESS, error, "hg_thread_spin_init() failed");
+    HG_QUEUE_INIT(&na_ucx_class->unexpected_op_queue.queue);
 
-    /* Initialize retry op queue */
-    rc = hg_thread_spin_init(&na_ucx_class->retry_op_queue.lock);
+    /* Initialize unexpected msg queue */
+    rc = hg_thread_spin_init(&na_ucx_class->unexpected_msg_queue.lock);
     NA_CHECK_SUBSYS_ERROR_NORET(
         cls, rc != HG_UTIL_SUCCESS, error, "hg_thread_spin_init() failed");
-    HG_QUEUE_INIT(&na_ucx_class->retry_op_queue.queue);
+    HG_QUEUE_INIT(&na_ucx_class->unexpected_msg_queue.queue);
 
     /* Initialize addr pool */
     rc = hg_thread_spin_init(&na_ucx_class->addr_pool.lock);
@@ -1903,16 +1872,16 @@ na_ucx_class_alloc(void)
     HG_QUEUE_INIT(&na_ucx_class->addr_pool.queue);
 
     /* Create address map */
-    na_ucx_class->addr_map.map =
+    na_ucx_class->addr_map.key_map =
         hg_hash_table_new(na_ucx_addr_key_hash, na_ucx_addr_key_equal);
-    NA_CHECK_SUBSYS_ERROR_NORET(cls, na_ucx_class->addr_map.map == NULL, error,
-        "Could not allocate address table");
+    NA_CHECK_SUBSYS_ERROR_NORET(cls, na_ucx_class->addr_map.key_map == NULL,
+        error, "Could not allocate key map");
 
     /* Create connection map */
-    na_ucx_class->addr_conn.map =
-        hg_hash_table_new(na_ucx_addr_conn_hash, na_ucx_addr_conn_equal);
-    NA_CHECK_SUBSYS_ERROR_NORET(cls, na_ucx_class->addr_conn.map == NULL, error,
-        "Could not allocate address table");
+    na_ucx_class->addr_map.ep_map =
+        hg_hash_table_new(na_ucx_addr_ep_hash, na_ucx_addr_ep_equal);
+    NA_CHECK_SUBSYS_ERROR_NORET(cls, na_ucx_class->addr_map.ep_map == NULL,
+        error, "Could not allocate EP handle map");
 
     return na_ucx_class;
 
@@ -1927,6 +1896,10 @@ error:
 static void
 na_ucx_class_free(struct na_ucx_class *na_ucx_class)
 {
+#ifdef NA_UCX_HAS_MEM_POOL
+    hg_mem_pool_destroy(na_ucx_class->mem_pool);
+#endif
+
     if (na_ucx_class->self_addr)
         na_ucx_addr_destroy(na_ucx_class->self_addr);
     if (na_ucx_class->ucp_listener)
@@ -1936,18 +1909,15 @@ na_ucx_class_free(struct na_ucx_class *na_ucx_class)
     if (na_ucx_class->ucp_context)
         na_ucp_context_destroy(na_ucx_class->ucp_context);
 
-    if (na_ucx_class->addr_map.map)
-        hg_hash_table_free(na_ucx_class->addr_map.map);
-    if (na_ucx_class->addr_conn.map)
-        hg_hash_table_free(na_ucx_class->addr_conn.map);
+    if (na_ucx_class->addr_map.key_map)
+        hg_hash_table_free(na_ucx_class->addr_map.key_map);
+    if (na_ucx_class->addr_map.ep_map)
+        hg_hash_table_free(na_ucx_class->addr_map.ep_map);
     (void) hg_thread_rwlock_destroy(&na_ucx_class->addr_map.lock);
-    (void) hg_thread_rwlock_destroy(&na_ucx_class->addr_conn.lock);
-    (void) hg_thread_spin_destroy(&na_ucx_class->retry_op_queue.lock);
-    (void) hg_thread_spin_destroy(&na_ucx_class->addr_pool.lock);
 
-#ifdef NA_UCX_HAS_MEM_POOL
-    hg_mem_pool_destroy(na_ucx_class->mem_pool);
-#endif
+    (void) hg_thread_spin_destroy(&na_ucx_class->unexpected_op_queue.lock);
+    (void) hg_thread_spin_destroy(&na_ucx_class->unexpected_msg_queue.lock);
+    (void) hg_thread_spin_destroy(&na_ucx_class->addr_pool.lock);
 
     free(na_ucx_class->protocol_name);
     free(na_ucx_class);
@@ -1958,45 +1928,52 @@ static na_return_t
 na_ucx_parse_hostname_info(const char *hostname_info, const char *subnet_info,
     char **net_device_p, struct sockaddr_storage **sockaddr_p)
 {
-    char **ifa_name_p = NULL;
     char *hostname = NULL;
+    //char host[64];
+    char *device_delim = NULL;
     unsigned int port = 0;
     na_return_t ret = NA_SUCCESS;
 
+    //printf("hostname_info: %s\n", hostname_info);
     /* Set hostname (use default interface name if no hostname was passed) */
     if (hostname_info) {
-        hostname = strdup(hostname_info);
-        NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
-            "strdup() of hostname failed");
+    	device_delim = strstr(hostname_info, "/");
+	if (device_delim) {
+	    char *addr_str = NULL;
+            strtok_r(hostname_info, "/", &addr_str);
+            hostname = strdup(addr_str);
+       	    NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
+                          "strdup() of hostname failed");
+            /* put NULL in hostname_info string after device name */
+	    *(++device_delim) = '\0';
+	    *net_device_p = hostname_info;
+	} else {
+            hostname = strdup(hostname_info);
+       	    NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
+                          "strdup() of hostname failed");
+	}
 
         /* TODO add support for IPv6 address parsing */
 
-        /* Extract hostname : port */
+        /* Extract hostname / port */
         if (strstr(hostname, ":")) {
             char *port_str = NULL;
             strtok_r(hostname, ":", &port_str);
             port = (unsigned int) strtoul(port_str, NULL, 10);
         }
-
-        /* Extract net_device if explicitly listed with '/' before IP */
-        if (strstr(hostname, "/")) {
-            char *host_str = NULL;
-            strtok_r(hostname, "/", &host_str);
-
-            *net_device_p = hostname;
-            hostname = strdup(host_str);
-            NA_CHECK_SUBSYS_ERROR(cls, hostname == NULL, done, ret, NA_NOMEM,
-                "strdup() of hostname failed");
-        } else
-            ifa_name_p = net_device_p;
     }
 
     /* TODO add support for IPv6 wildcards */
 
     if (hostname && strcmp(hostname, "0.0.0.0") != 0) {
-        /* Try to get matching IP/device */
-        ret = na_ip_check_interface(hostname, port, ifa_name_p, sockaddr_p);
-        NA_CHECK_SUBSYS_NA_ERROR(cls, done, ret, "Could not check interfaces");
+	struct sockaddr_storage *ss_addr = calloc(1, sizeof(*ss_addr));
+	struct sockaddr_in *sa = (struct sockaddr_in *) ss_addr;
+	sa->sin_family = AF_INET;
+	sa->sin_addr.s_addr = inet_addr(hostname);
+	sa->sin_port = htons(port & 0xffff);
+	if (sockaddr_p != NULL) 
+		*sockaddr_p = ss_addr;
+
     } else {
         char pref_anyip[NI_MAXHOST];
         uint32_t subnet = 0, netmask = 0;
@@ -2054,17 +2031,18 @@ na_ucx_addr_map_lookup(struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key)
     /* Lookup key */
     hg_thread_rwlock_rdlock(&na_ucx_map->lock);
     value =
-        hg_hash_table_lookup(na_ucx_map->map, (hg_hash_table_key_t) addr_key);
+        hg_hash_table_lookup(na_ucx_map->key_map, (hg_hash_table_key_t) addr_key);
     hg_thread_rwlock_release_rdlock(&na_ucx_map->lock);
 
     return (value == HG_HASH_TABLE_NULL) ? NULL : (struct na_ucx_addr *) value;
 }
 
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
     struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key,
-    struct na_ucx_addr **na_ucx_addr_p)
+    ucp_conn_request_h conn_request, struct na_ucx_addr **na_ucx_addr_p)
 {
     struct na_ucx_addr *na_ucx_addr = NULL;
     na_return_t ret = NA_SUCCESS;
@@ -2074,7 +2052,7 @@ na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
 
     /* Look up again to prevent race between lock release/acquire */
     na_ucx_addr = (struct na_ucx_addr *) hg_hash_table_lookup(
-        na_ucx_map->map, (hg_hash_table_key_t) addr_key);
+        na_ucx_map->key_map, (hg_hash_table_key_t) addr_key);
     if (na_ucx_addr) {
         ret = NA_EXIST; /* Entry already exists */
         goto done;
@@ -2085,8 +2063,34 @@ na_ucx_addr_map_insert(struct na_ucx_class *na_ucx_class,
     NA_CHECK_SUBSYS_NA_ERROR(
         addr, error, ret, "Could not allocate NA UCX addr");
 
-    /* Insert new value */
-    rc = hg_hash_table_insert(na_ucx_map->map,
+    if (conn_request) {
+        /* Accept connection */
+        ret = na_ucp_accept(na_ucx_class->ucp_worker, conn_request,
+            na_ucp_ep_error_cb, (void *) na_ucx_addr, &na_ucx_addr->ucp_ep);
+        NA_CHECK_SUBSYS_NA_ERROR(
+            addr, error, ret, "Could not accept connection request");
+    	//NA_LOG_SUBSYS_WARNING(addr, "UCP ep accepted on server: %lu",
+                              //na_ucx_addr->ucp_ep);
+    } else {
+        /* Create new endpoint */
+        ret = na_ucp_connect(na_ucx_class->ucp_worker,
+            na_ucx_addr->addr_key.addr, na_ucx_addr->addr_key.addrlen,
+            na_ucp_ep_error_cb, (void *) na_ucx_addr, &na_ucx_addr->ucp_ep);
+        NA_CHECK_SUBSYS_NA_ERROR(
+            addr, error, ret, "Could not connect UCP endpoint");
+    }
+    NA_LOG_SUBSYS_DEBUG(addr, "UCP ep for addr %p is %p", (void *) na_ucx_addr,
+        (void *) na_ucx_addr->ucp_ep);
+
+    /* Insert new value to secondary map to lookup by EP handle */
+    rc = hg_hash_table_insert(na_ucx_map->ep_map,
+        (hg_hash_table_key_t) na_ucx_addr->ucp_ep,
+        (hg_hash_table_value_t) na_ucx_addr);
+    NA_CHECK_SUBSYS_ERROR(
+        addr, rc == 0, error, ret, NA_NOMEM, "hg_hash_table_insert() failed");
+
+    /* Insert new value to primary map */
+    rc = hg_hash_table_insert(na_ucx_map->key_map,
         (hg_hash_table_key_t) &na_ucx_addr->addr_key,
         (hg_hash_table_value_t) na_ucx_addr);
     NA_CHECK_SUBSYS_ERROR(
@@ -2111,16 +2115,35 @@ error:
 static na_return_t
 na_ucx_addr_map_remove(struct na_ucx_map *na_ucx_map, ucs_sock_addr_t *addr_key)
 {
+    struct na_ucx_addr *na_ucx_addr = NULL;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
     hg_thread_rwlock_wrlock(&na_ucx_map->lock);
-    if (hg_hash_table_lookup(na_ucx_map->map, (hg_hash_table_key_t) addr_key) ==
-        HG_HASH_TABLE_NULL)
-        goto unlock;
 
-    rc = hg_hash_table_remove(na_ucx_map->map, (hg_hash_table_key_t) addr_key);
-    NA_CHECK_SUBSYS_ERROR_DONE(addr, rc == 0, "Could not remove key");
+    //NA_LOG_SUBSYS_WARNING(addr, "Looking up addr_key: %p", addr_key);
+    na_ucx_addr = hg_hash_table_lookup(
+        na_ucx_map->key_map, (hg_hash_table_key_t) addr_key);
+
+    if (na_ucx_addr == HG_HASH_TABLE_NULL)
+        goto unlock;
+    if (na_ucx_addr->refcount > 0)
+    	NA_LOG_SUBSYS_WARNING(addr, "Removing ep: %lu, with positive refcount: %d",
+                              na_ucx_addr->ucp_ep, na_ucx_addr->refcount);
+   
+    /* Remove addr key from primary map */
+    rc = hg_hash_table_remove(
+        na_ucx_map->key_map, (hg_hash_table_key_t) addr_key);
+    NA_CHECK_SUBSYS_ERROR(addr, rc != 1, unlock, ret, NA_NOENTRY,
+        "hg_hash_table_remove() failed");
+
+    /* Remove EP handle from secondary map */
+    
+    //NA_LOG_SUBSYS_WARNING(addr, "Removing end_point: %lu", na_ucx_addr->ucp_ep);
+    rc = hg_hash_table_remove(
+        na_ucx_map->ep_map, (hg_hash_table_key_t) na_ucx_addr->ucp_ep);
+    NA_CHECK_SUBSYS_ERROR(addr, rc != 1, unlock, ret, NA_NOENTRY,
+        "hg_hash_table_remove() failed");
 
 unlock:
     hg_thread_rwlock_release_wrlock(&na_ucx_map->lock);
@@ -2130,92 +2153,39 @@ unlock:
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE unsigned int
-na_ucx_addr_conn_hash(hg_hash_table_key_t key)
+na_ucx_addr_ep_hash(hg_hash_table_key_t key)
 {
-    return (unsigned int) *((uint32_t *) key);
+    na_uint64_t ep = (na_uint64_t) key;
+    na_uint32_t hi, lo;
+
+    hi = (na_uint32_t) (ep >> 32);
+    lo = (ep & 0xFFFFFFFFU);
+
+    return (hi & 0xFFFF0000U) | (lo & 0xFFFFU);
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE int
-na_ucx_addr_conn_equal(hg_hash_table_key_t key1, hg_hash_table_key_t key2)
+na_ucx_addr_ep_equal(hg_hash_table_key_t key1, hg_hash_table_key_t key2)
 {
-    return *((uint32_t *) key1) == *((uint32_t *) key2);
+    return (ucp_ep_h) key1 == (ucp_ep_h) key2;
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE struct na_ucx_addr *
-na_ucx_addr_conn_lookup(struct na_ucx_map *na_ucx_map, uint32_t *conn_id)
+na_ucx_addr_ep_lookup(struct na_ucx_map *na_ucx_map, ucp_ep_h ep)
 {
     hg_hash_table_value_t value = NULL;
 
     /* Lookup key */
     hg_thread_rwlock_rdlock(&na_ucx_map->lock);
-    value =
-        hg_hash_table_lookup(na_ucx_map->map, (hg_hash_table_key_t) conn_id);
+    value = hg_hash_table_lookup(na_ucx_map->ep_map, (hg_hash_table_key_t) ep);
     hg_thread_rwlock_release_rdlock(&na_ucx_map->lock);
 
     return (value == HG_HASH_TABLE_NULL) ? NULL : (struct na_ucx_addr *) value;
 }
 
 /*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucx_addr_conn_insert(
-    struct na_ucx_map *na_ucx_map, struct na_ucx_addr *na_ucx_addr)
-{
-    hg_hash_table_value_t lookup_value = NULL;
-    na_return_t ret;
-    int rc;
-
-    hg_thread_rwlock_wrlock(&na_ucx_map->lock);
-
-    /* Look up again to prevent race between lock release/acquire */
-    lookup_value = hg_hash_table_lookup(
-        na_ucx_map->map, (hg_hash_table_key_t) &na_ucx_addr->conn_id);
-    if (lookup_value != HG_HASH_TABLE_NULL) {
-        ret = NA_EXIST; /* Entry already exists */
-        goto done;
-    }
-
-    /* Insert new value */
-    rc = hg_hash_table_insert(na_ucx_map->map,
-        (hg_hash_table_key_t) &na_ucx_addr->conn_id,
-        (hg_hash_table_value_t) na_ucx_addr);
-    NA_CHECK_SUBSYS_ERROR(
-        addr, rc == 0, error, ret, NA_NOMEM, "hg_hash_table_insert() failed");
-
-done:
-    hg_thread_rwlock_release_wrlock(&na_ucx_map->lock);
-
-    return NA_SUCCESS;
-
-error:
-    hg_thread_rwlock_release_wrlock(&na_ucx_map->lock);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucx_addr_conn_remove(struct na_ucx_map *na_ucx_map, uint32_t *conn_id)
-{
-    na_return_t ret = NA_SUCCESS;
-    int rc;
-
-    hg_thread_rwlock_wrlock(&na_ucx_map->lock);
-    if (hg_hash_table_lookup(na_ucx_map->map, (hg_hash_table_key_t) conn_id) ==
-        HG_HASH_TABLE_NULL)
-        goto unlock;
-
-    rc = hg_hash_table_remove(na_ucx_map->map, (hg_hash_table_key_t) conn_id);
-    NA_CHECK_SUBSYS_ERROR_DONE(addr, rc == 0, "Could not remove key");
-
-unlock:
-    hg_thread_rwlock_release_wrlock(&na_ucx_map->lock);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
 static struct na_ucx_addr *
 na_ucx_addr_alloc(struct na_ucx_class *na_ucx_class)
 {
@@ -2232,7 +2202,7 @@ na_ucx_addr_alloc(struct na_ucx_class *na_ucx_class)
 static void
 na_ucx_addr_destroy(struct na_ucx_addr *na_ucx_addr)
 {
-    NA_LOG_SUBSYS_DEBUG(addr, "Destroying address %p", (void *) na_ucx_addr);
+    // NA_LOG_SUBSYS_WARNING(addr, "Destroying address %p, ep: %lu", (void *) na_ucx_addr, na_ucx_addr->ucp_ep);
 
     na_ucx_addr_release(na_ucx_addr);
     free(na_ucx_addr);
@@ -2264,16 +2234,18 @@ na_ucx_addr_pool_get(struct na_ucx_class *na_ucx_class)
 static void
 na_ucx_addr_release(struct na_ucx_addr *na_ucx_addr)
 {
+    /* Make sure we remove from map before we close the EP */
+    if (na_ucx_addr->addr_key.addr) {
+	// NA_LOG_SUBSYS_WARNING(addr, "Map removal for ep: %lu, refcount: %d", na_ucx_addr->ucp_ep, na_ucx_addr->refcount);
+        na_ucx_addr_map_remove(
+            &na_ucx_addr->na_ucx_class->addr_map, &na_ucx_addr->addr_key);
+    }
+
     if (na_ucx_addr->ucp_ep != NULL) {
         ucp_ep_close_nb(na_ucx_addr->ucp_ep, UCP_EP_CLOSE_MODE_FORCE);
         na_ucx_addr->ucp_ep = NULL;
     }
-    if (na_ucx_addr->addr_key.addr)
-        na_ucx_addr_map_remove(
-            &na_ucx_addr->na_ucx_class->addr_map, &na_ucx_addr->addr_key);
-    if (na_ucx_addr->conn_id)
-        na_ucx_addr_conn_remove(
-            &na_ucx_addr->na_ucx_class->addr_conn, &na_ucx_addr->conn_id);
+
     if (na_ucx_addr->worker_addr != NULL) {
         if (na_ucx_addr->worker_addr_alloc)
             free(na_ucx_addr->worker_addr);
@@ -2284,13 +2256,13 @@ na_ucx_addr_release(struct na_ucx_addr *na_ucx_addr)
     }
 }
 
+
 /*---------------------------------------------------------------------------*/
 static void
 na_ucx_addr_reset(struct na_ucx_addr *na_ucx_addr, ucs_sock_addr_t *addr_key)
 {
     na_ucx_addr->ucp_ep = NULL;
     hg_atomic_init32(&na_ucx_addr->refcount, 1);
-    hg_atomic_init32(&na_ucx_addr->status, NA_UCX_ADDR_INIT);
 
     if (addr_key && addr_key->addr) {
         memcpy(&na_ucx_addr->ss_addr, addr_key->addr, addr_key->addrlen);
@@ -2299,6 +2271,9 @@ na_ucx_addr_reset(struct na_ucx_addr *na_ucx_addr, ucs_sock_addr_t *addr_key)
         na_ucx_addr->addr_key.addr =
             (const struct sockaddr *) &na_ucx_addr->ss_addr;
         na_ucx_addr->addr_key.addrlen = addr_key->addrlen;
+    } else {
+	memset(&na_ucx_addr->ss_addr, 0, sizeof(na_ucx_addr->ss_addr));
+        na_ucx_addr->addr_key = (ucs_sock_addr_t){.addr = NULL, .addrlen = 0};
     }
 }
 
@@ -2358,11 +2333,14 @@ na_ucx_addr_ref_incr(struct na_ucx_addr *na_ucx_addr)
 static NA_INLINE void
 na_ucx_addr_ref_decr(struct na_ucx_addr *na_ucx_addr)
 {
+    //NA_LOG_SUBSYS_WARNING(addr, "Decrementing ep: %lu, refcount: %d", na_ucx_addr->ucp_ep, na_ucx_addr->refcount);
+
     if (hg_atomic_decr32(&na_ucx_addr->refcount) == 0) {
 #ifdef NA_UCX_HAS_ADDR_POOL
         struct na_ucx_addr_pool *addr_pool =
             &na_ucx_addr->na_ucx_class->addr_pool;
 
+     // NA_LOG_SUBSYS_WARNING(addr, "Calling addr release from decr for ep: %lu", na_ucx_addr->ucp_ep);
         na_ucx_addr_release(na_ucx_addr);
 
         /* Push address back to addr pool */
@@ -2377,104 +2355,6 @@ na_ucx_addr_ref_decr(struct na_ucx_addr *na_ucx_addr)
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucx_addr_resolve(
-    struct na_ucx_class *na_ucx_class, struct na_ucx_addr *na_ucx_addr)
-{
-    unsigned int retry = 0;
-    na_return_t ret;
-
-    /* Let only one thread at a time resolving the address */
-    if (!hg_atomic_cas32(
-            &na_ucx_addr->status, NA_UCX_ADDR_INIT, NA_UCX_ADDR_RESOLVING))
-        return NA_SUCCESS;
-
-    /* Create new endpoint */
-    ret = na_ucp_connect(na_ucx_class->ucp_worker, na_ucx_addr->addr_key.addr,
-        na_ucx_addr->addr_key.addrlen, na_ucp_ep_error_cb, (void *) na_ucx_addr,
-        &na_ucx_addr->ucp_ep);
-    NA_CHECK_SUBSYS_NA_ERROR(
-        addr, error, ret, "Could not connect UCP endpoint");
-
-    while (retry < NA_UCX_CONN_RETRY_MAX) {
-        /* Generate connection ID */
-        na_ucx_addr->conn_id = na_ucp_conn_id_gen(na_ucx_class);
-        NA_LOG_SUBSYS_DEBUG(
-            addr, "Generated connection ID %" PRId32, na_ucx_addr->conn_id);
-
-        /* Insert connection entry to lookup address by connection ID */
-        ret = na_ucx_addr_conn_insert(&na_ucx_class->addr_conn, na_ucx_addr);
-        if (ret == NA_SUCCESS)
-            break;
-        else if (ret == NA_EXIST) {
-            /* Attempt to use another connection ID */
-            retry++;
-            continue;
-        } else
-            NA_CHECK_SUBSYS_NA_ERROR(
-                addr, error, ret, "Could not insert new address");
-    }
-    /* Exchange IDs so that we can later use that ID to identify msg senders */
-    ret = na_ucp_conn_id_exchange(na_ucx_addr->ucp_ep, &na_ucx_addr->conn_id,
-        &na_ucx_addr->remote_conn_id, na_ucx_addr);
-    NA_CHECK_SUBSYS_NA_ERROR(
-        addr, error, ret, "Could not exchange connection IDs");
-
-    return NA_SUCCESS;
-
-error:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucx_msg_send(struct na_ucx_class *na_ucx_class, na_context_t *context,
-    na_cb_type_t cb_type, na_cb_t callback, void *arg, const void *buf,
-    na_size_t buf_size, struct na_ucx_addr *na_ucx_addr, na_tag_t tag,
-    struct na_ucx_op_id *na_ucx_op_id)
-{
-    na_return_t ret;
-
-    /* Check op_id */
-    NA_CHECK_SUBSYS_ERROR(op, na_ucx_op_id == NULL, error, ret, NA_INVALID_ARG,
-        "Invalid operation ID");
-    NA_CHECK_SUBSYS_ERROR(op,
-        !(hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_COMPLETED), error,
-        ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
-        na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
-
-    NA_UCX_OP_RESET(na_ucx_op_id, context, cb_type, callback, arg, na_ucx_addr);
-
-    /* TODO we assume that buf remains valid (safe because we pre-allocate
-     * buffers) */
-    na_ucx_op_id->info.msg = (struct na_ucx_msg_info){
-        .buf.const_ptr = buf, .buf_size = buf_size, .tag = tag};
-
-    if (hg_atomic_get32(&na_ucx_addr->status) != NA_UCX_ADDR_RESOLVED) {
-        ret = na_ucx_addr_resolve(na_ucx_class, na_ucx_addr);
-        NA_CHECK_SUBSYS_NA_ERROR(
-            msg, release, ret, "Could not resolve address");
-
-        na_ucx_op_retry(na_ucx_class, na_ucx_op_id);
-    } else {
-        ucp_tag_t ucp_tag = na_ucp_tag_gen(
-            tag, cb_type == NA_CB_SEND_UNEXPECTED, na_ucx_addr->remote_conn_id);
-
-        ret = na_ucp_msg_send(
-            na_ucx_addr->ucp_ep, buf, buf_size, ucp_tag, na_ucx_op_id);
-        NA_CHECK_SUBSYS_NA_ERROR(msg, release, ret, "Could not post msg send");
-    }
-
-    return NA_SUCCESS;
-
-release:
-    NA_UCX_OP_RELEASE(na_ucx_op_id);
-
-error:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
 na_ucx_rma(struct na_ucx_class NA_UNUSED *na_ucx_class, na_context_t *context,
     na_cb_type_t cb_type, na_cb_t callback, void *arg,
     struct na_ucx_mem_handle *local_mem_handle, na_offset_t local_offset,
@@ -2491,7 +2371,8 @@ na_ucx_rma(struct na_ucx_class NA_UNUSED *na_ucx_class, na_context_t *context,
         !(hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_COMPLETED), error,
         ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
         na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
-
+//  if (na_ucx_addr)
+//      NA_LOG_SUBSYS_WARNING(addr, "incrementing ep in ucx_rma: %lu, op_id: %p", na_ucx_addr->ucp_ep, na_ucx_op_id);
     NA_UCX_OP_RESET(na_ucx_op_id, context, cb_type, callback, arg, na_ucx_addr);
 
     na_ucx_op_id->info.rma.ucp_rma_op =
@@ -2575,137 +2456,6 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE void
-na_ucx_op_retry(
-    struct na_ucx_class *na_ucx_class, struct na_ucx_op_id *na_ucx_op_id)
-{
-    struct na_ucx_op_queue *retry_op_queue = &na_ucx_class->retry_op_queue;
-
-    NA_LOG_SUBSYS_DEBUG(op, "Pushing %p for retry (%s)", (void *) na_ucx_op_id,
-        na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
-
-    /* Push op ID to retry queue */
-    hg_thread_spin_lock(&retry_op_queue->lock);
-    HG_QUEUE_PUSH_TAIL(&retry_op_queue->queue, na_ucx_op_id, entry);
-    hg_atomic_set32(&na_ucx_op_id->status, NA_UCX_OP_QUEUED);
-    hg_thread_spin_unlock(&retry_op_queue->lock);
-}
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
-na_ucx_process_retries(struct na_ucx_class *na_ucx_class)
-{
-    struct na_ucx_op_queue *op_queue = &na_ucx_class->retry_op_queue;
-    struct na_ucx_op_id *na_ucx_op_id = NULL;
-    na_return_t ret = NA_SUCCESS;
-
-    do {
-        na_bool_t canceled = NA_FALSE;
-        na_cb_type_t cb_type;
-
-        hg_thread_spin_lock(&op_queue->lock);
-        na_ucx_op_id = HG_QUEUE_FIRST(&op_queue->queue);
-        if (!na_ucx_op_id) {
-            hg_thread_spin_unlock(&op_queue->lock);
-            /* Queue is empty */
-            break;
-        }
-
-        /* Check if OP ID was canceled */
-        if (hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_CANCELING) {
-            hg_atomic_or32(&na_ucx_op_id->status, NA_UCX_OP_CANCELED);
-            canceled = NA_TRUE;
-        } else if (hg_atomic_get32(&na_ucx_op_id->addr->status) !=
-                   NA_UCX_ADDR_RESOLVED) {
-            hg_thread_spin_unlock(&op_queue->lock);
-            break;
-        }
-
-        /* Dequeue OP ID */
-        HG_QUEUE_POP_HEAD(&op_queue->queue, entry);
-        hg_atomic_and32(&na_ucx_op_id->status, ~NA_UCX_OP_QUEUED);
-
-        hg_thread_spin_unlock(&op_queue->lock);
-
-        if (canceled) {
-            na_ucx_complete(na_ucx_op_id, NA_CANCELED);
-            /* Try again */
-            continue;
-        }
-
-        NA_LOG_SUBSYS_DEBUG(
-            op, "Attempting to retry %p", (void *) na_ucx_op_id);
-
-        cb_type = na_ucx_op_id->completion_data.callback_info.type;
-
-        /* Retry operation */
-        switch (cb_type) {
-            case NA_CB_SEND_UNEXPECTED:
-            case NA_CB_SEND_EXPECTED: {
-                ucp_tag_t ucp_tag = na_ucp_tag_gen(na_ucx_op_id->info.msg.tag,
-                    (cb_type == NA_CB_SEND_UNEXPECTED),
-                    na_ucx_op_id->addr->remote_conn_id);
-
-                ret = na_ucp_msg_send(na_ucx_op_id->addr->ucp_ep,
-                    na_ucx_op_id->info.msg.buf.const_ptr,
-                    na_ucx_op_id->info.msg.buf_size, ucp_tag, na_ucx_op_id);
-                NA_CHECK_SUBSYS_NA_ERROR(
-                    msg, error_retry, ret, "Could not post msg send operation");
-                break;
-            }
-            case NA_CB_RECV_EXPECTED: {
-                ucp_tag_t ucp_tag = na_ucp_tag_gen(na_ucx_op_id->info.msg.tag,
-                    NA_FALSE, na_ucx_op_id->addr->conn_id);
-
-                ret = na_ucp_msg_recv(na_ucx_class->ucp_worker,
-                    na_ucx_op_id->info.msg.buf.ptr,
-                    na_ucx_op_id->info.msg.buf_size, ucp_tag,
-                    NA_UCX_TAG_MASK | NA_UCX_TAG_SENDER_MASK, na_ucx_op_id,
-                    na_ucp_msg_recv_expected_cb, na_ucx_class);
-                NA_CHECK_SUBSYS_NA_ERROR(
-                    msg, error_retry, ret, "Could not post expected msg recv");
-                break;
-            }
-            case NA_CB_PUT:
-            case NA_CB_GET:
-                ret = na_ucx_op_id->info.rma.ucp_rma_op(
-                    na_ucx_op_id->addr->ucp_ep, na_ucx_op_id->info.rma.buf,
-                    na_ucx_op_id->info.rma.buf_size,
-                    na_ucx_op_id->info.rma.remote_addr,
-                    na_ucx_op_id->info.rma.remote_key, na_ucx_op_id);
-                NA_CHECK_SUBSYS_NA_ERROR(
-                    rma, error_retry, ret, "Could not post rma op");
-                break;
-            case NA_CB_RECV_UNEXPECTED:
-            default:
-                NA_GOTO_SUBSYS_ERROR(op, error, ret, NA_INVALID_ARG,
-                    "Operation type %s not supported",
-                    na_cb_type_to_string(cb_type));
-        }
-
-        /* If the operation got canceled while we retried it, attempt to
-         * cancel it */
-        if (hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_CANCELING) {
-            /* Do best effort to cancel the operation */
-            hg_atomic_or32(&na_ucx_op_id->status, NA_UCX_OP_CANCELED);
-            ucp_request_cancel(na_ucx_class->ucp_worker, (void *) na_ucx_op_id);
-        }
-    } while (1);
-
-    return NA_SUCCESS;
-
-error_retry:
-    /* Force internal completion in error mode */
-    hg_atomic_or32(&na_ucx_op_id->status, NA_UCX_OP_ERRORED);
-    na_ucx_complete(na_ucx_op_id, ret);
-
-    return NA_SUCCESS;
-
-error:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static NA_INLINE void
 na_ucx_complete(struct na_ucx_op_id *na_ucx_op_id, na_return_t cb_ret)
 {
     /* Mark op id as completed (independent of cb_ret) */
@@ -2730,6 +2480,8 @@ na_ucx_release(void *arg)
         "Releasing resources from an uncompleted operation");
 
     if (na_ucx_op_id && na_ucx_op_id->addr != NULL) {
+
+    	NA_LOG_SUBSYS_WARNING(addr, "decrementing ep in ucx_release: %lu, op_id: %p", na_ucx_op_id->addr->ucp_ep, na_ucx_op_id);
         na_ucx_addr_ref_decr(na_ucx_op_id->addr);
         na_ucx_op_id->addr = NULL;
     }
@@ -2743,8 +2495,8 @@ static na_bool_t
 na_ucx_check_protocol(const char *protocol_name)
 {
     ucp_config_t *config = NULL;
-    ucp_params_t params = {.field_mask = UCP_PARAM_FIELD_FEATURES,
-        .features = UCP_FEATURE_TAG | UCP_FEATURE_RMA | UCP_FEATURE_STREAM};
+    ucp_params_t params = {
+        .field_mask = UCP_PARAM_FIELD_FEATURES, .features = NA_UCX_FEATURES};
     ucp_context_h context = NULL;
     ucs_status_t status;
     na_bool_t accept = NA_FALSE;
@@ -2780,6 +2532,8 @@ na_ucx_initialize(
 #ifdef NA_UCX_HAS_LIB_QUERY
     ucp_lib_attr_t ucp_lib_attrs;
 #endif
+    char host_string[NI_MAXHOST];
+    char serv_string[NI_MAXSERV];
     char *net_device = NULL;
     struct sockaddr_storage *listen_ss_addr = NULL;
     struct sockaddr_storage ucp_listener_ss_addr;
@@ -2844,6 +2598,16 @@ na_ucx_initialize(
             ? na_info->na_init_info->ip_subnet
             : NULL,
         &net_device, (listen) ? &listen_ss_addr : NULL);
+	/*
+    char host_string[NI_MAXHOST];
+    char serv_string[NI_MAXSERV];
+
+    int rc = getnameinfo((const struct sockaddr *) listen_ss_addr,
+                         sizeof(struct sockaddr), host_string,
+			 sizeof(host_string), serv_string,
+			 sizeof(serv_string), NI_NUMERICHOST | NI_NUMERICSERV);
+    printf("net_device: %s, host: %s, serv: %s\n",  net_device, host_string, serv_string);
+    */
     NA_CHECK_SUBSYS_NA_ERROR(
         cls, error, ret, "na_ucx_parse_hostname_info() failed");
 
@@ -2874,8 +2638,8 @@ na_ucx_initialize(
         cls, error, ret, "Could not initialize UCX config");
 
     /* No longer needed */
-    free(net_device);
-    net_device = NULL;
+    //free(net_device);
+    //net_device = NULL;
 
     /* Create UCP context and release config */
     ret = na_ucp_context_create(config, no_wait, context_thread_mode,
@@ -2888,6 +2652,12 @@ na_ucx_initialize(
         &na_ucx_class->ucp_worker);
     NA_CHECK_SUBSYS_NA_ERROR(cls, error, ret, "Could not create UCX worker");
 
+    /* Set AM handler for unexpected messages */
+    ret = na_ucp_set_am_handler(
+        na_ucx_class->ucp_worker, na_ucp_am_recv_cb, (void *) na_ucx_class);
+    NA_CHECK_SUBSYS_NA_ERROR(
+        cls, error, ret, "Could not set handler for receiving active messages");
+
     /* Create listener if we're listening */
     if (listen) {
         ret = na_ucp_listener_create(na_ucx_class->ucp_worker,
@@ -2943,7 +2713,7 @@ na_ucx_initialize(
     return NA_SUCCESS;
 
 error:
-    free(net_device);
+    // free(net_device);
     free(listen_ss_addr);
     if (na_ucx_class)
         na_ucx_class_free(na_ucx_class);
@@ -2967,7 +2737,7 @@ na_ucx_finalize(na_class_t *na_class)
         hg_atomic_get32(&na_ucx_class->ncontexts));
 
     /* Iterate over remaining addresses and free them */
-    hg_hash_table_iterate(na_ucx_class->addr_map.map, &addr_table_iter);
+    hg_hash_table_iterate(na_ucx_class->addr_map.key_map, &addr_table_iter);
     while (hg_hash_table_iter_has_more(&addr_table_iter)) {
         struct na_ucx_addr *na_ucx_addr =
             (struct na_ucx_addr *) hg_hash_table_iter_next(&addr_table_iter);
@@ -2998,7 +2768,7 @@ na_ucx_op_create(na_class_t *na_class)
     struct na_ucx_op_id *na_ucx_op_id = NULL;
 
     /* When using UCP requests, OP IDs must have enough space to fit the
-     * UCP request data as a header */
+ *      * UCP request data as a header */
     na_ucx_op_id = hg_mem_header_alloc(NA_UCX_CLASS(na_class)->ucp_request_size,
         alignof(struct na_ucx_op_id), sizeof(*na_ucx_op_id));
     NA_CHECK_SUBSYS_ERROR_NORET(op, na_ucx_op_id == NULL, out,
@@ -3009,10 +2779,6 @@ na_ucx_op_create(na_class_t *na_class)
     /* Completed by default */
     hg_atomic_init32(&na_ucx_op_id->status, NA_UCX_OP_COMPLETED);
 
-    /* Set op ID release callbacks */
-    na_ucx_op_id->completion_data.plugin_callback = na_ucx_release;
-    na_ucx_op_id->completion_data.plugin_callback_args = na_ucx_op_id;
-
 out:
     return (na_op_id_t *) na_ucx_op_id;
 }
@@ -3088,8 +2854,8 @@ na_ucx_addr_lookup(na_class_t *na_class, const char *name, na_addr_t *addr_p)
             host_string);
 
         /* Insert new entry and create new address if needed */
-        na_ret = na_ucx_addr_map_insert(
-            na_ucx_class, &na_ucx_class->addr_map, &addr_key, &na_ucx_addr);
+        na_ret = na_ucx_addr_map_insert(na_ucx_class, &na_ucx_class->addr_map,
+            &addr_key, NULL, &na_ucx_addr);
         freeaddrinfo(hostname_res);
         NA_CHECK_SUBSYS_ERROR(addr, na_ret != NA_SUCCESS && na_ret != NA_EXIST,
             error, ret, na_ret, "Could not insert new address");
@@ -3112,7 +2878,11 @@ error:
 static NA_INLINE na_return_t
 na_ucx_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
+    struct na_ucx_addr* this_addr = (struct na_ucx_addr *) addr;
+
+    // NA_LOG_SUBSYS_WARNING(addr, "decrementing ep %lu in free, refcount: %d", this_addr->ucp_ep, this_addr->refcount);
     na_ucx_addr_ref_decr((struct na_ucx_addr *) addr);
+    // NA_LOG_SUBSYS_WARNING(addr, "decremented ep %lu in free, refcount: %d", this_addr->ucp_ep, this_addr->refcount);
 
     return NA_SUCCESS;
 }
@@ -3274,7 +3044,7 @@ na_ucx_addr_deserialize(na_class_t *na_class, na_addr_t *addr_p,
 error:
     if (na_ucx_addr)
         na_ucx_addr_destroy(na_ucx_addr);
-    if (worker_addr)
+    else if (worker_addr)
         free(worker_addr);
 
     return ret;
@@ -3345,14 +3115,41 @@ done:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucx_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
-    void NA_UNUSED *plugin_data, na_addr_t dest_addr,
+na_ucx_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
+    na_context_t *context, na_cb_t callback, void *arg, const void *buf,
+    na_size_t buf_size, void NA_UNUSED *plugin_data, na_addr_t dest_addr,
     na_uint8_t NA_UNUSED dest_id, na_tag_t tag, na_op_id_t *op_id)
 {
-    return na_ucx_msg_send(NA_UCX_CLASS(na_class), context,
-        NA_CB_SEND_UNEXPECTED, callback, arg, buf, buf_size,
-        (struct na_ucx_addr *) dest_addr, tag, (struct na_ucx_op_id *) op_id);
+    struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) dest_addr;
+    struct na_ucx_op_id *na_ucx_op_id = (struct na_ucx_op_id *) op_id;
+    na_return_t ret;
+
+    /* Check op_id */
+    NA_CHECK_SUBSYS_ERROR(op, na_ucx_op_id == NULL, error, ret, NA_INVALID_ARG,
+        "Invalid operation ID");
+    NA_CHECK_SUBSYS_ERROR(op,
+        !(hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_COMPLETED), error,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
+        na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
+
+    NA_UCX_OP_RESET(na_ucx_op_id, context, NA_CB_SEND_UNEXPECTED, callback, arg,
+        na_ucx_addr);
+
+    /* We assume buf remains valid (safe because we pre-allocate buffers) */
+    na_ucx_op_id->info.msg = (struct na_ucx_msg_info){
+        .buf.const_ptr = buf, .buf_size = buf_size, .tag = (ucp_tag_t) tag};
+
+    ret = na_ucp_am_send(na_ucx_addr->ucp_ep, buf, buf_size,
+        &na_ucx_op_id->info.msg.tag, na_ucx_op_id);
+    NA_CHECK_SUBSYS_NA_ERROR(msg, release, ret, "Could not post msg send");
+
+    return NA_SUCCESS;
+
+release:
+    NA_UCX_OP_RELEASE(na_ucx_op_id);
+
+error:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3372,37 +3169,59 @@ na_ucx_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
         ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
         na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
 
-    NA_UCX_OP_RESET_UNEXPECTED_RECV(na_ucx_op_id, context, callback, arg);
+    NA_UCX_OP_RESET(
+        na_ucx_op_id, context, NA_CB_RECV_UNEXPECTED, callback, arg, NULL);
 
     /* We assume buf remains valid (safe because we pre-allocate buffers) */
     na_ucx_op_id->info.msg = (struct na_ucx_msg_info){
-        .buf.ptr = buf, .buf_size = buf_size, .tag = 0};
+        .buf.ptr = buf, .buf_size = buf_size, .tag = (ucp_tag_t) 0};
 
-    ret = na_ucp_msg_recv(NA_UCX_CLASS(na_class)->ucp_worker, buf, buf_size,
-        NA_UCX_TAG_UNEXPECTED, NA_UCX_TAG_UNEXPECTED, na_ucx_op_id,
-        na_ucp_msg_recv_unexpected_cb, NA_UCX_CLASS(na_class));
-    NA_CHECK_SUBSYS_NA_ERROR(
-        msg, release, ret, "Could not post unexpected msg recv");
+    na_ucp_am_recv(NA_UCX_CLASS(na_class), na_ucx_op_id);
 
     return NA_SUCCESS;
 
-release:
-    NA_UCX_OP_RELEASE(na_ucx_op_id);
-
 error:
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ucx_msg_send_expected(na_class_t *na_class, na_context_t *context,
+na_ucx_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
     void NA_UNUSED *plugin_data, na_addr_t dest_addr,
     na_uint8_t NA_UNUSED dest_id, na_tag_t tag, na_op_id_t *op_id)
 {
-    return na_ucx_msg_send(NA_UCX_CLASS(na_class), context, NA_CB_SEND_EXPECTED,
-        callback, arg, buf, buf_size, (struct na_ucx_addr *) dest_addr, tag,
-        (struct na_ucx_op_id *) op_id);
+    struct na_ucx_addr *na_ucx_addr = (struct na_ucx_addr *) dest_addr;
+    struct na_ucx_op_id *na_ucx_op_id = (struct na_ucx_op_id *) op_id;
+    na_return_t ret;
+
+    /* Check op_id */
+    NA_CHECK_SUBSYS_ERROR(op, na_ucx_op_id == NULL, error, ret, NA_INVALID_ARG,
+        "Invalid operation ID");
+    NA_CHECK_SUBSYS_ERROR(op,
+        !(hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_COMPLETED), error,
+        ret, NA_BUSY, "Attempting to use OP ID that was not completed (%s)",
+        na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
+
+    // NA_LOG_SUBSYS_WARNING(addr, "In send exp, inc refcount for ep: %lu", na_ucx_addr->ucp_ep);
+    NA_UCX_OP_RESET(
+        na_ucx_op_id, context, NA_CB_SEND_EXPECTED, callback, arg, na_ucx_addr);
+
+    /* We assume buf remains valid (safe because we pre-allocate buffers) */
+    na_ucx_op_id->info.msg = (struct na_ucx_msg_info){
+        .buf.const_ptr = buf, .buf_size = buf_size, .tag = (ucp_tag_t) tag};
+
+    ret = na_ucp_msg_send(
+        na_ucx_addr->ucp_ep, buf, buf_size, (ucp_tag_t) tag, na_ucx_op_id);
+    NA_CHECK_SUBSYS_NA_ERROR(msg, release, ret, "Could not post msg send");
+
+    return NA_SUCCESS;
+
+release:
+    NA_UCX_OP_RELEASE(na_ucx_op_id);
+
+error:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3426,30 +3245,15 @@ na_ucx_msg_recv_expected(na_class_t *na_class, na_context_t *context,
 
     NA_UCX_OP_RESET(
         na_ucx_op_id, context, NA_CB_RECV_EXPECTED, callback, arg, na_ucx_addr);
-    na_ucx_op_id->completion_data.callback_info.info.recv_expected =
-        (struct na_cb_info_recv_expected){.actual_buf_size = 0};
 
     /* We assume buf remains valid (safe because we pre-allocate buffers) */
     na_ucx_op_id->info.msg = (struct na_ucx_msg_info){
-        .buf.ptr = buf, .buf_size = buf_size, .tag = tag};
-
-    if (hg_atomic_get32(&na_ucx_addr->status) != NA_UCX_ADDR_RESOLVED) {
-        ret = na_ucx_addr_resolve(NA_UCX_CLASS(na_class), na_ucx_addr);
-        NA_CHECK_SUBSYS_NA_ERROR(
-            msg, release, ret, "Could not resolve address");
-
-        na_ucx_op_retry(NA_UCX_CLASS(na_class), na_ucx_op_id);
-    } else {
-        ucp_tag_t ucp_tag = na_ucp_tag_gen(tag, NA_FALSE, na_ucx_addr->conn_id);
-
-        ret = na_ucp_msg_recv(NA_UCX_CLASS(na_class)->ucp_worker, buf, buf_size,
-            ucp_tag, NA_UCX_TAG_MASK | NA_UCX_TAG_SENDER_MASK, na_ucx_op_id,
-            na_ucp_msg_recv_expected_cb, NA_UCX_CLASS(na_class));
-        NA_CHECK_SUBSYS_NA_ERROR(
-            msg, release, ret, "Could not post expected msg recv");
-    }
+        .buf.ptr = buf, .buf_size = buf_size, .tag = (ucp_tag_t) tag};
 
-    NA_LOG_SUBSYS_DEBUG(msg, "Posted recv");
+    ret = na_ucp_msg_recv(NA_UCX_CLASS(na_class)->ucp_worker, buf, buf_size,
+        (ucp_tag_t) tag, na_ucx_op_id);
+    NA_CHECK_SUBSYS_NA_ERROR(
+        msg, release, ret, "Could not post expected msg recv");
 
     return NA_SUCCESS;
 
@@ -3754,18 +3558,10 @@ na_ucx_poll_try_wait(na_class_t *na_class, na_context_t NA_UNUSED *context)
 {
     struct na_ucx_class *na_ucx_class = NA_UCX_CLASS(na_class);
     ucs_status_t status;
-    na_bool_t retry_queue_empty;
 
     if (na_ucx_class->no_wait)
         return NA_FALSE;
 
-    /* Keep making progress if retry queue is not empty */
-    hg_thread_spin_lock(&na_ucx_class->retry_op_queue.lock);
-    retry_queue_empty = HG_QUEUE_IS_EMPTY(&na_ucx_class->retry_op_queue.queue);
-    hg_thread_spin_unlock(&na_ucx_class->retry_op_queue.lock);
-    if (!retry_queue_empty)
-        return NA_FALSE;
-
     status = ucp_worker_arm(na_ucx_class->ucp_worker);
     if (status == UCS_ERR_BUSY) {
         /* Events have already arrived */
@@ -3779,27 +3575,19 @@ na_ucx_poll_try_wait(na_class_t *na_class, na_context_t NA_UNUSED *context)
     return NA_TRUE;
 }
 
-/*---------------------------------------------------------------------------*/
-static na_return_t
+
+/*---------------------------------------------------------------------------*/static na_return_t
 na_ucx_progress(na_class_t *na_class, na_context_t NA_UNUSED *context,
     unsigned int timeout_ms)
 {
     hg_time_t deadline, now = hg_time_from_ms(0);
-    na_return_t ret;
 
     if (timeout_ms != 0)
         hg_time_get_current_ms(&now);
     deadline = hg_time_add(now, hg_time_from_ms(timeout_ms));
 
     do {
-        unsigned int progressed =
-            ucp_worker_progress(NA_UCX_CLASS(na_class)->ucp_worker);
-
-        /* Attempt to process retries */
-        ret = na_ucx_process_retries(NA_UCX_CLASS(na_class));
-        NA_CHECK_SUBSYS_NA_ERROR(poll, error, ret, "Could not process retries");
-
-        if (progressed != 0)
+        if (ucp_worker_progress(NA_UCX_CLASS(na_class)->ucp_worker) != 0)
             return NA_SUCCESS;
 
         if (timeout_ms != 0)
@@ -3807,9 +3595,6 @@ na_ucx_progress(na_class_t *na_class, na_context_t NA_UNUSED *context,
     } while (hg_time_less(now, deadline));
 
     return NA_TIMEOUT;
-
-error:
-    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3818,6 +3603,7 @@ na_ucx_cancel(
     na_class_t *na_class, na_context_t NA_UNUSED *context, na_op_id_t *op_id)
 {
     struct na_ucx_op_id *na_ucx_op_id = (struct na_ucx_op_id *) op_id;
+    na_cb_type_t cb_type;
     int32_t status;
 
     /* Exit if op has already completed */
@@ -3826,21 +3612,22 @@ na_ucx_cancel(
         (status & NA_UCX_OP_CANCELED) || (status & NA_UCX_OP_CANCELING))
         return NA_SUCCESS;
 
+    cb_type = na_ucx_op_id->completion_data.callback_info.type;
     NA_LOG_SUBSYS_DEBUG(op, "Canceling operation ID %p (%s)",
-        (void *) na_ucx_op_id,
-        na_cb_type_to_string(na_ucx_op_id->completion_data.callback_info.type));
+        (void *) na_ucx_op_id, na_cb_type_to_string(cb_type));
 
     /* Must set canceling before we check for the retry queue */
     hg_atomic_or32(&na_ucx_op_id->status, NA_UCX_OP_CANCELING);
 
-    /* Check if op_id is in retry queue */
-    if (hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_QUEUED) {
+    /* Check if op_id is in unexpected op queue */
+    if ((cb_type == NA_CB_RECV_UNEXPECTED) &&
+        (hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_QUEUED)) {
         struct na_ucx_op_queue *op_queue =
-            &NA_UCX_CLASS(na_class)->retry_op_queue;
+            &NA_UCX_CLASS(na_class)->unexpected_op_queue;
         na_bool_t canceled = NA_FALSE;
 
         /* If dequeued by process_retries() in the meantime, we'll just let it
-         * cancel there */
+ *          * cancel there */
 
         hg_thread_spin_lock(&op_queue->lock);
         if (hg_atomic_get32(&na_ucx_op_id->status) & NA_UCX_OP_QUEUED) {
