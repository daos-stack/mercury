diff --git a/Testing/CMakeLists.txt b/Testing/CMakeLists.txt
index b551008..4147f47 100644
--- a/Testing/CMakeLists.txt
+++ b/Testing/CMakeLists.txt
@@ -267,18 +267,14 @@ build_mercury_test(server)
 set(MERCURY_tests
   rpc
   bulk
-  overflow
 )
-if(NOT WIN32)
-  set(MERCURY_tests ${MERCURY_tests} posix)
-endif()
-#build_mercury_test(nested)
-build_mercury_test(cancel)
-build_mercury_test(perf)
+
+# Benchmarks
 build_mercury_test(rpc_lat)
 build_mercury_test(write_bw)
 build_mercury_test(read_bw)
-#build_mercury_test(init)
+
+# Cray DRC test
 if(HG_TESTING_HAS_CRAY_DRC)
   build_mercury_test(drc_auth)
 endif()
diff --git a/Testing/mercury_rpc_cb.c b/Testing/mercury_rpc_cb.c
index 5279c7f..45bdbf9 100644
--- a/Testing/mercury_rpc_cb.c
+++ b/Testing/mercury_rpc_cb.c
@@ -410,7 +410,7 @@ hg_test_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info)
         /* Fill output structure */
         out_struct.ret = 0;
     } else if (hg_cb_info->ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in callback");
+        HG_TEST_LOG_ERROR("Error in callback");
         ret = HG_PROTOCOL_ERROR;
         goto done;
     }
@@ -480,7 +480,7 @@ hg_test_bulk_bind_transfer_cb(const struct hg_cb_info *hg_cb_info)
         /* Fill output structure */
         out_struct.ret = 0;
     } else if (hg_cb_info->ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in callback");
+        HG_TEST_LOG_ERROR("Error in callback");
         ret = HG_PROTOCOL_ERROR;
         goto done;
     }
diff --git a/Testing/mercury_test.c b/Testing/mercury_test.c
index 0cd4be3..69b4734 100644
--- a/Testing/mercury_test.c
+++ b/Testing/mercury_test.c
@@ -61,6 +61,11 @@ hg_test_register(hg_class_t *hg_class);
 /* Local Variables */
 /*******************/
 
+/* Default error log mask */
+#ifdef HG_HAS_VERBOSE_ERROR
+unsigned int HG_TEST_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
+#endif
+
 extern int na_test_opt_ind_g; /* token pointer */
 extern const char *na_test_opt_arg_g; /* flag argument (or value) */
 extern const char *na_test_short_opt_g;
@@ -158,15 +163,12 @@ hg_test_parse_options(int argc, char *argv[], struct hg_test_info *hg_test_info)
 static hg_return_t
 hg_test_handle_create_cb(hg_handle_t handle, void *arg)
 {
-    struct hg_thread_work *hg_thread_work =
-        malloc(sizeof(struct hg_thread_work));
+    struct hg_thread_work *hg_thread_work;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_thread_work) {
-        HG_LOG_ERROR("Could not allocate hg_thread_work");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    hg_thread_work = malloc(sizeof(struct hg_thread_work));
+    HG_TEST_CHECK_ERROR(hg_thread_work == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate hg_thread_work");
 
     (void) arg;
     HG_Set_data(handle, hg_thread_work, free);
@@ -181,42 +183,33 @@ static hg_return_t
 hg_test_finalize_rpc(struct hg_test_info *hg_test_info, hg_uint8_t target_id)
 {
     hg_request_t *request_object = NULL;
-    hg_handle_t handle;
+    hg_handle_t handle = HG_HANDLE_NULL;
     hg_return_t ret = HG_SUCCESS;
 
     request_object = hg_request_create(hg_test_info->request_class);
 
     ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
         hg_test_finalize_id_g, &handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not create HG handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Set target ID */
     ret = HG_Set_target_id(handle, target_id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set HG handle target ID");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Forward call to target addr */
     ret = HG_Forward(handle, hg_test_finalize_rpc_cb, request_object, NULL);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not forward finalize call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request_object, HG_MAX_IDLE_TIME, NULL);
 
-    /* Complete */
+done:
     ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
-done:
     hg_request_destroy(request_object);
 
     return ret;
@@ -248,18 +241,14 @@ hg_test_finalize_cb(hg_handle_t handle)
 
     /* Free handle and send response back */
     ret = HG_Respond(handle, NULL, NULL, NULL);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not respond");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
+        HG_Error_to_string(ret));
 
+done:
     ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
-done:
     return ret;
 }
 
@@ -336,6 +325,15 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     struct hg_init_info hg_init_info;
     struct hg_test_context_info *hg_test_context_info;
     hg_return_t ret = HG_SUCCESS;
+    na_return_t na_ret;
+#ifdef HG_HAS_VERBOSE_ERROR
+    const char *log_level = NULL;
+
+    /* Set log level */
+    log_level = getenv("HG_TEST_LOG_LEVEL");
+    if (log_level && (strcmp(log_level, "debug") == 0))
+        HG_TEST_LOG_MASK |= HG_LOG_TYPE_DEBUG;
+#endif
 
     /* Get HG test options */
     hg_test_parse_options(argc, argv, hg_test_info);
@@ -345,10 +343,9 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         char hg_test_drc_key[NA_TEST_MAX_ADDR_NAME] = { '\0' };
 
         ret = hg_test_drc_acquire(argc, argv, hg_test_info);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not acquire DRC auth key");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "hg_test_drc_acquire() failed (%s)",
+            HG_Error_to_string(ret));
+
         sprintf(hg_test_drc_key, "%u", hg_test_info->cookie);
         hg_test_info->na_test_info.key = strdup(hg_test_drc_key);
 #endif
@@ -356,11 +353,9 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
     /* Initialize NA test layer */
     hg_test_info->na_test_info.extern_init = NA_TRUE;
-    if (NA_Test_init(argc, argv, &hg_test_info->na_test_info) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not initialize NA test layer");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    na_ret = NA_Test_init(argc, argv, &hg_test_info->na_test_info);
+    HG_TEST_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "NA_Test_init() failed (%s)",  NA_Error_to_string(na_ret));
 
     memset(&hg_init_info, 0, sizeof(struct hg_init_info));
 
@@ -390,28 +385,22 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     /* Init HG with init options */
     hg_test_info->hg_class = HG_Init_opt(NULL,
         hg_test_info->na_test_info.listen, &hg_init_info);
-    if (!hg_test_info->hg_class) {
-        HG_LOG_ERROR("Could not initialize HG");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_test_info->hg_class == NULL, done, ret, HG_FAULT,
+        "HG_Init_opt() failed (%s)");
     HG_CLASS_DEFAULT = hg_test_info->hg_class;
 
     /* Attach test info to class */
     ret = HG_Class_set_data(hg_test_info->hg_class, hg_test_info, NULL);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set HG class data");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Class_set_data() failed (%s)",
+        HG_Error_to_string(ret));
 
 #ifdef MERCURY_TESTING_HAS_THREAD_POOL
     /* Attach handle created */
     ret = HG_Class_set_handle_create_callback(hg_test_info->hg_class,
         hg_test_handle_create_cb, hg_test_info->hg_class);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set HG handle create callback");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret,
+        "HG_Class_set_handle_create_callback() failed (%s)",
+        HG_Error_to_string(ret));
 #endif
 
     /* Set header */
@@ -423,26 +412,21 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     /* For convenience */
     ret = HG_Hl_init_opt(NULL, hg_test_info->na_test_info.listen,
         &hg_init_info);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not initialize HG HL");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_init_opt() failed (%s)",
+        HG_Error_to_string(ret));
+
     hg_test_info->context = HG_CONTEXT_DEFAULT;
     hg_test_info->request_class = HG_REQUEST_CLASS_DEFAULT;
 
     /* Attach context info to context */
     hg_test_context_info = malloc(sizeof(struct hg_test_context_info));
-    if (!hg_test_context_info) {
-        HG_LOG_ERROR("Could not allocate HG test context info");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_test_context_info == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate HG test context info");
+
     hg_atomic_set32(&hg_test_context_info->finalizing, 0);
     ret = HG_Context_set_data(hg_test_info->context, hg_test_context_info, free);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set context data");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_set_data() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Register routines */
     hg_test_register(hg_test_info->hg_class);
@@ -474,16 +458,13 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         ret = HG_Bulk_create(hg_test_info->hg_class, 1, NULL,
             (hg_size_t *) &bulk_size, HG_BULK_READWRITE,
             &hg_test_info->bulk_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not create bulk handle");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+            HG_Error_to_string(ret));
+
         ret = HG_Bulk_access(hg_test_info->bulk_handle, 0, bulk_size,
             HG_BULK_READWRITE, 1, (void **) &buf_ptr, NULL, NULL);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not access bulk handle");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_access() failed (%s)",
+            HG_Error_to_string(ret));
         for (i = 0; i < bulk_size; i++)
             buf_ptr[i] = (char) i;
     }
@@ -501,57 +482,42 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
             hg_test_info->secondary_contexts = malloc(
                 secondary_contexts_count * sizeof(hg_context_t *));
-            if (!hg_test_info->secondary_contexts) {
-                HG_LOG_ERROR("Could not allocate secondary contexts");
-                ret = HG_NOMEM_ERROR;
-                goto done;
-            }
+            HG_TEST_CHECK_ERROR(hg_test_info->secondary_contexts == NULL, done,
+                ret, HG_NOMEM_ERROR, "Could not allocate secondary contexts");
             for (i = 0; i < secondary_contexts_count; i++) {
                 hg_uint8_t context_id = (hg_uint8_t) (i + 1);
                 hg_test_info->secondary_contexts[i] =
                     HG_Context_create_id(hg_test_info->hg_class, context_id);
-                if (!hg_test_info->secondary_contexts[i]) {
-                    HG_LOG_ERROR("Could not create HG context for id: %u", i);
-                    ret = HG_NOMEM_ERROR;
-                    goto done;
-                }
+                HG_TEST_CHECK_ERROR(hg_test_info->secondary_contexts[i] == NULL,
+                    done, ret, HG_FAULT, "HG_Context_create_id() failed");
 
                 /* Attach context info to context */
-                hg_test_context_info = malloc(sizeof(struct hg_test_context_info));
-                if (!hg_test_context_info) {
-                    HG_LOG_ERROR("Could not allocate context info");
-                    ret = HG_NOMEM_ERROR;
-                    goto done;
-                }
+                hg_test_context_info = malloc(
+                    sizeof(struct hg_test_context_info));
+                HG_TEST_CHECK_ERROR(hg_test_context_info == NULL, done, ret,
+                    HG_NOMEM_ERROR, "Could not allocate HG test context info");
+
                 hg_atomic_set32(&hg_test_context_info->finalizing, 0);
                 ret = HG_Context_set_data(hg_test_info->secondary_contexts[i],
                     hg_test_context_info, free);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not set HG context data");
-                    goto done;
-                }
+                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_set_data() failed"
+                    " (%s)", HG_Error_to_string(ret));
             }
         }
 
         /* TODO only rank 0 */
         ret = HG_Addr_self(hg_test_info->hg_class, &self_addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get HG self addr");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_self() failed (%s)",
+            HG_Error_to_string(ret));
 
         ret = HG_Addr_to_string(hg_test_info->hg_class, addr_string,
             &addr_string_len, self_addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not convert addr to string");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_to_string() failed (%s)",
+            HG_Error_to_string(ret));
 
         ret = HG_Addr_free(hg_test_info->hg_class, self_addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not free addr");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_free() failed (%s)",
+            HG_Error_to_string(ret));
 
         na_test_set_config(addr_string);
 
@@ -566,10 +532,8 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     } else if (hg_test_info->na_test_info.self_send) {
         /* Self addr is target */
         ret = HG_Addr_self(hg_test_info->hg_class, &hg_test_info->target_addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get HG self addr");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_self() failed (%s)",
+            HG_Error_to_string(ret));
     } else {
         char test_addr_name[NA_TEST_MAX_ADDR_NAME] = { '\0' };
 
@@ -588,6 +552,8 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
             &hg_test_info->na_test_info);
 
         hg_test_info->na_test_info.target_name = strdup(test_addr_name);
+        HG_TEST_CHECK_ERROR(hg_test_info->na_test_info.target_name == NULL,
+            done, ret, HG_NOMEM_ERROR, "Could not dup test_addr_name");
         printf("# Target name read: %s\n",
             hg_test_info->na_test_info.target_name);
 
@@ -595,11 +561,8 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         ret = HG_Hl_addr_lookup_wait(hg_test_info->context,
             hg_test_info->request_class, hg_test_info->na_test_info.target_name,
             &hg_test_info->target_addr, HG_MAX_IDLE_TIME);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not lookup addr for target %s",
-                hg_test_info->na_test_info.target_name);
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_addr_lookup_wait() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
 done:
@@ -627,10 +590,8 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
 
         /* Free addr id */
         ret = HG_Addr_free(hg_test_info->hg_class, hg_test_info->target_addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not free addr");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_free() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     NA_Test_barrier(&hg_test_info->na_test_info);
@@ -638,11 +599,16 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
     if (hg_test_info->na_test_info.listen
         || hg_test_info->na_test_info.self_send) {
 #ifdef MERCURY_TESTING_HAS_THREAD_POOL
+        /* Give some time before shutting down */
+        sleep(1);
+
         hg_thread_pool_destroy(hg_test_info->thread_pool);
         hg_thread_mutex_destroy(&hg_test_info->bulk_handle_mutex);
 #endif
         /* Destroy bulk handle */
-        HG_Bulk_free(hg_test_info->bulk_handle);
+        ret = HG_Bulk_free(hg_test_info->bulk_handle);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+            HG_Error_to_string(ret));
 
         /* Destroy secondary contexts */
         if (hg_test_info->secondary_contexts) {
@@ -652,10 +618,8 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
 
             for (i = 0; i < secondary_contexts_count; i++) {
                 ret = HG_Context_destroy(hg_test_info->secondary_contexts[i]);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not destroy HG context for id: %u", i);
-                    goto done;
-                }
+                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_destroy() failed"
+                    " (%s)", HG_Error_to_string(ret));
             }
             free(hg_test_info->secondary_contexts);
         }
@@ -663,22 +627,19 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
 
     /* Finalize interface */
     ret = HG_Hl_finalize();
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize HG Hl");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_finalize() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Finalize NA test interface */
     na_ret = NA_Test_finalize(&hg_test_info->na_test_info);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize NA test interface");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "NA_Test_finalize() failed (%s)", NA_Error_to_string(na_ret));
 
     if (hg_test_info->auth) {
 #ifdef HG_TESTING_HAS_CRAY_DRC
-        hg_test_drc_release(hg_test_info);
+        ret = hg_test_drc_release(hg_test_info);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "hg_test_drc_release() failed (%s)",
+            HG_Error_to_string(ret));
 #endif
     }
 
diff --git a/Testing/mercury_test.h b/Testing/mercury_test.h
index e74fffe..a7cff08 100644
--- a/Testing/mercury_test.h
+++ b/Testing/mercury_test.h
@@ -12,6 +12,7 @@
 #define MERCURY_TEST_H
 
 #include "na_test.h"
+
 #include "mercury.h"
 #include "mercury_request.h"
 #ifdef MERCURY_TESTING_HAS_THREAD_POOL
@@ -66,35 +67,106 @@ struct hg_test_context_info {
 /* Public Macros */
 /*****************/
 
+/* Number of threads */
+#define MERCURY_TESTING_NUM_THREADS_DEFAULT 8
+
 /* Default error macro */
 #ifdef HG_HAS_VERBOSE_ERROR
-  #include <mercury_log.h>
-  #define HG_TEST_LOG_MODULE_NAME "HG Test"
-  #define HG_TEST_LOG_ERROR(...)                                \
-      HG_LOG_WRITE_ERROR(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-  #define HG_TEST_LOG_WARNING(...)                              \
-      HG_LOG_WRITE_WARNING(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
+# include <mercury_log.h>
+# define HG_TEST_LOG_MASK hg_test_log_mask
+/* Log mask will be initialized in init routine */
+extern unsigned int HG_TEST_LOG_MASK;
+# define HG_TEST_LOG_MODULE_NAME "HG Test"
+# define HG_TEST_LOG_ERROR(...) do {                                \
+    if (HG_TEST_LOG_MASK & HG_LOG_TYPE_ERROR)                       \
+        HG_LOG_WRITE_ERROR(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__);   \
+} while (0)
+# define HG_TEST_LOG_DEBUG(...) do {                                \
+    if (HG_TEST_LOG_MASK & HG_LOG_TYPE_DEBUG)                       \
+        HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__);   \
+} while (0)
+# define HG_TEST_LOG_WARNING(...) do {                              \
+    if (HG_TEST_LOG_MASK & HG_LOG_TYPE_WARNING)                     \
+        HG_LOG_WRITE_WARNING(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__); \
+} while (0)
 #else
-  #define HG_TEST_LOG_ERROR(...) (void)0
-  #define HG_TEST_LOG_WARNING(...) (void)0
+# define HG_TEST_LOG_ERROR(...)     (void)0
+# define HG_TEST_LOG_DEBUG(...)     (void)0
+# define HG_TEST_LOG_WARNING(...)   (void)0
 #endif
 
-#define HG_TEST(x) do {         \
-    printf("Testing %-62s", x); \
-    fflush(stdout);             \
+/* Branch predictor hints */
+#ifndef _WIN32
+# define likely(x)       __builtin_expect(!!(x), 1)
+# define unlikely(x)     __builtin_expect(!!(x), 0)
+#else
+# define likely(x)       (x)
+# define unlikely(x)     (x)
+#endif
+
+/* Error macros */
+#define HG_TEST_GOTO_DONE(label, ret, ret_val) do {             \
+    ret = ret_val;                                              \
+    goto label;                                                 \
 } while (0)
 
-#define HG_PASSED() do {        \
-    puts(" PASSED");            \
-    fflush(stdout);             \
+#define HG_TEST_GOTO_ERROR(label, ret, err_val, ...) do {       \
+    HG_LOG_ERROR(__VA_ARGS__);                                  \
+    ret = err_val;                                              \
+    goto label;                                                 \
 } while (0)
 
-#define HG_FAILED() do {        \
-    puts("*FAILED*");           \
-    fflush(stdout);             \
+/* Check for hg_ret value and goto label */
+#define HG_TEST_CHECK_HG_ERROR(label, hg_ret, ...) do {         \
+    if (unlikely(hg_ret != HG_SUCCESS)) {                       \
+        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
+        goto label;                                             \
+    }                                                           \
 } while (0)
 
-#define MERCURY_TESTING_NUM_THREADS_DEFAULT 8
+/* Check for cond, set ret to err_val and goto label */
+#define HG_TEST_CHECK_ERROR(cond, label, ret, err_val, ...) do {\
+    if (unlikely(cond)) {                                       \
+        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
+        ret = err_val;                                          \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define HG_TEST_CHECK_ERROR_NORET(cond, label, ...) do {        \
+    if (unlikely(cond)) {                                       \
+        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define HG_TEST_CHECK_ERROR_DONE(cond, ...) do {                \
+    if (unlikely(cond)) {                                       \
+        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
+    }                                                           \
+} while (0)
+
+/* Check for cond and print warning */
+#define HG_TEST_CHECK_WARNING(cond, ...) do {                   \
+    if (unlikely(cond)) {                                       \
+        HG_TEST_LOG_WARNING(__VA_ARGS__);                       \
+    }                                                           \
+} while (0)
+
+#define HG_TEST(x) do {                                         \
+    printf("Testing %-62s", x);                                 \
+    fflush(stdout);                                             \
+} while (0)
+
+#define HG_PASSED() do {                                        \
+    puts(" PASSED");                                            \
+    fflush(stdout);                                             \
+} while (0)
+
+#define HG_FAILED() do {                                        \
+    puts("*FAILED*");                                           \
+    fflush(stdout);                                             \
+} while (0)
 
 /*********************/
 /* Public Prototypes */
diff --git a/Testing/mercury_test_drc.c b/Testing/mercury_test_drc.c
index b383c1d..2fbede4 100644
--- a/Testing/mercury_test_drc.c
+++ b/Testing/mercury_test_drc.c
@@ -125,7 +125,7 @@ hg_proc_hg_test_drc_grant_in_t(hg_proc_t proc, void *data)
 
     ret = hg_proc_hg_uint32_t(proc, &struct_data->wlm_id);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+        HG_TEST_LOG_ERROR("Proc error");
         goto done;
     }
 
@@ -143,13 +143,13 @@ hg_proc_hg_test_drc_grant_out_t(hg_proc_t proc, void *data)
 #ifdef HG_TEST_DRC_USE_TOKEN
     ret = hg_proc_hg_string_t(proc, &struct_data->token);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+        HG_TEST_LOG_ERROR("Proc error");
         goto done;
     }
 #else
     ret = hg_proc_hg_uint32_t(proc, &struct_data->credential);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+        HG_TEST_LOG_ERROR("Proc error");
         goto done;
     }
 #endif
@@ -183,7 +183,7 @@ hg_test_drc_grant_cb(hg_handle_t handle)
     /* Get input buffer */
     ret = HG_Get_input(handle, &in_struct);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get input");
+        HG_TEST_LOG_ERROR("Could not get input");
         goto done;
     }
 
@@ -202,7 +202,7 @@ drc_grant_again:
             sleep(1);
             goto drc_grant_again;
         }
-        HG_LOG_ERROR("drc_grant() to %d failed (%d, %s)", hg_test_info->wlm_id,
+        HG_TEST_LOG_ERROR("drc_grant() to %d failed (%d, %s)", hg_test_info->wlm_id,
             rc, drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -214,7 +214,7 @@ drc_grant_again:
 #ifndef HG_TEST_DRC_IGNORE
     rc = drc_get_credential_token(hg_test_info->credential, &token);
     if (rc != DRC_SUCCESS) {
-        HG_LOG_ERROR("drc_get_credential_token() failed (%d, %s)", rc,
+        HG_TEST_LOG_ERROR("drc_get_credential_token() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -234,7 +234,7 @@ drc_grant_again:
     /* Free handle and send response back */
     ret = HG_Respond(handle, NULL, NULL, &out_struct);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not respond");
+        HG_TEST_LOG_ERROR("Could not respond");
         goto done;
     }
 
@@ -264,7 +264,7 @@ drc_acquire_again:
                 sleep(1);
                 goto drc_acquire_again;
             }
-            HG_LOG_ERROR("drc_acquire() failed (%d, %s)", rc, drc_strerror(-rc));
+            HG_TEST_LOG_ERROR("drc_acquire() failed (%d, %s)", rc, drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
         }
@@ -284,7 +284,7 @@ drc_access_again:
             sleep(1);
             goto drc_access_again;
         }
-        HG_LOG_ERROR("drc_access() failed (%d, %s)", rc,
+        HG_TEST_LOG_ERROR("drc_access() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -329,7 +329,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
         hg_test_info->request_class, hg_test_info->na_test_info.target_name,
         &hg_test_info->target_addr, HG_MAX_IDLE_TIME);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not find addr for target %s",
+        HG_TEST_LOG_ERROR("Could not find addr for target %s",
             hg_test_info->na_test_info.target_name);
         goto done;
     }
@@ -341,7 +341,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
     ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
         hg_test_drc_grant_id_g, &handle);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not create handle");
+        HG_TEST_LOG_ERROR("Could not create handle");
         goto done;
     }
 
@@ -357,7 +357,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
     fflush(stdout);
     ret = HG_Forward(handle, hg_test_drc_token_request_cb, request, &in_struct);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not forward call with id=%d",
+        HG_TEST_LOG_ERROR("Could not forward call with id=%d",
             hg_test_drc_grant_id_g);
         goto done;
     }
@@ -368,7 +368,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
     /* Get output */
     ret = HG_Get_output(handle, &out_struct);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get output");
+        HG_TEST_LOG_ERROR("Could not get output");
         goto done;
     }
 
@@ -382,7 +382,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
 #ifndef HG_TEST_DRC_IGNORE
     rc = drc_access_with_token(token, 0, &hg_test_info->credential_info);
     if (rc != DRC_SUCCESS) {/* failed to grant access to the credential */
-        HG_LOG_ERROR("drc_access_with_token() failed (%d, %s)", rc,
+        HG_TEST_LOG_ERROR("drc_access_with_token() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -403,7 +403,7 @@ drc_access_again:
             sleep(1);
             goto drc_access_again;
         }
-        HG_LOG_ERROR("drc_access() failed (%d, %s)", rc,
+        HG_TEST_LOG_ERROR("drc_access() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -423,13 +423,13 @@ drc_access_again:
     /* Clean up resources */
     ret = HG_Free_output(handle, &out_struct);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free output");
+        HG_TEST_LOG_ERROR("Could not free output");
         goto done;
     }
 
     ret = HG_Destroy(handle);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy handle");
+        HG_TEST_LOG_ERROR("Could not destroy handle");
         goto done;
     }
 
@@ -438,7 +438,7 @@ drc_access_again:
     /* Free target addr */
     ret = HG_Addr_free(hg_test_info->hg_class, hg_test_info->target_addr);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free addr");
+        HG_TEST_LOG_ERROR("Could not free addr");
         goto done;
     }
 
@@ -454,7 +454,7 @@ hg_test_drc_token_request_cb(const struct hg_cb_info *callback_info)
     hg_return_t ret = HG_SUCCESS;
 
     if (callback_info->ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Return from callback info is not HG_SUCCESS");
+        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
         goto done;
     }
 
@@ -477,7 +477,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     hg_test_drc_info.na_test_info.protocol = strdup("tcp");
     hg_test_drc_info.na_test_info.listen = hg_test_info->na_test_info.listen;
     if (NA_Test_init(argc, argv, &hg_test_drc_info.na_test_info) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not initialize NA test layer");
+        HG_TEST_LOG_ERROR("Could not initialize NA test layer");
         ret = HG_NA_ERROR;
         goto done;
     }
@@ -489,7 +489,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     ret = HG_Hl_init_opt(NULL, hg_test_drc_info.na_test_info.listen,
         &hg_test_drc_init_info);
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not initialize HG HL");
+        HG_TEST_LOG_ERROR("Could not initialize HG HL");
         goto done;
     }
     hg_test_drc_info.hg_class = HG_CLASS_DEFAULT;
@@ -510,21 +510,21 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
         ret = hg_test_drc_token_acquire(&hg_test_drc_info);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not acquire DRC token");
+            HG_TEST_LOG_ERROR("Could not acquire DRC token");
             goto done;
         }
 
         /* TODO only rank 0 */
         ret = HG_Addr_self(hg_test_drc_info.hg_class, &self_addr);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get self addr");
+            HG_TEST_LOG_ERROR("Could not get self addr");
             goto done;
         }
 
         ret = HG_Addr_to_string(hg_test_drc_info.hg_class, addr_string,
             &addr_string_len, self_addr);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not convert addr to string");
+            HG_TEST_LOG_ERROR("Could not convert addr to string");
             goto done;
         }
         HG_Addr_free(hg_test_drc_info.hg_class, self_addr);
@@ -566,7 +566,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
         ret = hg_test_drc_token_request(&hg_test_drc_info);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not request DRC token");
+            HG_TEST_LOG_ERROR("Could not request DRC token");
             goto done;
         }
     }
@@ -578,7 +578,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     /* Finalize HG HL interface */
     ret = HG_Hl_finalize();
     if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize HG HL");
+        HG_TEST_LOG_ERROR("Could not finalize HG HL");
         goto done;
     }
 
@@ -587,7 +587,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     hg_test_drc_info.na_test_info.mpi_no_finalize = NA_TRUE;
 #endif
     if (NA_Test_finalize(&hg_test_drc_info.na_test_info) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize NA test interface");
+        HG_TEST_LOG_ERROR("Could not finalize NA test interface");
         ret = HG_NA_ERROR;
         goto done;
     }
@@ -596,7 +596,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
         hg_test_drc_info.credential = hg_test_info->credential;
         ret = hg_test_drc_token_acquire(&hg_test_drc_info);
         if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not acquire DRC token");
+            HG_TEST_LOG_ERROR("Could not acquire DRC token");
             goto done;
         }
     }
@@ -633,7 +633,7 @@ hg_test_drc_release(struct hg_test_info *hg_test_info)
     if (hg_test_info->credential_info) {
         rc = drc_release_local(&hg_test_info->credential_info);
         if (rc != DRC_SUCCESS) { /* failed to release credential info */
-            HG_LOG_ERROR("Could not release credential info (%d, %s)", rc,
+            HG_TEST_LOG_ERROR("Could not release credential info (%d, %s)", rc,
                 drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
@@ -645,7 +645,7 @@ hg_test_drc_release(struct hg_test_info *hg_test_info)
         rc = drc_revoke(hg_test_info->credential, hg_test_info->wlm_id,
             DRC_FLAGS_TARGET_WLM);
         if (rc != DRC_SUCCESS) { /* failed to release credential info */
-            HG_LOG_ERROR("Could not revoke access for %d (%d, %s)",
+            HG_TEST_LOG_ERROR("Could not revoke access for %d (%d, %s)",
                 hg_test_info->wlm_id, rc, drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
@@ -656,7 +656,7 @@ hg_test_drc_release(struct hg_test_info *hg_test_info)
         printf("# Releasing credential %u\n", hg_test_info->credential);
         rc = drc_release(hg_test_info->credential, 0);
         if (rc != DRC_SUCCESS) { /* failed to release credential */
-            HG_LOG_ERROR("Could not release credential (%d, %s)", rc,
+            HG_TEST_LOG_ERROR("Could not release credential (%d, %s)", rc,
                 drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
diff --git a/Testing/na/na_test.c b/Testing/na/na_test.c
index 0a48600..2d55055 100644
--- a/Testing/na/na_test.c
+++ b/Testing/na/na_test.c
@@ -71,6 +71,11 @@ extern const char *na_test_opt_arg_g; /* flag argument (or value) */
 extern const char *na_test_short_opt_g;
 extern const struct na_test_opt na_test_opt_g[];
 
+/* Default error log mask */
+#ifdef NA_HAS_VERBOSE_ERROR
+unsigned int NA_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
+#endif
+
 /*---------------------------------------------------------------------------*/
 void
 na_test_usage(const char *execname)
@@ -80,6 +85,7 @@ na_test_usage(const char *execname)
     printf("    -h, --help          Print a usage message and exit\n");
     printf("    -c, --comm          Select NA plugin\n"
            "                        NA plugins: bmi, mpi, cci, etc\n");
+    printf("    -d, --domain        Select NA OFI domain\n");
     printf("    -p, --protocol      Select plugin protocol\n"
            "                        Available protocols: tcp, ib, etc\n");
     printf("    -H, --hostname      Select hostname / IP address to use\n"
@@ -116,6 +122,9 @@ na_test_parse_options(int argc, char *argv[],
                 if (!na_test_info->comm)
                     na_test_info->comm = strdup(na_test_opt_arg_g);
                 break;
+            case 'd': /* Domain */
+                na_test_info->domain = strdup(na_test_opt_arg_g);
+                break;
             case 'p': /* Protocol */
                 /* Prevent from overriding protocol */
                 if (!na_test_info->protocol)
@@ -161,7 +170,7 @@ na_test_parse_options(int argc, char *argv[],
     }
     na_test_opt_ind_g = 1;
 
-    if (!na_test_info->comm || ! na_test_info->protocol) {
+    if (!na_test_info->protocol) {
         na_test_usage(argv[0]);
         exit(1);
     }
@@ -262,13 +271,16 @@ na_test_gen_config(struct na_test_info *na_test_info)
     info_string = (char *) malloc(sizeof(char) * NA_TEST_MAX_ADDR_NAME);
     if (!info_string) {
         NA_LOG_ERROR("Could not allocate info string");
-        ret = NA_NOMEM_ERROR;
+        ret = NA_NOMEM;
         goto done;
     }
     memset(info_string, '\0', NA_TEST_MAX_ADDR_NAME);
     info_string_ptr = info_string;
-    info_string_ptr += sprintf(info_string_ptr, "%s+%s", na_test_info->comm,
-        na_test_info->protocol);
+    if (na_test_info->comm)
+        info_string_ptr += sprintf(info_string_ptr, "%s+", na_test_info->comm);
+    info_string_ptr += sprintf(info_string_ptr, "%s://", na_test_info->protocol);
+    if (na_test_info->domain)
+        info_string_ptr += sprintf(info_string_ptr, "%s/", na_test_info->domain);
 
     if (strcmp("sm", na_test_info->protocol) == 0) {
 #if defined(PR_SET_PTRACER) && defined(PR_SET_PTRACER_ANY)
@@ -291,7 +303,7 @@ na_test_gen_config(struct na_test_info *na_test_info)
 #endif
         if (na_test_info->listen) {
             /* special-case SM (pid:id) */
-            sprintf(info_string_ptr, "://%d/%d", (int) getpid(), port_incr);
+            sprintf(info_string_ptr, "%d/%d", (int) getpid(), port_incr);
         }
     } else if ((strcmp("tcp", na_test_info->protocol) == 0)
         || (strcmp("verbs;ofi_rxm", na_test_info->protocol) == 0)
@@ -302,21 +314,21 @@ na_test_gen_config(struct na_test_info *na_test_info)
             /* Nothing */
         } else if (na_test_info->listen) {
             base_port += (unsigned int) na_test_info->mpi_comm_rank;
-            sprintf(info_string_ptr, "://%s:%d", na_test_info->hostname,
+            sprintf(info_string_ptr, "%s:%d", na_test_info->hostname,
                 base_port + port_incr);
         } else
-            sprintf(info_string_ptr, "://%s", na_test_info->hostname);
+            sprintf(info_string_ptr, "%s", na_test_info->hostname);
     } else if (strcmp("static", na_test_info->protocol) == 0) {
         /* Nothing */
     } else if (strcmp("dynamic", na_test_info->protocol) == 0) {
         /* Nothing */
     } else if (strcmp("gni", na_test_info->protocol) == 0) {
         base_port += (unsigned int) na_test_info->mpi_comm_rank;
-        sprintf(info_string_ptr, "://%s:%d", na_test_info->hostname,
+        sprintf(info_string_ptr, "%s:%d", na_test_info->hostname,
             base_port + port_incr);
     } else {
         NA_LOG_ERROR("Unknown protocol: %s", na_test_info->protocol);
-        ret = NA_INVALID_PARAM;
+        ret = NA_INVALID_ARG;
         goto done;
     }
 
diff --git a/Testing/na/na_test.h b/Testing/na/na_test.h
index 62c1b61..8290198 100644
--- a/Testing/na/na_test.h
+++ b/Testing/na/na_test.h
@@ -27,6 +27,7 @@ struct na_test_info {
     na_class_t *na_class;       /* NA class */
     char *target_name;          /* Target name */
     char *comm;                 /* Comm/Plugin name */
+    char *domain;               /* Domain name */
     char *protocol;             /* Protocol name */
     char *hostname;             /* Hostname */
     na_bool_t listen;           /* Listen */
diff --git a/Testing/na/na_test_getopt.c b/Testing/na/na_test_getopt.c
index 3f2005d..54f9c8d 100644
--- a/Testing/na/na_test_getopt.c
+++ b/Testing/na/na_test_getopt.c
@@ -17,10 +17,11 @@
 
 int na_test_opt_ind_g = 1; /* token pointer */
 const char *na_test_opt_arg_g = NULL; /* flag argument (or value) */
-const char *na_test_short_opt_g = "hc:p:H:LsSak:l:t:bmC:V";
+const char *na_test_short_opt_g = "hc:d:p:H:LsSak:l:t:bmC:V";
 const struct na_test_opt na_test_opt_g[] = {
     { "help", no_arg, 'h'},
     { "comm", require_arg, 'c' },
+    { "domain", require_arg, 'd' },
     { "protocol", require_arg, 'p' },
     { "hostname", require_arg, 'H' },
     { "listen", no_arg, 'L' },
diff --git a/Testing/na/test_lat_client.c b/Testing/na/test_lat_client.c
index e0d2c16..7ef42b1 100644
--- a/Testing/na/test_lat_client.c
+++ b/Testing/na/test_lat_client.c
@@ -120,18 +120,21 @@ na_test_target_lookup(struct na_test_lat_info *na_test_lat_info)
 {
     struct na_test_target_lookup_arg request_args = { 0 };
     hg_request_t *request = NULL;
+    na_op_id_t op_id = NA_OP_ID_NULL;
     na_return_t ret = NA_SUCCESS;
 
     request = hg_request_create(na_test_lat_info->request_class);
     request_args.addr_ptr = &na_test_lat_info->target_addr;
     request_args.request = request;
 
+    op_id = NA_Op_create(na_test_lat_info->na_class);
+
     /* Forward call to remote addr and get a new request */
     ret = NA_Addr_lookup(na_test_lat_info->na_class, na_test_lat_info->context,
         na_test_target_lookup_cb, &request_args,
-        na_test_lat_info->na_test_info.target_name, NA_OP_ID_IGNORE);
+        na_test_lat_info->na_test_info.target_name, &op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not lookup address");
+        NA_LOG_ERROR("Could not lookup address (%s)", NA_Error_to_string(ret));
         goto done;
     }
 
@@ -139,6 +142,7 @@ na_test_target_lookup(struct na_test_lat_info *na_test_lat_info)
     hg_request_wait(request, NA_MAX_IDLE_TIME, NULL);
 
 done:
+    NA_Op_destroy(na_test_lat_info->na_class, op_id);
     hg_request_destroy(request);
     return ret;
 }
@@ -217,16 +221,21 @@ na_test_measure_latency(struct na_test_lat_info *na_test_lat_info,
             recv_buf, buf_size, recv_buf_data, na_test_lat_info->target_addr, 0,
             0, &recv_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_recv_expected() failed");
+            NA_LOG_ERROR("NA_Msg_recv_expected() failed (%s)", NA_Error_to_string(ret));
             goto done;
         }
 
+again:
         /* Post send */
         ret = NA_Msg_send_unexpected(na_test_lat_info->na_class,
             na_test_lat_info->context, NULL, NULL, send_buf, buf_size,
             send_buf_data, na_test_lat_info->target_addr, 0, 0, &send_op_id);
+        if (ret == NA_AGAIN) {
+            hg_request_wait(recv_request, 0, NULL);
+            goto again;
+        }
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_send_unexpected() failed");
+            NA_LOG_ERROR("NA_Msg_send_unexpected() failed (%s)", NA_Error_to_string(ret));
             goto done;
         }
 
@@ -248,7 +257,7 @@ na_test_measure_latency(struct na_test_lat_info *na_test_lat_info,
             recv_buf, buf_size, recv_buf_data, na_test_lat_info->target_addr, 0,
             1, &recv_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_recv_expected() failed");
+            NA_LOG_ERROR("NA_Msg_recv_expected() failed (%s)", NA_Error_to_string(ret));
             goto done;
         }
 
@@ -258,7 +267,7 @@ na_test_measure_latency(struct na_test_lat_info *na_test_lat_info,
             send_buf_data, na_test_lat_info->target_addr, 0, 1,
             &send_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_send_unexpected() failed");
+            NA_LOG_ERROR("NA_Msg_send_unexpected() failed (%s)", NA_Error_to_string(ret));
             goto done;
         }
 
@@ -326,6 +335,8 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
         NA_Msg_get_unexpected_header_size(na_test_lat_info->na_class);
     na_size_t buf_size =
         (unexpected_header_size) ? unexpected_header_size + 1 : 1;
+    na_op_id_t send_op_id;
+    na_op_id_t recv_op_id;
     na_return_t ret = NA_SUCCESS;
 
     /* Prepare send_buf */
@@ -338,15 +349,18 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
         &recv_buf_data);
     memset(recv_buf, 0, buf_size);
 
+    send_op_id = NA_Op_create(na_test_lat_info->na_class);
+    recv_op_id = NA_Op_create(na_test_lat_info->na_class);
+
     recv_request = hg_request_create(na_test_lat_info->request_class);
 
     /* Post recv */
     ret = NA_Msg_recv_expected(na_test_lat_info->na_class,
         na_test_lat_info->context, na_test_recv_expected_cb, recv_request,
         recv_buf, buf_size, recv_buf_data, na_test_lat_info->target_addr, 0,
-        NA_TEST_TAG_DONE, NA_OP_ID_IGNORE);
+        NA_TEST_TAG_DONE, &recv_op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("NA_Msg_recv_expected() failed");
+        NA_LOG_ERROR("NA_Msg_recv_expected() failed (%s)", NA_Error_to_string(ret));
         goto done;
     }
 
@@ -354,9 +368,9 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
     ret = NA_Msg_send_unexpected(na_test_lat_info->na_class,
         na_test_lat_info->context, NULL, NULL, send_buf, buf_size,
         send_buf_data, na_test_lat_info->target_addr, 0, NA_TEST_TAG_DONE,
-        NA_OP_ID_IGNORE);
+        &send_op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("NA_Msg_send_unexpected() failed");
+        NA_LOG_ERROR("NA_Msg_send_unexpected() failed (%s)", NA_Error_to_string(ret));
         goto done;
     }
 
@@ -365,6 +379,8 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
 done:
     /* Clean up resources */
     hg_request_destroy(recv_request);
+    NA_Op_destroy(na_test_lat_info->na_class, send_op_id);
+    NA_Op_destroy(na_test_lat_info->na_class, recv_op_id);
     NA_Msg_buf_free(na_test_lat_info->na_class, send_buf, send_buf_data);
     NA_Msg_buf_free(na_test_lat_info->na_class, recv_buf, recv_buf_data);
     return ret;
diff --git a/Testing/na/test_lat_server.c b/Testing/na/test_lat_server.c
index ea48512..cd52b2e 100644
--- a/Testing/na/test_lat_server.c
+++ b/Testing/na/test_lat_server.c
@@ -142,7 +142,7 @@ na_test_recv_unexpected_cb(const struct na_cb_info *na_cb_info)
         na_cb_info->info.recv_unexpected.tag,
         &na_test_source_recv_arg->send_op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("NA_Msg_send_expected() failed");
+        NA_LOG_ERROR("NA_Msg_send_expected() failed (%s)", NA_Error_to_string(ret));
     }
 
     NA_Addr_free(na_test_lat_info->na_class,
@@ -210,7 +210,7 @@ na_test_loop_latency(struct na_test_lat_info *na_test_lat_info)
             &na_test_source_recv_arg, recv_buf, unexpected_size,
             recv_buf_data, &recv_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_recv_unexpected() failed");
+            NA_LOG_ERROR("NA_Msg_recv_unexpected() failed (%s)", NA_Error_to_string(ret));
             goto done;
         }
 
diff --git a/Testing/script/travis_build.sh b/Testing/script/travis_build.sh
index 32cc97f..61217bc 100755
--- a/Testing/script/travis_build.sh
+++ b/Testing/script/travis_build.sh
@@ -1,11 +1,11 @@
 #!/bin/bash
 
 BMI_VERSION=master
-CMAKE_VERSION_MAJOR=3.15
+CMAKE_VERSION_MAJOR=3.16
 CMAKE_VERSION_MINOR=1
-MPI_VERSION=3.3.1
+MPI_VERSION=3.3.2
 CCI_VERSION=2.1
-OFI_VERSION=1.8.0
+OFI_VERSION=1.9.0
 PREFIX=$HOME/install
 
 set -e
diff --git a/Testing/test_bulk.c b/Testing/test_bulk.c
index cfb31f2..541bae3 100644
--- a/Testing/test_bulk.c
+++ b/Testing/test_bulk.c
@@ -13,29 +13,38 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-extern hg_id_t hg_test_bulk_write_id_g;
-extern hg_id_t hg_test_bulk_bind_write_id_g;
+/****************/
+/* Local Macros */
+/****************/
 
 #define BUFSIZE (MERCURY_TESTING_BUFFER_SIZE * 1024 * 1024)
 
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
+
 struct forward_cb_args {
     hg_request_t *request;
     size_t expected_bytes;
     hg_return_t ret;
 };
 
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
+/********************/
+/* Local Prototypes */
+/********************/
+
+static hg_return_t
+hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info);
+
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+extern hg_id_t hg_test_bulk_write_id_g;
+extern hg_id_t hg_test_bulk_bind_write_id_g;
 
 /*---------------------------------------------------------------------------*/
-/**
- * HG_Forward callback
- */
 static hg_return_t
 hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -45,32 +54,24 @@ hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info)
     bulk_write_out_t bulk_write_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
 
     /* Get output */
     ret = HG_Get_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not get output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get output parameters */
     bulk_write_ret = bulk_write_out_struct.ret;
-    if (bulk_write_ret != args->expected_bytes) {
-        HG_TEST_LOG_ERROR("Returned: %zu bytes, was expecting %zu",
-            bulk_write_ret, args->expected_bytes);
-        args->ret = HG_SIZE_ERROR;
-    }
+    HG_TEST_CHECK_ERROR(bulk_write_ret != args->expected_bytes, done,
+        args->ret, HG_MSGSIZE, "Returned: %zu bytes, was expecting %zu",
+        bulk_write_ret, args->expected_bytes);
 
     /* Free request */
     ret = HG_Free_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not free output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     hg_request_complete(args->request);
@@ -87,32 +88,24 @@ hg_test_bulk_bind_forward_cb(const struct hg_cb_info *callback_info)
     bulk_bind_write_out_t bulk_write_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
 
     /* Get output */
     ret = HG_Get_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not get output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get output parameters */
     bulk_write_ret = bulk_write_out_struct.ret;
-    if (bulk_write_ret != args->expected_bytes) {
-        HG_TEST_LOG_ERROR("Returned: %zu bytes, was expecting %zu",
-            bulk_write_ret, args->expected_bytes);
-        args->ret = HG_SIZE_ERROR;
-    }
+    HG_TEST_CHECK_ERROR(bulk_write_ret != args->expected_bytes, done,
+        args->ret, HG_MSGSIZE, "Returned: %zu bytes, was expecting %zu",
+        bulk_write_ret, args->expected_bytes);
 
     /* Free request */
     ret = HG_Free_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not free output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     hg_request_complete(args->request);
@@ -140,14 +133,14 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
     hg_cb_t forward_cb = hg_test_bulk_forward_cb;
     size_t i;
 
-    if (origin_offset + transfer_size > bulk_size) {
-        HG_LOG_ERROR("Exceeding bulk size");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(origin_offset + transfer_size > bulk_size, done, ret,
+        HG_OVERFLOW, "Exceeding bulk size");
 
     /* Prepare bulk_buf */
     bulk_buf = malloc(bulk_size);
+    HG_TEST_CHECK_ERROR(bulk_buf == NULL, done, ret, HG_NOMEM_ERROR,
+         "Could not allocate bulk_buf");
+
     for (i = 0; i < bulk_size; i++)
         bulk_buf[i] = (char) i;
     buf_ptrs[0] = bulk_buf;
@@ -160,10 +153,8 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
     /* Register memory */
     ret = HG_Bulk_create(hg_class, 2, buf_ptrs, buf_sizes, HG_BULK_READ_ONLY,
         &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     if (bind_addr) {
         /* Bind local context to bulk, it is only necessary if this bulk handle
@@ -171,19 +162,16 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
          * should also work for normal case. Add here just to test the
          * functionality. */
         ret = HG_Bulk_bind(bulk_handle, context);
-        if (ret != HG_SUCCESS) {
-            HG_TEST_LOG_ERROR("Could not bind context to bulk handle");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_bind() failed (%s)",
+            HG_Error_to_string(ret));
+
         rpc_id = hg_test_bulk_bind_write_id_g;
         forward_cb = hg_test_bulk_bind_forward_cb;
     }
 
     ret = HG_Create(context, target_addr, rpc_id, &handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     bulk_write_in_struct.fildes = 0;
@@ -202,26 +190,20 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
     forward_cb_args.ret = HG_SUCCESS;
     ret = HG_Forward(handle, forward_cb, &forward_cb_args,
         &bulk_write_in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Complete */
     ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_destroy(request);
 
@@ -253,20 +235,26 @@ hg_test_bulk_seg(hg_class_t *hg_class, hg_context_t *context,
     hg_size_t bulk_size = BUFSIZE;
     size_t i;
 
-    if (origin_offset + transfer_size > bulk_size) {
-        HG_LOG_ERROR("Exceeding bulk size");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(origin_offset + transfer_size > bulk_size, done, ret,
+        HG_OVERFLOW, "Exceeding bulk size");
 
     /* Prepare bulk_buf */
     buf_ptrs = (void **) malloc(origin_segment_count * sizeof(void *));
+    HG_TEST_CHECK_ERROR(buf_ptrs == NULL, done, ret, HG_NOMEM_ERROR,
+         "Could not allocate buf_ptrs");
+
     buf_sizes = (hg_size_t *) malloc(origin_segment_count * sizeof(hg_size_t));
+    HG_TEST_CHECK_ERROR(buf_sizes == NULL, done, ret, HG_NOMEM_ERROR,
+         "Could not allocate buf_sizes");
+
     for (i = 0; i < origin_segment_count; i++) {
         hg_size_t j;
 
         buf_sizes[i] = bulk_size / origin_segment_count;
         buf_ptrs[i] = malloc(buf_sizes[i]);
+        HG_TEST_CHECK_ERROR(buf_ptrs == NULL, done, ret, HG_NOMEM_ERROR,
+             "Could not allocate bulk_buf");
+
         for (j = 0; j < buf_sizes[i]; j++) {
             ((char **) buf_ptrs)[i][j] = (char) (i * buf_sizes[i] + j);
         }
@@ -275,18 +263,14 @@ hg_test_bulk_seg(hg_class_t *hg_class, hg_context_t *context,
     request = hg_request_create(request_class);
 
     ret = HG_Create(context, target_addr, hg_test_bulk_write_id_g, &handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Register memory */
     ret = HG_Bulk_create(hg_class, origin_segment_count, buf_ptrs,
         buf_sizes, HG_BULK_READ_ONLY, &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     bulk_write_in_struct.fildes = 0;
@@ -306,26 +290,20 @@ hg_test_bulk_seg(hg_class_t *hg_class, hg_context_t *context,
     forward_cb_args.ret = HG_SUCCESS;
     ret = HG_Forward(handle, hg_test_bulk_forward_cb, &forward_cb_args,
             &bulk_write_in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Complete */
     ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_destroy(request);
 
@@ -360,11 +338,8 @@ hg_test_bulk_small(hg_class_t *hg_class, hg_context_t *context,
     hg_size_t bulk_size = 12;
     size_t i;
 
-    if (origin_offset + transfer_size > bulk_size) {
-        HG_LOG_ERROR("Exceeding bulk size");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(origin_offset + transfer_size > bulk_size, done, ret,
+        HG_OVERFLOW, "Exceeding bulk size");
 
     /* Prepare bulk buf */
     for (i = 0; i < bulk_size; i++)
@@ -373,18 +348,14 @@ hg_test_bulk_small(hg_class_t *hg_class, hg_context_t *context,
     request = hg_request_create(request_class);
 
     ret = HG_Create(context, target_addr, hg_test_bulk_write_id_g, &handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Register memory */
     ret = HG_Bulk_create(hg_class, 2, buf_ptrs, buf_sizes, HG_BULK_READ_ONLY,
         &bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     bulk_write_in_struct.fildes = 1;
@@ -404,26 +375,20 @@ hg_test_bulk_small(hg_class_t *hg_class, hg_context_t *context,
     forward_cb_args.ret = HG_SUCCESS;
     ret = HG_Forward(handle, hg_test_bulk_forward_cb, &forward_cb_args,
             &bulk_write_in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy bulk handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Complete */
     ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_destroy(request);
 
@@ -435,146 +400,126 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-int main(int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
     struct hg_test_info hg_test_info = { 0 };
     hg_return_t hg_ret;
     int ret = EXIT_SUCCESS;
 
     /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
+    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
     /* Simple RPC bulk test */
     HG_TEST("contiguous RPC bulk (size BUFSIZE, offsets 0, 0)");
     hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, 0, hg_test_info.target_addr, BUFSIZE, 0, 0);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "contiguous RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("contiguous RPC bulk (size BUFSIZE/4, offsets BUFSIZE/2 + 1, 0)");
     hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, 0, hg_test_info.target_addr, BUFSIZE/4,
         BUFSIZE/2 + 1, 0);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "contiguous RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("contiguous RPC bulk (size BUFSIZE/8, offsets BUFSIZE/2 + 1, BUFSIZE/4)");
     hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, 0, hg_test_info.target_addr, BUFSIZE/8,
         BUFSIZE/2 + 1, BUFSIZE/4);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "contiguous RPC bulk failed");
     HG_PASSED();
 
     /* small bulk test */
     HG_TEST("small segmented RPC bulk (size 8, offsets 0, 0)");
     hg_ret = hg_test_bulk_small(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 8, 0, 0);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "small segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("small segmented RPC bulk (size 4, offsets 8, 0)");
     hg_ret = hg_test_bulk_small(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 4, 8, 0);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "small segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("small segmented RPC bulk (size 8, offsets 4, 2)");
     hg_ret = hg_test_bulk_small(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 8, 4, 2);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "small segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("segmented RPC bulk (size BUFSIZE, offsets 0, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE, 0, 0, 16);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("segmented RPC bulk (size BUFSIZE/4, offsets BUFSIZE/2 + 1, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/4,
         BUFSIZE/2 + 1, 0, 16);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("segmented RPC bulk (size BUFSIZE/8, offsets BUFSIZE/2 + 1, BUFSIZE/4)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/8,
         BUFSIZE/2 + 1, BUFSIZE/4, 16);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("over-segmented RPC bulk (size BUFSIZE, offsets 0, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE, 0, 0,
         1024);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "over-segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("over-segmented RPC bulk (size BUFSIZE/4, offsets BUFSIZE/2 + 1, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/4,
         BUFSIZE/2 + 1, 0, 1024);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "over-segmented RPC bulk failed");
     HG_PASSED();
 
     HG_TEST("over-segmented RPC bulk (size BUFSIZE/8, offsets BUFSIZE/2 + 1, BUFSIZE/4)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/8,
         BUFSIZE/2 + 1, BUFSIZE/4, 1024);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "over-segmented RPC bulk failed");
     HG_PASSED();
 
     if (strcmp(HG_Class_get_name(hg_test_info.hg_class), "ofi") == 0) {
         HG_TEST("bind contiguous RPC bulk (size BUFSIZE, offsets 0, 0)");
         hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
             hg_test_info.request_class, 1, hg_test_info.target_addr, BUFSIZE, 0, 0);
-        if (hg_ret != HG_SUCCESS) {
-            ret = EXIT_FAILURE;
-            goto done;
-        }
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "bind contiguous RPC bulk failed");
         HG_PASSED();
     }
 
 done:
     if (ret != EXIT_SUCCESS)
         HG_FAILED();
-    HG_Test_finalize(&hg_test_info);
+
+    hg_ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
+
     return ret;
 }
diff --git a/Testing/test_bulk.h b/Testing/test_bulk.h
index 02eecaf..ecafb96 100644
--- a/Testing/test_bulk.h
+++ b/Testing/test_bulk.h
@@ -45,34 +45,24 @@ hg_proc_bulk_write_in_t(hg_proc_t proc, void *data)
     bulk_write_in_t *struct_data = (bulk_write_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fildes);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_size_t(proc, &struct_data->transfer_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_size_t(proc, &struct_data->origin_offset);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_size_t(proc, &struct_data->target_offset);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -90,10 +80,8 @@ hg_proc_bulk_write_out_t(hg_proc_t proc, void *data)
     bulk_write_out_t *struct_data = (bulk_write_out_t *) data;
 
     ret = hg_proc_hg_size_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -112,16 +100,12 @@ hg_proc_bulk_bind_write_out_t(hg_proc_t proc, void *data)
     bulk_bind_write_out_t *struct_data = (bulk_bind_write_out_t *) data;
 
     ret = hg_proc_hg_size_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
diff --git a/Testing/test_bulk_seg.c b/Testing/test_bulk_seg.c
deleted file mode 100644
index c025d3f..0000000
--- a/Testing/test_bulk_seg.c
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#include "mercury_test.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-extern hg_id_t hg_test_bulk_seg_write_id_g;
-
-static hg_return_t
-hg_test_bulk_seg_forward_cb(const struct hg_cb_info *callback_info)
-{
-    hg_handle_t handle = callback_info->info.forward.handle;
-    hg_request_t *request = (hg_request_t *) callback_info->arg;
-    size_t bulk_write_ret = 0;
-    bulk_write_out_t bulk_write_out_struct;
-    hg_return_t ret = HG_SUCCESS;
-
-    /* Get output */
-    ret = HG_Get_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not get output\n");
-        goto done;
-    }
-
-    /* Get output parameters */
-    bulk_write_ret = bulk_write_out_struct.ret;
-    printf("bulk_write returned: %zu\n", bulk_write_ret);
-
-    /* Free request */
-    ret = HG_Free_output(handle, &bulk_write_out_struct);
-    if (ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free output\n");
-        goto done;
-    }
-
-    hg_request_complete(request);
-
-done:
-    return ret;
-}
-
-/*****************************************************************************/
-int main(int argc, char *argv[])
-{
-    struct hg_test_info hg_test_info = { 0 };
-    hg_request_t *request = NULL;
-    hg_handle_t handle;
-
-    bulk_write_in_t bulk_write_in_struct;
-
-    int fildes = 12345;
-    void **bulk_buf;
-    size_t *bulk_sizes;
-    size_t bulk_size = 1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE / sizeof(int);
-    size_t bulk_size_x = 16;
-    size_t bulk_size_y = 0;
-    size_t *bulk_size_y_var = NULL;
-    hg_bulk_t bulk_handle = HG_BULK_NULL;
-
-    hg_return_t hg_ret;
-    size_t i, j;
-
-    /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
-
-    request = hg_request_create(hg_test_info.request_class);
-
-    hg_ret = HG_Create(hg_test_info.context, hg_test_info.target_addr,
-        hg_test_bulk_seg_write_id_g, &handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not start call\n");
-        return EXIT_FAILURE;
-    }
-
-    /* This will create a list of variable size segments */
-//    if (hg_test_info.variable) {
-//        printf("Using variable size segments!\n");
-//        /* bulk_size_x >= 2 */
-//        /* 524288 + 262144 + 131072 + 65536 + 32768 + 16384 + 8192 + 8192 */
-//        bulk_size_x = 8;
-//        bulk_size_y_var = (size_t*) malloc(bulk_size_x * sizeof(size_t));
-//        bulk_size_y_var[0] = bulk_size / 2;
-//        for (i = 1; i < bulk_size_x - 1; i++) {
-//            bulk_size_y_var[i] = bulk_size_y_var[i-1] / 2;
-//        }
-//        bulk_size_y_var[bulk_size_x - 1] = bulk_size_y_var[bulk_size_x - 2];
-//    }
-//    /* This will use an extra encoding buffer */
-//    else if (hg_test_info.extra) {
-//        printf("Using large number of segments!\n");
-//        bulk_size_x = 1024;
-//        bulk_size_y = bulk_size / bulk_size_x;
-//    }
-//    else {
-        /* This will create a list of fixed size segments */
-        bulk_size_y = bulk_size / bulk_size_x;
-//    }
-
-    /* Prepare bulk_buf */
-    bulk_buf = (void **) malloc(bulk_size_x * sizeof(void *));
-    bulk_sizes = (size_t *) malloc(bulk_size_x * sizeof(size_t));
-    if (bulk_size_y_var) {
-        int val = 0;
-        for (i = 0; i < bulk_size_x; i++) {
-            bulk_sizes[i] = bulk_size_y_var[i] * sizeof(int);
-            bulk_buf[i] = malloc(bulk_sizes[i]);
-            for (j = 0; j < bulk_size_y_var[i]; j++) {
-                ((int **) (bulk_buf))[i][j] = val;
-                val++;
-            }
-        }
-    } else {
-        for (i = 0; i < bulk_size_x; i++) {
-            bulk_sizes[i] = bulk_size_y * sizeof(int);
-            bulk_buf[i] = malloc(bulk_sizes[i]);
-            for (j = 0; j < bulk_size_y; j++) {
-                ((int **) (bulk_buf))[i][j] = (int) (i * bulk_size_y + j);
-            }
-        }
-    }
-
-    /* Register memory */
-    hg_ret = HG_Bulk_create(hg_test_info.hg_class, (hg_uint32_t) bulk_size_x,
-        bulk_buf, (hg_size_t *) bulk_sizes, HG_BULK_READ_ONLY, &bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    free(bulk_sizes);
-    bulk_sizes = NULL;
-    if (bulk_size_y_var) free(bulk_size_y_var);
-    bulk_size_y_var = NULL;
-
-    /* Fill input structure */
-    bulk_write_in_struct.fildes = fildes;
-    bulk_write_in_struct.bulk_handle = bulk_handle;
-
-    /* Forward call to remote addr and get a new request */
-    printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_seg_write_id_g);
-    hg_ret = HG_Forward(handle, hg_test_bulk_seg_forward_cb, request,
-            &bulk_write_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not forward call\n");
-        return EXIT_FAILURE;
-    }
-
-    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
-
-    /* Free memory handle */
-    hg_ret = HG_Bulk_free(bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Complete */
-    hg_ret = HG_Destroy(handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not complete\n");
-        return EXIT_FAILURE;
-    }
-
-    hg_request_destroy(request);
-
-    HG_Test_finalize(&hg_test_info);
-
-    /* Free bulk_buf */
-    for (i = 0; i < bulk_size_x; i++) {
-        free(bulk_buf[i]);
-        bulk_buf[i] = NULL;
-    }
-    free(bulk_buf);
-    bulk_buf = NULL;
-
-    return EXIT_SUCCESS;
-}
diff --git a/Testing/test_cancel.c b/Testing/test_cancel.c
deleted file mode 100644
index 5e1b834..0000000
--- a/Testing/test_cancel.c
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#include "mercury_test.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-extern hg_id_t hg_test_cancel_rpc_id_g;
-
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
-
-/*---------------------------------------------------------------------------*/
-/**
- * HG_Forward callback
- */
-static hg_return_t
-hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
-{
-    hg_request_t *request = (hg_request_t *) callback_info->arg;
-    hg_return_t ret = HG_SUCCESS;
-
-    if (callback_info->ret != HG_CANCELED) {
-        HG_TEST_LOG_DEBUG("Error: HG_Forward() was not canceled: %d",
-            callback_info->ret);
-    } else {
-        HG_TEST_LOG_DEBUG("HG_Forward() was successfully canceled");
-    }
-
-    hg_request_complete(request);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
-{
-    hg_request_t *request = NULL;
-    hg_handle_t handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    request = hg_request_create(request_class);
-
-    /* Create RPC request */
-    ret = HG_Create(context, addr, rpc_id, &handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
-
-    /* Forward call to remote addr and get a new request */
-    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
-    ret = HG_Forward(handle, callback, request, NULL);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
-
-    /* Cancel request */
-    ret = HG_Cancel(handle);
-    if (ret != HG_SUCCESS && ret != HG_CANCEL_ERROR) {
-        HG_TEST_LOG_ERROR("Could not cancel call");
-        goto done;
-    }
-
-    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
-
-    /* Complete */
-    ret = HG_Destroy(handle);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
-
-done:
-    hg_request_destroy(request);
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-int
-main(int argc, char *argv[])
-{
-    struct hg_test_info hg_test_info = { 0 };
-    hg_return_t hg_ret;
-    int ret = EXIT_SUCCESS;
-
-    /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
-
-    /* Skip for OFI/tcp for now (cancelation of unexpected send is not
-     * guaranteed by underlying provider) */
-    if (!(strcmp(HG_Class_get_name(hg_test_info.hg_class), "ofi"))
-        && !strcmp(hg_test_info.na_test_info.protocol, "tcp"))
-        goto done;
-
-    /* Cancel RPC test */
-    HG_TEST("cancel RPC");
-    hg_ret = hg_test_cancel_rpc(hg_test_info.context,
-        hg_test_info.request_class, hg_test_info.target_addr,
-        hg_test_cancel_rpc_id_g, hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
-    HG_PASSED();
-
-done:
-    if (ret != EXIT_SUCCESS)
-        HG_FAILED();
-    HG_Test_finalize(&hg_test_info);
-    return ret;
-}
diff --git a/Testing/test_multiple.c b/Testing/test_multiple.c
deleted file mode 100644
index 6c80d21..0000000
--- a/Testing/test_multiple.c
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#include "mercury_test.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-extern hg_id_t hg_test_rpc_open_id_g;
-extern hg_id_t hg_test_bulk_write_id_g;
-
-/******************************************************************************/
-int main(int argc, char *argv[])
-{
-    hg_addr_t addr;
-
-    rpc_open_in_t  rpc_open_in_struct;
-    rpc_open_out_t rpc_open_out_struct;
-    hg_request_t rpc_open_request;
-
-    bulk_write_in_t bulk_write_in_struct;
-    bulk_write_out_t bulk_write_out_struct;
-    hg_request_t bulk_write_request;
-
-    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
-    rpc_handle_t rpc_open_handle;
-    int rpc_open_ret = 0;
-    int rpc_open_event_id = 0;
-
-    int fildes = 12345;
-    int *bulk_buf = NULL;
-    size_t bulk_size = 1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE / sizeof(int);
-    hg_bulk_t bulk_handle = HG_BULK_NULL;
-    size_t bulk_write_ret = 0;
-
-    hg_status_t rpc_open_status;
-    hg_status_t bulk_write_status;
-    hg_return_t hg_ret;
-    size_t i;
-
-    /* Prepare bulk_buf */
-    bulk_buf = (int*) malloc(sizeof(int) * bulk_size);
-    for (i = 0; i < bulk_size; i++) {
-        bulk_buf[i] = i;
-    }
-
-    /* Initialize the interface (for convenience, shipper_test_client_init
-     * initializes the network interface with the selected plugin)
-     */
-    HG_Test_client_init(argc, argv, &addr, NULL);
-
-    /* Register memory */
-    hg_ret = HG_Bulk_handle_create(bulk_buf, sizeof(int) * bulk_size, HG_BULK_READ_ONLY,
-            &bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Fill input structure */
-    rpc_open_handle.cookie = 12345;
-    rpc_open_in_struct.path = rpc_open_path;
-    rpc_open_in_struct.handle = rpc_open_handle;
-    bulk_write_in_struct.fildes = fildes;
-    bulk_write_in_struct.bulk_handle = bulk_handle;
-
-    /* Forward call to remote addr and get a new request */
-    printf("Forwarding rpc_open, op id: %u...\n", hg_test_rpc_open_id_g);
-    hg_ret = HG_Forward(addr, hg_test_rpc_open_id_g, &rpc_open_in_struct,
-            &rpc_open_out_struct, &rpc_open_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not forward call\n");
-        return EXIT_FAILURE;
-    }
-    printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_write_id_g);
-    hg_ret = HG_Forward(addr, hg_test_bulk_write_id_g,
-            &bulk_write_in_struct, &bulk_write_out_struct, &bulk_write_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not forward call\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Wait for call to be executed and return value to be sent back
-     * (Request is freed when the call completes)
-     */
-    hg_ret = HG_Wait(rpc_open_request, HG_MAX_IDLE_TIME, &rpc_open_status);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Error during wait\n");
-        return EXIT_FAILURE;
-    }
-    if (!rpc_open_status) {
-        fprintf(stderr, "Operation did not complete\n");
-        return EXIT_FAILURE;
-    } else {
-        printf("Call completed\n");
-    }
-    hg_ret = HG_Wait(bulk_write_request, HG_MAX_IDLE_TIME, &bulk_write_status);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Error during wait\n");
-        return EXIT_FAILURE;
-    }
-    if (!bulk_write_status) {
-        fprintf(stderr, "Operation did not complete\n");
-        return EXIT_FAILURE;
-    } else {
-        printf("Call completed\n");
-    }
-
-    /* Get output parameters */
-    rpc_open_ret = rpc_open_out_struct.ret;
-    rpc_open_event_id = rpc_open_out_struct.event_id;
-    printf("rpc_open returned: %d with event_id: %d\n", rpc_open_ret, rpc_open_event_id);
-    bulk_write_ret = bulk_write_out_struct.ret;
-    printf("bulk_write returned: %lu\n", bulk_write_ret);
-
-    /* Free request */
-    hg_ret = HG_Request_free(rpc_open_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free request\n");
-        return EXIT_FAILURE;
-    }
-    hg_ret = HG_Request_free(bulk_write_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free request\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Free memory handle */
-    hg_ret = HG_Bulk_handle_free(bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Free bulk data */
-    free(bulk_buf);
-
-    HG_Test_finalize();
-
-    return EXIT_SUCCESS;
-}
diff --git a/Testing/test_multiple.h b/Testing/test_multiple.h
deleted file mode 100644
index b497125..0000000
--- a/Testing/test_multiple.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#ifndef TEST_MULTIPLE_H
-#define TEST_MULTIPLE_H
-
-#include "test_rpc.h"
-#include "test_bulk.h"
-
-#endif /* TEST_MULTIPLE_H */
diff --git a/Testing/test_overflow.c b/Testing/test_overflow.c
deleted file mode 100644
index 49499a6..0000000
--- a/Testing/test_overflow.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#include "mercury_test.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-extern hg_id_t hg_test_overflow_id_g;
-
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
-{
-    hg_handle_t handle = callback_info->info.forward.handle;
-    hg_request_t *request = (hg_request_t *) callback_info->arg;
-    overflow_out_t out_struct;
-    hg_string_t string;
-    size_t string_len;
-    hg_return_t ret = HG_SUCCESS;
-
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_WARNING("Return from callback info is not HG_SUCCESS");
-        goto done;
-    }
-
-    /* Get output */
-    ret = HG_Get_output(handle, &out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not get output");
-        goto done;
-    }
-
-    /* Get output parameters */
-    string = out_struct.string;
-    string_len = out_struct.string_len;
-    HG_TEST_LOG_DEBUG("Returned string (length %zu): %s", string_len, string);
-    (void) string;
-    (void) string_len;
-
-    /* Free request */
-    ret = HG_Free_output(handle, &out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not free output");
-        goto done;
-    }
-
-done:
-    hg_request_complete(request);
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_overflow(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
-{
-    hg_request_t *request = NULL;
-    hg_handle_t handle;
-    hg_return_t hg_ret = HG_SUCCESS;
-
-    request = hg_request_create(request_class);
-
-    /* Create RPC request */
-    hg_ret = HG_Create(context, addr, rpc_id, &handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
-
-    /* Forward call to remote addr and get a new request */
-    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
-    hg_ret = HG_Forward(handle, callback, request, NULL);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
-
-    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
-
-    /* Complete */
-    hg_ret = HG_Destroy(handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
-
-done:
-    hg_request_destroy(request);
-    return hg_ret;
-}
-
-/*---------------------------------------------------------------------------*/
-int
-main(int argc, char *argv[])
-{
-    struct hg_test_info hg_test_info = { 0 };
-    hg_return_t hg_ret;
-    int ret = EXIT_SUCCESS;
-
-    /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
-
-    /* Overflow RPC test */
-    HG_TEST("overflow RPC");
-    hg_ret = hg_test_overflow(hg_test_info.context, hg_test_info.request_class,
-        hg_test_info.target_addr, hg_test_overflow_id_g,
-        hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
-    HG_PASSED();
-
-done:
-    if (ret != EXIT_SUCCESS)
-        HG_FAILED();
-    HG_Test_finalize(&hg_test_info);
-    return ret;
-}
diff --git a/Testing/test_overflow.h b/Testing/test_overflow.h
index 7fad03a..b85a72c 100644
--- a/Testing/test_overflow.h
+++ b/Testing/test_overflow.h
@@ -32,16 +32,12 @@ hg_proc_overflow_out_t(hg_proc_t proc, void *data)
     overflow_out_t *struct_data = (overflow_out_t *) data;
 
     ret = hg_proc_hg_string_t(proc, &struct_data->string);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_uint64_t(proc, &struct_data->string_len);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
diff --git a/Testing/test_pipeline.c b/Testing/test_pipeline.c
deleted file mode 100644
index 9f540a0..0000000
--- a/Testing/test_pipeline.c
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
- *                    UChicago Argonne, LLC and The HDF Group.
- * All rights reserved.
- *
- * The full copyright notice, including terms governing use, modification,
- * and redistribution, is contained in the COPYING file that can be
- * found at the root of the source code distribution tree.
- */
-
-#include "mercury_test.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-extern hg_id_t hg_test_pipeline_write_id_g;
-
-/*****************************************************************************/
-int main(int argc, char *argv[])
-{
-    hg_addr_t addr;
-
-    bulk_write_in_t bulk_write_in_struct;
-    bulk_write_out_t bulk_write_out_struct;
-    hg_request_t bulk_write_request;
-
-    int fildes = 12345;
-    int *bulk_buf;
-    void *buf_ptr[1];
-    size_t count = (1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE) / sizeof(int);
-    size_t bulk_size = count * sizeof(int);
-    hg_bulk_t bulk_handle = HG_BULK_NULL;
-    size_t bulk_write_ret = 0;
-
-    hg_status_t bla_open_status;
-    hg_return_t hg_ret;
-    size_t i;
-
-    /* Initialize the interface (for convenience, shipper_test_client_init
-     * initializes the network interface with the selected plugin)
-     */
-    HG_Test_client_init(argc, argv, &addr, NULL);
-
-    /* Prepare bulk_buf */
-    bulk_buf = (int*) malloc(bulk_size);
-    for (i = 0; i < count; i++) {
-        bulk_buf[i] = (int) i;
-    }
-    *buf_ptr = bulk_buf;
-
-    /* Register memory */
-    hg_ret = HG_Bulk_handle_create(1, buf_ptr, &bulk_size,
-            HG_BULK_READ_ONLY, &bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not create bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Fill input structure */
-    bulk_write_in_struct.fildes = fildes;
-    bulk_write_in_struct.bulk_handle = bulk_handle;
-
-    /* Forward call to remote addr and get a new request */
-    /* printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_write_id_g); */
-    hg_ret = HG_Forward(addr, hg_test_pipeline_write_id_g,
-            &bulk_write_in_struct, &bulk_write_out_struct, &bulk_write_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not forward call\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Wait for call to be executed and return value to be sent back
-     * (Request is freed when the call completes)
-     */
-    hg_ret = HG_Wait(bulk_write_request, HG_MAX_IDLE_TIME, &bla_open_status);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Error during wait\n");
-        return EXIT_FAILURE;
-    }
-    if (!bla_open_status) {
-        fprintf(stderr, "Operation did not complete\n");
-        return EXIT_FAILURE;
-    } else {
-        /* printf("Call completed\n"); */
-    }
-
-    /* Get output parameters */
-    bulk_write_ret = bulk_write_out_struct.ret;
-    if (bulk_write_ret != bulk_size) {
-        fprintf(stderr, "Data not correctly processed\n");
-    }
-
-    /* Free request */
-    hg_ret = HG_Request_free(bulk_write_request);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free request\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Free memory handle */
-    hg_ret = HG_Bulk_handle_free(bulk_handle);
-    if (hg_ret != HG_SUCCESS) {
-        fprintf(stderr, "Could not free bulk data handle\n");
-        return EXIT_FAILURE;
-    }
-
-    /* Free bulk_buf */
-    free(bulk_buf);
-    bulk_buf = NULL;
-
-    HG_Test_finalize();
-
-    return EXIT_SUCCESS;
-}
diff --git a/Testing/test_posix.h b/Testing/test_posix.h
index 770f946..9e88136 100644
--- a/Testing/test_posix.h
+++ b/Testing/test_posix.h
@@ -66,22 +66,16 @@ hg_proc_open_in_t(hg_proc_t proc, void *data)
     open_in_t *struct_data = (open_in_t *) data;
 
     ret = hg_proc_hg_const_string_t(proc, &struct_data->path);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_int32_t(proc, &struct_data->flags);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_uint32_t(proc, &struct_data->mode);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -99,10 +93,8 @@ hg_proc_open_out_t(hg_proc_t proc, void *data)
     open_out_t *struct_data = (open_out_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -120,10 +112,8 @@ hg_proc_close_in_t(hg_proc_t proc, void *data)
     close_in_t *struct_data = (close_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fd);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -141,10 +131,8 @@ hg_proc_close_out_t(hg_proc_t proc, void *data)
     close_out_t *struct_data = (close_out_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -163,16 +151,12 @@ hg_proc_write_in_t(hg_proc_t proc, void *data)
     write_in_t *struct_data = (write_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fd);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -190,10 +174,8 @@ hg_proc_write_out_t(hg_proc_t proc, void *data)
     write_out_t *struct_data = (write_out_t *) data;
 
     ret = hg_proc_int64_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -212,16 +194,12 @@ hg_proc_read_in_t(hg_proc_t proc, void *data)
     read_in_t *struct_data = (read_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fd);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -239,10 +217,8 @@ hg_proc_read_out_t(hg_proc_t proc, void *data)
     read_out_t *struct_data = (read_out_t *) data;
 
     ret = hg_proc_int64_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
diff --git a/Testing/test_rpc.c b/Testing/test_rpc.c
index 67834dd..2146b0e 100644
--- a/Testing/test_rpc.c
+++ b/Testing/test_rpc.c
@@ -9,32 +9,72 @@
  */
 
 #include "mercury_test.h"
+#include "mercury_hl.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 
-extern hg_id_t hg_test_rpc_open_id_g;
-extern hg_id_t hg_test_rpc_open_id_no_resp_g;
+/****************/
+/* Local Macros */
+/****************/
 
 #define NINFLIGHT 32
 
+/************************************/
+/* Local Type and Struct Definition */
+/************************************/
+
 struct forward_cb_args {
     hg_request_t *request;
     rpc_handle_t *rpc_handle;
 };
 
-//#define HG_TEST_DEBUG
-#ifdef HG_TEST_DEBUG
-#define HG_TEST_LOG_DEBUG(...)                                \
-    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
-#else
-#define HG_TEST_LOG_DEBUG(...) (void)0
-#endif
+/********************/
+/* Local Prototypes */
+/********************/
+
+static hg_return_t
+hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+hg_test_rpc_forward_no_resp_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+hg_test_rpc_forward_reset_cb(const struct hg_cb_info *callback_info);
+static hg_return_t
+hg_test_rpc_forward_overflow_cb(const struct hg_cb_info *callback_info);
+
+static hg_return_t
+hg_test_rpc(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_rpc_lookup(hg_context_t *context, hg_request_class_t *request_class,
+    const char *target_name, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_uint8_t target_id, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_overflow(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
+static hg_return_t
+hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
+
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+extern hg_id_t hg_test_rpc_open_id_g;
+extern hg_id_t hg_test_rpc_open_id_no_resp_g;
+extern hg_id_t hg_test_overflow_id_g;
+extern hg_id_t hg_test_cancel_rpc_id_g;
 
 /*---------------------------------------------------------------------------*/
-/**
- * HG_Forward callback
- */
 static hg_return_t
 hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -45,17 +85,16 @@ hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
     rpc_open_out_t rpc_open_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_DEBUG("Return from callback info is not HG_SUCCESS");
+    if (callback_info->ret == HG_NOENTRY)
         goto done;
-    }
+
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
 
     /* Get output */
     ret = HG_Get_output(handle, &rpc_open_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not get output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Get output parameters */
     rpc_open_ret = rpc_open_out_struct.ret;
@@ -63,17 +102,13 @@ hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
     HG_TEST_LOG_DEBUG("rpc_open returned: %d with event_id: %d", rpc_open_ret,
         rpc_open_event_id);
     (void)rpc_open_ret;
-    if (rpc_open_event_id != (int) args->rpc_handle->cookie) {
-        HG_TEST_LOG_ERROR("Cookie did not match RPC response");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(rpc_open_event_id != (int) args->rpc_handle->cookie,
+        done, ret, HG_FAULT, "Cookie did not match RPC response");
 
     /* Free request */
     ret = HG_Free_output(handle, &rpc_open_out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not free output");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     hg_request_complete(args->request);
@@ -81,19 +116,14 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-/**
- * HG_Forward callback (no response)
- */
 static hg_return_t
 hg_test_rpc_forward_no_resp_cb(const struct hg_cb_info *callback_info)
 {
     struct forward_cb_args *args = (struct forward_cb_args *) callback_info->arg;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
 
 done:
     hg_request_complete(args->request);
@@ -107,44 +137,91 @@ hg_test_rpc_forward_reset_cb(const struct hg_cb_info *callback_info)
     struct forward_cb_args *args = (struct forward_cb_args *) callback_info->arg;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
 
     ret = HG_Reset(callback_info->info.forward.handle, HG_ADDR_NULL, 0);
-    if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not reset handle");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Reset() failed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     hg_request_complete(args->request);
     return ret;
 }
 
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_rpc_forward_overflow_cb(const struct hg_cb_info *callback_info)
+{
+    hg_handle_t handle = callback_info->info.forward.handle;
+    hg_request_t *request = (hg_request_t *) callback_info->arg;
+    overflow_out_t out_struct;
+    hg_string_t string;
+    size_t string_len;
+    hg_return_t ret = HG_SUCCESS;
+
+    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
+
+    /* Get output */
+    ret = HG_Get_output(handle, &out_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
+        HG_Error_to_string(ret));
+
+    /* Get output parameters */
+    string = out_struct.string;
+    string_len = out_struct.string_len;
+    HG_TEST_LOG_DEBUG("Returned string (length %zu): %s", string_len, string);
+
+    /* Free request */
+    ret = HG_Free_output(handle, &out_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
+        HG_Error_to_string(ret));
+
+done:
+    hg_request_complete(request);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_rpc_forward_cancel_cb(const struct hg_cb_info *callback_info)
+{
+    hg_request_t *request = (hg_request_t *) callback_info->arg;
+    hg_return_t ret = HG_SUCCESS;
+
+    if (callback_info->ret == HG_CANCELED)
+        HG_TEST_LOG_DEBUG("HG_Forward() was successfully canceled");
+    else
+        HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
+            "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
+
+done:
+    hg_request_complete(request);
+    return ret;
+}
+
 /*---------------------------------------------------------------------------*/
 static hg_return_t
 hg_test_rpc(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
-    hg_handle_t handle;
-    hg_return_t hg_ret = HG_SUCCESS;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
     hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
-    rpc_open_in_t  rpc_open_in_struct;
+    rpc_open_in_t rpc_open_in_struct;
 
     request = hg_request_create(request_class);
 
     /* Create RPC request */
-    hg_ret = HG_Create(context, addr, rpc_id, &handle);
-    if (hg_ret != HG_SUCCESS) {
-        if (hg_ret != HG_NO_MATCH)
-            HG_TEST_LOG_ERROR("Could not create handle");
+    ret = HG_Create(context, addr, rpc_id, &handle);
+    if (ret == HG_NOENTRY)
         goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     rpc_open_handle.cookie = 100;
@@ -155,25 +232,95 @@ hg_test_rpc(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args.request = request;
     forward_cb_args.rpc_handle = &rpc_open_handle;
-    hg_ret = HG_Forward(handle, callback, &forward_cb_args,
+again:
+    ret = HG_Forward(handle, callback, &forward_cb_args,
         &rpc_open_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
+    if (ret == HG_AGAIN) {
+        hg_request_wait(request, 0, NULL);
+        goto again;
     }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
-    /* Complete */
-    hg_ret = HG_Destroy(handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    hg_request_destroy(request);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_rpc_lookup(hg_context_t *context, hg_request_class_t *request_class,
+    const char *target_name, hg_id_t rpc_id, hg_cb_t callback)
+{
+    hg_request_t *request = NULL;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS;
+    struct forward_cb_args forward_cb_args;
+    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    rpc_handle_t rpc_open_handle;
+    rpc_open_in_t rpc_open_in_struct;
+    hg_addr_t target_addr = HG_ADDR_NULL;
+    int i;
+
+    for (i = 0; i < 32; i++) {
+        request = hg_request_create(request_class);
+
+        /* Look up target addr using target name info */
+        ret = HG_Hl_addr_lookup_wait(context, request_class, target_name,
+            &target_addr, HG_MAX_IDLE_TIME);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_addr_lookup_wait() failed (%s)",
+            HG_Error_to_string(ret));
+
+        /* Create RPC request */
+        ret = HG_Create(context, target_addr, rpc_id, &handle);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+            HG_Error_to_string(ret));
+
+        /* Fill input structure */
+        rpc_open_handle.cookie = 100;
+        rpc_open_in_struct.path = rpc_open_path;
+        rpc_open_in_struct.handle = rpc_open_handle;
+
+        /* Forward call to remote addr and get a new request */
+        HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
+        forward_cb_args.request = request;
+        forward_cb_args.rpc_handle = &rpc_open_handle;
+        ret = HG_Forward(handle, callback, &forward_cb_args,
+            &rpc_open_in_struct);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+            HG_Error_to_string(ret));
+
+        hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+        /* Complete */
+        ret = HG_Destroy(handle);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+            HG_Error_to_string(ret));
+
+        ret = HG_Addr_set_remove(context->hg_class, target_addr);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_set_remove() failed (%s)",
+            HG_Error_to_string(ret));
+
+        ret = HG_Addr_free(context->hg_class, target_addr);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_free() failed (%s)",
+            HG_Error_to_string(ret));
+        target_addr = HG_ADDR_NULL;
+
+        hg_request_destroy(request);
+        request = NULL;
     }
 
 done:
     hg_request_destroy(request);
-    return hg_ret;
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -182,28 +329,24 @@ hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
-    hg_handle_t handle;
-    hg_return_t hg_ret = HG_SUCCESS;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
     hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
-    rpc_open_in_t  rpc_open_in_struct;
+    rpc_open_in_t rpc_open_in_struct;
 
     request = hg_request_create(request_class);
 
     /* Create request with invalid RPC id */
-    hg_ret = HG_Create(context, HG_ADDR_NULL, 0, &handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    ret = HG_Create(context, HG_ADDR_NULL, 0, &handle);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Reset with valid addr and ID */
-    hg_ret = HG_Reset(handle, addr, rpc_id);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not reset handle");
-        goto done;
-    }
+    ret = HG_Reset(handle, addr, rpc_id);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Reset() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     rpc_open_handle.cookie = 100;
@@ -214,26 +357,21 @@ hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args.request = request;
     forward_cb_args.rpc_handle = &rpc_open_handle;
-    hg_ret = HG_Forward(handle, callback, &forward_cb_args,
+    ret = HG_Forward(handle, callback, &forward_cb_args,
         &rpc_open_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
-    /* Complete */
-    hg_ret = HG_Destroy(handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_destroy(request);
 
-done:
-    return hg_ret;
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -242,8 +380,8 @@ hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
-    hg_handle_t handle;
-    hg_return_t hg_ret = HG_SUCCESS;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
     hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
@@ -252,13 +390,13 @@ hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
     request = hg_request_create(request_class);
 
     /* Create request with invalid RPC id */
-    hg_ret = HG_Create(context, addr, rpc_id, &handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    ret = HG_Create(context, addr, rpc_id, &handle);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
 
-    HG_Set_target_id(handle, 0);
+    ret = HG_Set_target_id(handle, 0);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     rpc_open_handle.cookie = 100;
@@ -269,26 +407,21 @@ hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args.request = request;
     forward_cb_args.rpc_handle = &rpc_open_handle;
-    hg_ret = HG_Forward(handle, callback, &forward_cb_args,
+    ret = HG_Forward(handle, callback, &forward_cb_args,
         &rpc_open_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
-    /* Complete */
-    hg_ret = HG_Destroy(handle);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_destroy(request);
 
-done:
-    return hg_ret;
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -299,8 +432,8 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     hg_request_t *request1 = NULL, *request2 = NULL;
     hg_handle_t handle1, handle2;
     struct forward_cb_args forward_cb_args1, forward_cb_args2;
-    hg_return_t hg_ret = HG_SUCCESS;
-    rpc_open_in_t  rpc_open_in_struct;
+    hg_return_t ret = HG_SUCCESS;
+    rpc_open_in_t rpc_open_in_struct;
     hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle1, rpc_open_handle2;
     /* Used for multiple in-flight RPCs */
@@ -313,16 +446,13 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     /* Create request 1 */
     request1 = hg_request_create(request_class);
 
-    hg_ret = HG_Create(context, addr, rpc_id, &handle1);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
-    hg_ret = HG_Set_target_id(handle1, target_id);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not set target ID to handle");
-        goto done;
-    }
+    ret = HG_Create(context, addr, rpc_id, &handle1);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
+
+    ret = HG_Set_target_id(handle1, target_id);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     rpc_open_handle1.cookie = 1;
@@ -333,26 +463,20 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args1.request = request1;
     forward_cb_args1.rpc_handle = &rpc_open_handle1;
-    hg_ret = HG_Forward(handle1, callback, &forward_cb_args1,
-        &rpc_open_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
+    ret = HG_Forward(handle1, callback, &forward_cb_args1, &rpc_open_in_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Create request 2 */
     request2 = hg_request_create(request_class);
 
-    hg_ret = HG_Create(context, addr, rpc_id, &handle2);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
-        goto done;
-    }
-    hg_ret = HG_Set_target_id(handle2, target_id);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not set target ID to handle");
-        goto done;
-    }
+    ret = HG_Create(context, addr, rpc_id, &handle2);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
+
+    ret = HG_Set_target_id(handle2, target_id);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+        HG_Error_to_string(ret));
 
     /* Fill input structure */
     rpc_open_handle2.cookie = 2;
@@ -363,27 +487,21 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args2.request = request2;
     forward_cb_args2.rpc_handle = &rpc_open_handle2;
-    hg_ret = HG_Forward(handle2, callback, &forward_cb_args2,
-        &rpc_open_in_struct);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    ret = HG_Forward(handle2, callback, &forward_cb_args2, &rpc_open_in_struct);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_wait(request2, HG_MAX_IDLE_TIME, NULL);
     hg_request_wait(request1, HG_MAX_IDLE_TIME, NULL);
 
     /* Complete */
-    hg_ret = HG_Destroy(handle1);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
-    hg_ret = HG_Destroy(handle2);
-    if (hg_ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
-        goto done;
-    }
+    ret = HG_Destroy(handle1);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    ret = HG_Destroy(handle2);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
 
     hg_request_destroy(request1);
     hg_request_destroy(request2);
@@ -393,46 +511,115 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
      */
     HG_TEST_LOG_DEBUG("Creating %u requests...", NINFLIGHT);
     for (i = 0; i < NINFLIGHT; i++) {
-	    request_m[i] = hg_request_create(request_class);
-	    hg_ret = HG_Create(context, addr, rpc_id, handle_m + i );
-	    if (hg_ret != HG_SUCCESS) {
-	        HG_TEST_LOG_ERROR("Could not create handle");
-		    goto done;
-	    }
-	    hg_ret = HG_Set_target_id(handle_m[i], target_id);
-	    if (hg_ret != HG_SUCCESS) {
-	        HG_TEST_LOG_ERROR("Could not set target ID to handle");
-	        goto done;
-	    }
-	    rpc_open_handle_m[i].cookie = i;
-	    rpc_open_in_struct.path = rpc_open_path;
-	    rpc_open_in_struct.handle = rpc_open_handle_m[i];
-	    HG_TEST_LOG_DEBUG(" %d Forwarding rpc_open, op id: %u...", i, rpc_id);
-	    forward_cb_args_m[i].request = request_m[i];
-	    forward_cb_args_m[i].rpc_handle = &rpc_open_handle_m[i];
-	    hg_ret = HG_Forward(handle_m[i], callback, &forward_cb_args_m[i],
-	        &rpc_open_in_struct);
-	    if (hg_ret != HG_SUCCESS) {
-	        HG_TEST_LOG_ERROR("Could not forward call");
-		    goto done;
-	    }
+        request_m[i] = hg_request_create(request_class);
+        ret = HG_Create(context, addr, rpc_id, handle_m + i);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+            HG_Error_to_string(ret));
+
+        ret = HG_Set_target_id(handle_m[i], target_id);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+            HG_Error_to_string(ret));
+
+        rpc_open_handle_m[i].cookie = i;
+        rpc_open_in_struct.path = rpc_open_path;
+        rpc_open_in_struct.handle = rpc_open_handle_m[i];
+        HG_TEST_LOG_DEBUG(" %d Forwarding rpc_open, op id: %u...", i, rpc_id);
+        forward_cb_args_m[i].request = request_m[i];
+        forward_cb_args_m[i].rpc_handle = &rpc_open_handle_m[i];
+        ret = HG_Forward(handle_m[i], callback, &forward_cb_args_m[i],
+            &rpc_open_in_struct);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     /* Complete */
     for (i = 0; i < NINFLIGHT; i++) {
-	    hg_request_wait(request_m[i], HG_MAX_IDLE_TIME, NULL);
-
-	    hg_ret = HG_Destroy(handle_m[i]);
-	    if (hg_ret != HG_SUCCESS) {
-	        HG_TEST_LOG_ERROR("Could not destroy handle");
-		    goto done;
-	    }
-	    hg_request_destroy(request_m[i]);
+        hg_request_wait(request_m[i], HG_MAX_IDLE_TIME, NULL);
+
+        ret = HG_Destroy(handle_m[i]);
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+            HG_Error_to_string(ret));
+
+        hg_request_destroy(request_m[i]);
     }
     HG_TEST_LOG_DEBUG("Done");
 
 done:
-    return hg_ret;
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_overflow(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
+{
+    hg_request_t *request = NULL;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS;
+
+    request = hg_request_create(request_class);
+
+    /* Create RPC request */
+    ret = HG_Create(context, addr, rpc_id, &handle);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
+
+    /* Forward call to remote addr and get a new request */
+    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
+    ret = HG_Forward(handle, callback, request, NULL);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
+
+    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    hg_request_destroy(request);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
+{
+    hg_request_t *request = NULL;
+    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_return_t ret = HG_SUCCESS;
+
+    request = hg_request_create(request_class);
+
+    /* Create RPC request */
+    ret = HG_Create(context, addr, rpc_id, &handle);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+        HG_Error_to_string(ret));
+
+    /* Forward call to remote addr and get a new request */
+    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
+    ret = HG_Forward(handle, callback, request, NULL);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+        HG_Error_to_string(ret));
+
+    /* Cancel request before making progress, this ensures that the RPC has not
+     * completed yet. */
+    ret = HG_Cancel(handle);
+    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Cancel() failed (%s)",
+        HG_Error_to_string(ret));
+
+    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+done:
+    ret = HG_Destroy(handle);
+    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
+        HG_Error_to_string(ret));
+
+    hg_request_destroy(request);
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -445,28 +632,48 @@ main(int argc, char *argv[])
     int ret = EXIT_SUCCESS;
 
     /* Initialize the interface */
-    HG_Test_init(argc, argv, &hg_test_info);
+    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
     /* Simple RPC test */
     HG_TEST("simple RPC");
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "simple RPC test failed");
     HG_PASSED();
 
+    /* RPC test with lookup/free */
+    if (!hg_test_info.na_test_info.self_send &&
+        strcmp(HG_Class_get_name(hg_test_info.hg_class), "mpi")) {
+        HG_Addr_free(hg_test_info.hg_class, hg_test_info.target_addr);
+        hg_test_info.target_addr = HG_ADDR_NULL;
+
+        HG_TEST("lookup RPC");
+        hg_ret = hg_test_rpc_lookup(hg_test_info.context,
+            hg_test_info.request_class, hg_test_info.na_test_info.target_name,
+            hg_test_rpc_open_id_g, hg_test_rpc_forward_cb);
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "lookup test failed");
+        HG_PASSED();
+
+        /* Look up target addr using target name info */
+        hg_ret = HG_Hl_addr_lookup_wait(hg_test_info.context,
+            hg_test_info.request_class, hg_test_info.na_test_info.target_name,
+            &hg_test_info.target_addr, HG_MAX_IDLE_TIME);
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "HG_Hl_addr_lookup_wait() failed (%s)", HG_Error_to_string(hg_ret));
+    }
+
     /* RPC reset test */
     HG_TEST("RPC reset");
     hg_ret = hg_test_rpc_reset(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "reset RPC test failed");
     HG_PASSED();
 
     /* RPC test with tag mask */
@@ -474,10 +681,8 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc_mask(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "tagged RPC test failed");
     HG_PASSED();
 
     /* RPC test with no response */
@@ -485,37 +690,37 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_no_resp_g,
         hg_test_rpc_forward_no_resp_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "no response RPC test failed");
     HG_PASSED();
 
     /* RPC test with unregistered ID */
-    HG_TEST("unregistered RPC");
-    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "unreg_id", void, void, NULL);
+    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "unreg_id", void, void,
+        NULL);
+    HG_TEST_CHECK_ERROR(inv_id == 0, done, ret, EXIT_FAILURE,
+        "HG_Register() failed");
     hg_ret = HG_Deregister(hg_test_info.hg_class, inv_id);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Deregister() failed (%s)", HG_Error_to_string(hg_ret));
+
+    HG_TEST("unregistered RPC");
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, inv_id, hg_test_rpc_forward_cb);
-    if (hg_ret == HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "unregistered RPC test failed");
     HG_PASSED();
 
     /* RPC test with invalid ID (not registered on server) */
+    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "inv_id", void, void,
+        NULL);
+    HG_TEST_CHECK_ERROR(inv_id == 0, done, ret, EXIT_FAILURE,
+        "HG_Register() failed");
+
     HG_TEST("invalid RPC");
-    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "inv_id", void, void, NULL);
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, inv_id, hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "invalid RPC test failed");
     HG_PASSED();
 
     /* RPC test with reset */
@@ -523,10 +728,8 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_reset_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "reset RPC test failed");
     HG_PASSED();
 
     /* RPC test with multiple handle in flight */
@@ -534,10 +737,8 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc_multiple(hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 0,
         hg_test_rpc_open_id_g, hg_test_rpc_forward_cb);
-    if (hg_ret != HG_SUCCESS) {
-        ret = EXIT_FAILURE;
-        goto done;
-    }
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "concurrent RPC test failed");
     HG_PASSED();
 
     /* RPC test with multiple handle to multiple target contexts */
@@ -545,22 +746,43 @@ main(int argc, char *argv[])
         hg_uint8_t i, context_count =
             hg_test_info.na_test_info.max_contexts;
 
-        HG_TEST("multi-target RPCs");
+        HG_TEST("multi context target RPCs");
         for (i = 0; i < context_count; i++) {
             hg_ret = hg_test_rpc_multiple(hg_test_info.context,
                 hg_test_info.request_class, hg_test_info.target_addr, i,
                 hg_test_rpc_open_id_g, hg_test_rpc_forward_cb);
-            if (hg_ret != HG_SUCCESS) {
-                ret = EXIT_FAILURE;
-                goto done;
-            }
+            HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+                "multi context target RPC test failed");
         }
         HG_PASSED();
     }
 
+    /* Overflow RPC test */
+    HG_TEST("overflow RPC");
+    hg_ret = hg_test_overflow(hg_test_info.context, hg_test_info.request_class,
+        hg_test_info.target_addr, hg_test_overflow_id_g,
+        hg_test_rpc_forward_overflow_cb);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "overflow RPC test failed");
+    HG_PASSED();
+
+    /* Cancel RPC test (self cancelation is not supported) */
+    if (!hg_test_info.na_test_info.self_send) {
+        HG_TEST("cancel RPC");
+        hg_ret = hg_test_cancel_rpc(hg_test_info.context,
+            hg_test_info.request_class, hg_test_info.target_addr,
+            hg_test_cancel_rpc_id_g, hg_test_rpc_forward_cancel_cb);
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "cancel RPC test failed");
+        HG_PASSED();
+    }
+
 done:
     if (ret != EXIT_SUCCESS)
         HG_FAILED();
-    HG_Test_finalize(&hg_test_info);
+
+    hg_ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
+
     return ret;
 }
diff --git a/Testing/test_rpc.h b/Testing/test_rpc.h
index fddc856..6f14eaa 100644
--- a/Testing/test_rpc.h
+++ b/Testing/test_rpc.h
@@ -50,10 +50,8 @@ hg_proc_rpc_handle_t(hg_proc_t proc, void *data)
     rpc_handle_t *struct_data = (rpc_handle_t *) data;
 
     ret = hg_proc_uint64_t(proc, &struct_data->cookie);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -72,16 +70,12 @@ hg_proc_rpc_open_in_t(hg_proc_t proc, void *data)
     rpc_open_in_t *struct_data = (rpc_open_in_t *) data;
 
     ret = hg_proc_hg_const_string_t(proc, &struct_data->path);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_rpc_handle_t(proc, &struct_data->handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -100,16 +94,12 @@ hg_proc_rpc_open_out_t(hg_proc_t proc, void *data)
     rpc_open_out_t *struct_data = (rpc_open_out_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     ret = hg_proc_int32_t(proc, &struct_data->event_id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     return ret;
 }
@@ -123,10 +113,8 @@ hg_proc_perf_rpc_lat_in_t(hg_proc_t proc, void *data)
     hg_return_t ret = HG_SUCCESS;
 
     ret = hg_proc_hg_uint32_t(proc, &struct_data->buf_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Proc error");
+    if (ret != HG_SUCCESS)
         return ret;
-    }
 
     if (struct_data->buf_size) {
         switch (hg_proc_get_op(proc)) {
@@ -135,17 +123,14 @@ hg_proc_perf_rpc_lat_in_t(hg_proc_t proc, void *data)
                 HG_FALLTHROUGH();
             case HG_ENCODE:
                 ret = hg_proc_raw(proc, struct_data->buf, struct_data->buf_size);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                if (ret != HG_SUCCESS)
                     return ret;
-                }
                 break;
             case HG_FREE:
                 free(struct_data->buf);
                 break;
             default:
-                HG_LOG_ERROR("Proc error");
-                ret = HG_PROTOCOL_ERROR;
+                ret = HG_INVALID_ARG;
                 return ret;
         }
 
diff --git a/Testing/test_rpc_lat.c b/Testing/test_rpc_lat.c
index a31c3c2..2ddc1bc 100644
--- a/Testing/test_rpc_lat.c
+++ b/Testing/test_rpc_lat.c
@@ -79,12 +79,17 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
     /* Prepare bulk_buf */
     if (nbytes) {
         bulk_buf = malloc(nbytes);
+        HG_TEST_CHECK_ERROR(bulk_buf == NULL, done, ret, HG_NOMEM_ERROR,
+            "Could not allocate bulk buf");
         for (i = 0; i < nbytes; i++)
             bulk_buf[i] = (char) i;
     }
 
     /* Create handles */
     handles = malloc(nhandles * sizeof(hg_handle_t));
+    HG_TEST_CHECK_ERROR(handles == NULL, done, ret, HG_NOMEM_ERROR,
+        "Could not allocate handles");
+
     for (i = 0; i < nhandles; i++) {
         /* Use NULL RPC ID to skip proc encoding if total_size = 0 */
         hg_id_t rpc_id = total_size ? hg_test_perf_rpc_lat_id_g :
@@ -92,10 +97,8 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
 
         ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
             rpc_id, &handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not start call\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
     request = hg_request_create(hg_test_info->request_class);
@@ -114,10 +117,8 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
         for (j = 0; j < nhandles; j++) {
             ret = HG_Forward(handles[j], hg_test_perf_forward_cb,
                 &args, &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
-            }
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -136,16 +137,17 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
 
         for (j = 0; j < nhandles; j++) {
             /* Assign handles to multiple targets */
-            if (hg_test_info->na_test_info.max_contexts > 1)
-                HG_Set_target_id(handles[j],
+            if (hg_test_info->na_test_info.max_contexts > 1) {
+                ret = HG_Set_target_id(handles[j],
                     (hg_uint8_t) (avg_iter % hg_test_info->na_test_info.max_contexts));
+                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
+                    HG_Error_to_string(ret));
+            }
 
             ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
 			     &in_struct);
-            if (ret != HG_SUCCESS) {
-                fprintf(stderr, "Could not forward call\n");
-                goto done;
-            }
+            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
+                HG_Error_to_string(ret));
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -178,10 +180,8 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
     hg_request_destroy(request);
     for (i = 0; i < nhandles; i++) {
         ret = HG_Destroy(handles[i]);
-        if (ret != HG_SUCCESS) {
-            fprintf(stderr, "Could not complete\n");
-            goto done;
-        }
+        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
+            HG_Error_to_string(ret));
     }
 
 done:
@@ -197,8 +197,12 @@ main(int argc, char *argv[])
     struct hg_test_info hg_test_info = { 0 };
     unsigned int nhandles;
     size_t size;
+    hg_return_t hg_ret;
+    int ret = EXIT_SUCCESS;
 
-    HG_Test_init(argc, argv, &hg_test_info);
+    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
+    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+        "HG_Test_init() failed");
 
     for (nhandles = 1; nhandles <= MAX_HANDLES; nhandles *= 2) {
         if (hg_test_info.na_test_info.mpi_comm_rank == 0) {
@@ -215,16 +219,23 @@ main(int argc, char *argv[])
         }
 
         /* NULL RPC */
-        measure_rpc_latency(&hg_test_info, 0, nhandles);
+        hg_ret = measure_rpc_latency(&hg_test_info, 0, nhandles);
+        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+            "measure_rpc_latency() failed");
 
         /* RPC with different sizes */
-        for (size = sizeof(hg_uint32_t); size <= MAX_MSG_SIZE; size *= 2)
-            measure_rpc_latency(&hg_test_info, size, nhandles);
+        for (size = sizeof(hg_uint32_t); size <= MAX_MSG_SIZE; size *= 2) {
+            hg_ret = measure_rpc_latency(&hg_test_info, size, nhandles);
+            HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
+                "measure_rpc_latency() failed");
+        }
 
         fprintf(stdout, "\n");
     }
 
-    HG_Test_finalize(&hg_test_info);
+done:
+    hg_ret = HG_Test_finalize(&hg_test_info);
+    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
 
-    return EXIT_SUCCESS;
+    return ret;
 }
diff --git a/Testing/test_server.c b/Testing/test_server.c
index bee0c8e..8023c04 100644
--- a/Testing/test_server.c
+++ b/Testing/test_server.c
@@ -127,7 +127,7 @@ main(int argc, char *argv[])
     }
 #else
     if (hg_test_info.secondary_contexts)
-        HG_LOG_WARNING("Secondary contexts only supported with thread pool");
+        HG_TEST_LOG_WARNING("Secondary contexts only supported with thread pool");
 
     do {
         unsigned int actual_count = 0;
diff --git a/Testing/util/test_thread.c b/Testing/util/test_thread.c
index 1888b33..0312b5d 100644
--- a/Testing/util/test_thread.c
+++ b/Testing/util/test_thread.c
@@ -56,6 +56,20 @@ done:
     return thread_ret;
 }
 
+static HG_THREAD_RETURN_TYPE
+thread_cb_equal(void *arg)
+{
+    hg_thread_ret_t thread_ret = (hg_thread_ret_t) 0;
+    hg_thread_t *t1_ptr = (hg_thread_t *) arg;
+    hg_thread_t t2 = hg_thread_self();
+
+    if (hg_thread_equal(*t1_ptr, t2) == 0)
+        fprintf(stderr, "Error: t1 is not equal to t2\n");
+
+    hg_thread_exit(thread_ret);
+    return thread_ret;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -86,6 +100,9 @@ main(int argc, char *argv[])
     hg_thread_join(thread);
     hg_thread_key_delete(thread_key);
 
+    hg_thread_create(&thread, thread_cb_equal, &thread);
+    hg_thread_join(thread);
+
 done:
     return ret;
 }
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 55e1b8f..f258f24 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -243,7 +243,6 @@ set(MERCURY_HEADERS
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core_header.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core_types.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_error.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_header.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_macros.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_proc_bulk.h
diff --git a/src/mercury.c b/src/mercury.c
index af27515..fcf0a42 100644
--- a/src/mercury.c
+++ b/src/mercury.c
@@ -12,6 +12,7 @@
 #include "mercury_bulk.h"
 #include "mercury_proc.h"
 #include "mercury_proc_bulk.h"
+#include "mercury_error.h"
 
 #include "mercury_hash_string.h"
 #include "mercury_mem.h"
@@ -19,6 +20,7 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include <assert.h>
 
 /****************/
 /* Local Macros */
@@ -26,10 +28,6 @@
 
 #define HG_POST_LIMIT_DEFAULT 256
 
-/* Convert value to string */
-#define HG_ERROR_STRING_MACRO(def, value, string) \
-  if (value == def) string = #def
-
 #define HG_CONTEXT_CLASS(context) \
     ((struct hg_private_class *)(context->hg_class))
 
@@ -40,11 +38,9 @@
 /* HG class */
 struct hg_private_class {
     struct hg_class hg_class;       /* Must remain as first field */
-    hg_thread_spin_t register_lock; /* Register lock */
-
-    /* Callbacks */
     hg_return_t (*handle_create)(hg_handle_t, void *);  /* handle_create */
     void *handle_create_arg;                            /* handle_create arg */
+    hg_thread_spin_t register_lock; /* Register lock */
 };
 
 /* Info for function map */
@@ -52,28 +48,28 @@ struct hg_proc_info {
     hg_rpc_cb_t rpc_cb;             /* RPC callback */
     hg_proc_cb_t in_proc_cb;        /* Input proc callback */
     hg_proc_cb_t out_proc_cb;       /* Output proc callback */
-    hg_bool_t no_response;          /* RPC response not expected */
     void *data;                     /* User data */
     void (*free_callback)(void *);  /* User data free callback */
+    hg_bool_t no_response;          /* RPC response not expected */
 };
 
 /* HG handle */
 struct hg_private_handle {
     struct hg_handle handle;        /* Must remain as first field */
+    struct hg_header hg_header;     /* Header for input/output */
     hg_cb_t forward_cb;             /* Forward callback */
-    void *forward_arg;              /* Forward callback args */
     hg_cb_t respond_cb;             /* Respond callback */
+    hg_return_t (*extra_bulk_transfer_cb)(hg_core_handle_t); /* Bulk transfer callback */
+    void *forward_arg;              /* Forward callback args */
     void *respond_arg;              /* Respond callback args */
-    struct hg_header hg_header;     /* Header for input/output */
+    void *in_extra_buf;             /* Extra input buffer */
+    void *out_extra_buf;            /* Extra output buffer */
     hg_proc_t in_proc;              /* Proc for input */
     hg_proc_t out_proc;             /* Proc for output */
-    void *in_extra_buf;             /* Extra input buffer */
-    hg_size_t in_extra_buf_size;    /* Extra input buffer size */
     hg_bulk_t in_extra_bulk;        /* Extra input bulk handle */
-    void *out_extra_buf;            /* Extra output buffer */
-    hg_size_t out_extra_buf_size;   /* Extra output buffer size */
     hg_bulk_t out_extra_bulk;       /* Extra output bulk handle */
-    hg_return_t (*extra_bulk_transfer_cb)(hg_core_handle_t); /* Bulk transfer callback */
+    hg_size_t in_extra_buf_size;    /* Extra input buffer size */
+    hg_size_t out_extra_buf_size;   /* Extra output buffer size */
 };
 
 /* HG op id */
@@ -83,13 +79,13 @@ struct hg_op_info_lookup {
 };
 
 struct hg_op_id {
-    struct hg_context *context;     /* Context */
-    hg_cb_type_t type;              /* Callback type */
-    hg_cb_t callback;               /* Callback */
-    void *arg;                      /* Callback arguments */
     union {
         struct hg_op_info_lookup lookup;
     } info;
+    struct hg_context *context;     /* Context */
+    hg_cb_t callback;               /* Callback */
+    void *arg;                      /* Callback arguments */
+    hg_cb_type_t type;              /* Callback type */
 };
 
 /********************/
@@ -244,6 +240,16 @@ hg_core_respond_cb(
 /* Local Variables */
 /*******************/
 
+/* Return code string table */
+#define X(a) #a,
+static const char *const hg_return_name[] = { HG_RETURN_VALUES };
+#undef X
+
+/* Default error log mask */
+#ifdef HG_HAS_VERBOSE_ERROR
+unsigned int HG_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
+#endif
+
 /*---------------------------------------------------------------------------*/
 /**
  * Free function for value in function map.
@@ -268,28 +274,27 @@ hg_handle_create(struct hg_private_class *hg_class)
     /* Create private data to wrap callbacks etc */
     hg_handle = (struct hg_private_handle *) malloc(
         sizeof(struct hg_private_handle));
-    if (!hg_handle) {
-        HG_LOG_ERROR("Could not allocate private data");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_handle == NULL, error,
+        "Could not allocate handle private data");
+
     memset(hg_handle, 0, sizeof(struct hg_private_handle));
     hg_handle->handle.info.hg_class = (hg_class_t *) hg_class;
     hg_header_init(&hg_handle->hg_header, HG_UNDEF);
 
     /* CRC32 is enough for small size buffers */
-    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32, &hg_handle->in_proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Cannot create HG proc");
-        goto done;
-    }
-    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32, &hg_handle->out_proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Cannot create HG proc");
-        goto done;
-    }
+    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32,
+        &hg_handle->in_proc);
+    HG_CHECK_HG_ERROR(error, ret, "Cannot create HG proc");
+
+    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32,
+        &hg_handle->out_proc);
+    HG_CHECK_HG_ERROR(error, ret, "Cannot create HG proc");
 
-done:
     return hg_handle;
+
+error:
+    hg_handle_free(hg_handle);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -298,6 +303,9 @@ hg_handle_free(void *arg)
 {
     struct hg_private_handle *hg_handle = (struct hg_private_handle *) arg;
 
+    if (!hg_handle)
+        return;
+
     if (hg_handle->handle.data_free_callback)
         hg_handle->handle.data_free_callback(hg_handle->handle.data);
     if (hg_handle->in_proc != HG_PROC_NULL)
@@ -317,11 +325,9 @@ hg_handle_create_cb(hg_core_handle_t core_handle, void *arg)
     hg_return_t ret = HG_SUCCESS;
 
     hg_handle = hg_handle_create(HG_CONTEXT_CLASS(hg_context));
-    if (!hg_handle) {
-        HG_LOG_ERROR("Could not create HG handle");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_handle == NULL, error, ret, HG_NOMEM,
+        "Could not create HG handle");
+
     hg_handle->handle.core_handle = core_handle;
     hg_handle->handle.info.context = hg_context;
 
@@ -332,13 +338,13 @@ hg_handle_create_cb(hg_core_handle_t core_handle, void *arg)
         ret = HG_CONTEXT_CLASS(hg_context)->handle_create(
             (hg_handle_t) hg_handle,
             HG_CONTEXT_CLASS(hg_context)->handle_create_arg);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Error in handle create callback");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Error in handle create callback");
     }
 
-done:
+    return ret;
+
+error:
+    hg_handle_free(hg_handle);
     return ret;
 }
 
@@ -353,11 +359,8 @@ hg_more_data_cb(hg_core_handle_t core_handle, hg_op_t op,
 
     /* Retrieve private data */
     hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
-    if (!hg_handle) {
-        HG_LOG_ERROR("Could not get private data");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_handle == NULL, done, ret, HG_FAULT,
+        "Could not get private data");
 
     switch (op) {
         case HG_INPUT:
@@ -367,25 +370,18 @@ hg_more_data_cb(hg_core_handle_t core_handle, hg_op_t op,
             extra_buf = hg_handle->out_extra_buf;
             break;
         default:
-            HG_LOG_ERROR("Invalid HG op");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
     }
 
     if (extra_buf) {
         /* We were forwarding to ourself and the extra buf is already set */
         ret = done_cb(core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not execute more data done callback");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret,
+            "Could not execute more data done callback");
     } else {
         /* We need to do a bulk transfer to get the extra data */
         ret = hg_get_extra_payload(hg_handle, op, done_cb);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get extra input");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not get extra payload");
     }
 
 done:
@@ -400,14 +396,10 @@ hg_more_data_free_cb(hg_core_handle_t core_handle)
 
     /* Retrieve private data */
     hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
-    if (!hg_handle) {
-        goto done;
-    }
+    if (!hg_handle)
+        return;
 
     hg_free_extra_payload(hg_handle);
-
-done:
-    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -425,16 +417,17 @@ hg_core_rpc_cb(hg_core_handle_t core_handle)
     hg_handle->handle.info.context_id = hg_core_info->context_id;
     hg_handle->handle.info.id = hg_core_info->id;
 
-    if (!hg_proc_info->rpc_cb) {
-        HG_LOG_ERROR("No RPC callback registered");
-        /* Need to decrement refcount on handle */
-        HG_Core_destroy(core_handle);
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info->rpc_cb == NULL, error, ret, HG_INVALID_ARG,
+        "No RPC callback registered");
+
     ret = hg_proc_info->rpc_cb((hg_handle_t) hg_handle);
 
-done:
+    return ret;
+
+error:
+    /* Need to decrement refcount on handle */
+    HG_Core_destroy(core_handle);
+
     return ret;
 }
 
@@ -454,6 +447,7 @@ hg_core_addr_lookup_cb(const struct hg_core_cb_info *callback_info)
         hg_op_id->callback(&hg_cb_info);
 
     free(hg_op_id);
+
     return ret;
 }
 
@@ -484,21 +478,19 @@ hg_get_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.input.hash;
 #endif
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get input buffer");
-                goto done;
-            }
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer");
+
             extra_buf = hg_handle->in_extra_buf;
             extra_buf_size = hg_handle->in_extra_buf_size;
             break;
         case HG_OUTPUT:
             /* Cannot respond if no_response flag set */
-            if (hg_proc_info->no_response) {
-                HG_LOG_ERROR("No output was produced on that RPC (no response)");
-                ret = HG_PROTOCOL_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(hg_proc_info->no_response, done, ret,
+                HG_OPNOTSUPPORTED,
+                "No output was produced on that RPC (no response)");
+
             /* Use custom header offset */
             header_offset += hg_handle->handle.info.hg_class->out_offset;
             /* Set output proc */
@@ -508,34 +500,25 @@ hg_get_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.output.hash;
 #endif
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get output buffer");
-                goto done;
-            }
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer");
+
             extra_buf = hg_handle->out_extra_buf;
             extra_buf_size = hg_handle->out_extra_buf_size;
             break;
         default:
-            HG_LOG_ERROR("Invalid HG op");
-            ret = HG_INVALID_PARAM;
-            goto done;
-    }
-    if (!proc_cb) {
-        HG_LOG_ERROR("No proc set, proc must be set in HG_Register()");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
     }
+    HG_CHECK_ERROR(proc_cb == NULL, done, ret, HG_FAULT,
+        "No proc set, proc must be set in HG_Register()");
 
     /* Reset header */
     hg_header_reset(hg_header, op);
 
     /* Get header */
     ret = hg_header_proc(HG_DECODE, buf, buf_size, hg_header);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process header");
 
     /* If the payload did not fit into the core buffer and we have an extra
      * buffer set, use that buffer directly */
@@ -550,33 +533,21 @@ hg_get_struct(struct hg_private_handle *hg_handle,
 
     /* Reset proc */
     ret = hg_proc_reset(proc, buf, buf_size, HG_DECODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
 
     /* Decode parameters */
     ret = proc_cb(proc, struct_ptr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode parameters");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not decode parameters");
 
     /* Flush proc */
     ret = hg_proc_flush(proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in proc flush");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
 
 #ifdef HG_HAS_CHECKSUMS
     /* Compare checksum with header hash */
     ret = hg_proc_checksum_verify(proc, &hg_header_hash->payload,
         sizeof(hg_header_hash->payload));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in proc checksum verify");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error in proc checksum verify");
 #endif
 
     /* Increment ref count on handle so that it remains valid until free_struct
@@ -616,22 +587,20 @@ hg_set_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.input.hash;
 #endif
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get input buffer");
-                goto done;
-            }
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer");
+
             extra_buf = &hg_handle->in_extra_buf;
             extra_buf_size = &hg_handle->in_extra_buf_size;
             extra_bulk = &hg_handle->in_extra_bulk;
             break;
         case HG_OUTPUT:
             /* Cannot respond if no_response flag set */
-            if (hg_proc_info->no_response) {
-                HG_LOG_ERROR("No output was produced on that RPC (no response)");
-                ret = HG_PROTOCOL_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(hg_proc_info->no_response, done, ret,
+                HG_OPNOTSUPPORTED,
+                "No output was produced on that RPC (no response)");
+
             /* Use custom header offset */
             header_offset += hg_handle->handle.info.hg_class->out_offset;
             /* Set output proc */
@@ -641,19 +610,16 @@ hg_set_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.output.hash;
 #endif
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get output buffer");
-                goto done;
-            }
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer");
+
             extra_buf = &hg_handle->out_extra_buf;
             extra_buf_size = &hg_handle->out_extra_buf_size;
             extra_bulk = &hg_handle->out_extra_bulk;
             break;
         default:
-            HG_LOG_ERROR("Invalid HG op");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
     }
     if (!proc_cb || !struct_ptr) {
         /* Silently skip */
@@ -670,33 +636,21 @@ hg_set_struct(struct hg_private_handle *hg_handle,
 
     /* Reset proc */
     ret = hg_proc_reset(proc, buf, buf_size, HG_ENCODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
 
     /* Encode parameters */
     ret = proc_cb(proc, struct_ptr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode parameters");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode parameters");
 
     /* Flush proc */
     ret = hg_proc_flush(proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in proc flush");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
 
 #ifdef HG_HAS_CHECKSUMS
     /* Set checksum in header */
     ret = hg_proc_checksum_get(proc, &hg_header_hash->payload,
         sizeof(hg_header_hash->payload));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in getting proc checksum");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error in getting proc checksum");
 #endif
 
     /* The proc object may have allocated an extra buffer at this point.
@@ -709,9 +663,8 @@ hg_set_struct(struct hg_private_handle *hg_handle,
         /* Potentially free previous payload if handle was not reset */
         hg_free_extra_payload(hg_handle);
 #ifdef HG_HAS_XDR
-        HG_LOG_ERROR("Extra encoding using XDR is not yet supported");
-        ret = HG_SIZE_ERROR;
-        goto done;
+        HG_GOTO_ERROR(done, HG_PROTOCOL_ERROR,
+            "Extra encoding using XDR is not yet supported");
 #endif
         /* Create a bulk descriptor only of the size that is used */
         *extra_buf = hg_proc_get_extra_buf(proc);
@@ -723,38 +676,23 @@ hg_set_struct(struct hg_private_handle *hg_handle,
         /* Create bulk descriptor */
         ret = HG_Bulk_create(hg_handle->handle.info.hg_class, 1, extra_buf,
             extra_buf_size, HG_BULK_READ_ONLY, extra_bulk);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not create bulk data handle");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not create bulk data handle");
 
         /* Reset proc */
         ret = hg_proc_reset(proc, buf, buf_size, HG_ENCODE);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not reset proc");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
 
         /* Encode extra_bulk_handle, we can do that safely here because
          * the user payload has been copied so we don't have to worry
          * about overwriting the user's data */
         ret = hg_proc_hg_bulk_t(proc, extra_bulk);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not process extra bulk handle");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not process extra bulk handle");
 
         ret = hg_proc_flush(proc);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Error in proc flush");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
 
-        if (hg_proc_get_extra_buf(proc)) {
-            HG_LOG_ERROR("Extra bulk handle could not fit into buffer");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_proc_get_extra_buf(proc), done, ret,
+            HG_OVERFLOW, "Extra bulk handle could not fit into buffer");
 
         *more_data = HG_TRUE;
     }
@@ -763,10 +701,7 @@ hg_set_struct(struct hg_private_handle *hg_handle,
     buf = (char *) buf - header_offset;
     buf_size += header_offset;
     ret = hg_header_proc(HG_ENCODE, buf, buf_size, hg_header);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process header");
 
     /* Only send the actual size of the data, not the entire buffer */
     *payload_size = hg_proc_get_size_used(proc) + header_offset;
@@ -796,36 +731,22 @@ hg_free_struct(struct hg_private_handle *hg_handle,
             proc_cb = hg_proc_info->out_proc_cb;
             break;
         default:
-            HG_LOG_ERROR("Invalid HG op");
-            ret = HG_INVALID_PARAM;
-            goto done;
-    }
-    if (!proc_cb) {
-        HG_LOG_ERROR("No proc set, proc must be set in HG_Register()");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
     }
+    HG_CHECK_ERROR(proc_cb == NULL, done, ret, HG_FAULT,
+        "No proc set, proc must be set in HG_Register()");
 
     /* Reset proc */
     ret = hg_proc_reset(proc, NULL, 0, HG_FREE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
 
     /* Free memory allocated during decode operation */
     ret = proc_cb(proc, struct_ptr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free allocated parameters");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free allocated parameters");
 
     /* Decrement ref count or free */
     ret = HG_Core_destroy(hg_handle->handle.core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decrement handle ref count");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not decrement handle ref count");
 
 done:
     return ret;
@@ -854,11 +775,10 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
             /* Set input proc */
             proc = hg_handle->in_proc;
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get input buffer");
-                goto done;
-            }
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer");
+
             extra_buf = &hg_handle->in_extra_buf;
             extra_buf_size = &hg_handle->in_extra_buf_size;
             extra_bulk = &hg_handle->in_extra_bulk;
@@ -869,19 +789,16 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
             /* Set output proc */
             proc = hg_handle->out_proc;
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not get output buffer");
-                goto done;
-            }
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf,
+                &buf_size);
+            HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer");
+
             extra_buf = &hg_handle->out_extra_buf;
             extra_buf_size = &hg_handle->out_extra_buf_size;
             extra_bulk = &hg_handle->out_extra_bulk;
             break;
         default:
-            HG_LOG_ERROR("Invalid HG op");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
     }
 
     /* Include our own header offset */
@@ -889,39 +806,24 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
     buf_size -= header_offset;
 
     ret = hg_proc_reset(proc, buf, buf_size, HG_DECODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
 
     /* Decode extra bulk handle */
     ret = hg_proc_hg_bulk_t(proc, extra_bulk);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process extra bulk handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process extra bulk handle");
 
     ret = hg_proc_flush(proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in proc flush");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
 
     /* Create a new local handle to read the data */
     *extra_buf_size = HG_Bulk_get_size(*extra_bulk);
     *extra_buf = hg_mem_aligned_alloc(page_size, *extra_buf_size);
-    if (!*extra_buf) {
-        HG_LOG_ERROR("Could not allocate extra payload buffer");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(*extra_buf == NULL, done, ret, HG_NOMEM,
+        "Could not allocate extra payload buffer");
 
     ret = HG_Bulk_create(hg_handle->handle.info.hg_class, 1, extra_buf,
         extra_buf_size, HG_BULK_READWRITE, &local_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not create HG bulk handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not create HG bulk handle");
 
     /* Read bulk data here and wait for the data to be here  */
     hg_handle->extra_bulk_transfer_cb = done_cb;
@@ -930,10 +832,7 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
         (hg_addr_t) hg_core_info->addr, hg_core_info->context_id,
         *extra_bulk, 0, local_handle, 0, *extra_buf_size,
         HG_OP_ID_IGNORE /* TODO not used for now */);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not transfer bulk data");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not transfer bulk data");
 
 done:
     HG_Bulk_free(local_handle);
@@ -953,10 +852,7 @@ hg_get_extra_payload_cb(const struct hg_cb_info *callback_info)
     hg_return_t ret = HG_SUCCESS;
 
     ret = hg_handle->extra_bulk_transfer_cb(hg_handle->handle.core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not execute bulk transfer callback");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not execute bulk transfer callback");
 
 done:
     return ret;
@@ -1047,21 +943,7 @@ HG_Version_get(unsigned int *major, unsigned int *minor, unsigned int *patch)
 const char *
 HG_Error_to_string(hg_return_t errnum)
 {
-    const char *hg_error_string = "UNDEFINED/UNRECOGNIZED NA ERROR";
-
-    HG_ERROR_STRING_MACRO(HG_SUCCESS, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_NA_ERROR, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_TIMEOUT, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_INVALID_PARAM, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_SIZE_ERROR, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_NOMEM_ERROR, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_PROTOCOL_ERROR, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_NO_MATCH, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_CHECKSUM_ERROR, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_CANCELED, errnum, hg_error_string);
-    HG_ERROR_STRING_MACRO(HG_OTHER_ERROR, errnum, hg_error_string);
-
-    return hg_error_string;
+    return hg_return_name[errnum];
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1077,34 +959,42 @@ HG_Init_opt(const char *na_info_string, hg_bool_t na_listen,
     const struct hg_init_info *hg_init_info)
 {
     struct hg_private_class *hg_class = NULL;
-    hg_return_t ret = HG_SUCCESS;
+#ifdef HG_HAS_VERBOSE_ERROR
+    const char *log_level = NULL;
+
+    /* Set log level */
+    log_level = getenv("HG_LOG_LEVEL");
+    if (log_level && (strcmp(log_level, "debug") == 0))
+        HG_LOG_MASK |= HG_LOG_TYPE_DEBUG;
+#endif
+
+    /* Make sure error return codes match */
+    assert(HG_CANCELED == (hg_return_t) NA_CANCELED);
 
     hg_class = malloc(sizeof(struct hg_private_class));
-    if (!hg_class) {
-        HG_LOG_ERROR("Could not allocate HG class");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_class == NULL, error,
+        "Could not allocate HG class");
+
     memset(hg_class, 0, sizeof(struct hg_private_class));
     hg_thread_spin_init(&hg_class->register_lock);
 
     hg_class->hg_class.core_class = HG_Core_init_opt(na_info_string, na_listen,
         hg_init_info);
-    if (!hg_class->hg_class.core_class) {
-        HG_LOG_ERROR("Could not create HG core class");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_class->hg_class.core_class == NULL, error,
+        "Could not create HG core class");
 
     /* Set more data callback */
     HG_Core_set_more_data_callback(hg_class->hg_class.core_class,
         hg_more_data_cb, hg_more_data_free_cb);
 
-done:
-    if (ret != HG_SUCCESS) {
+    return (hg_class_t *) hg_class;
+
+error:
+    if (hg_class) {
+        hg_thread_spin_destroy(&hg_class->register_lock);
         free(hg_class);
-        hg_class = NULL;
     }
-    return (hg_class_t *) hg_class;
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1116,10 +1006,8 @@ HG_Finalize(hg_class_t *hg_class)
     hg_return_t ret = HG_SUCCESS;
 
     ret = HG_Core_finalize(private_class->hg_class.core_class);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize HG core class");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not finalize HG core class");
+
     hg_thread_spin_destroy(&private_class->register_lock);
     free(private_class);
 
@@ -1143,11 +1031,8 @@ HG_Class_set_handle_create_callback(hg_class_t *hg_class,
         (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     private_class->handle_create = callback;
     private_class->handle_create_arg = arg;
@@ -1174,26 +1059,19 @@ HG_Context_create_id(hg_class_t *hg_class, hg_uint8_t id)
 #else
     unsigned int request_count = HG_POST_LIMIT_DEFAULT;
 #endif
-    hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_class == NULL, error, "NULL HG class");
 
     hg_context = malloc(sizeof(struct hg_context));
-    if (!hg_context) {
-        HG_LOG_ERROR("Could not allocate HG context");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_context == NULL, error,
+        "Could not allocate HG context");
+
     memset(hg_context, 0, sizeof(struct hg_context));
     hg_context->hg_class = hg_class;
     hg_context->core_context = HG_Core_context_create_id(
         hg_class->core_class, id);
-    if (!hg_context->core_context) {
-        HG_LOG_ERROR("Could not create context for ID %u", id);
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_context->core_context == NULL, error,
+        "Could not create context for ID %u", id);
 
     /* Set handle create callback */
     HG_Core_context_set_handle_create_callback(hg_context->core_context,
@@ -1201,16 +1079,24 @@ HG_Context_create_id(hg_class_t *hg_class, hg_uint8_t id)
 
     /* If we are listening, start posting requests */
     if (HG_Core_class_is_listening(hg_class->core_class)) {
-        ret = HG_Core_context_post(hg_context->core_context, request_count,
-            HG_TRUE);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not post context requests");
-            goto done;
-        }
+        hg_return_t ret = HG_Core_context_post(hg_context->core_context,
+            request_count, HG_TRUE);
+        HG_CHECK_HG_ERROR(error, ret, "Could not post context requests (%s)",
+            HG_Error_to_string(ret));
     }
 
-done:
     return hg_context;
+
+error:
+    if (hg_context) {
+        if (hg_context->core_context) {
+            hg_return_t ret = HG_Core_context_destroy(hg_context->core_context);
+            HG_CHECK_ERROR_DONE(ret != HG_SUCCESS,
+                "Could not destroy HG core context");
+        }
+        free(hg_context);
+    }
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1219,17 +1105,13 @@ HG_Context_destroy(hg_context_t *context)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
 
     ret = HG_Core_context_destroy(context->core_context);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy HG core context");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not destroy HG core context (%s)",
+        HG_Error_to_string(ret));
+
     free(context);
 
 done:
@@ -1242,26 +1124,18 @@ HG_Register_name(hg_class_t *hg_class, const char *func_name,
     hg_proc_cb_t in_proc_cb, hg_proc_cb_t out_proc_cb, hg_rpc_cb_t rpc_cb)
 {
     hg_id_t id = 0;
-    hg_return_t ret = HG_SUCCESS;
+    hg_return_t ret;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
-    if (!func_name) {
-        HG_LOG_ERROR("NULL string");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_class == NULL, done, "NULL HG class");
+    HG_CHECK_ERROR_NORET(func_name == NULL, done, "NULL string");
 
     /* Generate an ID from the function name */
     id = hg_hash_string(func_name);
 
     /* Register RPC */
     ret = HG_Register(hg_class, id, in_proc_cb, out_proc_cb, rpc_cb);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not register RPC id");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not register RPC ID (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return id;
@@ -1277,31 +1151,23 @@ HG_Registered_name(hg_class_t *hg_class, const char *func_name, hg_id_t *id,
     hg_id_t rpc_id = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!func_name) {
-        HG_LOG_ERROR("NULL string");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    hg_thread_spin_lock(&private_class->register_lock);
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
+    HG_CHECK_ERROR(func_name == NULL, done, ret, HG_INVALID_ARG, "NULL string");
 
     /* Generate an ID from the function name */
     rpc_id = hg_hash_string(func_name);
 
+    hg_thread_spin_lock(&private_class->register_lock);
+
     ret = HG_Core_registered(private_class->hg_class.core_class, rpc_id, flag);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not check for registered RPC id");
-        hg_thread_spin_unlock(&private_class->register_lock);
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(unlock, ret, "Could not check for registered RPC ID (%s)",
+        HG_Error_to_string(ret));
 
-    if (id) *id = rpc_id;
+    if (id)
+        *id = rpc_id;
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1316,67 +1182,59 @@ HG_Register(hg_class_t *hg_class, hg_id_t id, hg_proc_cb_t in_proc_cb,
     struct hg_private_class *private_class =
         (struct hg_private_class *) hg_class;
     struct hg_proc_info *hg_proc_info = NULL;
-    hg_bool_t registered;
+    hg_bool_t registered = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Check if already registered */
     ret = HG_Core_registered(hg_class->core_class, id, &registered);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not check for registered RPC id");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not check for registered RPC ID (%s)",
+        HG_Error_to_string(ret));
 
     /* Register RPC (register only RPC callback if already registered) */
     ret = HG_Core_register(hg_class->core_class, id, hg_core_rpc_cb);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not register RPC id");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not register RPC ID (%s)",
+        HG_Error_to_string(ret));
 
     if (!registered) {
         hg_proc_info =
             (struct hg_proc_info *) malloc(sizeof(struct hg_proc_info));
-        if (!hg_proc_info) {
-            HG_LOG_ERROR("Could not allocate proc info");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_proc_info == NULL, error, ret, HG_NOMEM,
+            "Could not allocate proc info");
         memset(hg_proc_info, 0, sizeof(struct hg_proc_info));
 
         /* Attach proc info to RPC ID */
         ret = HG_Core_register_data(hg_class->core_class, id, hg_proc_info,
             hg_proc_info_free);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not set proc info");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not set proc info (%s)",
+            HG_Error_to_string(ret));
+        registered = HG_TRUE;
     } else {
         /* Retrieve proc function from function map */
         hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
             hg_class->core_class, id);
-        if (!hg_proc_info) {
-            HG_LOG_ERROR("Could not get registered data");
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_proc_info == NULL, error, ret, HG_FAULT,
+            "Could not get registered data");
     }
     hg_proc_info->rpc_cb = rpc_cb;
     hg_proc_info->in_proc_cb = in_proc_cb;
     hg_proc_info->out_proc_cb = out_proc_cb;
 
+    hg_thread_spin_unlock(&private_class->register_lock);
+
 done:
-    if (ret != HG_SUCCESS) {
+    return ret;
+
+error:
+    if (registered)
+        HG_Core_deregister(hg_class->core_class, id);
+    else
         free(hg_proc_info);
-    }
-    if (hg_class)
-        hg_thread_spin_unlock(&private_class->register_lock);
+    hg_thread_spin_unlock(&private_class->register_lock);
     return ret;
 }
 
@@ -1388,15 +1246,14 @@ HG_Deregister(hg_class_t *hg_class, hg_id_t id)
         (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
     ret = HG_Core_deregister(hg_class->core_class, id);
     hg_thread_spin_unlock(&private_class->register_lock);
+    HG_CHECK_HG_ERROR(done, ret, "Could not deregister RPC ID (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1410,15 +1267,14 @@ HG_Registered(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag)
         (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
     ret = HG_Core_registered(hg_class->core_class, id, flag);
     hg_thread_spin_unlock(&private_class->register_lock);
+    HG_CHECK_HG_ERROR(done, ret, "Could not check for registered RPC ID (s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1434,31 +1290,29 @@ HG_Registered_proc_cb(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     ret = HG_Core_registered(hg_class->core_class, id, flag);
-    if(ret == HG_SUCCESS && *flag) {
+    HG_CHECK_HG_ERROR(unlock, ret, "Could not check for registered RPC ID (%s)",
+        HG_Error_to_string(ret));
+
+    if(*flag) {
         /* if RPC is registered, retrieve pointers */
         hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
             hg_class->core_class, id);
-        if (!hg_proc_info) {
-            HG_LOG_ERROR("Could not get registered data");
-            ret = HG_NO_MATCH;
-            hg_thread_spin_unlock(&private_class->register_lock);
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_FAULT,
+            "Could not get registered data");
+
         if (in_proc_cb)
             *in_proc_cb = hg_proc_info->in_proc_cb;
         if (out_proc_cb)
             *out_proc_cb = hg_proc_info->out_proc_cb;
     }
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1475,27 +1329,21 @@ HG_Register_data(hg_class_t *hg_class, hg_id_t id, void *data,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get registered data");
-        ret = HG_NO_MATCH;
-        hg_thread_spin_unlock(&private_class->register_lock);
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_NOENTRY,
+        "Could not get registered data");
 
     hg_proc_info->data = data;
     hg_proc_info->free_callback = free_callback;
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1511,24 +1359,19 @@ HG_Registered_data(hg_class_t *hg_class, hg_id_t id)
     struct hg_proc_info *hg_proc_info = NULL;
     void *data = NULL;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_class == NULL, done, "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get registered data");
-        hg_thread_spin_unlock(&private_class->register_lock);
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_proc_info == NULL, unlock,
+        "Could not get registered data");
 
     data = hg_proc_info->data;
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1545,26 +1388,20 @@ HG_Registered_disable_response(hg_class_t *hg_class, hg_id_t id,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get registered data");
-        ret = HG_NO_MATCH;
-        hg_thread_spin_unlock(&private_class->register_lock);
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_NOENTRY,
+        "Could not get registered data");
 
     hg_proc_info->no_response = disable;
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1581,31 +1418,22 @@ HG_Registered_disabled_response(hg_class_t *hg_class, hg_id_t id,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!disabled) {
-        HG_LOG_ERROR("NULL pointer to disabled flag");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
+    HG_CHECK_ERROR(disabled == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to disabled flag");
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get registered data");
-        ret = HG_NO_MATCH;
-        hg_thread_spin_unlock(&private_class->register_lock);
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_NOENTRY,
+        "Could not get registered data");
 
     *disabled = hg_proc_info->no_response;
 
+unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1620,33 +1448,34 @@ HG_Addr_lookup(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_op_id *hg_op_id = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, error, ret, HG_INVALID_ARG,
+        "NULL HG context");
 
     /* Allocate op_id */
     hg_op_id = (struct hg_op_id *) malloc(sizeof(struct hg_op_id));
-    if (!hg_op_id) {
-        HG_LOG_ERROR("Could not allocate HG operation ID");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_op_id == NULL, error, ret, HG_NOMEM,
+        "Could not allocate HG operation ID");
+
     hg_op_id->context = context;
     hg_op_id->type = HG_CB_LOOKUP;
     hg_op_id->callback = callback;
     hg_op_id->arg = arg;
     hg_op_id->info.lookup.hg_addr = HG_ADDR_NULL;
 
+    ret = HG_Core_addr_lookup(context->core_context, hg_core_addr_lookup_cb,
+        hg_op_id, name, &hg_op_id->info.lookup.core_op_id);
+    HG_CHECK_HG_ERROR(error, ret, "Could not lookup %s (%s)", name,
+        HG_Error_to_string(ret));
+
     /* Assign op_id */
     if (op_id && op_id != HG_OP_ID_IGNORE)
         *op_id = (hg_op_id_t) hg_op_id;
 
-    ret = HG_Core_addr_lookup(context->core_context, hg_core_addr_lookup_cb,
-        hg_op_id, name, &hg_op_id->info.lookup.core_op_id);
+    return ret;
+
+error:
+    free(hg_op_id);
 
-done:
     return ret;
 }
 
@@ -1656,13 +1485,29 @@ HG_Addr_free(hg_class_t *hg_class, hg_addr_t addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     ret = HG_Core_addr_free(hg_class->core_class, (hg_core_addr_t) addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not free addr (%s)",
+        HG_Error_to_string(ret));
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
+HG_Addr_set_remove(hg_class_t *hg_class, hg_addr_t addr)
+{
+    hg_return_t ret = HG_SUCCESS;
+
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
+
+    ret = HG_Core_addr_set_remove(hg_class->core_class, (hg_core_addr_t) addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not set addr to be removed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1674,13 +1519,12 @@ HG_Addr_self(hg_class_t *hg_class, hg_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     ret = HG_Core_addr_self(hg_class->core_class, (hg_core_addr_t *) addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not retrieve self addr (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1692,14 +1536,13 @@ HG_Addr_dup(hg_class_t *hg_class, hg_addr_t addr, hg_addr_t *new_addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     ret = HG_Core_addr_dup(hg_class->core_class, (hg_core_addr_t) addr,
         (hg_core_addr_t *) new_addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not dup addr (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1712,14 +1555,13 @@ HG_Addr_to_string(hg_class_t *hg_class, char *buf, hg_size_t *buf_size,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     ret = HG_Core_addr_to_string(hg_class->core_class, buf, buf_size,
         (hg_core_addr_t) addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not convert addr to string (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1734,20 +1576,16 @@ HG_Create(hg_context_t *context, hg_addr_t addr, hg_id_t id,
     hg_core_handle_t core_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
 
     /* Create HG core handle (calls handle_create_cb) */
     ret = HG_Core_create(context->core_context, (hg_core_addr_t) addr, id,
         &core_handle);
-    if (ret != HG_SUCCESS) {
-        if (ret != HG_NO_MATCH) /* silence error if invalid ID is used */
-            HG_LOG_ERROR("Cannot create HG handle with ID %lu", id);
-        goto done;
-    }
+    if (ret == HG_NOENTRY)
+        goto done; /* silence error if invalid ID is used */
+    HG_CHECK_HG_ERROR(done, ret, "Cannot create HG handle with ID %lu (%s)", id,
+        HG_Error_to_string(ret));
 
     /* Get data and HG info */
     hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
@@ -1766,13 +1604,12 @@ HG_Destroy(hg_handle_t handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
+    if (handle == HG_HANDLE_NULL)
         goto done;
-    }
 
     ret = HG_Core_destroy(handle->core_handle);
+    HG_CHECK_HG_ERROR(done, ret, "Could not set handle to be destroyed (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1786,18 +1623,13 @@ HG_Reset(hg_handle_t handle, hg_addr_t addr, hg_id_t id)
         (struct hg_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
 
     /* Call core reset */
     ret = HG_Core_reset(handle->core_handle, (hg_core_addr_t) addr, id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset core HG handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not reset core HG handle (%s)",
+        HG_Error_to_string(ret));
 
     /* Set info */
     private_handle->handle.info.addr = addr;
@@ -1815,33 +1647,22 @@ HG_Get_input(hg_handle_t handle, void *in_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!in_struct) {
-        HG_LOG_ERROR("NULL pointer to input struct");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(in_struct == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to input struct");
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Get input struct */
     ret = hg_get_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_INPUT, in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get input");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get input (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1854,33 +1675,22 @@ HG_Free_input(hg_handle_t handle, void *in_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!in_struct) {
-        HG_LOG_ERROR("NULL pointer to input struct");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(in_struct == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to input struct");
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Free input struct */
     ret = hg_free_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_INPUT, in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free input");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free input (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1893,33 +1703,22 @@ HG_Get_output(hg_handle_t handle, void *out_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!out_struct) {
-        HG_LOG_ERROR("NULL pointer to output struct");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(out_struct == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to output struct");
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Get output struct */
     ret = hg_get_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_OUTPUT, out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get output");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get output (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1932,33 +1731,22 @@ HG_Free_output(hg_handle_t handle, void *out_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!out_struct) {
-        HG_LOG_ERROR("NULL pointer to output struct");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(out_struct == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to output struct");
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Free output struct */
     ret = hg_free_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_OUTPUT, out_struct);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free output");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free output (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1971,16 +1759,10 @@ HG_Get_input_buf(hg_handle_t handle, void **in_buf, hg_size_t *in_buf_size)
     hg_size_t buf_size, header_offset = hg_header_get_size(HG_INPUT);
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!in_buf) {
-        HG_LOG_ERROR("NULL pointer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(in_buf == NULL, done, ret, HG_INVALID_ARG,
+        "NULL input buffer pointer");
 
     /* Get core input buffer */
     /* Note: any extra header information will be transmitted with the
@@ -1988,10 +1770,8 @@ HG_Get_input_buf(hg_handle_t handle, void **in_buf, hg_size_t *in_buf_size)
      * limit.
      */
     ret = HG_Core_get_input(handle->core_handle, in_buf, &buf_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get input buffer");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer (%s)",
+        HG_Error_to_string(ret));
 
     *in_buf = (char *) *in_buf + header_offset;
     if (in_buf_size)
@@ -2008,16 +1788,10 @@ HG_Get_output_buf(hg_handle_t handle, void **out_buf, hg_size_t *out_buf_size)
     hg_size_t buf_size, header_offset = hg_header_get_size(HG_OUTPUT);
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!out_buf) {
-        HG_LOG_ERROR("NULL pointer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(out_buf == NULL, done, ret, HG_INVALID_ARG,
+        "NULL output buffer pointer");
 
     /* Get core output buffer */
     /* Note: any extra header information will be transmitted with the
@@ -2025,10 +1799,8 @@ HG_Get_output_buf(hg_handle_t handle, void **out_buf, hg_size_t *out_buf_size)
      * size limit.
      */
     ret = HG_Core_get_output(handle->core_handle, out_buf, &buf_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get output buffer");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer (%s)",
+        HG_Error_to_string(ret));
 
     *out_buf = (char *) *out_buf + header_offset;
     if (out_buf_size)
@@ -2038,23 +1810,66 @@ done:
     return ret;
 }
 
+/*---------------------------------------------------------------------------*/
+hg_return_t
+HG_Get_input_extra_buf(hg_handle_t handle, void **in_buf,
+    hg_size_t *in_buf_size)
+{
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
+    hg_return_t ret = HG_SUCCESS;
+
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(in_buf == NULL, done, ret, HG_INVALID_ARG,
+        "NULL input buffer pointer");
+
+    /* No offset if extra buffer since only the user payload is copied */
+    *in_buf = private_handle->in_extra_buf;
+    if (in_buf_size)
+        *in_buf_size = private_handle->in_extra_buf_size;
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
+HG_Get_output_extra_buf(hg_handle_t handle, void **out_buf,
+    hg_size_t *out_buf_size)
+{
+    struct hg_private_handle *private_handle =
+        (struct hg_private_handle *) handle;
+    hg_return_t ret = HG_SUCCESS;
+
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
+    HG_CHECK_ERROR(out_buf == NULL, done, ret, HG_INVALID_ARG,
+        "NULL output buffer pointer");
+
+    /* No offset if extra buffer since only the user payload is copied */
+    *out_buf = private_handle->out_extra_buf;
+    if (out_buf_size)
+        *out_buf_size = private_handle->out_extra_buf_size;
+
+done:
+    return ret;
+}
+
 /*---------------------------------------------------------------------------*/
 hg_return_t
 HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
 {
     struct hg_private_handle *private_handle =
         (struct hg_private_handle *) handle;
-    const struct hg_proc_info *hg_proc_info;
-    hg_size_t payload_size;
+    const struct hg_proc_info *hg_proc_info = NULL;
+    hg_size_t payload_size = 0;
     hg_bool_t more_data = HG_FALSE;
     hg_uint8_t flags = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
 
     /* Set callback data */
     private_handle->forward_cb = callback;
@@ -2063,19 +1878,14 @@ HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Set input struct */
     ret = hg_set_struct(private_handle, hg_proc_info, HG_INPUT, in_struct,
         &payload_size, &more_data);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set input");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not set input (%s)",
+        HG_Error_to_string(ret));
 
     /* Set more data flag on handle so that handle_more_callback is triggered */
     if (more_data)
@@ -2088,10 +1898,10 @@ HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
     /* Send request */
     ret = HG_Core_forward(handle->core_handle, hg_core_forward_cb, handle,
         flags, payload_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not forward call");
+    if (ret == HG_AGAIN)
         goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not forward call (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -2109,11 +1919,8 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     hg_uint8_t flags = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
 
     /* Set callback data */
     private_handle->respond_cb = callback;
@@ -2122,19 +1929,14 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    if (!hg_proc_info) {
-        HG_LOG_ERROR("Could not get proc info");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
+        "Could not get proc info");
 
     /* Set output struct */
     ret = hg_set_struct(private_handle, hg_proc_info, HG_OUTPUT, out_struct,
         &payload_size, &more_data);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not set output");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not set output (%s)",
+        HG_Error_to_string(ret));
 
     /* Set more data flag on handle so that handle_more_callback is triggered */
     if (more_data)
@@ -2143,10 +1945,8 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     /* Send response back */
     ret = HG_Core_respond(handle->core_handle, hg_core_respond_cb, handle,
         flags, payload_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not respond");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not respond (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -2158,13 +1958,13 @@ HG_Progress(hg_context_t *context, unsigned int timeout)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
 
     ret = HG_Core_progress(context->core_context, timeout);
+    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        "Could not make progress on context (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -2177,14 +1977,14 @@ HG_Trigger(hg_context_t *context, unsigned int timeout, unsigned int max_count,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
 
     ret = HG_Core_trigger(context->core_context, timeout, max_count,
         actual_count);
+    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        "Could not trigger operations from context (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -2196,13 +1996,12 @@ HG_Cancel(hg_handle_t handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG handle");
 
     ret = HG_Core_cancel(handle->core_handle);
+    HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle (%s)",
+        HG_Error_to_string(ret));
 
 done:
     return ret;
diff --git a/src/mercury.h b/src/mercury.h
index a052735..91e4778 100644
--- a/src/mercury.h
+++ b/src/mercury.h
@@ -13,7 +13,6 @@
 
 #include "mercury_types.h"
 #include "mercury_header.h"
-#include "mercury_error.h"
 
 #include "mercury_core.h"
 
@@ -46,7 +45,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Version_get(
         unsigned int *major,
         unsigned int *minor,
@@ -60,7 +59,7 @@ HG_Version_get(
  *
  * \return String
  */
-HG_EXPORT const char *
+HG_PUBLIC const char *
 HG_Error_to_string(
         hg_return_t errnum
         );
@@ -76,7 +75,7 @@ HG_Error_to_string(
  *
  * \return Pointer to HG class or NULL in case of failure
  */
-HG_EXPORT hg_class_t *
+HG_PUBLIC hg_class_t *
 HG_Init(
         const char *na_info_string,
         hg_bool_t na_listen
@@ -95,7 +94,7 @@ HG_Init(
  *
  * \return Pointer to HG class or NULL in case of failure
  */
-HG_EXPORT hg_class_t *
+HG_PUBLIC hg_class_t *
 HG_Init_opt(
         const char *na_info_string,
         hg_bool_t na_listen,
@@ -109,7 +108,7 @@ HG_Init_opt(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Finalize(
         hg_class_t *hg_class
         );
@@ -120,7 +119,7 @@ HG_Finalize(
  * to HG_Finalize(), this routine gives a chance to programs that terminate
  * abnormally to easily clean up those resources.
  */
-HG_EXPORT void
+HG_PUBLIC void
 HG_Cleanup(
         void
         );
@@ -264,7 +263,7 @@ HG_Class_get_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Class_set_handle_create_callback(
         hg_class_t *hg_class,
         hg_return_t (*callback)(hg_handle_t, void *),
@@ -283,7 +282,7 @@ HG_Class_set_handle_create_callback(
  *
  * \return Pointer to HG context or NULL in case of failure
  */
-HG_EXPORT hg_context_t *
+HG_PUBLIC hg_context_t *
 HG_Context_create(
         hg_class_t *hg_class
         );
@@ -304,7 +303,7 @@ HG_Context_create(
  *
  * \return Pointer to HG context or NULL in case of failure
  */
-HG_EXPORT hg_context_t *
+HG_PUBLIC hg_context_t *
 HG_Context_create_id(
         hg_class_t *hg_class,
         hg_uint8_t id
@@ -317,7 +316,7 @@ HG_Context_create_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Context_destroy(
         hg_context_t *context
         );
@@ -389,7 +388,7 @@ HG_Context_get_data(
  *
  * \return unique ID associated to the registered function
  */
-HG_EXPORT hg_id_t
+HG_PUBLIC hg_id_t
 HG_Register_name(
         hg_class_t *hg_class,
         const char *func_name,
@@ -409,7 +408,7 @@ HG_Register_name(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Registered_name(
         hg_class_t *hg_class,
         const char *func_name,
@@ -430,7 +429,7 @@ HG_Registered_name(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Register(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -449,7 +448,7 @@ HG_Register(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Deregister(
         hg_class_t *hg_class,
         hg_id_t id
@@ -464,7 +463,7 @@ HG_Deregister(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Registered(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -483,7 +482,7 @@ HG_Registered(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Registered_proc_cb(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -504,7 +503,7 @@ HG_Registered_proc_cb(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Register_data(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -521,7 +520,7 @@ HG_Register_data(
  *
  * \return Pointer to data or NULL
  */
-HG_EXPORT void *
+HG_PUBLIC void *
 HG_Registered_data(
         hg_class_t *hg_class,
         hg_id_t id
@@ -541,7 +540,7 @@ HG_Registered_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Registered_disable_response(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -559,7 +558,7 @@ HG_Registered_disable_response(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Registered_disabled_response(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -579,7 +578,7 @@ HG_Registered_disabled_response(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Addr_lookup(
         hg_context_t *context,
         hg_cb_t       callback,
@@ -589,19 +588,36 @@ HG_Addr_lookup(
         );
 
 /**
- * Free the addr from the list of peers.
+ * Free the addr.
  *
  * \param hg_class [IN]         pointer to HG class
  * \param addr [IN]             abstract address
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Addr_free(
         hg_class_t *hg_class,
         hg_addr_t   addr
         );
 
+/**
+ * Hint that the address is no longer valid. This may happen if the peer is
+ * no longer responding. This can be used to force removal of the
+ * peer address from the list of the peers, before freeing it and reclaim
+ * resources.
+ *
+ * \param hg_class [IN]         pointer to HG class
+ * \param addr [IN]             abstract address
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_PUBLIC hg_return_t
+HG_Addr_set_remove(
+        hg_class_t *hg_class,
+        hg_addr_t   addr
+        );
+
 /**
  * Access self address. Address must be freed with HG_Addr_free().
  *
@@ -610,7 +626,7 @@ HG_Addr_free(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Addr_self(
         hg_class_t *hg_class,
         hg_addr_t  *addr
@@ -627,7 +643,7 @@ HG_Addr_self(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Addr_dup(
         hg_class_t *hg_class,
         hg_addr_t   addr,
@@ -648,7 +664,7 @@ HG_Addr_dup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Addr_to_string(
         hg_class_t *hg_class,
         char       *buf,
@@ -669,7 +685,7 @@ HG_Addr_to_string(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Create(
         hg_context_t *context,
         hg_addr_t addr,
@@ -685,7 +701,7 @@ HG_Create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Destroy(
         hg_handle_t handle
         );
@@ -702,7 +718,7 @@ HG_Destroy(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Reset(
         hg_handle_t handle,
         hg_addr_t addr,
@@ -789,7 +805,7 @@ HG_Get_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Get_input(
         hg_handle_t handle,
         void *in_struct
@@ -805,7 +821,7 @@ HG_Get_input(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Free_input(
         hg_handle_t handle,
         void *in_struct
@@ -825,7 +841,7 @@ HG_Free_input(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Get_output(
         hg_handle_t handle,
         void *out_struct
@@ -841,7 +857,7 @@ HG_Get_output(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Free_output(
         hg_handle_t handle,
         void *out_struct
@@ -866,7 +882,7 @@ HG_Free_output(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Get_input_buf(
         hg_handle_t handle,
         void **in_buf,
@@ -892,13 +908,57 @@ HG_Get_input_buf(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Get_output_buf(
         hg_handle_t handle,
         void **out_buf,
         hg_size_t *out_buf_size
         );
 
+/**
+ * Get raw extra input buffer from handle that can be used for encoding and
+ * decoding parameters. This buffer is only valid if the input payload is large
+ * enough that it cannot fit into an eager buffer.
+ *
+ * \remark NULL pointer will be returned if there is no associated buffer.
+ *
+ * \remark in_buf_size argument will be ignored if NULL.
+ *
+ * \param handle [IN]           HG handle
+ * \param in_buf [OUT]          pointer to input buffer
+ * \param in_buf_size [OUT]     pointer to input buffer size
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_PUBLIC hg_return_t
+HG_Get_input_extra_buf(
+        hg_handle_t handle,
+        void **in_buf,
+        hg_size_t *in_buf_size
+        );
+
+/**
+ * Get raw extra output buffer from handle that can be used for encoding and
+ * decoding parameters. This buffer is only valid if the output payload is large
+ * enough that it cannot fit into an eager buffer.
+ *
+ * \remark NULL pointer will be returned if there is no associated buffer.
+ *
+ * \remark out_buf_size argument will be ignored if NULL.
+ *
+ * \param handle [IN]           HG handle
+ * \param out_buf [OUT]         pointer to output buffer
+ * \param out_buf_size [OUT]    pointer to output buffer size
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_PUBLIC hg_return_t
+HG_Get_output_extra_buf(
+        hg_handle_t handle,
+        void **out_buf,
+        hg_size_t *out_buf_size
+        );
+
 /**
  * Set target context ID that will receive and process the RPC request
  * (ID is defined on target context creation, see HG_Context_create_id()).
@@ -933,7 +993,7 @@ HG_Set_target_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Forward(
         hg_handle_t handle,
         hg_cb_t callback,
@@ -959,7 +1019,7 @@ HG_Forward(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Respond(
         hg_handle_t handle,
         hg_cb_t callback,
@@ -979,7 +1039,7 @@ HG_Respond(
  *
  * \return HG_SUCCESS if any completion has occurred / HG error code otherwise
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Progress(
         hg_context_t *context,
         unsigned int timeout
@@ -997,7 +1057,7 @@ HG_Progress(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Trigger(
         hg_context_t *context,
         unsigned int timeout,
@@ -1012,7 +1072,7 @@ HG_Trigger(
  *
  * \return HG_SUCCESS or HG_CANCEL_ERROR or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Cancel(
         hg_handle_t handle
         );
@@ -1036,8 +1096,8 @@ struct hg_context {
 
 /* HG handle */
 struct hg_handle {
-    hg_core_handle_t core_handle;       /* Core handle */
     struct hg_info info;                /* HG info */
+    hg_core_handle_t core_handle;       /* Core handle */
     void *data;                         /* User data */
     void (*data_free_callback)(void *); /* User data free callback */
 };
@@ -1046,12 +1106,6 @@ struct hg_handle {
 static HG_INLINE const char *
 HG_Class_get_name(const hg_class_t *hg_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return NULL;
-    }
-#endif
     return HG_Core_class_get_name(hg_class->core_class);
 }
 
@@ -1059,12 +1113,6 @@ HG_Class_get_name(const hg_class_t *hg_class)
 static HG_INLINE const char *
 HG_Class_get_protocol(const hg_class_t *hg_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return NULL;
-    }
-#endif
     return HG_Core_class_get_protocol(hg_class->core_class);
 }
 
@@ -1072,12 +1120,6 @@ HG_Class_get_protocol(const hg_class_t *hg_class)
 static HG_INLINE hg_bool_t
 HG_Class_is_listening(const hg_class_t *hg_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return HG_FALSE;
-    }
-#endif
     return HG_Core_class_is_listening(hg_class->core_class);
 }
 
@@ -1085,15 +1127,8 @@ HG_Class_is_listening(const hg_class_t *hg_class)
 static HG_INLINE hg_size_t
 HG_Class_get_input_eager_size(const hg_class_t *hg_class)
 {
-    hg_size_t core, header;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return 0;
-    }
-#endif
-    core = HG_Core_class_get_input_eager_size(hg_class->core_class);
-    header = hg_header_get_size(HG_INPUT);
+    hg_size_t core = HG_Core_class_get_input_eager_size(hg_class->core_class),
+        header = hg_header_get_size(HG_INPUT);
 
     return (core > header) ? core - header : 0;
 }
@@ -1102,15 +1137,8 @@ HG_Class_get_input_eager_size(const hg_class_t *hg_class)
 static HG_INLINE hg_size_t
 HG_Class_get_output_eager_size(const hg_class_t *hg_class)
 {
-    hg_size_t core, header;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return 0;
-    }
-#endif
-    core = HG_Core_class_get_output_eager_size(hg_class->core_class);
-    header = hg_header_get_size(HG_OUTPUT);
+    hg_size_t core = HG_Core_class_get_output_eager_size(hg_class->core_class),
+        header = hg_header_get_size(HG_OUTPUT);
 
     return (core > header) ? core - header : 0;
 }
@@ -1119,15 +1147,9 @@ HG_Class_get_output_eager_size(const hg_class_t *hg_class)
 static HG_INLINE hg_return_t
 HG_Class_set_input_offset(hg_class_t *hg_class, hg_size_t offset)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return HG_INVALID_PARAM;
-    }
-#endif
     /* Extra input header must not be larger than eager size */
     if (offset > HG_Class_get_input_eager_size(hg_class))
-        return HG_INVALID_PARAM;
+        return HG_INVALID_ARG;
 
     hg_class->in_offset = offset;
 
@@ -1138,15 +1160,9 @@ HG_Class_set_input_offset(hg_class_t *hg_class, hg_size_t offset)
 static HG_INLINE hg_return_t
 HG_Class_set_output_offset(hg_class_t *hg_class, hg_size_t offset)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return HG_INVALID_PARAM;
-    }
-#endif
     /* Extra output header must not be larger than eager size */
     if (offset > HG_Class_get_output_eager_size(hg_class))
-        return HG_INVALID_PARAM;
+        return HG_INVALID_ARG;
 
     hg_class->out_offset = offset;
 
@@ -1158,12 +1174,6 @@ static HG_INLINE hg_return_t
 HG_Class_set_data(hg_class_t *hg_class, void *data,
     void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return HG_INVALID_PARAM;
-    }
-#endif
     return HG_Core_class_set_data(hg_class->core_class, data, free_callback);
 }
 
@@ -1171,12 +1181,6 @@ HG_Class_set_data(hg_class_t *hg_class, void *data,
 static HG_INLINE void *
 HG_Class_get_data(const hg_class_t *hg_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        return NULL;
-    }
-#endif
     return HG_Core_class_get_data(hg_class->core_class);
 }
 
@@ -1184,12 +1188,6 @@ HG_Class_get_data(const hg_class_t *hg_class)
 static HG_INLINE hg_class_t *
 HG_Context_get_class(const hg_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        return NULL;
-    }
-#endif
     return context->hg_class;
 }
 
@@ -1197,12 +1195,6 @@ HG_Context_get_class(const hg_context_t *context)
 static HG_INLINE hg_uint8_t
 HG_Context_get_id(const hg_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        return 0;
-    }
-#endif
     return HG_Core_context_get_id(context->core_context);
 }
 
@@ -1211,12 +1203,6 @@ static HG_INLINE hg_return_t
 HG_Context_set_data(hg_context_t *context, void *data,
     void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        return HG_INVALID_PARAM;
-    }
-#endif
     return HG_Core_context_set_data(context->core_context, data, free_callback);
 }
 
@@ -1224,12 +1210,6 @@ HG_Context_set_data(hg_context_t *context, void *data,
 static HG_INLINE void *
 HG_Context_get_data(const hg_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG context");
-        return NULL;
-    }
-#endif
     return HG_Core_context_get_data(context->core_context);
 }
 
@@ -1237,12 +1217,6 @@ HG_Context_get_data(const hg_context_t *context)
 static HG_INLINE hg_return_t
 HG_Ref_incr(hg_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
     return HG_Core_ref_incr(handle->core_handle);
 }
 
@@ -1250,12 +1224,6 @@ HG_Ref_incr(hg_handle_t handle)
 static HG_INLINE hg_int32_t
 HG_Ref_get(hg_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return -1;
-    }
-#endif
     return HG_Core_ref_get(handle->core_handle);
 }
 
@@ -1263,12 +1231,6 @@ HG_Ref_get(hg_handle_t handle)
 static HG_INLINE const struct hg_info *
 HG_Get_info(hg_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return NULL;
-    }
-#endif
     return &handle->info;
 }
 
@@ -1276,12 +1238,6 @@ HG_Get_info(hg_handle_t handle)
 static HG_INLINE hg_return_t
 HG_Set_data(hg_handle_t handle, void *data, void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
     handle->data = data;
     handle->data_free_callback = free_callback;
 
@@ -1292,12 +1248,6 @@ HG_Set_data(hg_handle_t handle, void *data, void (*free_callback)(void *))
 static HG_INLINE void *
 HG_Get_data(hg_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return NULL;
-    }
-#endif
     return handle->data;
 }
 
@@ -1305,12 +1255,6 @@ HG_Get_data(hg_handle_t handle)
 static HG_INLINE hg_return_t
 HG_Set_target_id(hg_handle_t handle, hg_uint8_t id)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
     handle->info.context_id = id;
 
     return HG_Core_set_target_id(handle->core_handle, id);
diff --git a/src/mercury_bulk.c b/src/mercury_bulk.c
index ba0040c..22afddd 100644
--- a/src/mercury_bulk.c
+++ b/src/mercury_bulk.c
@@ -13,8 +13,6 @@
 #include "mercury_private.h"
 #include "mercury_error.h"
 
-#include "na.h"
-
 #include "mercury_atomic.h"
 
 #include <stdlib.h>
@@ -26,13 +24,16 @@
 #define HG_BULK_MIN(a, b) \
     (a < b) ? a : b
 
+/* Number of retries when receiving NA_AGAIN error */
+#define HG_BULK_MAX_AGAIN_RETRY     (10)
+
 /* Remove warnings when plugin does not use callback arguments */
 #if defined(__cplusplus)
-    #define HG_BULK_UNUSED
+# define HG_BULK_UNUSED
 #elif defined(__GNUC__) && (__GNUC__ >= 4)
-    #define HG_BULK_UNUSED __attribute__((unused))
+# define HG_BULK_UNUSED __attribute__((unused))
 #else
-    #define HG_BULK_UNUSED
+# define HG_BULK_UNUSED
 #endif
 
 /************************************/
@@ -51,6 +52,10 @@ struct hg_context {
 
 /* HG Bulk op id */
 struct hg_bulk_op_id {
+    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
+    struct hg_bulk *hg_bulk_origin;       /* Origin handle */
+    struct hg_bulk *hg_bulk_local;        /* Local handle */
+    na_op_id_t *na_op_ids ;               /* NA operations IDs */
     hg_context_t *context;                /* Context */
     na_class_t *na_class;                 /* NA class */
     na_context_t *na_context;             /* NA context */
@@ -58,14 +63,10 @@ struct hg_bulk_op_id {
     void *arg;                            /* Callback arguments */
     hg_atomic_int32_t completed;          /* Operation completed TODO needed ? */
     hg_atomic_int32_t canceled;           /* Operation canceled */
-    unsigned int op_count;                /* Number of ongoing operations */
     hg_atomic_int32_t op_completed_count; /* Number of operations completed */
+    unsigned int op_count;                /* Number of ongoing operations */
     hg_bulk_op_t op;                      /* Operation type */
-    struct hg_bulk *hg_bulk_origin;       /* Origin handle */
-    struct hg_bulk *hg_bulk_local;        /* Local handle */
-    na_op_id_t *na_op_ids ;               /* NA operations IDs */
     hg_bool_t is_self;                    /* Is self operation */
-    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
 };
 
 /* Segment used to transfer data and map to NA layer */
@@ -99,23 +100,23 @@ struct hg_bulk {
 #ifdef HG_HAS_SM_ROUTING
     na_class_t *na_sm_class;             /* NA SM class */
 #endif
-    hg_uint8_t context_id;               /* Context ID (valid if bound to handle) */
     hg_core_addr_t addr;                 /* Addr (valid if bound to handle) */
-    hg_size_t total_size;                /* Total size of data abstracted */
-    hg_uint32_t segment_count;           /* Number of segments */
     struct hg_bulk_segment *segments;    /* Array of segments */
     na_mem_handle_t *na_mem_handles;     /* Array of NA memory handles */
 #ifdef HG_HAS_SM_ROUTING
     na_mem_handle_t *na_sm_mem_handles;  /* Array of NA SM memory handles */
 #endif
+    void *serialize_ptr;                 /* Cached serialization buffer */
+    hg_size_t total_size;                /* Total size of data abstracted */
+    hg_size_t serialize_size;            /* Cached serialization size */
+    hg_uint32_t segment_count;           /* Number of segments */
     hg_uint32_t na_mem_handle_count;     /* Number of handles */
+    hg_atomic_int32_t ref_count;         /* Reference count */
     hg_bool_t segment_published;         /* NA memory handles published */
     hg_bool_t segment_alloc;             /* Allocated memory to mirror data */
-    hg_uint8_t flags;                    /* Permission flags */
     hg_bool_t eager_mode;                /* Eager transfer */
-    void *serialize_ptr;                 /* Cached serialization buffer */
-    hg_size_t serialize_size;            /* Cached serialization size */
-    hg_atomic_int32_t ref_count;         /* Reference count */
+    hg_uint8_t flags;                    /* Permission flags */
+    hg_uint8_t context_id;               /* Context ID (valid if bound to handle) */
 };
 
 /********************/
@@ -254,9 +255,26 @@ hg_bulk_na_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_offset_t remote_offset, na_size_t data_size, na_addr_t remote_addr,
     na_uint8_t remote_id, na_op_id_t *op_id)
 {
-    return NA_Put(na_class, context, callback, arg, local_mem_handle,
+    na_return_t na_ret;
+    int retry_cnt = 0;
+
+    /* Post RMA put */
+    do {
+        na_ret = NA_Put(na_class, context, callback, arg, local_mem_handle,
             local_offset, remote_mem_handle, remote_offset, data_size,
             remote_addr, remote_id, op_id);
+        if (na_ret != NA_AGAIN || retry_cnt++ > HG_BULK_MAX_AGAIN_RETRY)
+            break;
+
+        /* Attempt to make progress on NA with timeout of 0 */
+        na_ret = NA_Progress(na_class, context, 0);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done,
+            na_ret, na_ret, "Could not make progress on NA (%s)",
+            NA_Error_to_string(na_ret));
+    } while (1);
+
+done:
+    return na_ret;
 }
 
 /**
@@ -270,9 +288,26 @@ hg_bulk_na_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_offset_t remote_offset, na_size_t data_size, na_addr_t remote_addr,
     na_uint8_t remote_id, na_op_id_t *op_id)
 {
-    return NA_Get(na_class, context, callback, arg, local_mem_handle,
+    na_return_t na_ret;
+    int retry_cnt = 0;
+
+    /* Post RMA get */
+    do {
+        na_ret = NA_Get(na_class, context, callback, arg, local_mem_handle,
             local_offset, remote_mem_handle, remote_offset, data_size,
             remote_addr, remote_id, op_id);
+        if (na_ret != NA_AGAIN || retry_cnt++ > HG_BULK_MAX_AGAIN_RETRY)
+            break;
+
+        /* Attempt to make progress on NA with timeout of 0 */
+        na_ret = NA_Progress(na_class, context, 0);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done,
+            na_ret, na_ret, "Could not make progress on NA (%s)",
+            NA_Error_to_string(na_ret));
+    } while (1);
+
+done:
+    return na_ret;
 }
 
 /**
@@ -328,11 +363,8 @@ hg_bulk_serialize_memcpy(char **dest, ssize_t *dest_left, const void *src,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if ((*dest_left -= (ssize_t) n) < 0) {
-        HG_LOG_ERROR("Buffer size too small");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR((*dest_left -= (ssize_t) n) < 0, done, ret, HG_OVERFLOW,
+        "Serialize buffer size too small");
     memcpy(*dest, src, n);
     *dest += n;
 
@@ -349,11 +381,8 @@ hg_bulk_deserialize_memcpy(const char **src, ssize_t *src_left, void *dest,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if ((*src_left -= (ssize_t) n) < 0) {
-        HG_LOG_ERROR("Buffer size too small");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR((*src_left -= (ssize_t) n) < 0, done, ret, HG_OVERFLOW,
+        "Deserialize buffer size too small");
     memcpy(dest, *src, n);
     *src += n;
 
@@ -383,11 +412,9 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
     unsigned int i;
 
     hg_bulk = (struct hg_bulk *) malloc(sizeof(struct hg_bulk));
-    if (!hg_bulk) {
-        HG_LOG_ERROR("Could not allocate handle");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, error, ret, HG_NOMEM,
+        "Could not allocate handle");
+
     memset(hg_bulk, 0, sizeof(struct hg_bulk));
     hg_bulk->hg_class = hg_class;
     hg_bulk->na_class = na_class;
@@ -403,11 +430,9 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
     /* Allocate segments */
     hg_bulk->segments = (struct hg_bulk_segment *) malloc(
         hg_bulk->segment_count * sizeof(struct hg_bulk_segment));
-    if (!hg_bulk->segments) {
-        HG_LOG_ERROR("Could not allocate segment array");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk->segments == NULL, error, ret, HG_NOMEM,
+        "Could not allocate segment array");
+
     memset(hg_bulk->segments, 0,
            hg_bulk->segment_count * sizeof(struct hg_bulk_segment));
 
@@ -422,31 +447,23 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
             /* Use calloc to avoid uninitialized memory used for transfer */
             hg_bulk->segments[i].address = (hg_ptr_t) calloc(
                 hg_bulk->segments[i].size, sizeof(char));
-            if (!hg_bulk->segments[i].address) {
-                HG_LOG_ERROR("Could not allocate segment");
-                ret = HG_NOMEM_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(hg_bulk->segments[i].address == (hg_ptr_t ) 0, error,
+                ret, HG_NOMEM, "Could not allocate segment");
         }
     }
 
     /* Allocate NA memory handles */
     hg_bulk->na_mem_handles = (na_mem_handle_t *) malloc(
         hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-    if (!hg_bulk->na_mem_handles) {
-        HG_LOG_ERROR("Could not allocate mem handle array");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk->na_mem_handles == NULL, error, ret, HG_NOMEM,
+        "Could not allocate mem handle array");
+
 #ifdef HG_HAS_SM_ROUTING
     if (na_sm_class) {
         hg_bulk->na_sm_mem_handles = (na_mem_handle_t *) malloc(
             hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-        if (!hg_bulk->na_sm_mem_handles) {
-            HG_LOG_ERROR("Could not allocate SM mem handle array");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_bulk->na_sm_mem_handles == NULL, error, ret,
+            HG_NOMEM, "Could not allocate SM mem handle array");
     }
 #endif
     for (i = 0; i < hg_bulk->na_mem_handle_count; i++) {
@@ -469,69 +486,67 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
             na_size_t na_segment_count = (na_size_t) hg_bulk->segment_count;
             na_ret = NA_Mem_handle_create_segments(na_class, na_segments,
                 na_segment_count, flags, &hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_handle_create_segments failed");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                (hg_return_t ) na_ret,
+                "NA_Mem_handle_create_segments() failed (%s)",
+                NA_Error_to_string(na_ret));
+
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles) {
                 na_ret = NA_Mem_handle_create_segments(na_sm_class, na_segments,
                     na_segment_count, flags, &hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_handle_create_segments for SM failed");
-                    ret = HG_NA_ERROR;
-                    goto done;
-                }
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                    (hg_return_t) na_ret,
+                    "NA_Mem_handle_create_segments() for SM failed (%s)",
+                    NA_Error_to_string(na_ret));
             }
 #endif
         } else {
             na_ret = NA_Mem_handle_create(na_class,
                 (void *) hg_bulk->segments[i].address,
                 hg_bulk->segments[i].size, flags, &hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_handle_create failed");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                (hg_return_t) na_ret,
+                "NA_Mem_handle_create() failed (%s)",
+                NA_Error_to_string(na_ret));
+
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles) {
                 na_ret = NA_Mem_handle_create(na_sm_class,
                     (void *) hg_bulk->segments[i].address,
-                    hg_bulk->segments[i].size, flags, &hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_handle_create for SM failed");
-                    ret = HG_NA_ERROR;
-                    goto done;
-                }
+                    hg_bulk->segments[i].size, flags,
+                    &hg_bulk->na_sm_mem_handles[i]);
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                    (hg_return_t) na_ret,
+                    "NA_Mem_handle_create() for SM failed (%s)",
+                    NA_Error_to_string(na_ret));
             }
 #endif
         }
+
         /* Register segment */
         na_ret = NA_Mem_register(na_class, hg_bulk->na_mem_handles[i]);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("NA_Mem_register failed");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+            "NA_Mem_register() failed (%s)", NA_Error_to_string(na_ret));
+
 #ifdef HG_HAS_SM_ROUTING
         if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-            na_ret = NA_Mem_register(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_register failed");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            na_ret = NA_Mem_register(na_sm_class,
+                hg_bulk->na_sm_mem_handles[i]);
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                (hg_return_t) na_ret,
+                "NA_Mem_register() failed (%s)", NA_Error_to_string(na_ret));
         }
 #endif
     }
 
     *hg_bulk_ptr = hg_bulk;
 
-done:
-    if (ret != HG_SUCCESS) {
-        hg_bulk_free(hg_bulk);
-    }
+    return ret;
+
+error:
+    hg_bulk_free(hg_bulk);
+
     return ret;
 }
 
@@ -542,12 +557,12 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
     hg_return_t ret = HG_SUCCESS;
     unsigned int i;
 
-    if (!hg_bulk) goto done;
+    if (!hg_bulk)
+        goto done;
 
-    if (hg_atomic_decr32(&hg_bulk->ref_count)) {
-        /* Cannot free yet */
+    /* Cannot free yet */
+    if (hg_atomic_decr32(&hg_bulk->ref_count))
         goto done;
-    }
 
     if (hg_bulk->na_mem_handles) {
         na_class_t *na_class = hg_bulk->na_class;
@@ -564,15 +579,18 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
                     continue;
 
                 na_ret = NA_Mem_unpublish(na_class, hg_bulk->na_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_unpublish failed");
-                }
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                    (hg_return_t) na_ret,
+                    "NA_Mem_unpublish() failed (%s)");
+
 #ifdef HG_HAS_SM_ROUTING
                 if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-                    na_ret = NA_Mem_unpublish(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-                    if (na_ret != NA_SUCCESS) {
-                        HG_LOG_ERROR("NA_Mem_unpublish for SM failed");
-                    }
+                    na_ret = NA_Mem_unpublish(na_sm_class,
+                        hg_bulk->na_sm_mem_handles[i]);
+                    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                        (hg_return_t) na_ret,
+                        "NA_Mem_unpublish() for SM failed (%s)",
+                        NA_Error_to_string(na_ret));
                 }
 #endif
             }
@@ -586,26 +604,33 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
                 continue;
 
             na_ret = NA_Mem_deregister(na_class, hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_deregister failed");
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t) na_ret,
+                "NA_Mem_deregister() failed (%s)", NA_Error_to_string(na_ret));
 
             na_ret = NA_Mem_handle_free(na_class, hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_handle_free failed");
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t) na_ret,
+                "NA_Mem_handle_free() failed (%s)", NA_Error_to_string(na_ret));
+
             hg_bulk->na_mem_handles[i] = NA_MEM_HANDLE_NULL;
 
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-                na_ret = NA_Mem_deregister(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_deregister for SM failed");
-                }
-                na_ret = NA_Mem_handle_free(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_handle_free for SM failed");
-                }
+                na_ret = NA_Mem_deregister(na_sm_class,
+                    hg_bulk->na_sm_mem_handles[i]);
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                    (hg_return_t) na_ret,
+                    "NA_Mem_deregister() for SM failed (%s)",
+                    NA_Error_to_string(na_ret));
+
+                na_ret = NA_Mem_handle_free(na_sm_class,
+                    hg_bulk->na_sm_mem_handles[i]);
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                    (hg_return_t) na_ret,
+                    "NA_Mem_handle_free() for SM failed (%s)",
+                    NA_Error_to_string(na_ret));
+
                 hg_bulk->na_sm_mem_handles[i] = NA_MEM_HANDLE_NULL;
             }
 #endif
@@ -626,7 +651,8 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
     free(hg_bulk->segments);
 
     /* Free addr if any was attached to handle */
-    HG_Core_addr_free(hg_bulk->hg_class->core_class, hg_bulk->addr);
+    ret = HG_Core_addr_free(hg_bulk->hg_class->core_class, hg_bulk->addr);
+    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk addr");
 
     free(hg_bulk);
 
@@ -702,7 +728,8 @@ hg_bulk_access(struct hg_bulk *hg_bulk, hg_size_t offset, hg_size_t size,
         count++;
     }
 
-    if (actual_count) *actual_count = count;
+    if (actual_count)
+        *actual_count = count;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -711,18 +738,14 @@ hg_bulk_transfer_cb(const struct na_cb_info *callback_info)
 {
     struct hg_bulk_op_id *hg_bulk_op_id =
         (struct hg_bulk_op_id *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     int ret = 0;
 
-    if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
+    /* If canceled, mark handle as canceled */
+    if (callback_info->ret == NA_CANCELED)
         hg_atomic_cas32(&hg_bulk_op_id->canceled, 0, 1);
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback: %s",
-            NA_Error_to_string(callback_info->ret));
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* When all NA transfers that correspond to bulk operation complete
      * add HG user callback to completion queue
@@ -734,7 +757,6 @@ hg_bulk_transfer_cb(const struct na_cb_info *callback_info)
     }
 
 done:
-    (void) na_ret;
     return ret;
 }
 
@@ -800,11 +822,11 @@ hg_bulk_transfer_pieces(na_bulk_op_t na_bulk_op, na_addr_t origin_addr, na_uint8
                 hg_bulk_origin->segments[origin_segment_index].address,
                 origin_segment_offset, transfer_size, origin_addr, origin_id,
                 &hg_bulk_op_id->na_op_ids[count]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("Could not transfer data");
-                ret = HG_NA_ERROR;
-                break;
-            }
+            if (na_ret == NA_AGAIN)
+                HG_GOTO_DONE(done, ret, HG_AGAIN);
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t ) na_ret, "Could not transfer data (%s)",
+                NA_Error_to_string(na_ret));
         }
         count++;
 
@@ -835,6 +857,7 @@ hg_bulk_transfer_pieces(na_bulk_op_t na_bulk_op, na_addr_t origin_addr, na_uint8
         }
     }
 
+done:
     /* Set number of NA operations issued */
     if (na_op_count)
         *na_op_count = count;
@@ -885,19 +908,15 @@ hg_bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
                 scatter_gather = HG_FALSE;
             break;
         default:
-            HG_LOG_ERROR("Unknown bulk operation");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(error, ret, HG_INVALID_ARG, "Unknown bulk operation");
     }
 
     /* Allocate op_id */
     hg_bulk_op_id = (struct hg_bulk_op_id *) malloc(
         sizeof(struct hg_bulk_op_id));
-    if (!hg_bulk_op_id) {
-        HG_LOG_ERROR("Could not allocate HG Bulk operation ID");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk_op_id == NULL, error, ret, HG_NOMEM,
+        "Could not allocate HG Bulk operation ID");
+
     hg_bulk_op_id->context = context;
 #ifdef HG_HAS_SM_ROUTING
     if (na_sm_class == na_origin_addr_class) {
@@ -937,43 +956,45 @@ hg_bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
 
     /* Figure out number of NA operations required */
     if (!scatter_gather) {
-        hg_bulk_transfer_pieces(NULL, NA_ADDR_NULL, origin_id, use_sm, hg_bulk_origin,
-            origin_segment_start_index, origin_segment_start_offset,
-            hg_bulk_local, local_segment_start_index,
-            local_segment_start_offset, size, HG_FALSE, NULL,
-            &hg_bulk_op_id->op_count);
-        if (!hg_bulk_op_id->op_count) {
-            HG_LOG_ERROR("Could not get bulk op_count");
-            ret = HG_INVALID_PARAM;
-            goto done;
-        }
+        ret = hg_bulk_transfer_pieces(NULL, NA_ADDR_NULL, origin_id, use_sm,
+            hg_bulk_origin, origin_segment_start_index,
+            origin_segment_start_offset, hg_bulk_local,
+            local_segment_start_index, local_segment_start_offset, size,
+            HG_FALSE, NULL, &hg_bulk_op_id->op_count);
+        HG_CHECK_HG_ERROR(error, ret, "Could not get bulk op count");
+        HG_CHECK_ERROR(hg_bulk_op_id->op_count == 0, error, ret,
+            HG_INVALID_ARG, "Could not get bulk op_count");
     }
 
     /* Allocate memory for NA operation IDs */
-    hg_bulk_op_id->na_op_ids = malloc(sizeof(na_op_id_t) * hg_bulk_op_id->op_count);
-    if (!hg_bulk_op_id->na_op_ids) {
-        HG_LOG_ERROR("Could not allocate memory for op_ids");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    for (i = 0; i < hg_bulk_op_id->op_count; i++)
-        hg_bulk_op_id->na_op_ids[i] = NA_OP_ID_NULL;
+    hg_bulk_op_id->na_op_ids = malloc(
+        sizeof(na_op_id_t) * hg_bulk_op_id->op_count);
+    HG_CHECK_ERROR(hg_bulk_op_id->na_op_ids == NULL, error, ret, HG_NOMEM,
+        "Could not allocate memory for op_ids");
 
-    /* Assign op_id */
-    if (op_id && op_id != HG_OP_ID_IGNORE) *op_id = (hg_op_id_t) hg_bulk_op_id;
+    for (i = 0; i < hg_bulk_op_id->op_count; i++) {
+        hg_bulk_op_id->na_op_ids[i] = NA_Op_create(hg_bulk_op_id->na_class);
+        HG_CHECK_ERROR(hg_bulk_op_id->na_op_ids[i] == NA_OP_ID_NULL, error, ret,
+            HG_NA_ERROR, "Could not create NA op ID");
+    }
 
     /* Do actual transfer */
     ret = hg_bulk_transfer_pieces(na_bulk_op, na_origin_addr, origin_id, use_sm,
         hg_bulk_origin, origin_segment_start_index, origin_segment_start_offset,
         hg_bulk_local, local_segment_start_index, local_segment_start_offset,
         size, scatter_gather, hg_bulk_op_id, NULL);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not transfer data pieces");
-        goto done;
-    }
+    if (ret == HG_AGAIN)
+       goto error;
+    HG_CHECK_HG_ERROR(error, ret, "Could not transfer data pieces");
 
-done:
-    if (ret != HG_SUCCESS && hg_bulk_op_id) {
+    /* Assign op_id */
+    if (op_id && op_id != HG_OP_ID_IGNORE)
+        *op_id = (hg_op_id_t) hg_bulk_op_id;
+
+    return ret;
+
+error:
+    if (hg_bulk_op_id) {
         free(hg_bulk_op_id->na_op_ids);
         free(hg_bulk_op_id);
     }
@@ -994,10 +1015,7 @@ hg_bulk_complete(struct hg_bulk_op_id *hg_bulk_op_id)
         /* In the case of eager bulk transfer, directly trigger the operation
          * to avoid potential deadlocks */
         ret = hg_bulk_trigger_entry(hg_bulk_op_id);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not trigger completion entry");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not trigger completion entry");
     } else {
         struct hg_completion_entry *hg_completion_entry =
             &hg_bulk_op_id->hg_completion_entry;
@@ -1007,10 +1025,8 @@ hg_bulk_complete(struct hg_bulk_op_id *hg_bulk_op_id)
 
         ret = hg_core_completion_add(context->core_context, hg_completion_entry,
             hg_bulk_op_id->is_self);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not add HG completion entry to completion queue");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret,
+            "Could not add HG completion entry to completion queue");
     }
 
 done:
@@ -1022,6 +1038,7 @@ hg_return_t
 hg_bulk_trigger_entry(struct hg_bulk_op_id *hg_bulk_op_id)
 {
     hg_return_t ret = HG_SUCCESS;
+    unsigned int i;
 
     /* Execute callback */
     if (hg_bulk_op_id->callback) {
@@ -1043,17 +1060,18 @@ hg_bulk_trigger_entry(struct hg_bulk_op_id *hg_bulk_op_id)
 
     /* Decrement ref_count */
     ret = hg_bulk_free(hg_bulk_op_id->hg_bulk_origin);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free bulk handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk handle");
+
     ret = hg_bulk_free(hg_bulk_op_id->hg_bulk_local);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free bulk handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk handle");
 
     /* Free op */
+    for (i = 0; i < hg_bulk_op_id->op_count; i++) {
+        na_return_t na_ret = NA_Op_destroy(hg_bulk_op_id->na_class,
+            hg_bulk_op_id->na_op_ids[i]);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not destroy NA op ID (%s)", NA_Error_to_string(na_ret));
+    }
     free(hg_bulk_op_id->na_op_ids);
     free(hg_bulk_op_id);
 
@@ -1069,49 +1087,29 @@ HG_Bulk_create(hg_class_t *hg_class, hg_uint32_t count, void **buf_ptrs,
     struct hg_bulk *hg_bulk = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!count) {
-        HG_LOG_ERROR("Invalid number of segments");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!buf_sizes) {
-        HG_LOG_ERROR("NULL segment pointer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG class");
+    HG_CHECK_ERROR(count == 0, done, ret, HG_INVALID_ARG,
+        "Invalid number of segments");
+    HG_CHECK_ERROR(buf_sizes == NULL, done, ret, HG_INVALID_ARG,
+        "NULL segment size pointer");
 
     switch (flags) {
         case HG_BULK_READWRITE:
-            break;
         case HG_BULK_READ_ONLY:
-            break;
         case HG_BULK_WRITE_ONLY:
             break;
         default:
-            HG_LOG_ERROR("Unrecognized handle flag");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG,
+                "Unrecognized handle flag");
     }
 
     ret = hg_bulk_create(hg_class, count, buf_ptrs, buf_sizes, flags, &hg_bulk);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not create bulk handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not create bulk handle");
 
     *handle = (hg_bulk_t) hg_bulk;
 
 done:
-    if (ret != HG_SUCCESS) {
-        hg_bulk_free(hg_bulk);
-    }
     return ret;
 }
 
@@ -1122,9 +1120,11 @@ HG_Bulk_free(hg_bulk_t handle)
     hg_return_t ret = HG_SUCCESS;
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    if (!hg_bulk) goto done;
+    if (!hg_bulk)
+        goto done;
 
     ret = hg_bulk_free(hg_bulk);
+    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk handle");
 
 done:
     return ret;
@@ -1137,11 +1137,8 @@ HG_Bulk_ref_incr(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
 
     /* Increment ref count */
     hg_atomic_incr32(&hg_bulk->ref_count);
@@ -1158,30 +1155,16 @@ HG_Bulk_bind(hg_bulk_t handle, hg_context_t *context)
     struct hg_context *hg_context = context;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!context) {
-        HG_LOG_ERROR("NULL HG bulk context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hg_bulk->addr != HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("Handle is already bound to existing address");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
+    HG_CHECK_ERROR(hg_bulk->addr != HG_CORE_ADDR_NULL, done, ret,
+        HG_INVALID_ARG, "Handle is already bound to existing address");
 
     /* Retrieve self address */
     ret = HG_Core_addr_self(hg_bulk->hg_class->core_class, &hg_bulk->addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get self address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get self address");
 
     /* Add context ID */
     hg_bulk->context_id = HG_Core_context_get_id(hg_context->core_context);
@@ -1197,10 +1180,7 @@ HG_Bulk_get_addr(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_core_addr_t ret = HG_CORE_ADDR_NULL;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
 
     ret = hg_bulk->addr;
 
@@ -1215,10 +1195,7 @@ HG_Bulk_get_context_id(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_uint8_t ret = 0;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
 
     ret = hg_bulk->context_id;
 
@@ -1233,24 +1210,18 @@ HG_Bulk_access(hg_bulk_t handle, hg_size_t offset, hg_size_t size,
     hg_size_t *buf_sizes, hg_uint32_t *actual_count)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
-    hg_uint32_t count = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
 
-    if (!size || !max_count) goto done;
+    if (!size || !max_count)
+        goto done;
 
     hg_bulk_access(hg_bulk, offset, size, flags, max_count, buf_ptrs,
-        buf_sizes, &count);
+        buf_sizes, actual_count);
 
 done:
-    if (ret == HG_SUCCESS) {
-        if (actual_count) *actual_count = count;
-    }
     return ret;
 }
 
@@ -1261,10 +1232,7 @@ HG_Bulk_get_size(hg_bulk_t handle)
     hg_size_t ret = 0;
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
 
     ret = hg_bulk->total_size;
 
@@ -1279,10 +1247,7 @@ HG_Bulk_get_segment_count(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_uint32_t ret = 0;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL bulk handle passed");
 
     ret = hg_bulk->segment_count;
 
@@ -1298,10 +1263,7 @@ HG_Bulk_get_serialize_size(hg_bulk_t handle, hg_bool_t request_eager)
     hg_size_t ret = 0;
     hg_uint32_t i;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
 
     /* Permission flags */
     ret = sizeof(hg_bulk->flags);
@@ -1325,17 +1287,15 @@ HG_Bulk_get_serialize_size(hg_bulk_t handle, hg_bool_t request_eager)
     for (i = 0; i < hg_bulk->na_mem_handle_count; i++) {
         na_size_t serialize_size = 0;
 
-        if (hg_bulk->na_mem_handles[i]) {
+        if (hg_bulk->na_mem_handles[i])
             serialize_size = NA_Mem_handle_get_serialize_size(
                 hg_bulk->na_class, hg_bulk->na_mem_handles[i]);
-        }
         ret += sizeof(serialize_size) + serialize_size;
 #ifdef HG_HAS_SM_ROUTING
         if (hg_bulk->na_sm_mem_handles) {
-            if (hg_bulk->na_sm_mem_handles[i]) {
+            if (hg_bulk->na_sm_mem_handles[i])
                 serialize_size = NA_Mem_handle_get_serialize_size(
                     hg_bulk->na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-            }
             ret += sizeof(serialize_size) + serialize_size;
         }
 #endif
@@ -1368,11 +1328,8 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
 #endif
     hg_uint32_t i;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
 
     /* Get NA class */
     na_class = hg_bulk->na_class;
@@ -1387,19 +1344,18 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
                 continue;
 
             na_ret = NA_Mem_publish(na_class, hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("NA_Mem_publish failed");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t ) na_ret, "NA_Mem_publish() failed (%s)",
+                NA_Error_to_string(na_ret));
+
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-                na_ret = NA_Mem_publish(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("NA_Mem_publish for SM failed");
-                    ret = HG_NA_ERROR;
-                    goto done;
-                }
+                na_ret = NA_Mem_publish(na_sm_class,
+                    hg_bulk->na_sm_mem_handles[i]);
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                    (hg_return_t ) na_ret,
+                    "NA_Mem_publish() for SM failed (%s)",
+                    NA_Error_to_string(na_ret));
             }
 #endif
         }
@@ -1409,19 +1365,13 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
     /* Add the permission flags */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->flags, sizeof(hg_bulk->flags));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode permission flags");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode permission flags");
 
     /* Address information is bound */
     bind_addr = (hg_bool_t) (hg_bulk->addr != HG_CORE_ADDR_NULL);
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &bind_addr, sizeof(bind_addr));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode bind address boolean");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode bind address boolean");
 
     /* Add the address information and context ID */
     if (hg_bulk->addr != HG_CORE_ADDR_NULL) {
@@ -1430,85 +1380,62 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
 
         ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
             &serialize_size, sizeof(serialize_size));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not encode serialize size");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not encode serialize size");
 
         na_ret = NA_Addr_serialize(na_class, buf_ptr, (na_size_t) buf_size_left,
             HG_Core_addr_get_na(hg_bulk->addr));
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not serialize address");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not serialize address (%s)", NA_Error_to_string(na_ret));
+
         buf_ptr += serialize_size;
         buf_size_left -= (ssize_t) serialize_size;
 
         ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->context_id, sizeof(hg_bulk->context_id));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not encode context ID");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not encode context ID");
     }
 
     /* Add the total size of the segments */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->total_size, sizeof(hg_bulk->total_size));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode total size");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode total size");
 
     /* Add the number of segments */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->segment_count, sizeof(hg_bulk->segment_count));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode segment count");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode segment count");
 
     /* Add the array of segments */
     for (i = 0; i < hg_bulk->segment_count; i++) {
         ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->segments[i], sizeof(hg_bulk->segments[i]));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not encode segment");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not encode segment");
     }
 
     /* Add the number of NA memory handles */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->na_mem_handle_count, sizeof(hg_bulk->na_mem_handle_count));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode NA memory handle count");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode NA memory handle count");
 
     /* Add the NA memory handles */
     for (i = 0; i < hg_bulk->na_mem_handle_count; i++) {
         na_size_t serialize_size = 0;
 
-        if (hg_bulk->na_mem_handles[i]) {
+        if (hg_bulk->na_mem_handles[i])
             serialize_size = NA_Mem_handle_get_serialize_size(
                 na_class, hg_bulk->na_mem_handles[i]);
-        }
-        ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left, &serialize_size,
-            sizeof(serialize_size));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not encode serialize size");
-            goto done;
-        }
+
+        ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
+            &serialize_size, sizeof(serialize_size));
+        HG_CHECK_HG_ERROR(done, ret, "Could not encode serialize size");
+
         if (hg_bulk->na_mem_handles[i]) {
             na_ret = NA_Mem_handle_serialize(na_class, buf_ptr,
                 (na_size_t) buf_size_left, hg_bulk->na_mem_handles[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("Could not serialize memory handle");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t ) na_ret, "Could not serialize memory handle (%s)",
+                NA_Error_to_string(na_ret));
+
             buf_ptr += serialize_size;
             buf_size_left -= (ssize_t) serialize_size;
         }
@@ -1522,18 +1449,16 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
                 serialize_size = 0;
             ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
                 &serialize_size, sizeof(serialize_size));
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not encode serialize size");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(done, ret, "Could not encode serialize size");
+
             if (hg_bulk->na_sm_mem_handles[i]) {
                 na_ret = NA_Mem_handle_serialize(na_sm_class, buf_ptr,
                     (na_size_t) buf_size_left, hg_bulk->na_sm_mem_handles[i]);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("Could not serialize SM memory handle");
-                    ret = HG_NA_ERROR;
-                    goto done;
-                }
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                    (hg_return_t ) na_ret,
+                    "Could not serialize SM memory handle (%s)",
+                    NA_Error_to_string(na_ret));
+
                 buf_ptr += serialize_size;
                 buf_size_left -= (ssize_t) serialize_size;
             }
@@ -1545,10 +1470,7 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
     eager_mode = (request_eager && (hg_bulk->flags == HG_BULK_READ_ONLY));
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left, &eager_mode,
         sizeof(eager_mode));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode eager_mode bool");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode eager_mode bool");
 
     /* Add the serialized data */
     if (eager_mode) {
@@ -1559,15 +1481,12 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
             ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
                 (const void *) hg_bulk->segments[i].address,
                 hg_bulk->segments[i].size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not encode segment data");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(done, ret, "Could not encode segment data");
         }
     }
 
-    if (buf_size_left)
-        HG_LOG_WARNING("Buf size left greater than 0, %zd", buf_size_left);
+    HG_CHECK_WARNING(buf_size_left > 0, "Buf size left greater than 0, %zd",
+        buf_size_left);
 
 done:
     return ret;
@@ -1586,18 +1505,13 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
     hg_bool_t bind_addr;
     hg_uint32_t i;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == NULL, error, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
 
     hg_bulk = (struct hg_bulk *) malloc(sizeof(struct hg_bulk));
-    if (!hg_bulk) {
-        HG_LOG_ERROR("Could not allocate handle");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, error, ret, HG_NOMEM,
+        "Could not allocate handle");
+
     memset(hg_bulk, 0, sizeof(struct hg_bulk));
     hg_bulk->hg_class = hg_class;
     hg_bulk->na_class = HG_Core_class_get_na(hg_class->core_class);
@@ -1609,18 +1523,12 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
     /* Get the permission flags */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->flags, sizeof(hg_bulk->flags));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode permission flags");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode permission flags");
 
     /* Address information is bound */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &bind_addr, sizeof(bind_addr));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode bind address boolean");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode bind address boolean");
 
     /* Get the address information and context ID */
     if (bind_addr) {
@@ -1629,96 +1537,67 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
 
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &serialize_size, sizeof(serialize_size));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not decode serialize size");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not decode serialize size");
 
         na_ret = NA_Addr_deserialize(hg_bulk->na_class, &na_addr, buf_ptr,
             (na_size_t) buf_size_left);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not deserialize address");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+            "Could not deserialize address (%s)", NA_Error_to_string(na_ret));
+
         buf_ptr += serialize_size;
         buf_size_left -= (ssize_t) serialize_size;
 
-        ret = HG_Core_addr_create(hg_bulk->hg_class->core_class, &hg_bulk->addr);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not create core addr");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        ret = HG_Core_addr_create(hg_bulk->hg_class->core_class,
+            &hg_bulk->addr);
+        HG_CHECK_HG_ERROR(error, ret, "Could not create core addr");
+
         HG_Core_addr_set_na(hg_bulk->addr, na_addr);
 
         /* Decode context ID */
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->context_id, sizeof(hg_bulk->context_id));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not decode context ID");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not decode context ID");
     }
 
     /* Get the total size of the segments */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->total_size, sizeof(hg_bulk->total_size));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode total size");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode total size");
 
     /* Get the number of segments */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->segment_count, sizeof(hg_bulk->segment_count));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode segment count");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode segment count");
 
     /* Get the array of segments */
     hg_bulk->segments = (struct hg_bulk_segment *) malloc(
             hg_bulk->segment_count * sizeof(struct hg_bulk_segment));
-    if (!hg_bulk->segments) {
-        HG_LOG_ERROR("Could not allocate segment array");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk->segments == NULL, error, ret, HG_NOMEM,
+        "Could not allocate segment array");
+
     for (i = 0; i < hg_bulk->segment_count; i++) {
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->segments[i], sizeof(hg_bulk->segments[i]));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not decode segment");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not decode segment");
     }
 
     /* Get the number of NA memory handles */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->na_mem_handle_count, sizeof(hg_bulk->na_mem_handle_count));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode NA memory handle count");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode NA memory handle count");
 
     /* Get the NA memory handles */
     hg_bulk->na_mem_handles = (na_mem_handle_t *) malloc(
             hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-    if (!hg_bulk->na_mem_handles) {
-        HG_LOG_ERROR("Could not allocate NA memory handle array");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk->na_mem_handles == NULL, error, ret, HG_NOMEM,
+        "Could not allocate NA memory handle array");
+
 #ifdef HG_HAS_SM_ROUTING
     if (hg_bulk->na_sm_class) {
         hg_bulk->na_sm_mem_handles = (na_mem_handle_t *) malloc(
                 hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-        if (!hg_bulk->na_sm_mem_handles) {
-            HG_LOG_ERROR("Could not allocate NA SM memory handle array");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_bulk->na_sm_mem_handles == NULL, error, ret,
+            HG_NOMEM, "Could not allocate NA SM memory handle array");
     }
 #endif
 
@@ -1727,47 +1606,39 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
 
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &serialize_size, sizeof(serialize_size));
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not decode serialize size");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not decode serialize size");
+
         if (serialize_size) {
             na_ret = NA_Mem_handle_deserialize(hg_bulk->na_class,
                 &hg_bulk->na_mem_handles[i], buf_ptr,
                 (na_size_t) buf_size_left);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("Could not deserialize memory handle");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                (hg_return_t ) na_ret, "Could not deserialize memory handle");
+
             buf_ptr += serialize_size;
             buf_size_left -= (ssize_t) serialize_size;
-        } else {
+        } else
             hg_bulk->na_mem_handles[i] = NA_MEM_HANDLE_NULL;
-        }
 
 #ifdef HG_HAS_SM_ROUTING
         if (hg_bulk->na_sm_mem_handles) {
             ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
                 &serialize_size, sizeof(serialize_size));
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not decode serialize size");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(error, ret, "Could not decode serialize size");
+
             if (serialize_size) {
                 na_ret = NA_Mem_handle_deserialize(hg_bulk->na_sm_class,
                     &hg_bulk->na_sm_mem_handles[i], buf_ptr,
                     (na_size_t) buf_size_left);
-                if (na_ret != NA_SUCCESS) {
-                    HG_LOG_ERROR("Could not deserialize SM memory handle");
-                    ret = HG_NA_ERROR;
-                    goto done;
-                }
+                HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
+                    (hg_return_t ) na_ret,
+                    "Could not deserialize SM memory handle (%s)",
+                    NA_Error_to_string(na_ret));
+
                 buf_ptr += serialize_size;
                 buf_size_left -= (ssize_t) serialize_size;
-            } else {
+            } else
                 hg_bulk->na_sm_mem_handles[i] = NA_MEM_HANDLE_NULL;
-            }
         }
 #endif
     }
@@ -1775,10 +1646,7 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
     /* Get whether data is serialized or not */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->eager_mode, sizeof(hg_bulk->eager_mode));
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode eager_mode bool");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not decode eager_mode bool");
 
     /* Get the serialized data */
     if (hg_bulk->eager_mode) {
@@ -1790,30 +1658,26 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
             /* Use calloc to avoid uninitialized memory used for transfer */
             hg_bulk->segments[i].address = (hg_ptr_t) calloc(
                 hg_bulk->segments[i].size, sizeof(char));
-            if (!hg_bulk->segments[i].address) {
-                HG_LOG_ERROR("Could not allocate segment");
-                ret = HG_NOMEM_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(hg_bulk->segments[i].address == 0, error, ret,
+                HG_NOMEM, "Could not allocate segment");
+
             ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
                 (void *) hg_bulk->segments[i].address,
                 hg_bulk->segments[i].size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not decode segment data");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(error, ret, "Could not decode segment data");
         }
     }
 
-    if (buf_size_left)
-        HG_LOG_WARNING("Buf size left greater than 0, %zd", buf_size_left);
+    HG_CHECK_WARNING(buf_size_left > 0, "Buf size left greater than 0, %zd",
+        buf_size_left);
 
     *handle = (hg_bulk_t) hg_bulk;
 
-done:
-    if (ret != HG_SUCCESS) {
-        hg_bulk_free(hg_bulk);
-    }
+    return ret;
+
+error:
+    hg_bulk_free(hg_bulk);
+
     return ret;
 }
 
@@ -1823,12 +1687,12 @@ HG_Bulk_get_serialize_cached_ptr(hg_bulk_t handle)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        return NULL;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, error, "NULL memory handle passed");
 
     return hg_bulk->serialize_ptr;
+
+error:
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1837,12 +1701,12 @@ HG_Bulk_get_serialize_cached_size(hg_bulk_t handle)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        return 0;
-    }
+    HG_CHECK_ERROR_NORET(hg_bulk == NULL, error, "NULL memory handle passed");
 
     return hg_bulk->serialize_size;
+
+error:
+    return 0;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1851,16 +1715,16 @@ HG_Bulk_set_serialize_cached_ptr(hg_bulk_t handle, void *buf,
     na_size_t buf_size)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
+    hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk) {
-        HG_LOG_ERROR("NULL bulk handle");
-        return HG_INVALID_PARAM;
-    }
+    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
+        "NULL memory handle passed");
 
     hg_bulk->serialize_ptr = buf;
     hg_bulk->serialize_size = buf_size;
 
-    return HG_SUCCESS;
+done:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1873,18 +1737,11 @@ HG_Bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_bulk *hg_bulk_origin = (struct hg_bulk *) origin_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk_origin) {
-        HG_LOG_ERROR("NULL origin handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hg_bulk_origin->addr != HG_CORE_ADDR_NULL
-        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr) {
-        HG_LOG_ERROR("Mismatched address information passed with origin handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk_origin == NULL, done, ret, HG_INVALID_ARG,
+        "NULL origin handle passed");
+    HG_CHECK_ERROR(hg_bulk_origin->addr != HG_CORE_ADDR_NULL
+        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr, done, ret,
+        HG_INVALID_ARG, "Mismatched address information from origin handle");
 
     ret = HG_Bulk_transfer_id(context, callback, arg, op, origin_addr, 0,
         origin_handle, origin_offset, local_handle, local_offset, size, op_id);
@@ -1903,18 +1760,11 @@ HG_Bulk_bind_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_bulk *hg_bulk_origin = (struct hg_bulk *) origin_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk_origin) {
-        HG_LOG_ERROR("NULL origin handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hg_bulk_origin->addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("No address information found on bulk handle, "
-            "HG_Bulk_bind() must be called on bulk handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk_origin == NULL, done, ret, HG_INVALID_ARG,
+        "NULL origin handle passed");
+    HG_CHECK_ERROR(hg_bulk_origin->addr == HG_CORE_ADDR_NULL, done, ret,
+        HG_INVALID_ARG, "No address information found on bulk handle, "
+        "HG_Bulk_bind() must be called on bulk handle");
 
     ret = HG_Bulk_transfer_id(context, callback, arg, op,
         (hg_addr_t) hg_bulk_origin->addr, hg_bulk_origin->context_id,
@@ -1935,84 +1785,48 @@ HG_Bulk_transfer_id(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_bulk *hg_bulk_local = (struct hg_bulk *) local_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG bulk context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!hg_bulk_origin || !hg_bulk_local) {
-        HG_LOG_ERROR("NULL memory handle passed");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hg_bulk_origin->addr != HG_CORE_ADDR_NULL
-        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr) {
-        HG_LOG_ERROR("Mismatched address information passed with origin handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hg_bulk_origin->addr != HG_CORE_ADDR_NULL
-        && hg_bulk_origin->context_id != origin_id) {
-        HG_LOG_ERROR("Mismatched context ID information passed with origin handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!size) {
-        HG_LOG_ERROR("Transfer size must be non-zero");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
-
-    if (size > hg_bulk_origin->total_size) {
-        HG_LOG_ERROR("Exceeding size of memory exposed by origin handle");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
-
-    if (size > hg_bulk_local->total_size) {
-        HG_LOG_ERROR("Exceeding size of memory exposed by local handle");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG context");
+    HG_CHECK_ERROR(hg_bulk_origin == NULL || hg_bulk_local == NULL, done, ret,
+        HG_INVALID_ARG, "NULL memory handle passed");
+    HG_CHECK_ERROR(hg_bulk_origin->addr != HG_CORE_ADDR_NULL
+        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr, done, ret,
+        HG_INVALID_ARG, "Mismatched address information from origin handle");
+    HG_CHECK_ERROR(hg_bulk_origin->addr != HG_CORE_ADDR_NULL
+        && hg_bulk_origin->context_id != origin_id, done, ret, HG_INVALID_ARG,
+        "Mismatched context ID information from origin handle");
+    HG_CHECK_ERROR(size == 0, done, ret, HG_INVALID_ARG,
+        "Transfer size must be non-zero");
+    HG_CHECK_ERROR(size > hg_bulk_origin->total_size, done, ret, HG_INVALID_ARG,
+        "Exceeding size of memory exposed by origin handle");
+    HG_CHECK_ERROR(size > hg_bulk_local->total_size, done, ret, HG_INVALID_ARG,
+        "Exceeding size of memory exposed by local handle");
 
     switch (op) {
         case HG_BULK_PUSH:
-            if (!(hg_bulk_origin->flags & HG_BULK_WRITE_ONLY)
-                || !(hg_bulk_local->flags & HG_BULK_READ_ONLY)) {
-                HG_LOG_ERROR("Invalid permission flags for PUSH operation "
-                    "(origin=%d, local=%d)", hg_bulk_origin->flags,
-                    hg_bulk_local->flags);
-                ret = HG_INVALID_PARAM;
-                goto done;
-            }
+            HG_CHECK_ERROR(!(hg_bulk_origin->flags & HG_BULK_WRITE_ONLY)
+                || !(hg_bulk_local->flags & HG_BULK_READ_ONLY), done, ret,
+                HG_PERMISSION, "Invalid permission flags for PUSH operation "
+                "(origin=%d, local=%d)", hg_bulk_origin->flags,
+                hg_bulk_local->flags);
             break;
         case HG_BULK_PULL:
-            if (!(hg_bulk_origin->flags & HG_BULK_READ_ONLY)
-                || !(hg_bulk_local->flags & HG_BULK_WRITE_ONLY)) {
-                HG_LOG_ERROR("Invalid permission flags for PULL operation "
-                    "(origin=%d, local=%d)", hg_bulk_origin->flags,
-                    hg_bulk_local->flags);
-                ret = HG_INVALID_PARAM;
-                goto done;
-            }
+            HG_CHECK_ERROR(!(hg_bulk_origin->flags & HG_BULK_READ_ONLY)
+                || !(hg_bulk_local->flags & HG_BULK_WRITE_ONLY), done, ret,
+                HG_PERMISSION, "Invalid permission flags for PULL operation "
+                "(origin=%d, local=%d)", hg_bulk_origin->flags,
+                hg_bulk_local->flags);
             break;
         default:
-            HG_LOG_ERROR("Unknown bulk operation");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Unknown bulk operation");
     }
 
     ret = hg_bulk_transfer(context, callback, arg, op, origin_addr, origin_id,
         hg_bulk_origin, origin_offset, hg_bulk_local, local_offset, size,
         op_id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not transfer data");
+    if (ret == HG_AGAIN)
         goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not start transfer of bulk data");
 
 done:
     return ret;
@@ -2025,27 +1839,19 @@ HG_Bulk_cancel(hg_op_id_t op_id)
     struct hg_bulk_op_id *hg_bulk_op_id = (struct hg_bulk_op_id *) op_id;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_bulk_op_id) {
-        HG_LOG_ERROR("NULL HG bulk operation ID");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_bulk_op_id == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG bulk operation ID");
 
     if (HG_UTIL_TRUE != hg_atomic_cas32(&hg_bulk_op_id->completed, 1, 0)) {
         unsigned int i = 0;
 
         /* Cancel all NA operations issued */
         for (i = 0; i < hg_bulk_op_id->op_count; i++) {
-            na_return_t na_ret;
-
-            /* Cancel NA operation */
-            na_ret = NA_Cancel(hg_bulk_op_id->na_class,
+            na_return_t na_ret = NA_Cancel(hg_bulk_op_id->na_class,
                 hg_bulk_op_id->na_context, hg_bulk_op_id->na_op_ids[i]);
-            if (na_ret != NA_SUCCESS) {
-                HG_LOG_ERROR("Could not cancel op id");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
+                (hg_return_t ) na_ret, "Could not cancel NA op ID (%s)",
+                NA_Error_to_string(na_ret));
         }
     }
 
diff --git a/src/mercury_bulk.h b/src/mercury_bulk.h
index 9b60d8b..338f24d 100644
--- a/src/mercury_bulk.h
+++ b/src/mercury_bulk.h
@@ -54,7 +54,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_create(
         hg_class_t *hg_class,
         hg_uint32_t count,
@@ -71,7 +71,7 @@ HG_Bulk_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_free(
         hg_bulk_t handle
         );
@@ -83,7 +83,7 @@ HG_Bulk_free(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_ref_incr(
         hg_bulk_t handle
         );
@@ -112,7 +112,7 @@ HG_Bulk_ref_incr(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_bind(
         hg_bulk_t handle,
         hg_context_t *context
@@ -126,7 +126,7 @@ HG_Bulk_bind(
  *
  * \return abstract HG address or HG_ADDR_NULL in case of error
 */
-HG_EXPORT hg_addr_t
+HG_PUBLIC hg_addr_t
 HG_Bulk_get_addr(
        hg_bulk_t handle
        );
@@ -139,7 +139,7 @@ HG_Bulk_get_addr(
  *
  * \return valid context ID or 0 by default
 */
-HG_EXPORT hg_uint8_t
+HG_PUBLIC hg_uint8_t
 HG_Bulk_get_context_id(
        hg_bulk_t handle
        );
@@ -163,7 +163,7 @@ HG_Bulk_get_context_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_access(
         hg_bulk_t handle,
         hg_size_t offset,
@@ -182,7 +182,7 @@ HG_Bulk_access(
  *
  * \return Non-negative value
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 HG_Bulk_get_size(
         hg_bulk_t handle
         );
@@ -194,7 +194,7 @@ HG_Bulk_get_size(
  *
  * \return Non-negative value
  */
-HG_EXPORT hg_uint32_t
+HG_PUBLIC hg_uint32_t
 HG_Bulk_get_segment_count(
         hg_bulk_t handle
         );
@@ -209,7 +209,7 @@ HG_Bulk_get_segment_count(
  *
  * \return Non-negative value
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 HG_Bulk_get_serialize_size(
         hg_bulk_t handle,
         hg_bool_t request_eager
@@ -228,7 +228,7 @@ HG_Bulk_get_serialize_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_serialize(
         void *buf,
         hg_size_t buf_size,
@@ -246,7 +246,7 @@ HG_Bulk_serialize(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_deserialize(
         hg_class_t *hg_class,
         hg_bulk_t *handle,
@@ -261,7 +261,7 @@ HG_Bulk_deserialize(
  *
  * \return Pointer to buffer or NULL in case of error
  */
-HG_EXPORT void *
+HG_PUBLIC void *
 HG_Bulk_get_serialize_cached_ptr(
         hg_bulk_t handle
         );
@@ -273,7 +273,7 @@ HG_Bulk_get_serialize_cached_ptr(
  *
  * \return Non-negative value or 0 in case of error
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 HG_Bulk_get_serialize_cached_size(
         hg_bulk_t handle
         );
@@ -287,7 +287,7 @@ HG_Bulk_get_serialize_cached_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_set_serialize_cached_ptr(
         hg_bulk_t handle,
         void *buf,
@@ -315,7 +315,7 @@ HG_Bulk_set_serialize_cached_ptr(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_transfer(
         hg_context_t *context,
         hg_cb_t callback,
@@ -350,7 +350,7 @@ HG_Bulk_transfer(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_bind_transfer(
         hg_context_t *context,
         hg_cb_t callback,
@@ -387,7 +387,7 @@ HG_Bulk_bind_transfer(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_transfer_id(
         hg_context_t *context,
         hg_cb_t callback,
@@ -410,7 +410,7 @@ HG_Bulk_transfer_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Bulk_cancel(
         hg_op_id_t op_id
         );
diff --git a/src/mercury_config.h.in b/src/mercury_config.h.in
index fe0e00f..3812057 100644
--- a/src/mercury_config.h.in
+++ b/src/mercury_config.h.in
@@ -89,19 +89,20 @@ typedef hg_uint8_t   hg_bool_t;
 #endif
 
 /* Environment variable names (to be removed) */
-#define HG_NA_PLUGIN "MERCURY_NA_PLUGIN"
 #define HG_PORT_NAME "MERCURY_PORT_NAME"
 
 /* Shared libraries */
 #cmakedefine HG_BUILD_SHARED_LIBS
 #ifdef HG_BUILD_SHARED_LIBS
 # ifdef mercury_EXPORTS
-#  define HG_EXPORT HG_ABI_EXPORT
+#  define HG_PUBLIC HG_ABI_EXPORT
 # else
-#  define HG_EXPORT HG_ABI_IMPORT
+#  define HG_PUBLIC HG_ABI_IMPORT
 # endif
+# define HG_PRIVATE HG_ABI_HIDDEN
 #else
-# define HG_EXPORT
+# define HG_PUBLIC
+# define HG_PRIVATE
 #endif
 
 /* Build Options */
diff --git a/src/mercury_core.c b/src/mercury_core.c
index f114699..f1e45f9 100644
--- a/src/mercury_core.c
+++ b/src/mercury_core.c
@@ -25,6 +25,7 @@
 #include "mercury_thread_pool.h"
 #include "mercury_thread_spin.h"
 #include "mercury_time.h"
+#include "mercury_error.h"
 
 #ifdef HG_HAS_SM_ROUTING
 #include <uuid/uuid.h>
@@ -37,11 +38,9 @@
 /* Local Macros */
 /****************/
 
-#define HG_CORE_MAX_SELF_THREADS    4
-#define HG_CORE_MASK_NBITS          8
 #define HG_CORE_ATOMIC_QUEUE_SIZE   1024
 #define HG_CORE_PENDING_INCR        256
-#define HG_CORE_PROCESSING_TIMEOUT  1000
+#define HG_CORE_CLEANUP_TIMEOUT     1000
 #define HG_CORE_MAX_TRIGGER_COUNT   1
 #ifdef HG_HAS_SM_ROUTING
 # define HG_CORE_UUID_MAX_LEN       36
@@ -51,6 +50,9 @@
 # define HG_CORE_MIN(a, b)          (a < b) ? a : b /* Min macro */
 #endif
 
+/* Number of retries when receiving NA_AGAIN error */
+#define HG_CORE_MAX_AGAIN_RETRY         (10)
+
 /* Remove warnings when routine does not use arguments */
 #if defined(__cplusplus)
 # define HG_UNUSED
@@ -93,51 +95,47 @@ struct hg_core_private_class {
     uuid_t na_sm_uuid;                  /* UUID for local identification */
 #endif
     hg_hash_table_t *func_map;          /* Function map */
-    hg_thread_spin_t func_map_lock;     /* Function map mutex */
-    hg_atomic_int32_t request_tag;      /* Atomic used for tag generation */
+    hg_return_t (*more_data_acquire)(hg_core_handle_t, hg_op_t,
+        hg_return_t (*done_callback)(hg_core_handle_t)); /* more_data_acquire */
+    void (*more_data_release)(hg_core_handle_t);         /* more_data_release */
     na_tag_t request_max_tag;           /* Max value for tag */
-    hg_bool_t na_ext_init;              /* NA externally initialized */
+    hg_atomic_int32_t n_contexts;       /* Atomic used for number of contexts */
+    hg_atomic_int32_t n_addrs;          /* Atomic used for number of addrs */
+    hg_atomic_int32_t request_tag;      /* Atomic used for tag generation */
+    hg_thread_spin_t func_map_lock;     /* Function map lock */
     na_progress_mode_t progress_mode;   /* NA progress mode */
+    hg_bool_t na_ext_init;              /* NA externally initialized */
 #ifdef HG_HAS_COLLECT_STATS
     hg_bool_t stats;                    /* (Debug) Print stats at exit */
 #endif
-    hg_atomic_int32_t n_contexts;       /* Atomic used for number of contexts */
-    hg_atomic_int32_t n_addrs;          /* Atomic used for number of addrs */
-
-    /* Callbacks */
-    hg_return_t (*more_data_acquire)(hg_core_handle_t, hg_op_t,
-        hg_return_t (*done_callback)(hg_core_handle_t)); /* more_data_acquire */
-    void (*more_data_release)(hg_core_handle_t); /* more_data_release */
 };
 
 /* HG context */
 struct hg_core_private_context {
     struct hg_core_context core_context;        /* Must remain as first field */
-    struct hg_poll_set *poll_set;               /* Context poll set */
-    /* Pointer to function used for making progress */
-    hg_return_t (*progress)(struct hg_core_private_context *context,
-        unsigned int timeout);
-    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
-    HG_QUEUE_HEAD(hg_completion_entry) backfill_queue; /* Backfill completion queue */
-    hg_atomic_int32_t backfill_queue_count;     /* Backfill queue count */
-    hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
     hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
-    hg_atomic_int32_t trigger_waiting;          /* Waiting in trigger */
+    hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
+    HG_QUEUE_HEAD(hg_completion_entry) backfill_queue;  /* Backfill completion queue */
+    struct hg_atomic_queue *completion_queue;           /* Default completion queue */
+    HG_LIST_HEAD(hg_core_private_handle) created_list;  /* List of handles for that context */
     HG_LIST_HEAD(hg_core_private_handle) pending_list;  /* List of pending handles */
-    hg_thread_spin_t pending_list_lock;         /* Pending list lock */
 #ifdef HG_HAS_SM_ROUTING
-    HG_LIST_HEAD(hg_core_private_handle) sm_pending_list; /* List of SM pending handles */
-    hg_thread_spin_t sm_pending_list_lock;      /* SM pending list lock */
+    HG_LIST_HEAD(hg_core_private_handle) sm_pending_list;   /* List of SM pending handles */
 #endif
-    HG_LIST_HEAD(hg_core_private_handle) created_list;  /* List of handles for that context */
+    hg_return_t (*handle_create)(hg_core_handle_t, void *); /* handle_create */
+    void *handle_create_arg;                    /* handle_create arg */
+    struct hg_poll_set *poll_set;               /* Context poll set */
+    hg_return_t (*progress)(struct hg_core_private_context *context,
+        unsigned int timeout);                  /* Progress function */
+    hg_atomic_int32_t backfill_queue_count;     /* Backfill queue count */
+    hg_atomic_int32_t trigger_waiting;          /* Waiting in trigger */
+    hg_atomic_int32_t n_handles;                /* Atomic used for number of handles */
     hg_thread_spin_t created_list_lock;         /* Handle list lock */
+    hg_thread_spin_t pending_list_lock;         /* Pending list lock */
 #ifdef HG_HAS_SELF_FORWARD
     int completion_queue_notify;                /* Self notification */
 #endif
-    hg_return_t (*handle_create)(hg_core_handle_t, void *); /* handle_create */
-    void *handle_create_arg;                    /* handle_create arg */
     hg_bool_t finalizing;                       /* Prevent reposts */
-    hg_atomic_int32_t n_handles;                /* Atomic used for number of handles */
 };
 
 #ifdef HG_HAS_SELF_FORWARD
@@ -156,8 +154,8 @@ struct hg_core_private_addr {
 #ifdef HG_HAS_SM_ROUTING
     uuid_t na_sm_uuid;                  /* NA SM UUID */
 #endif
-    hg_bool_t is_mine;                  /* Created internally or not */
     hg_atomic_int32_t ref_count;        /* Reference count */
+    hg_bool_t is_mine;                  /* Created internally or not */
 };
 
 /* HG core op type */
@@ -175,71 +173,59 @@ typedef enum {
 /* HG core handle */
 struct hg_core_private_handle {
     struct hg_core_handle core_handle;  /* Must remain as first field */
+    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
+    HG_LIST_ENTRY(hg_core_private_handle) created;  /* Created list entry */
+    HG_LIST_ENTRY(hg_core_private_handle) pending;  /* Pending list entry */
+    struct hg_core_header in_header;    /* Input header */
+    struct hg_core_header out_header;   /* Output header */
     na_class_t *na_class;               /* NA class */
     na_context_t *na_context;           /* NA context */
     hg_core_cb_t request_callback;      /* Request callback */
     void *request_arg;                  /* Request callback arguments */
     hg_core_cb_t response_callback;     /* Response callback */
     void *response_arg;                 /* Response callback arguments */
-    hg_core_op_type_t op_type;          /* Core operation type */
-    na_tag_t tag;                       /* Tag used for request and response */
-    hg_uint8_t cookie;                  /* Cookie */
-    hg_return_t ret;                    /* Return code associated to handle */
-    HG_LIST_ENTRY(hg_core_private_handle) created;  /* Created list entry */
-    HG_LIST_ENTRY(hg_core_private_handle) pending;  /* Pending list entry */
-    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
-    hg_bool_t repost;                   /* Repost handle on completion (listen) */
-    hg_bool_t is_self;                  /* Self processed */
-    hg_atomic_int32_t in_use;           /* Is in use */
-    hg_bool_t no_response;              /* Require response or not */
-
+    hg_return_t (*forward)(struct hg_core_private_handle *hg_core_handle);    /* forward */
+    hg_return_t (*respond)(struct hg_core_private_handle *hg_core_handle);    /* respond */
+    hg_return_t (*no_respond)(struct hg_core_private_handle *hg_core_handle); /* no_respond */
+    void *ack_buf;                      /* Ack buf for more data */
     void *in_buf_plugin_data;           /* Input buffer NA plugin data */
-    na_size_t in_buf_used;              /* Amount of input buffer used */
     void *out_buf_plugin_data;          /* Output buffer NA plugin data */
-    na_size_t out_buf_used;             /* Amount of output buffer used */
-    void *ack_buf;                      /* Ack buf for more data */
     void *ack_buf_plugin_data;          /* Ack plugin data */
-
     na_op_id_t na_send_op_id;           /* Operation ID for send */
     na_op_id_t na_recv_op_id;           /* Operation ID for recv */
     na_op_id_t na_ack_op_id;            /* Operation ID for ack */
-    unsigned int na_op_count;           /* Number of ongoing operations */
-    hg_atomic_int32_t na_op_completed_count;    /* Number of NA operations completed */
-    hg_bool_t na_op_id_mine;            /* Operation ID created by HG */
-
-    struct hg_core_header in_header;    /* Input header */
-    struct hg_core_header out_header;   /* Output header */
-
+    na_size_t in_buf_used;              /* Amount of input buffer used */
+    na_size_t out_buf_used;             /* Amount of output buffer used */
+    na_tag_t tag;                       /* Tag used for request and response */
+    hg_atomic_int32_t na_op_completed_count; /* Number of NA operations completed */
+    hg_atomic_int32_t in_use;           /* Is in use */
     hg_atomic_int32_t ref_count;        /* Reference count */
-
-    /* Callbacks */
-    hg_return_t (*forward)(
-        struct hg_core_private_handle *hg_core_handle
-        ); /* forward */
-    hg_return_t (*respond)(
-        struct hg_core_private_handle *hg_core_handle
-        ); /* respond */
-    hg_return_t (*no_respond)(
-        struct hg_core_private_handle *hg_core_handle
-        ); /* no_respond */
+    hg_atomic_int32_t posted;           /* Handle has been posted */
+    hg_atomic_int32_t canceling;        /* Handle is being canceled */
+    unsigned int na_op_count;           /* Number of ongoing operations */
+    hg_core_op_type_t op_type;          /* Core operation type */
+    hg_return_t ret;                    /* Return code associated to handle */
+    hg_uint8_t cookie;                  /* Cookie */
+    hg_bool_t repost;                   /* Repost handle on completion (listen) */
+    hg_bool_t is_self;                  /* Self processed */
+    hg_bool_t no_response;              /* Require response or not */
 };
 
 /* HG op id */
 struct hg_core_op_info_lookup {
-    struct hg_core_private_addr *hg_core_addr; /* Address */
-    na_op_id_t na_lookup_op_id;         /* Operation ID for lookup */
+    struct hg_core_private_addr *hg_core_addr;  /* Address */
+    na_op_id_t na_lookup_op_id;                 /* Operation ID for lookup */
 };
 
 struct hg_core_op_id {
-    struct hg_core_private_context *context; /* Context */
-    hg_cb_type_t type;                  /* Callback type */
-    hg_core_cb_t callback;              /* Callback */
-    void *arg;                          /* Callback arguments */
-    hg_atomic_int32_t completed;        /* Operation completed TODO needed ? */
+    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
     union {
         struct hg_core_op_info_lookup lookup;
     } info;
-    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
+    struct hg_core_private_context *context;        /* Context */
+    hg_core_cb_t callback;                          /* Callback */
+    void *arg;                                      /* Callback arguments */
+    hg_cb_type_t type;                              /* Callback type */
 };
 
 /********************/
@@ -317,21 +303,11 @@ hg_core_pending_list_cancel(
         struct hg_core_private_context *context
         );
 
-#ifdef HG_HAS_SM_ROUTING
-/**
- * Cancel entries from pending list.
- */
-static hg_return_t
-hg_core_sm_pending_list_cancel(
-        struct hg_core_private_context *context
-        );
-#endif
-
 /**
- * Wail until handle list is empty.
+ * Wail until handle lists are empty.
  */
 static hg_return_t
-hg_core_created_list_wait(
+hg_core_context_lists_wait(
         struct hg_core_private_context *context
         );
 
@@ -641,7 +617,6 @@ hg_core_process(
 static HG_INLINE hg_return_t
 hg_core_complete_na(
         struct hg_core_private_handle *hg_core_handle,
-        na_op_id_t *op_id,
         hg_bool_t *completed
         );
 
@@ -846,11 +821,8 @@ hg_core_get_sm_uuid(uuid_t *sm_uuid)
         uuid_generate(new_uuid);
 
         uuid_config = fopen(sm_path, "w");
-        if (!uuid_config) {
-            HG_LOG_ERROR("Could not open %s for write", sm_path);
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(uuid_config == NULL, done, ret, HG_NOENTRY,
+            "Could not open %s for write", sm_path);
         uuid_unparse(new_uuid, uuid_str);
         fprintf(uuid_config, "%s\n", uuid_str);
     } else {
@@ -884,7 +856,8 @@ hg_core_int_hash(void *vlocation)
 static void
 hg_core_func_map_value_free(hg_hash_table_value_t value)
 {
-    struct hg_core_rpc_info *hg_core_rpc_info = (struct hg_core_rpc_info *) value;
+    struct hg_core_rpc_info *hg_core_rpc_info =
+        (struct hg_core_rpc_info *) value;
 
     if (hg_core_rpc_info->free_callback)
         hg_core_rpc_info->free_callback(hg_core_rpc_info->data);
@@ -921,17 +894,11 @@ hg_core_proc_header_request(struct hg_core_handle *hg_core_handle,
     /* Proc request header */
     ret = hg_core_header_request_proc(op, header_buf, header_buf_size,
         hg_core_header);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process request header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process request header");
 
     if (op == HG_DECODE) {
         ret = hg_core_header_request_verify(hg_core_header);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not verify request header");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not verify request header");
     }
 
 done:
@@ -952,17 +919,11 @@ hg_core_proc_header_response(struct hg_core_handle *hg_core_handle,
     /* Proc response header */
     ret = hg_core_header_response_proc(op, header_buf, header_buf_size,
         hg_core_header);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process response header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process response header");
 
     if (op == HG_DECODE) {
         ret = hg_core_header_response_verify(hg_core_header);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not verify response header");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not verify response header");
     }
 
 done:
@@ -973,75 +934,55 @@ done:
 static hg_return_t
 hg_core_pending_list_cancel(struct hg_core_private_context *context)
 {
+    struct hg_core_private_handle *hg_core_handle;
     hg_return_t ret = HG_SUCCESS;
 
     hg_thread_spin_lock(&context->pending_list_lock);
 
-    while (!HG_LIST_IS_EMPTY(&context->pending_list)) {
-        struct hg_core_private_handle *hg_core_handle =
-            HG_LIST_FIRST(&context->pending_list);
-        HG_LIST_REMOVE(hg_core_handle, pending);
-
+    HG_QUEUE_FOREACH(hg_core_handle, &context->pending_list, pending) {
         /* Prevent reposts */
         hg_core_handle->repost = HG_FALSE;
 
         /* Cancel handle */
         ret = hg_core_cancel(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel handle");
-            break;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle");
     }
 
-    hg_thread_spin_unlock(&context->pending_list_lock);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
 #ifdef HG_HAS_SM_ROUTING
-static hg_return_t
-hg_core_sm_pending_list_cancel(struct hg_core_private_context *context)
-{
-    hg_return_t ret = HG_SUCCESS;
-
-    hg_thread_spin_lock(&context->sm_pending_list_lock);
-
-    while (!HG_LIST_IS_EMPTY(&context->sm_pending_list)) {
-        struct hg_core_private_handle *hg_core_handle =
-            HG_LIST_FIRST(&context->sm_pending_list);
-        HG_LIST_REMOVE(hg_core_handle, pending);
-
+    HG_QUEUE_FOREACH(hg_core_handle, &context->sm_pending_list, pending) {
         /* Prevent reposts */
         hg_core_handle->repost = HG_FALSE;
 
         /* Cancel handle */
         ret = hg_core_cancel(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel SM handle");
-            break;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle");
     }
+#endif
 
-    hg_thread_spin_unlock(&context->sm_pending_list_lock);
-
+done:
+    hg_thread_spin_unlock(&context->pending_list_lock);
     return ret;
 }
-#endif
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_created_list_wait(struct hg_core_private_context *context)
+hg_core_context_lists_wait(struct hg_core_private_context *context)
 {
     hg_util_bool_t created_list_empty = HG_UTIL_FALSE;
+    hg_util_bool_t pending_list_empty = HG_UTIL_FALSE;
+#ifdef HG_HAS_SM_ROUTING
+    hg_util_bool_t sm_pending_list_empty = HG_UTIL_FALSE;
+#else
+    hg_util_bool_t sm_pending_list_empty = HG_UTIL_TRUE;
+#endif
     /* Convert timeout in ms into seconds */
-    double remaining = HG_CORE_PROCESSING_TIMEOUT / 1000.0;
+    double remaining = HG_CORE_CLEANUP_TIMEOUT / 1000.0;
     hg_return_t ret = HG_SUCCESS;
 
-    while (remaining > 0) {
+    do {
         unsigned int actual_count = 0;
         hg_time_t t1, t2;
-        hg_return_t trigger_ret;
+        hg_return_t trigger_ret, progress_ret;
 
         hg_time_get_current(&t1);
 
@@ -1049,22 +990,35 @@ hg_core_created_list_wait(struct hg_core_private_context *context)
         do {
             trigger_ret = hg_core_trigger(context, 0, 1, &actual_count);
         } while ((trigger_ret == HG_SUCCESS) && actual_count);
+        HG_CHECK_ERROR(trigger_ret != HG_SUCCESS && trigger_ret != HG_TIMEOUT,
+            done, ret, trigger_ret, "Could not trigger entry");
 
         hg_thread_spin_lock(&context->created_list_lock);
         created_list_empty = HG_LIST_IS_EMPTY(&context->created_list);
         hg_thread_spin_unlock(&context->created_list_lock);
 
-        if (created_list_empty)
+        hg_thread_spin_lock(&context->pending_list_lock);
+        pending_list_empty = HG_LIST_IS_EMPTY(&context->pending_list);
+#ifdef HG_HAS_SM_ROUTING
+        sm_pending_list_empty = HG_LIST_IS_EMPTY(&context->sm_pending_list);
+#endif
+        hg_thread_spin_unlock(&context->pending_list_lock);
+
+        if (created_list_empty && pending_list_empty && sm_pending_list_empty)
             break;
 
-        ret = context->progress(context, (unsigned int) (remaining * 1000.0));
-        if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
-            HG_LOG_ERROR("Could not make progress");
-            goto done;
-        }
+        progress_ret = context->progress(context,
+            (unsigned int) (remaining * 1000.0));
+        HG_CHECK_ERROR(progress_ret != HG_SUCCESS && progress_ret != HG_TIMEOUT,
+            done, ret, progress_ret, "Could not make progress");
         hg_time_get_current(&t2);
         remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
-    }
+        if (remaining < 0)
+            remaining = 0;
+    } while (remaining > 0 || !pending_list_empty || !sm_pending_list_empty);
+
+    HG_LOG_DEBUG("Remaining %lf, Context list status: %d, %d, %d", remaining,
+        created_list_empty, pending_list_empty, sm_pending_list_empty);
 
 done:
     return ret;
@@ -1086,11 +1040,8 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     /* Create new HG class */
     hg_core_class = (struct hg_core_private_class *) malloc(
         sizeof(struct hg_core_private_class));
-    if (!hg_core_class) {
-        HG_LOG_ERROR("Could not allocate HG class");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, error, ret, HG_NOMEM,
+        "Could not allocate HG class");
     memset(hg_core_class, 0, sizeof(struct hg_core_private_class));
 
     /* Parse options */
@@ -1104,19 +1055,16 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
 #ifdef HG_HAS_SM_ROUTING
         auto_sm = hg_init_info->auto_sm;
 #else
-        if (hg_init_info->auto_sm) {
-            HG_LOG_WARNING("Auto SM requested but not enabled, "
-                "please turn ON MERCURY_USE_SM_ROUTING in CMake options");
-        }
+        HG_CHECK_WARNING(hg_init_info->auto_sm,
+            "Auto SM requested but not enabled, "
+            "please turn ON MERCURY_USE_SM_ROUTING in CMake options");
 #endif
 #ifdef HG_HAS_COLLECT_STATS
         hg_core_class->stats = hg_init_info->stats;
         if (hg_core_class->stats && !hg_core_print_stats_registered_g) {
-            if (atexit(hg_core_print_stats) != 0) {
-                HG_LOG_ERROR("Could not register hg_core_print_stats");
-                ret = HG_PROTOCOL_ERROR;
-                goto done;
-            }
+            int rc = atexit(hg_core_print_stats);
+            HG_CHECK_ERROR(rc != 0, error, ret, HG_PROTOCOL_ERROR,
+                "Could not register hg_core_print_stats");
             hg_core_print_stats_registered_g = HG_TRUE;
         }
 #endif
@@ -1126,62 +1074,44 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     if (!hg_core_class->na_ext_init) {
         hg_core_class->core_class.na_class = NA_Initialize_opt(
             na_info_string, na_listen, &hg_init_info->na_init_info);
-        if (!hg_core_class->core_class.na_class) {
-            HG_LOG_ERROR("Could not initialize NA class");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_core_class->core_class.na_class == NULL, error, ret,
+            HG_NA_ERROR, "Could not initialize NA class");
     }
 
 #ifdef HG_HAS_SM_ROUTING
     /* Initialize SM plugin */
     if (auto_sm) {
-        if (strcmp(NA_Get_class_name(hg_core_class->core_class.na_class),
-            "na") == 0) {
-            HG_LOG_ERROR("Cannot use auto SM mode if initialized NA class is "
-                "already using SM");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(strcmp(NA_Get_class_name(
+            hg_core_class->core_class.na_class), "na") == 0, error, ret,
+            HG_PROTONOSUPPORT, "Cannot use auto SM mode if initialized "
+                "NA class is already using SM");
 
         /* Initialize NA SM first so that tmp directories are created */
         hg_core_class->core_class.na_sm_class = NA_Initialize_opt("na+sm",
             na_listen, &hg_init_info->na_init_info);
-        if (!hg_core_class->core_class.na_sm_class) {
-            HG_LOG_ERROR("Could not initialize NA SM class");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_core_class->core_class.na_sm_class == NULL, error,
+            ret, HG_NA_ERROR, "Could not initialize NA SM class");
 
         /* Get SM UUID */
         ret = hg_core_get_sm_uuid(&hg_core_class->na_sm_uuid);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not get SM UUID");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Could not get SM UUID");
     }
 #endif
 
     /* Compute max request tag */
     na_max_tag = NA_Msg_get_max_tag(hg_core_class->core_class.na_class);
-    if (!na_max_tag) {
-        HG_LOG_ERROR("NA Max tag is not defined");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(na_max_tag == 0, error, ret, HG_NA_ERROR,
+        "NA Max tag is not defined");
     hg_core_class->request_max_tag = na_max_tag;
 
 #ifdef HG_HAS_SM_ROUTING
     if (auto_sm) {
         na_sm_max_tag = NA_Msg_get_max_tag(
             hg_core_class->core_class.na_sm_class);
-        if (!na_max_tag) {
-            HG_LOG_ERROR("NA Max tag is not defined");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
-        hg_core_class->request_max_tag = HG_CORE_MIN(hg_core_class->request_max_tag,
-            na_sm_max_tag);
+        HG_CHECK_ERROR(na_sm_max_tag == 0, error, ret, HG_NA_ERROR,
+            "NA Max tag is not defined");
+        hg_core_class->request_max_tag = HG_CORE_MIN(
+            hg_core_class->request_max_tag, na_sm_max_tag);
     }
 #endif
 
@@ -1195,12 +1125,11 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     hg_atomic_init32(&hg_core_class->n_addrs, 0);
 
     /* Create new function map */
-    hg_core_class->func_map = hg_hash_table_new(hg_core_int_hash, hg_core_int_equal);
-    if (!hg_core_class->func_map) {
-        HG_LOG_ERROR("Could not create function map");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    hg_core_class->func_map = hg_hash_table_new(hg_core_int_hash,
+        hg_core_int_equal);
+    HG_CHECK_ERROR(hg_core_class->func_map == NULL, error, ret, HG_NOMEM,
+        "Could not create function map");
+
     /* Automatically free all the values with the hash map */
     hg_hash_table_register_free_functions(hg_core_class->func_map, free,
             hg_core_func_map_value_free);
@@ -1208,12 +1137,13 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     /* Initialize mutex */
     hg_thread_spin_init(&hg_core_class->func_map_lock);
 
-done:
-    if (ret != HG_SUCCESS) {
-        hg_core_finalize(hg_core_class);
-        hg_core_class = NULL;
-    }
+    // TODO
+    (void)ret;
     return hg_core_class;
+
+error:
+    hg_core_finalize(hg_core_class);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1222,24 +1152,19 @@ hg_core_finalize(struct hg_core_private_class *hg_core_class)
 {
     hg_util_int32_t n_addrs, n_contexts;
     hg_return_t ret = HG_SUCCESS;
+    na_return_t na_ret;
 
-    if (!hg_core_class) goto done;
+    if (!hg_core_class)
+        goto done;
 
     n_contexts = hg_atomic_get32(&hg_core_class->n_contexts);
-    if (n_contexts != 0) {
-        HG_LOG_ERROR("HG contexts must be destroyed before finalizing HG"
-            " (%d remaining)", n_contexts);
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(n_contexts != 0, done, ret, HG_BUSY,
+        "HG contexts must be destroyed before finalizing HG (%d remaining)",
+        n_contexts);
 
     n_addrs = hg_atomic_get32(&hg_core_class->n_addrs);
-    if (n_addrs != 0) {
-        HG_LOG_ERROR("HG addrs must be freed before finalizing HG"
-            " (%d remaining)", n_addrs);
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(n_addrs != 0, done, ret, HG_BUSY,
+        "HG addrs must be freed before finalizing HG (%d remaining)", n_addrs);
 
     /* Delete function map */
     if(hg_core_class->func_map)
@@ -1256,27 +1181,23 @@ hg_core_finalize(struct hg_core_private_class *hg_core_class)
 
     if (!hg_core_class->na_ext_init) {
         /* Finalize interface */
-        if (NA_Finalize(hg_core_class->core_class.na_class) != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not finalize NA interface");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        na_ret = NA_Finalize(hg_core_class->core_class.na_class);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not finalize NA interface (%s)", NA_Error_to_string(na_ret));
         hg_core_class->core_class.na_class = NULL;
     }
 
 #ifdef HG_HAS_SM_ROUTING
     /* Finalize SM interface */
-    if (NA_Finalize(hg_core_class->core_class.na_sm_class) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not finalize NA SM interface");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    na_ret = NA_Finalize(hg_core_class->core_class.na_sm_class);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "Could not finalize NA SM interface (%s)", NA_Error_to_string(na_ret));
 #endif
 
-done:
     /* Free HG class */
     free(hg_core_class);
 
+done:
     return ret;
 }
 
@@ -1289,10 +1210,9 @@ hg_core_addr_create(struct hg_core_private_class *hg_core_class,
 
     hg_core_addr = (struct hg_core_private_addr *) malloc(
         sizeof(struct hg_core_private_addr));
-    if (!hg_core_addr) {
-        HG_LOG_ERROR("Could not allocate HG addr");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_addr == NULL, done,
+        "Could not allocate HG addr");
+
     memset(hg_core_addr, 0, sizeof(struct hg_core_private_addr));
     hg_core_addr->core_addr.na_class = na_class;
     hg_core_addr->core_addr.na_addr = NA_ADDR_NULL;
@@ -1317,6 +1237,7 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
     na_context_t *na_context = context->core_context.na_context;
     struct hg_core_op_id *hg_core_op_id = NULL;
     struct hg_core_private_addr *hg_core_addr = NULL;
+    na_addr_t na_addr = NA_ADDR_NULL;
     na_return_t na_ret;
 #ifdef HG_HAS_SM_ROUTING
     char lookup_name[HG_CORE_ADDR_MAX_SIZE] = {'\0'};
@@ -1325,27 +1246,21 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
     hg_return_t ret = HG_SUCCESS, progress_ret;
 
     /* Allocate op_id */
-    hg_core_op_id = (struct hg_core_op_id *) malloc(sizeof(struct hg_core_op_id));
-    if (!hg_core_op_id) {
-        HG_LOG_ERROR("Could not allocate HG operation ID");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    hg_core_op_id = (struct hg_core_op_id *) malloc(
+        sizeof(struct hg_core_op_id));
+    HG_CHECK_ERROR(hg_core_op_id == NULL, error, ret, HG_NOMEM,
+        "Could not allocate HG operation ID");
+
     hg_core_op_id->context = context;
     hg_core_op_id->type = HG_CB_LOOKUP;
     hg_core_op_id->callback = callback;
     hg_core_op_id->arg = arg;
-    hg_atomic_init32(&hg_core_op_id->completed, 0);
     hg_core_op_id->info.lookup.hg_core_addr = NULL;
-    hg_core_op_id->info.lookup.na_lookup_op_id = NA_OP_ID_NULL;
 
     /* Allocate addr */
     hg_core_addr = hg_core_addr_create(HG_CORE_CONTEXT_CLASS(context), NULL);
-    if (!hg_core_addr) {
-        HG_LOG_ERROR("Could not create HG addr");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_addr == NULL, error, ret, HG_NOMEM,
+        "Could not create HG addr");
     hg_core_op_id->info.lookup.hg_core_addr = hg_core_addr;
 
 #ifdef HG_HAS_SM_ROUTING
@@ -1359,11 +1274,9 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
         /* Get first part of address string with UUID */
         strtok_r(lookup_name, HG_CORE_ADDR_DELIMITER, &lookup_names);
 
-        if (!strstr(name, HG_CORE_PROTO_DELIMITER)) {
-            HG_LOG_ERROR("Malformed address format");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(strstr(name, HG_CORE_PROTO_DELIMITER) == NULL, error,
+            ret, HG_PROTOCOL_ERROR, "Malformed address format");
+
         /* Get address SM UUID */
         strtok_r(lookup_name, HG_CORE_PROTO_DELIMITER, &local_id_str);
         uuid_parse(local_id_str + 2, hg_core_addr->na_sm_uuid);
@@ -1388,33 +1301,47 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
     /* Assign corresponding NA class */
     hg_core_addr->core_addr.na_class = na_class;
 
-    /* Assign op_id */
-    if (op_id && op_id != HG_CORE_OP_ID_IGNORE)
-        *op_id = (hg_core_op_id_t) hg_core_op_id;
+    /* Try to use immediate lookup */
+    na_ret = NA_Addr_lookup2(na_class, name_str, &na_addr);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not start lookup for address %s (%s)", name_str,
+        NA_Error_to_string(na_ret));
+
+    if (na_addr != NA_ADDR_NULL) {
+        struct na_cb_info callback_info;
+        callback_info.arg = hg_core_op_id;
+        callback_info.ret = NA_SUCCESS;
+        callback_info.type = NA_CB_LOOKUP;
+        callback_info.info.lookup.addr = na_addr;
+        hg_core_op_id->info.lookup.na_lookup_op_id = NA_OP_ID_NULL;
+
+        hg_core_addr_lookup_cb(&callback_info);
+    } else {
+        /* Create operation ID */
+        hg_core_op_id->info.lookup.na_lookup_op_id = NA_Op_create(na_class);
 
-    na_ret = NA_Addr_lookup(na_class, na_context, hg_core_addr_lookup_cb,
-        hg_core_op_id, name_str, &hg_core_op_id->info.lookup.na_lookup_op_id);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not start lookup for address %s", name_str);
-        ret = HG_NA_ERROR;
-        goto done;
+        na_ret = NA_Addr_lookup(na_class, na_context, hg_core_addr_lookup_cb,
+            hg_core_op_id, name_str, &hg_core_op_id->info.lookup.na_lookup_op_id);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+            "Could not start lookup for address %s (%s)", name_str,
+            NA_Error_to_string(na_ret));
     }
 
     /* TODO to avoid blocking after lookup make progress on the HG layer with
      * timeout of 0 */
     progress_ret = context->progress(context, 0);
-    if (progress_ret != HG_SUCCESS && progress_ret != HG_TIMEOUT) {
-        HG_LOG_ERROR("Could not make progress");
-        ret = progress_ret;
-        goto done;
-    }
+    HG_CHECK_ERROR(progress_ret != HG_SUCCESS && progress_ret != HG_TIMEOUT,
+        error, ret, progress_ret, "Could not make progress");
 
-done:
-    if (ret != HG_SUCCESS) {
-        free(hg_core_op_id);
-        if (hg_core_addr != NULL)
-            hg_core_addr_free(HG_CORE_CONTEXT_CLASS(context), hg_core_addr);
-    }
+    /* Assign op_id */
+    if (op_id && op_id != HG_CORE_OP_ID_IGNORE)
+        *op_id = (hg_core_op_id_t) hg_core_op_id;
+
+    return ret;
+
+error:
+    free(hg_core_op_id);
+    hg_core_addr_free(HG_CORE_CONTEXT_CLASS(context), hg_core_addr);
 
     return ret;
 }
@@ -1425,26 +1352,24 @@ hg_core_addr_lookup_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_op_id *hg_core_op_id =
         (struct hg_core_op_id *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
+    na_return_t na_ret = callback_info->ret;
+    hg_return_t hg_ret;
     int ret = 0;
 
-    if (callback_info->ret != NA_SUCCESS) {
-        return ret;
-    }
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done, "(%s)",
+        NA_Error_to_string(na_ret));
 
     /* Assign addr */
     hg_core_op_id->info.lookup.hg_core_addr->core_addr.na_addr =
         callback_info->info.lookup.addr;
 
     /* Mark as completed */
-    if (hg_core_addr_lookup_complete(hg_core_op_id) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    hg_ret = hg_core_addr_lookup_complete(hg_core_op_id);
+    HG_CHECK_HG_ERROR(done, hg_ret, "Could not complete operation");
+
     ret++;
 
 done:
-    (void) na_ret;
     return ret;
 }
 
@@ -1457,17 +1382,12 @@ hg_core_addr_lookup_complete(struct hg_core_op_id *hg_core_op_id)
         &hg_core_op_id->hg_completion_entry;
     hg_return_t ret = HG_SUCCESS;
 
-    /* Mark operation as completed */
-    hg_atomic_incr32(&hg_core_op_id->completed);
-
     hg_completion_entry->op_type = HG_ADDR;
     hg_completion_entry->op_id.hg_core_op_id = hg_core_op_id;
 
     ret = hg_core_completion_add(context, hg_completion_entry, HG_FALSE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not add HG completion entry to completion queue");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret,
+        "Could not add HG completion entry to completion queue");
 
 done:
     return ret;
@@ -1481,12 +1401,12 @@ hg_core_addr_free(struct hg_core_private_class *hg_core_class,
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
-    if (!hg_core_addr) goto done;
+    if (!hg_core_addr)
+        goto done;
 
-    if (hg_atomic_decr32(&hg_core_addr->ref_count)) {
+    if (hg_atomic_decr32(&hg_core_addr->ref_count))
         /* Cannot free yet */
         goto done;
-    }
 
     /* Decrement N addrs from HG class */
     hg_atomic_decr32(&hg_core_class->n_addrs);
@@ -1496,22 +1416,17 @@ hg_core_addr_free(struct hg_core_private_class *hg_core_class,
     if (hg_core_addr->core_addr.na_sm_addr != NA_ADDR_NULL) {
         na_ret = NA_Addr_free(hg_core_class->core_class.na_sm_class,
             hg_core_addr->core_addr.na_sm_addr);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not free NA SM address");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not free NA SM address (%s)", NA_Error_to_string(na_ret));
     }
 #endif
 
     /* Free NA address */
     na_ret = NA_Addr_free(hg_core_addr->core_addr.na_class,
         hg_core_addr->core_addr.na_addr);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not free address");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "Could not free NA address (%s)", NA_Error_to_string(na_ret));
+
     free(hg_core_addr);
 
 done:
@@ -1529,30 +1444,21 @@ hg_core_addr_self(struct hg_core_private_class *hg_core_class,
 
     hg_core_addr = hg_core_addr_create(hg_core_class,
         hg_core_class->core_class.na_class);
-    if (!hg_core_addr) {
-        HG_LOG_ERROR("Could not create HG addr");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_addr == NULL, done, ret, HG_NOMEM,
+        "Could not create HG addr");
 
     na_ret = NA_Addr_self(hg_core_class->core_class.na_class,
         &hg_core_addr->core_addr.na_addr);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not get self address");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "Could not get self address (%s)", NA_Error_to_string(na_ret));
 
 #ifdef HG_HAS_SM_ROUTING
     if (hg_core_class->core_class.na_sm_class) {
         /* Get SM address */
         na_ret = NA_Addr_self(hg_core_class->core_class.na_sm_class,
             &hg_core_addr->core_addr.na_sm_addr);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not get self SM address");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not get self SM address (%s)", NA_Error_to_string(na_ret));
 
         /* Copy local UUID */
         uuid_copy(hg_core_addr->na_sm_uuid, hg_core_class->na_sm_uuid);
@@ -1584,18 +1490,14 @@ hg_core_addr_dup(struct hg_core_private_class *hg_core_class,
 
         dup = hg_core_addr_create(hg_core_class,
             hg_core_addr->core_addr.na_class);
-        if (!dup) {
-            HG_LOG_ERROR("Could not create HG addr");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(dup == NULL, done, ret, HG_NOMEM,
+            "Could not create dup HG addr");
+
         na_ret = NA_Addr_dup(hg_core_addr->core_addr.na_class,
             hg_core_addr->core_addr.na_addr, &dup->core_addr.na_addr);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not duplicate address");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not duplicate address (%s)", NA_Error_to_string(na_ret));
+
         *hg_new_addr = dup;
     } else {
         hg_atomic_incr32(&hg_core_addr->ref_count);
@@ -1616,11 +1518,6 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
-    if (!buf_size) {
-        HG_LOG_ERROR("NULL buffer size");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
     new_buf_size = *buf_size;
 
 #ifdef HG_HAS_SM_ROUTING
@@ -1633,11 +1530,9 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
         uuid_unparse(hg_core_addr->na_sm_uuid, uuid_str);
         desc_len = snprintf(addr_str, HG_CORE_ADDR_MAX_SIZE,
             "uid://%s" HG_CORE_ADDR_DELIMITER, uuid_str);
-        if (desc_len > HG_CORE_ADDR_MAX_SIZE) {
-            HG_LOG_ERROR("Exceeding max addr name");
-            ret = HG_SIZE_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(desc_len > HG_CORE_ADDR_MAX_SIZE, done, ret,
+            HG_OVERFLOW, "Exceeding max addr name");
+
         if (buf_ptr) {
             strcpy(buf_ptr, addr_str);
             buf_ptr += desc_len;
@@ -1649,11 +1544,10 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
         /* Get NA SM address string */
         na_ret = NA_Addr_to_string(hg_core_class->core_class.na_sm_class,
             buf_ptr, &new_buf_size, hg_core_addr->core_addr.na_sm_addr);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not convert SM address to string");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not convert SM address to string (%s)",
+            NA_Error_to_string(na_ret));
+
         if (buf_ptr) {
             buf_ptr[new_buf_size - 1] = *HG_CORE_ADDR_DELIMITER;
             buf_ptr += new_buf_size;
@@ -1667,11 +1561,9 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
     /* Get NA address string */
     na_ret = NA_Addr_to_string(hg_core_class->core_class.na_class, buf_ptr,
         &new_buf_size, hg_core_addr->core_addr.na_addr);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not convert address to string");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "Could not convert address to string (%s)", NA_Error_to_string(na_ret));
+
     *buf_size = new_buf_size + buf_size_used;
 
 done:
@@ -1687,10 +1579,9 @@ hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
 
     hg_core_handle = (struct hg_core_private_handle *) malloc(
         sizeof(struct hg_core_private_handle));
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("Could not allocate handle");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_handle == NULL, error,
+        "Could not allocate handle");
+
     memset(hg_core_handle, 0, sizeof(struct hg_core_private_handle));
 
     hg_core_handle->op_type = HG_CORE_PROCESS; /* Default */
@@ -1713,6 +1604,12 @@ hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
     /* Handle is not in use */
     hg_atomic_init32(&hg_core_handle->in_use, HG_FALSE);
 
+    /* Handle has not been posted */
+    hg_atomic_init32(&hg_core_handle->posted, HG_FALSE);
+
+    /* Handle is not being canceled */
+    hg_atomic_init32(&hg_core_handle->canceling, HG_FALSE);
+
     /* Init in/out header */
     hg_core_header_request_init(&hg_core_handle->in_header);
     hg_core_header_response_init(&hg_core_handle->out_header);
@@ -1725,25 +1622,21 @@ hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
 
     /* Alloc/init NA resources */
     ret = hg_core_alloc_na(hg_core_handle, use_sm);
-    if (ret != HG_SUCCESS) {
-        NA_LOG_ERROR("Could not allocate NA handle ops");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not allocate NA handle ops");
 
-done:
-    if (ret != HG_SUCCESS) {
-        hg_core_destroy(hg_core_handle);
-        hg_core_handle = NULL;
-    }
     return hg_core_handle;
+
+error:
+    hg_core_destroy(hg_core_handle);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
 static void
 hg_core_destroy(struct hg_core_private_handle *hg_core_handle)
 {
-    if (!hg_core_handle) goto done;
+    if (!hg_core_handle)
+        goto done;
 
     if (hg_atomic_decr32(&hg_core_handle->ref_count))
         goto done; /* Cannot free yet */
@@ -1788,6 +1681,7 @@ hg_core_alloc_na(struct hg_core_private_handle *hg_core_handle,
     hg_bool_t HG_UNUSED use_sm)
 {
     hg_return_t ret = HG_SUCCESS;
+    na_return_t na_ret;
 
     /* Set handle NA class/context */
     hg_core_handle->na_class =
@@ -1814,45 +1708,49 @@ hg_core_alloc_na(struct hg_core_private_handle *hg_core_handle,
     hg_core_handle->core_handle.in_buf = NA_Msg_buf_alloc(
         hg_core_handle->na_class, hg_core_handle->core_handle.in_buf_size,
         &hg_core_handle->in_buf_plugin_data);
-    if (!hg_core_handle->core_handle.in_buf) {
-        HG_LOG_ERROR("Could not allocate buffer for input");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    NA_Msg_init_unexpected(hg_core_handle->na_class,
+    HG_CHECK_ERROR(hg_core_handle->core_handle.in_buf == NULL, error, ret,
+        HG_NOMEM, "Could not allocate buffer for input");
+
+    na_ret = NA_Msg_init_unexpected(hg_core_handle->na_class,
         hg_core_handle->core_handle.in_buf,
         hg_core_handle->core_handle.in_buf_size);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not initialize input buffer (%s)",
+        NA_Error_to_string(na_ret));
 
     hg_core_handle->core_handle.out_buf = NA_Msg_buf_alloc(
         hg_core_handle->na_class, hg_core_handle->core_handle.out_buf_size,
         &hg_core_handle->out_buf_plugin_data);
-    if (!hg_core_handle->core_handle.out_buf) {
-        HG_LOG_ERROR("Could not allocate buffer for output");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    NA_Msg_init_expected(hg_core_handle->na_class,
+    HG_CHECK_ERROR(hg_core_handle->core_handle.out_buf == NULL, error, ret,
+        HG_NOMEM, "Could not allocate buffer for output");
+
+    na_ret = NA_Msg_init_expected(hg_core_handle->na_class,
         hg_core_handle->core_handle.out_buf,
         hg_core_handle->core_handle.out_buf_size);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not initialize output buffer (%s)",
+        NA_Error_to_string(na_ret));
 
     /* Create NA operation IDs */
     hg_core_handle->na_send_op_id = NA_Op_create(hg_core_handle->na_class);
+    HG_CHECK_ERROR(hg_core_handle->na_send_op_id == NA_OP_ID_NULL, error, ret,
+        HG_NA_ERROR, "Could not create NA op ID");
     hg_core_handle->na_recv_op_id = NA_Op_create(hg_core_handle->na_class);
-    if (hg_core_handle->na_recv_op_id || hg_core_handle->na_send_op_id) {
-        if ((hg_core_handle->na_recv_op_id == NA_OP_ID_NULL)
-            || (hg_core_handle->na_send_op_id == NA_OP_ID_NULL)) {
-            HG_LOG_ERROR("NULL operation ID");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
-        hg_core_handle->na_op_id_mine = HG_TRUE;
-    }
+    HG_CHECK_ERROR(hg_core_handle->na_recv_op_id == NA_OP_ID_NULL, error, ret,
+        HG_NA_ERROR, "Could not create NA op ID");
+    hg_core_handle->na_ack_op_id = NA_Op_create(hg_core_handle->na_class);
+    HG_CHECK_ERROR(hg_core_handle->na_ack_op_id == NA_OP_ID_NULL, error, ret,
+        HG_NA_ERROR, "Could not create NA op ID");
+
     hg_core_handle->na_op_count = 1; /* Default (no response) */
     hg_atomic_init32(&hg_core_handle->na_op_completed_count, 0);
 
-done:
     return ret;
-}
+
+error:
+    hg_core_free_na(hg_core_handle);
+    return ret;
+}
 
 /*---------------------------------------------------------------------------*/
 static void
@@ -1860,30 +1758,52 @@ hg_core_free_na(struct hg_core_private_handle *hg_core_handle)
 {
     na_return_t na_ret;
 
-    /* Free eventual ack buffer */
-    if (hg_core_handle->ack_buf) {
-        NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->ack_buf,
-            hg_core_handle->ack_buf_plugin_data);
-        hg_core_handle->ack_buf = NULL;
-    }
-
     /* Destroy NA op IDs */
-    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_send_op_id);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA op ID");
-    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_recv_op_id);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA op ID");
+    na_ret = NA_Op_destroy(hg_core_handle->na_class,
+        hg_core_handle->na_send_op_id);
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+        "Could not destroy send op ID (%s)", NA_Error_to_string(na_ret));
+    hg_core_handle->na_send_op_id = NA_OP_ID_NULL;
+
+    na_ret = NA_Op_destroy(hg_core_handle->na_class,
+        hg_core_handle->na_recv_op_id);
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+        "Could not destroy recv op ID (%s)", NA_Error_to_string(na_ret));
+    hg_core_handle->na_recv_op_id = NA_OP_ID_NULL;
+
+    na_ret = NA_Op_destroy(hg_core_handle->na_class,
+        hg_core_handle->na_ack_op_id);
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+        "Could not destroy ack op ID (%s)", NA_Error_to_string(na_ret));
+    hg_core_handle->na_ack_op_id = NA_OP_ID_NULL;
 
     /* Free buffers */
     na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
         hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_plugin_data);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA input msg buffer");
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+        "Could not free input buffer (%s)", NA_Error_to_string(na_ret));
+    hg_core_handle->core_handle.in_buf = NULL;
+    hg_core_handle->in_buf_plugin_data = NULL;
+
     na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
-        hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_plugin_data);
-    if (na_ret != NA_SUCCESS)
-        HG_LOG_ERROR("Could not destroy NA output msg buffer");
+        hg_core_handle->core_handle.out_buf,
+        hg_core_handle->out_buf_plugin_data);
+    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+        "Could not free output buffer (%s)", NA_Error_to_string(na_ret));
+    hg_core_handle->core_handle.out_buf = NULL;
+    hg_core_handle->out_buf_plugin_data = NULL;
+
+    if (hg_core_handle->ack_buf) {
+        na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
+            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
+        HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
+        hg_core_handle->ack_buf = NULL;
+        hg_core_handle->ack_buf_plugin_data = NULL;
+    }
+
+done:
+    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1895,8 +1815,11 @@ hg_core_reset(struct hg_core_private_handle *hg_core_handle,
     if (reset_info) {
         if (hg_core_handle->core_handle.info.addr != HG_CORE_ADDR_NULL
             && hg_core_handle->core_handle.info.addr->na_addr != NA_ADDR_NULL) {
-            NA_Addr_free(hg_core_handle->core_handle.info.addr->na_class,
+            na_return_t na_ret = NA_Addr_free(
+                hg_core_handle->core_handle.info.addr->na_class,
                 hg_core_handle->core_handle.info.addr->na_addr);
+            HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+                "Could not free NA address (%s)", NA_Error_to_string(na_ret));
             hg_core_handle->core_handle.info.addr->na_addr = NA_ADDR_NULL;
         }
         hg_core_handle->core_handle.info.id = 0;
@@ -1921,14 +1844,19 @@ hg_core_reset(struct hg_core_private_handle *hg_core_handle,
         HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_release(
             (hg_core_handle_t) hg_core_handle);
     if (hg_core_handle->ack_buf) {
-        NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->ack_buf,
-            hg_core_handle->ack_buf_plugin_data);
+        na_return_t na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
+            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
+        HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
+            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
         hg_core_handle->ack_buf = NULL;
         hg_core_handle->ack_buf_plugin_data = NULL;
     }
 
     hg_core_header_request_reset(&hg_core_handle->in_header);
     hg_core_header_response_reset(&hg_core_handle->out_header);
+
+done:
+    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1974,11 +1902,9 @@ hg_core_set_rpc(struct hg_core_private_handle *hg_core_handle,
             (hg_hash_table_key_t) &id);
         hg_thread_spin_unlock(
             &HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map_lock);
-        if (!hg_core_rpc_info) {
-            /* HG_LOG_ERROR("Could not find RPC ID in function map"); */
-            ret = HG_NO_MATCH;
-            goto done;
-        }
+        if (!hg_core_rpc_info)
+            HG_GOTO_DONE(done, ret, HG_NOENTRY);
+
         hg_core_handle->core_handle.info.id = id;
 
         /* Cache RPC info */
@@ -2001,10 +1927,7 @@ hg_core_forward_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Post operation to self processing pool */
     ret = hg_core_process_self(hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not self process handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not self process handle");
 
 done:
     return ret;
@@ -2017,6 +1940,7 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
 {
     na_return_t na_ret;
     hg_return_t ret = HG_SUCCESS;
+    int retry_cnt = 0;
 
     /* Set operation type for trigger */
     hg_core_handle->op_type = HG_CORE_FORWARD;
@@ -2025,11 +1949,8 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
     hg_core_handle->tag = hg_core_gen_request_tag(
         HG_CORE_HANDLE_CLASS(hg_core_handle));
 
+    /* Pre-post recv (output) if response is expected */
     if (!hg_core_handle->no_response) {
-        /* Increment number of expected NA operations */
-        hg_core_handle->na_op_count++;
-
-        /* Pre-post the recv message (output) if response is expected */
         na_ret = NA_Msg_recv_expected(hg_core_handle->na_class,
             hg_core_handle->na_context, hg_core_recv_output_cb, hg_core_handle,
             hg_core_handle->core_handle.out_buf,
@@ -2038,35 +1959,62 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
             hg_core_handle->core_handle.info.addr->na_addr,
             hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
             &hg_core_handle->na_recv_op_id);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not post recv for output buffer");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
-    }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not post recv for output buffer (%s)",
+            NA_Error_to_string(na_ret));
 
-    /* And post the send message (input) */
-    na_ret = NA_Msg_send_unexpected(hg_core_handle->na_class,
-        hg_core_handle->na_context, hg_core_send_input_cb, hg_core_handle,
-        hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_used,
-        hg_core_handle->in_buf_plugin_data,
-        hg_core_handle->core_handle.info.addr->na_addr,
-        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
-        &hg_core_handle->na_send_op_id);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not post send for input buffer");
-        /* Cancel the above posted recv op */
-        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-            hg_core_handle->na_recv_op_id);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel recv op id");
-        }
-        ret = HG_NA_ERROR;
-        goto done;
+        /* Increment number of expected NA operations */
+        hg_core_handle->na_op_count++;
     }
 
+    /* Mark handle as posted */
+    hg_atomic_set32(&hg_core_handle->posted, HG_TRUE);
+
+    /* Post send (input) */
+    do {
+        na_ret = NA_Msg_send_unexpected(hg_core_handle->na_class,
+            hg_core_handle->na_context, hg_core_send_input_cb, hg_core_handle,
+            hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_used,
+            hg_core_handle->in_buf_plugin_data,
+            hg_core_handle->core_handle.info.addr->na_addr,
+            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
+            &hg_core_handle->na_send_op_id);
+        if (na_ret != NA_AGAIN || retry_cnt++ > HG_CORE_MAX_AGAIN_RETRY)
+            break;
+
+        /* Attempt to make progress on NA with timeout of 0 */
+        na_ret = NA_Progress(hg_core_handle->na_class,
+            hg_core_handle->na_context, 0);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, cancel,
+            ret, (hg_return_t) na_ret, "Could not make progress on NA (%s)",
+            NA_Error_to_string(na_ret));
+    } while (1);
+    /* Silently return on NA_AGAIN error so that users can manually retry */
+    if (na_ret == NA_AGAIN)
+        HG_GOTO_DONE(cancel, ret, HG_AGAIN);
+
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, cancel, ret, (hg_return_t) na_ret,
+        "Could not post send for input buffer (%s)",
+        NA_Error_to_string(na_ret));
+
 done:
     return ret;
+
+cancel:
+    if (!hg_core_handle->no_response)
+        hg_core_handle->na_op_count--;
+
+    /* Handle is no longer posted and being canceled*/
+    hg_atomic_set32(&hg_core_handle->posted, HG_FALSE);
+    hg_atomic_set32(&hg_core_handle->canceling, HG_TRUE);
+
+    /* Cancel the above posted recv op */
+    na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
+        hg_core_handle->na_recv_op_id);
+    HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
+        "Could not cancel recv op id (%s)", NA_Error_to_string(na_ret));
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2081,10 +2029,7 @@ hg_core_respond_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Complete and add to completion queue */
     ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete handle");
 
 done:
     return ret;
@@ -2101,10 +2046,7 @@ hg_core_no_respond_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Complete and add to completion queue */
     ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete handle");
 
 done:
     return ret;
@@ -2117,6 +2059,8 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
+    hg_bool_t ack_recv_posted = HG_FALSE;
+    int retry_cnt = 0;
 
     /* Increment number of expected NA operations */
     hg_core_handle->na_op_count++;
@@ -2131,15 +2075,15 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
 
         hg_core_handle->ack_buf = NA_Msg_buf_alloc(hg_core_handle->na_class,
             sizeof(hg_uint8_t), &hg_core_handle->ack_buf_plugin_data);
-        if (!hg_core_handle->ack_buf) {
-            HG_LOG_ERROR("Could not allocate buffer for ack");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
-        NA_Msg_init_expected(hg_core_handle->na_class, hg_core_handle->ack_buf,
-            sizeof(hg_uint8_t));
+        HG_CHECK_ERROR(hg_core_handle->ack_buf == NULL, error, ret,
+            HG_NA_ERROR, "Could not allocate buffer for ack");
+
+        na_ret = NA_Msg_init_expected(hg_core_handle->na_class,
+            hg_core_handle->ack_buf, sizeof(hg_uint8_t));
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+            "Could not initialize ack buffer (%s)", NA_Error_to_string(na_ret));
 
-        /* Pre-post the recv message (output) if response is expected */
+        /* Pre-post recv (ack) if more data is expected */
         na_ret = NA_Msg_recv_expected(hg_core_handle->na_class,
             hg_core_handle->na_context, hg_core_recv_ack_cb, hg_core_handle,
             hg_core_handle->ack_buf, sizeof(hg_uint8_t),
@@ -2147,28 +2091,55 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
             hg_core_handle->core_handle.info.addr->na_addr,
             hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
             &hg_core_handle->na_ack_op_id);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not post recv for ack buffer");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+            "Could not post recv for ack buffer (%s)",
+            NA_Error_to_string(na_ret));
+        ack_recv_posted = HG_TRUE;
     }
 
-    /* Respond back */
-    na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
-        hg_core_handle->na_context, hg_core_send_output_cb, hg_core_handle,
-        hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_used,
-        hg_core_handle->out_buf_plugin_data,
-        hg_core_handle->core_handle.info.addr->na_addr,
-        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
-        &hg_core_handle->na_send_op_id);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not post send for output buffer");
-        ret = HG_NA_ERROR;
-        goto done;
+    /* Post expected send (output) */
+    do {
+        na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
+            hg_core_handle->na_context, hg_core_send_output_cb, hg_core_handle,
+            hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_used,
+            hg_core_handle->out_buf_plugin_data,
+            hg_core_handle->core_handle.info.addr->na_addr,
+            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
+            &hg_core_handle->na_send_op_id);
+        if (na_ret != NA_AGAIN || retry_cnt++ > HG_CORE_MAX_AGAIN_RETRY)
+            break;
+
+        /* Attempt to make progress on NA with timeout of 0 */
+        na_ret = NA_Progress(hg_core_handle->na_class,
+            hg_core_handle->na_context, 0);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, error,
+            ret, (hg_return_t) na_ret, "Could not make progress on NA (%s)",
+            NA_Error_to_string(na_ret));
+    } while (1);
+    /* Expected sends should always succeed after retry */
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not post send for output buffer (%s)",
+        NA_Error_to_string(na_ret));
+
+    return ret;
+
+error:
+    if (ack_recv_posted) {
+        /* Cancel the above posted recv ack op */
+        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
+            hg_core_handle->na_ack_op_id);
+        HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
+            "Could not cancel ack op id (%s)", NA_Error_to_string(na_ret));
+    }
+    if (hg_core_handle->ack_buf) {
+        na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
+            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
+        HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
+            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
+        hg_core_handle->ack_buf = NULL;
+        hg_core_handle->ack_buf_plugin_data = NULL;
     }
 
-done:
     return ret;
 }
 
@@ -2182,10 +2153,7 @@ hg_core_no_respond_na(struct hg_core_private_handle *hg_core_handle)
     hg_core_handle->op_type = HG_CORE_NO_RESPOND;
 
     ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
     return ret;
@@ -2197,27 +2165,20 @@ hg_core_send_input_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
-    if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
+    /* If canceled, mark handle as canceled */
+    if (callback_info->ret == NA_CANCELED)
         hg_core_handle->ret = HG_CANCELED;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_send_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Error in NA callback");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2230,103 +2191,77 @@ hg_core_recv_input_cb(const struct na_cb_info *callback_info)
     const struct na_cb_info_recv_unexpected *na_cb_info_recv_unexpected =
         &callback_info->info.recv_unexpected;
 #ifndef HG_HAS_POST_LIMIT
-    hg_bool_t pending_empty = NA_FALSE;
-# ifdef HG_HAS_SM_ROUTING
-    hg_bool_t sm_pending_empty = NA_FALSE;
-# endif
+    hg_bool_t pending_empty = HG_FALSE;
+    hg_bool_t use_sm = HG_FALSE;
 #endif
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
+    /* Remove handle from pending list */
+    hg_thread_spin_lock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+    HG_LIST_REMOVE(hg_core_handle, pending);
+    hg_thread_spin_unlock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+
+    /* If canceled, mark handle as canceled */
     if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
         /* Only decrement refcount and exit */
         hg_core_destroy(hg_core_handle);
         goto done;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    } else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* Fill unexpected info */
     hg_core_handle->core_handle.info.addr->na_addr =
         na_cb_info_recv_unexpected->source;
     hg_core_handle->tag = na_cb_info_recv_unexpected->tag;
-    if (na_cb_info_recv_unexpected->actual_buf_size >
-    hg_core_handle->core_handle.in_buf_size) {
-        HG_LOG_ERROR("Actual transfer size is too large for unexpected recv");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(na_cb_info_recv_unexpected->actual_buf_size >
+        hg_core_handle->core_handle.in_buf_size, done,
+        "Actual transfer size is too large for unexpected recv");
     hg_core_handle->in_buf_used = na_cb_info_recv_unexpected->actual_buf_size;
 
-    /* Remove handle from pending list */
-#ifdef HG_HAS_SM_ROUTING
-    if (hg_core_handle->na_class ==
-        hg_core_handle->core_handle.info.core_class->na_sm_class) {
-        hg_thread_spin_lock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
-        HG_LIST_REMOVE(hg_core_handle, pending);
-# ifndef HG_HAS_POST_LIMIT
-        sm_pending_empty = HG_LIST_IS_EMPTY(
+#ifndef HG_HAS_POST_LIMIT
+    /* Check if we need more handles */
+    hg_thread_spin_lock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+
+# ifdef HG_HAS_SM_ROUTING
+    if (hg_core_handle->na_class
+        == hg_core_handle->core_handle.info.core_class->na_sm_class) {
+        pending_empty =  HG_LIST_IS_EMPTY(
             &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list);
+        use_sm = HG_TRUE;
+    } else
 # endif
-        hg_thread_spin_unlock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
-    } else {
-#endif
-        hg_thread_spin_lock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
-        HG_LIST_REMOVE(hg_core_handle, pending);
-#ifndef HG_HAS_POST_LIMIT
         pending_empty = HG_LIST_IS_EMPTY(
             &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list);
-#endif
-        hg_thread_spin_unlock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
-#ifdef HG_HAS_SM_ROUTING
-    }
-#endif
 
-#ifndef HG_HAS_POST_LIMIT
-    /* If pending list is empty, post more handles */
-    if (pending_empty
-        && hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
-        HG_CORE_PENDING_INCR, hg_core_handle->repost, HG_FALSE) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not post additional handles");
-        goto done;
-    }
-# ifdef HG_HAS_SM_ROUTING
+    hg_thread_spin_unlock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+
     /* If pending list is empty, post more handles */
-    if (sm_pending_empty
-        && hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
-        HG_CORE_PENDING_INCR, hg_core_handle->repost, HG_TRUE) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not post additional SM handles");
-        goto done;
+    if (pending_empty) {
+        ret = hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
+            HG_CORE_PENDING_INCR, hg_core_handle->repost, use_sm);
+        HG_CHECK_HG_ERROR(done, ret, "Could not post additional handles");
     }
-# endif
 #endif
 
     /* Set operation type for trigger */
     hg_core_handle->op_type = HG_CORE_PROCESS;
 
     /* Process input information */
-    if (hg_core_process_input(hg_core_handle, &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process input");
-        goto done;
-    }
+    ret = hg_core_process_input(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not process input");
 
     /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_recv_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2345,10 +2280,7 @@ hg_core_process_input(struct hg_core_private_handle *hg_core_handle,
     /* Get and verify input header */
     ret = hg_core_proc_header_request(&hg_core_handle->core_handle,
         &hg_core_handle->in_header, HG_DECODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get request header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get request header");
 
     /* Get operation ID from header */
     hg_core_handle->core_handle.info.id =
@@ -2372,21 +2304,17 @@ hg_core_process_input(struct hg_core_private_handle *hg_core_handle,
 
     /* Must let upper layer get extra payload if HG_CORE_MORE_DATA is set */
     if (hg_core_handle->in_header.msg.request.flags & HG_CORE_MORE_DATA) {
-        if (!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire) {
-            HG_LOG_ERROR("No callback defined for acquiring more data");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire,
+            done, ret, HG_OPNOTSUPPORTED,
+            "No callback defined for acquiring more data");
 #ifdef HG_HAS_COLLECT_STATS
         /* Increment counter */
         hg_core_stat_incr(&hg_core_rpc_extra_count_g);
 #endif
         ret = HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire(
             (hg_core_handle_t) hg_core_handle, HG_INPUT, hg_core_complete);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Error in HG core handle more data acquire callback");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret,
+            "Error in HG core handle more data acquire callback");
         *completed = HG_FALSE;
     } else
         *completed = HG_TRUE;
@@ -2401,28 +2329,21 @@ hg_core_send_output_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
-    if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
+    /* If canceled, mark handle as canceled */
+    if (callback_info->ret == NA_CANCELED)
         hg_core_handle->ret = HG_CANCELED;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_send_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2432,36 +2353,35 @@ hg_core_recv_output_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
+    /* If canceled, mark handle as canceled */
     if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+
+        /* Do not add handle to completion queue if it was not posted */
+        if (hg_atomic_get32(&hg_core_handle->posted))
+            goto complete;
+        else {
+            /* Cancelation has been processed */
+            hg_atomic_set32(&hg_core_handle->canceling, HG_FALSE);
+            goto done;
+        }
+    } else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* Process output information */
-    if (hg_core_handle->ret != HG_CANCELED
-        && hg_core_process_output(hg_core_handle, &completed, hg_core_send_ack)
-            != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process output");
-        goto done;
-    }
+    ret = hg_core_process_output(hg_core_handle, &completed, hg_core_send_ack);
+    HG_CHECK_HG_ERROR(done, ret, "Could not process output");
 
+complete:
     /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_recv_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2474,11 +2394,9 @@ hg_core_process_output(struct hg_core_private_handle *hg_core_handle,
     hg_return_t ret = HG_SUCCESS;
 
     /* Get and verify output header */
-    if (hg_core_proc_header_response(&hg_core_handle->core_handle,
-        &hg_core_handle->out_header, HG_DECODE) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not decode header");
-        goto done;
-    }
+    ret= hg_core_proc_header_response(&hg_core_handle->core_handle,
+        &hg_core_handle->out_header, HG_DECODE);
+    HG_CHECK_HG_ERROR(done, ret, "Could not decode header");
 
     /* Get return code from header */
     hg_core_handle->ret =
@@ -2488,17 +2406,14 @@ hg_core_process_output(struct hg_core_private_handle *hg_core_handle,
 
     /* Must let upper layer get extra payload if HG_CORE_MORE_DATA is set */
     if (hg_core_handle->out_header.msg.response.flags & HG_CORE_MORE_DATA) {
-        if (!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire) {
-            HG_LOG_ERROR("No callback defined for acquiring more data");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire,
+            done, ret, HG_OPNOTSUPPORTED,
+            "No callback defined for acquiring more data");
+
         ret = HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire(
             (hg_core_handle_t) hg_core_handle, HG_OUTPUT, done_callback);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Error in HG core handle more data acquire callback");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret,
+            "Error in HG core handle more data acquire callback");
         *completed = HG_FALSE;
     } else
         *completed = HG_TRUE;
@@ -2515,6 +2430,7 @@ hg_core_send_ack(hg_core_handle_t handle)
         (struct hg_core_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
+    int retry_cnt = 0;
 
     /* Increment number of expected NA operations */
     hg_core_handle->na_op_count++;
@@ -2522,29 +2438,48 @@ hg_core_send_ack(hg_core_handle_t handle)
     /* Allocate buffer for ack */
     hg_core_handle->ack_buf = NA_Msg_buf_alloc(hg_core_handle->na_class,
         sizeof(hg_uint8_t), &hg_core_handle->ack_buf_plugin_data);
-    if (!hg_core_handle->ack_buf) {
-        HG_LOG_ERROR("Could not allocate buffer for ack");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
-    NA_Msg_init_expected(hg_core_handle->na_class, hg_core_handle->ack_buf,
-        sizeof(hg_uint8_t));
-
-    /* Pre-post the recv message (output) if response is expected */
-    na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
-        hg_core_handle->na_context, hg_core_send_ack_cb, hg_core_handle,
-        hg_core_handle->ack_buf, sizeof(hg_uint8_t),
-        hg_core_handle->ack_buf_plugin_data,
-        hg_core_handle->core_handle.info.addr->na_addr,
-        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
-        &hg_core_handle->na_ack_op_id);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not post send for ack buffer");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->ack_buf == NULL, error, ret, HG_NA_ERROR,
+        "Could not allocate buffer for ack");
 
-done:
+    na_ret = NA_Msg_init_expected(hg_core_handle->na_class,
+        hg_core_handle->ack_buf, sizeof(hg_uint8_t));
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not initialize ack buffer (%s)", NA_Error_to_string(na_ret));
+
+    /* Post expected send (ack) */
+    do {
+        na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
+            hg_core_handle->na_context, hg_core_send_ack_cb, hg_core_handle,
+            hg_core_handle->ack_buf, sizeof(hg_uint8_t),
+            hg_core_handle->ack_buf_plugin_data,
+            hg_core_handle->core_handle.info.addr->na_addr,
+            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
+            &hg_core_handle->na_ack_op_id);
+        if (na_ret != NA_AGAIN || retry_cnt++ > HG_CORE_MAX_AGAIN_RETRY)
+            break;
+
+        /* Attempt to make progress on NA with timeout of 0 */
+        na_ret = NA_Progress(hg_core_handle->na_class,
+            hg_core_handle->na_context, 0);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, error,
+            ret, (hg_return_t) na_ret, "Could not make progress on NA (%s)",
+            NA_Error_to_string(na_ret));
+    } while (1);
+    /* Expected sends should always succeed after retry */
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not post send for ack buffer (%s)", NA_Error_to_string(na_ret));
+
+    return ret;
+
+error:
+    if (hg_core_handle->ack_buf) {
+        na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
+            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
+        HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
+            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
+        hg_core_handle->ack_buf = NULL;
+        hg_core_handle->ack_buf_plugin_data = NULL;
+    }
     return ret;
 }
 
@@ -2554,28 +2489,21 @@ hg_core_send_ack_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
-    if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
+    /* If canceled, mark handle as canceled */
+    if (callback_info->ret == NA_CANCELED)
         hg_core_handle->ret = HG_CANCELED;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_ack_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2585,28 +2513,21 @@ hg_core_recv_ack_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
-    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
+    hg_return_t ret;
 
-    if (callback_info->ret == NA_CANCELED) {
-        /* If canceled, mark handle as canceled */
+    /* If canceled, mark handle as canceled */
+    if (callback_info->ret == NA_CANCELED)
         hg_core_handle->ret = HG_CANCELED;
-    } else if (callback_info->ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Error in NA callback");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    else
+        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
+            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
 
     /* Complete operation */
-    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_ack_op_id,
-        &completed) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
-        na_ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    ret = hg_core_complete_na(hg_core_handle, &completed);
+    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
 
 done:
-    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2640,15 +2561,12 @@ hg_core_self_cb(const struct hg_core_cb_info *callback_info)
 
     /* Process output */
     ret = hg_core_process_output(hg_core_handle, &completed, hg_core_complete);
-    if (ret != HG_SUCCESS) {
-       HG_LOG_ERROR("Could not process output");
-       goto done;
-   }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process output");
 
     /* Mark as completed */
-    if (completed
-        && hg_core_complete((hg_core_handle_t) hg_core_handle) != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not complete operation");
+    if (completed) {
+        ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
+        HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
     }
 
 done:
@@ -2667,18 +2585,12 @@ hg_core_process_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Process input */
     ret = hg_core_process_input(hg_core_handle, &completed);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not process input");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not process input");
 
     /* Mark as completed */
     if (completed) {
         ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
     }
 
 done:
@@ -2701,15 +2613,12 @@ hg_core_process(struct hg_core_private_handle *hg_core_handle)
     hg_thread_spin_unlock(&HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map_lock);
     if (!hg_core_rpc_info) {
         HG_LOG_WARNING("Could not find RPC ID in function map");
-        ret = HG_NO_MATCH;
+        ret = HG_NOENTRY;
         goto done;
     }
 
-    if (!hg_core_rpc_info->rpc_cb) {
-        HG_LOG_ERROR("No RPC callback registered");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_rpc_info->rpc_cb == NULL, done, ret,
+        HG_INVALID_ARG, "No RPC callback registered");
 
     /* Cache RPC info */
     hg_core_handle->core_handle.rpc_info = hg_core_rpc_info;
@@ -2720,10 +2629,7 @@ hg_core_process(struct hg_core_private_handle *hg_core_handle)
 
     /* Execute RPC callback */
     ret = hg_core_rpc_info->rpc_cb((hg_core_handle_t) hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Error while executing RPC callback");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Error while executing RPC callback");
 
 done:
     return ret;
@@ -2732,22 +2638,17 @@ done:
 /*---------------------------------------------------------------------------*/
 static HG_INLINE hg_return_t
 hg_core_complete_na(struct hg_core_private_handle *hg_core_handle,
-    na_op_id_t *op_id, hg_bool_t *completed)
+    hg_bool_t *completed)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    /* Reset op ID value */
-    if (!hg_core_handle->na_op_id_mine)
-        *op_id = NA_OP_ID_NULL;
-
     /* Add handle to completion queue when expected operations have completed */
     if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
         == (hg_util_int32_t) hg_core_handle->na_op_count && *completed) {
         /* Mark as completed */
-        if (hg_core_complete((hg_core_handle_t) hg_core_handle) != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not complete operation");
-            goto done;
-        }
+        ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
+        HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
+
         /* Increment number of entries added to completion queue */
         *completed = HG_TRUE;
     } else
@@ -2773,10 +2674,8 @@ hg_core_complete(hg_core_handle_t handle)
 
     ret = hg_core_completion_add(context, hg_completion_entry,
         hg_core_handle->is_self);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not add HG completion entry to completion queue");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret,
+        "Could not add HG completion entry to completion queue");
 
 done:
     return ret;
@@ -2817,15 +2716,16 @@ hg_core_completion_add(struct hg_core_context *context,
 
 #ifdef HG_HAS_SELF_FORWARD
     /* TODO could prevent from self notifying if hg_poll_wait() not entered */
-    if (self_notify && private_context->completion_queue_notify
-        && hg_event_set(private_context->completion_queue_notify) != HG_UTIL_SUCCESS) {
-        HG_LOG_ERROR("Could not signal completion queue");
-        ret = HG_PROTOCOL_ERROR;
+    if (self_notify && private_context->completion_queue_notify) {
+        int rc = hg_event_set(private_context->completion_queue_notify);
+        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_FAULT,
+            "Could not signal completion queue");
     }
 #else
     (void) self_notify;
 #endif
 
+done:
     return ret;
 }
 
@@ -2843,32 +2743,27 @@ hg_core_context_post(struct hg_core_private_context *context,
         struct hg_core_private_addr *hg_core_addr = NULL;
 
         /* Create a new handle */
+        // TODO
         hg_core_handle = hg_core_create(context, use_sm);
-        if (!hg_core_handle) {
-            HG_LOG_ERROR("Could not create HG core handle");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_core_handle == NULL, error, ret, HG_NOMEM,
+            "Could not create HG core handle");
 
         /* Execute class callback on handle, this allows upper layers to
          * allocate private data on handle creation */
         if (context->handle_create) {
             ret = context->handle_create((hg_core_handle_t) hg_core_handle,
                 context->handle_create_arg);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Error in HG core handle create callback");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(error, ret,
+                "Error in HG core handle create callback");
         }
 
         /* Create internal addresses */
+        // TODO
         hg_core_addr = hg_core_addr_create(HG_CORE_CONTEXT_CLASS(context),
             hg_core_handle->na_class);
-        if (!hg_core_addr) {
-            HG_LOG_ERROR("Could not create HG addr");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_core_addr == NULL, error, ret, HG_NOMEM,
+            "Could not create HG addr");
+
         /* To safely repost handle and prevent externally referenced address */
         hg_core_addr->is_mine = HG_TRUE;
         hg_core_handle->core_handle.info.addr = (hg_core_addr_t) hg_core_addr;
@@ -2877,13 +2772,13 @@ hg_core_context_post(struct hg_core_private_context *context,
         hg_core_handle->repost = repost;
 
         ret = hg_core_post(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Cannot post handle");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Cannot post handle");
     }
 
-done:
+    return ret;
+
+error:
+    /* TODO */
     return ret;
 }
 
@@ -2901,12 +2796,12 @@ hg_core_post(struct hg_core_private_handle *hg_core_handle)
     if (hg_core_handle->na_class ==
         hg_core_handle->core_handle.info.core_class->na_sm_class) {
         hg_thread_spin_lock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
         HG_LIST_INSERT_HEAD(
             &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list,
             hg_core_handle, pending);
         hg_thread_spin_unlock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
     } else {
 #endif
         hg_thread_spin_lock(
@@ -2926,13 +2821,19 @@ hg_core_post(struct hg_core_private_handle *hg_core_handle)
         hg_core_handle->core_handle.in_buf,
         hg_core_handle->core_handle.in_buf_size,
         hg_core_handle->in_buf_plugin_data, &hg_core_handle->na_recv_op_id);
-    if (na_ret != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not post unexpected recv for input buffer");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
+        "Could not post unexpected recv for input buffer (%s)",
+        NA_Error_to_string(na_ret));
 
-done:
+    return ret;
+
+error:
+    hg_thread_spin_lock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+    HG_LIST_REMOVE(hg_core_handle, pending);
+    hg_thread_spin_unlock(
+        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+    hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
     return ret;
 }
 
@@ -2954,10 +2855,7 @@ hg_core_reset_post(struct hg_core_private_handle *hg_core_handle)
 
     /* Safe to repost */
     ret = hg_core_post(hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Cannot post handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Cannot post handle");
 
 done:
     return ret;
@@ -2972,15 +2870,13 @@ hg_core_completion_queue_notify_cb(void *arg,
     struct hg_core_private_context *context =
         (struct hg_core_private_context *) arg;
     hg_util_bool_t notified = HG_UTIL_FALSE;
-    int ret = HG_UTIL_SUCCESS;
+    int rc = HG_UTIL_SUCCESS;
 
     /* TODO could prevent from self notifying if hg_poll_wait() not entered */
-    if (hg_event_get(context->completion_queue_notify,
-        &notified) != HG_UTIL_SUCCESS) {
-        HG_LOG_ERROR("Could not get completion notification");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_event_get(context->completion_queue_notify, &notified);
+    HG_CHECK_ERROR_NORET(rc != HG_UTIL_SUCCESS, done,
+        "Could not get completion notification");
+
     if (notified || !hg_atomic_queue_is_empty(context->completion_queue)
         || hg_atomic_get32(&context->backfill_queue_count)) {
         *progressed = HG_UTIL_TRUE; /* Progressed */
@@ -2990,7 +2886,7 @@ hg_core_completion_queue_notify_cb(void *arg,
     *progressed = HG_UTIL_FALSE;
 
 done:
-    return ret;
+    return rc;
 }
 #endif
 
@@ -3002,24 +2898,21 @@ hg_core_progress_na_cb(void *arg, int HG_UNUSED error,
     struct hg_core_private_context *context =
         (struct hg_core_private_context *) arg;
      unsigned int actual_count = 0;
-    na_return_t na_ret;
     unsigned int completed_count = 0;
     int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
-    int ret = HG_UTIL_SUCCESS;
+    int rc = HG_UTIL_SUCCESS;
+    na_return_t na_ret;
 
     /* Check progress on NA (no need to call try_wait here) */
     na_ret = NA_Progress(HG_CORE_CONTEXT_CLASS(context)->core_class.na_class,
         context->core_context.na_context, 0);
-    if (na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT) {
-        HG_LOG_ERROR("Could not make progress on NA");
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-    if (na_ret != NA_SUCCESS) {
+    if (na_ret == NA_TIMEOUT) {
         /* Nothing progressed */
         *progressed = HG_UTIL_FALSE;
         goto done;
-    }
+    } else
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, rc, HG_UTIL_FAIL,
+            "Could not make progress on NA (%s)", NA_Error_to_string(na_ret));
 
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
@@ -3033,6 +2926,9 @@ hg_core_progress_na_cb(void *arg, int HG_UNUSED error,
         for (i = 0; i < actual_count; i++)
             completed_count += (unsigned int) cb_ret[i];
     } while ((na_ret == NA_SUCCESS) && actual_count);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, rc,
+        HG_UTIL_FAIL, "Could not trigger NA callback (%s)",
+        NA_Error_to_string(na_ret));
 
     /* We can't only verify that the completion queue is not empty, we need
      * to check what was added to the completion queue, as the completion queue
@@ -3047,7 +2943,7 @@ hg_core_progress_na_cb(void *arg, int HG_UNUSED error,
     *progressed = HG_UTIL_TRUE;
 
 done:
-    return ret;
+    return rc;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3059,24 +2955,22 @@ hg_core_progress_na_sm_cb(void *arg, int HG_UNUSED error,
     struct hg_core_private_context *context =
         (struct hg_core_private_context *) arg;
     unsigned int actual_count = 0;
-    na_return_t na_ret;
     unsigned int completed_count = 0;
     int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
-    int ret = HG_UTIL_SUCCESS;
+    int rc = HG_UTIL_SUCCESS;
+    na_return_t na_ret;
 
     /* Check progress on NA SM (no need to call try_wait here) */
     na_ret = NA_Progress(HG_CORE_CONTEXT_CLASS(context)->core_class.na_sm_class,
         context->core_context.na_sm_context, 0);
-    if (na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT) {
-        HG_LOG_ERROR("Could not make progress on NA SM");
-        ret = HG_UTIL_FAIL;
-        goto done;
-    }
-    if (na_ret != NA_SUCCESS) {
+    if (na_ret == NA_TIMEOUT) {
         /* Nothing progressed */
         *progressed = HG_UTIL_FALSE;
         goto done;
-    }
+    } else
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, rc, HG_UTIL_FAIL,
+            "Could not make progress on NA SM (%s)",
+            NA_Error_to_string(na_ret));
 
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
@@ -3090,6 +2984,9 @@ hg_core_progress_na_sm_cb(void *arg, int HG_UNUSED error,
         for (i = 0; i < actual_count; i++)
             completed_count += (unsigned int)cb_ret[i];
     } while ((na_ret == NA_SUCCESS) && actual_count);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, rc,
+        HG_UTIL_FAIL, "Could not trigger NA SM callback (%s)",
+        NA_Error_to_string(na_ret));
 
     /* We can't only verify that the completion queue is not empty, we need
      * to check what was added to the completion queue, as the completion queue
@@ -3104,7 +3001,7 @@ hg_core_progress_na_sm_cb(void *arg, int HG_UNUSED error,
     *progressed = HG_UTIL_TRUE;
 
 done:
-    return ret;
+    return rc;
 }
 #endif
 
@@ -3120,9 +3017,8 @@ hg_core_progress_na(struct hg_core_private_context *context,
     if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
-    } else {
+    } else
         remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
-    }
 
     for (;;) {
         unsigned int actual_count = 0;
@@ -3144,6 +3040,9 @@ hg_core_progress_na(struct hg_core_private_context *context,
             for (i = 0; i < actual_count; i++)
                 completed_count += (unsigned int)cb_ret[i];
         } while ((na_ret == NA_SUCCESS) && actual_count);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
+            (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
+            NA_Error_to_string(na_ret));
 
         /* We can't only verify that the completion queue is not empty, we need
          * to check what was added to the completion queue, as the completion
@@ -3179,16 +3078,14 @@ hg_core_progress_na(struct hg_core_private_context *context,
             remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
         }
 
-        if (na_ret == NA_SUCCESS) {
-            /* Trigger NA callbacks and check whether we completed something */
+        /* Trigger NA callbacks and check whether we completed something */
+        if (na_ret == NA_SUCCESS)
             continue;
-        } else if (na_ret == NA_TIMEOUT) {
+        else if (na_ret == NA_TIMEOUT)
             break;
-        } else {
-            HG_LOG_ERROR("Could not make NA Progress");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        else
+            HG_GOTO_ERROR(done, ret, (hg_return_t) na_ret,
+                "Could not make NA Progress (%s)", NA_Error_to_string(na_ret));
     }
 
 done:
@@ -3245,17 +3142,16 @@ hg_core_progress_poll(struct hg_core_private_context *context,
     do {
         hg_time_t t1, t2;
         hg_util_bool_t progressed;
+        int rc;
 
         if (timeout)
             hg_time_get_current(&t1);
 
         /* Will call hg_core_poll_try_wait_cb if timeout is not 0 */
-        if (hg_poll_wait(context->poll_set, (unsigned int)(remaining * 1000.0),
-            &progressed) != HG_UTIL_SUCCESS) {
-            HG_LOG_ERROR("hg_poll_wait() failed");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_poll_wait(context->poll_set, (unsigned int)(remaining * 1000.0),
+            &progressed);
+        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_PROTOCOL_ERROR,
+            "hg_poll_wait() failed");
 
         /* We progressed, return success */
         if (progressed) {
@@ -3345,50 +3241,42 @@ hg_core_trigger(struct hg_core_private_context *context, unsigned int timeout,
         }
 
         /* Completion queue should not be empty now */
-        if (!hg_completion_entry) {
-            HG_LOG_ERROR("NULL completion entry");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_completion_entry == NULL, done, ret,
+            HG_FAULT, "NULL completion entry");
 
         /* Trigger entry */
         switch(hg_completion_entry->op_type) {
             case HG_ADDR:
                 ret = hg_core_trigger_lookup_entry(
                     hg_completion_entry->op_id.hg_core_op_id);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not trigger completion entry");
-                    goto done;
-                }
+                HG_CHECK_HG_ERROR(done, ret,
+                    "Could not trigger addr completion entry");
                 break;
             case HG_RPC:
                 ret = hg_core_trigger_entry((struct hg_core_private_handle *)
                     hg_completion_entry->op_id.hg_core_handle);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not trigger completion entry");
-                    goto done;
-                }
+                HG_CHECK_HG_ERROR(done, ret,
+                    "Could not trigger RPC completion entry");
                 break;
             case HG_BULK:
                 ret = hg_bulk_trigger_entry(
                     hg_completion_entry->op_id.hg_bulk_op_id);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not trigger completion entry");
-                    goto done;
-                }
+                HG_CHECK_HG_ERROR(done, ret,
+                    "Could not trigger bulk completion entry");
                 break;
             default:
-                HG_LOG_ERROR("Invalid type of completion entry");
-                ret = HG_PROTOCOL_ERROR;
-                goto done;
+                HG_GOTO_ERROR(done, ret, HG_INVALID_ARG,
+                    "Invalid type of completion entry (%d)",
+                    (int) hg_completion_entry->op_type);
         }
 
         count++;
     }
 
-done:
-    if ((ret == HG_SUCCESS || ret == HG_TIMEOUT) && actual_count)
+    if (actual_count)
         *actual_count = count;
+
+done:
     return ret;
 }
 
@@ -3398,6 +3286,15 @@ hg_core_trigger_lookup_entry(struct hg_core_op_id *hg_core_op_id)
 {
     hg_return_t ret = HG_SUCCESS;
 
+    /* Free op */
+    if (hg_core_op_id->info.lookup.na_lookup_op_id != NA_OP_ID_NULL) {
+        na_return_t na_ret = NA_Op_destroy(
+            hg_core_op_id->info.lookup.hg_core_addr->core_addr.na_class,
+            hg_core_op_id->info.lookup.na_lookup_op_id);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not destroy addr op ID (%s)", NA_Error_to_string(na_ret));
+    }
+
     /* Execute callback */
     if (hg_core_op_id->callback) {
         struct hg_core_cb_info hg_core_cb_info;
@@ -3411,7 +3308,7 @@ hg_core_trigger_lookup_entry(struct hg_core_op_id *hg_core_op_id)
         hg_core_op_id->callback(&hg_core_cb_info);
     }
 
-    /* Free op */
+done:
     free(hg_core_op_id);
     return ret;
 }
@@ -3436,19 +3333,13 @@ hg_core_trigger_entry(struct hg_core_private_handle *hg_core_handle)
             hg_core_handle->ret = ret;
             ret = HG_Core_respond((hg_core_handle_t) hg_core_handle, NULL, NULL,
                 0, header_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not respond");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(done, ret, "Could not respond");
         }
 
         /* No response callback */
         if (hg_core_handle->no_response) {
             ret = hg_core_handle->no_respond(hg_core_handle);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not complete handle");
-                goto done;
-            }
+            HG_CHECK_HG_ERROR(done, ret, "Could not complete handle");
         }
     } else {
         hg_core_cb_t hg_cb = NULL;
@@ -3491,9 +3382,8 @@ hg_core_trigger_entry(struct hg_core_private_handle *hg_core_handle)
                 break;
             case HG_CORE_PROCESS:
             default:
-                HG_LOG_ERROR("Invalid core operation type");
-                ret = HG_PROTOCOL_ERROR;
-                goto done;
+                HG_GOTO_ERROR(done, ret, HG_OPNOTSUPPORTED,
+                    "Invalid core operation type");
         }
 
         /* Execute user callback */
@@ -3506,10 +3396,7 @@ hg_core_trigger_entry(struct hg_core_private_handle *hg_core_handle)
         && !HG_CORE_HANDLE_CONTEXT(hg_core_handle)->finalizing) {
         /* Repost handle */
         ret = hg_core_reset_post(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Cannot repost handle");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Cannot repost handle");
     } else
         hg_core_destroy(hg_core_handle);
 
@@ -3523,54 +3410,30 @@ hg_core_cancel(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (hg_core_handle->is_self) {
-        HG_LOG_ERROR("Local cancelation is not supported");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->is_self, done, ret, HG_OPNOTSUPPORTED,
+        "Local cancellation is not supported");
 
     /* Cancel all NA operations issued */
     if (hg_core_handle->na_recv_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret;
-
-        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-            hg_core_handle->na_recv_op_id);
-        if (na_ret == NA_CANCEL_ERROR)
-            ret = HG_CANCEL_ERROR;
-        else if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel recv op id");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        na_return_t na_ret = NA_Cancel(hg_core_handle->na_class,
+            hg_core_handle->na_context, hg_core_handle->na_recv_op_id);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not cancel recv op id (%s)", NA_Error_to_string(na_ret));
     }
 
     if (hg_core_handle->na_send_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret;
-
-        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-            hg_core_handle->na_send_op_id);
-        if (na_ret == NA_CANCEL_ERROR)
-            ret = HG_CANCEL_ERROR;
-        else if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel send op id");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        na_return_t na_ret = NA_Cancel(hg_core_handle->na_class,
+            hg_core_handle->na_context, hg_core_handle->na_send_op_id);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not cancel send op id (%s)", NA_Error_to_string(na_ret));
     }
 
-    /* TODO
     if (hg_core_handle->na_ack_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret;
-
-        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-            hg_core_handle->na_ack_op_id);
-        if (na_ret != NA_SUCCESS) {
-            HG_LOG_ERROR("Could not cancel ack op id");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        na_return_t na_ret = NA_Cancel(hg_core_handle->na_class,
+            hg_core_handle->na_context, hg_core_handle->na_ack_op_id);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not cancel ack op id (%s)", NA_Error_to_string(na_ret));
     }
-    */
 
 done:
     return ret;
@@ -3589,19 +3452,12 @@ HG_Core_init_opt(const char *na_info_string, hg_bool_t na_listen,
     const struct hg_init_info *hg_init_info)
 {
     struct hg_core_private_class *hg_core_class = NULL;
-    hg_return_t ret = HG_SUCCESS;
 
     hg_core_class = hg_core_init(na_info_string, na_listen, hg_init_info);
-    if (!hg_core_class) {
-        HG_LOG_ERROR("Cannot initialize HG core layer");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_class == NULL, done,
+        "Cannot initialize HG core layer");
 
 done:
-    if (ret != HG_SUCCESS) {
-        /* Nothing */
-    }
     return (hg_core_class_t *) hg_core_class;
 }
 
@@ -3609,13 +3465,10 @@ done:
 hg_return_t
 HG_Core_finalize(hg_core_class_t *hg_core_class)
 {
-    hg_return_t ret = HG_SUCCESS;
+    hg_return_t ret;
 
     ret = hg_core_finalize((struct hg_core_private_class *) hg_core_class);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Cannot finalize HG core layer");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Cannot finalize HG core layer");
 
 done:
     return ret;
@@ -3639,11 +3492,8 @@ HG_Core_set_more_data_callback(struct hg_core_class *hg_core_class,
         (struct hg_core_private_class *) hg_core_class;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
 
     private_class->more_data_acquire = more_data_acquire_callback;
     private_class->more_data_release = more_data_release_callback;
@@ -3663,35 +3513,26 @@ HG_Core_context_create(hg_core_class_t *hg_core_class)
 hg_core_context_t *
 HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
 {
-    hg_return_t ret = HG_SUCCESS;
     struct hg_core_private_context *context = NULL;
     int na_poll_fd;
 #ifdef HG_HAS_SELF_FORWARD
     int fd;
 #endif
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_class == NULL, error, "NULL HG core class");
 
     context = (struct hg_core_private_context *) malloc(
         sizeof(struct hg_core_private_context));
-    if (!context) {
-        HG_LOG_ERROR("Could not allocate HG context");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(context == NULL, error,
+        "Could not allocate HG context");
+
     memset(context, 0, sizeof(struct hg_core_private_context));
     context->core_context.core_class = hg_core_class;
     context->completion_queue =
         hg_atomic_queue_alloc(HG_CORE_ATOMIC_QUEUE_SIZE);
-    if (!context->completion_queue) {
-        HG_LOG_ERROR("Could not allocate queue");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(context->completion_queue == NULL, error,
+        "Could not allocate queue");
+
     HG_QUEUE_INIT(&context->backfill_queue);
     hg_atomic_init32(&context->backfill_queue_count, 0);
     HG_LIST_INIT(&context->pending_list);
@@ -3709,46 +3550,31 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
     hg_atomic_init32(&context->trigger_waiting, 0);
 
     hg_thread_spin_init(&context->pending_list_lock);
-#ifdef HG_HAS_SM_ROUTING
-    hg_thread_spin_init(&context->sm_pending_list_lock);
-#endif
     hg_thread_spin_init(&context->created_list_lock);
 
     context->core_context.na_context = NA_Context_create_id(
         hg_core_class->na_class, id);
-    if (!context->core_context.na_context) {
-        HG_LOG_ERROR("Could not create NA context");
-        ret = HG_NA_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(context->core_context.na_context == NULL, error,
+        "Could not create NA context");
+
 #ifdef HG_HAS_SM_ROUTING
     if (hg_core_class->na_sm_class) {
         context->core_context.na_sm_context = NA_Context_create(
             hg_core_class->na_sm_class);
-        if (!context->core_context.na_sm_context) {
-            HG_LOG_ERROR("Could not create NA SM context");
-            ret = HG_NA_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR_NORET(context->core_context.na_sm_context == NULL, error,
+            "Could not create NA SM context");
     }
 #endif
 
     /* Create poll set */
     context->poll_set = hg_poll_create();
-    if (!context->poll_set) {
-        HG_LOG_ERROR("Could not create poll set");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(context->poll_set == NULL, error,
+        "Could not create poll set");
 
 #ifdef HG_HAS_SELF_FORWARD
     /* Create event for completion queue notification */
     fd = hg_event_create();
-    if (fd < 0) {
-        HG_LOG_ERROR("Could not create event");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(fd < 0, error, "Could not create event");
     context->completion_queue_notify = fd;
 
     /* Add event to context poll set */
@@ -3776,22 +3602,17 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
 #ifdef HG_HAS_SM_ROUTING
     /* Auto SM requires hg_core_progress_poll */
     if (context->core_context.na_sm_context) {
-        if (context->progress != hg_core_progress_poll) {
-            HG_LOG_ERROR("Auto SM mode not supported with selected plugin");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR_NORET(context->progress != hg_core_progress_poll, error,
+            "Auto SM mode not supported with selected plugin");
+
         if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
             /* Force to use progress poll */
             na_poll_fd = 0;
         else {
             na_poll_fd = NA_Poll_get_fd(hg_core_class->na_sm_class,
                 context->core_context.na_sm_context);
-            if (na_poll_fd < 0) {
-                HG_LOG_ERROR("Could not get NA SM poll fd");
-                ret = HG_NA_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR_NORET(na_poll_fd < 0, error,
+                "Could not get NA SM poll fd");
         }
         hg_poll_add(context->poll_set, na_poll_fd, HG_POLLIN,
             hg_core_progress_na_sm_cb, context);
@@ -3804,12 +3625,11 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
     /* Increment context count of parent class */
     hg_atomic_incr32(&HG_CORE_CONTEXT_CLASS(context)->n_contexts);
 
-done:
-    if (ret != HG_SUCCESS && context) {
-        HG_Core_context_destroy((hg_core_context_t *) context);
-        context = NULL;
-    }
     return (hg_core_context_t *) context;
+
+error:
+    HG_Core_context_destroy((hg_core_context_t *) context);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3818,41 +3638,32 @@ HG_Core_context_destroy(hg_core_context_t *context)
 {
     struct hg_core_private_context *private_context =
         (struct hg_core_private_context *) context;
-    na_return_t na_ret;
-    hg_return_t ret = HG_SUCCESS;
     unsigned int actual_count;
     int na_poll_fd;
     hg_util_int32_t n_handles;
+    hg_bool_t empty;
+    na_return_t na_ret;
+    hg_return_t ret = HG_SUCCESS;
+    int rc;
 
-    if (!context) goto done;
+    if (!context)
+        goto done;
 
     /* Prevent repost of handles */
     private_context->finalizing = HG_TRUE;
 
     /* Check pending list and cancel posted handles */
-    if (!HG_LIST_IS_EMPTY(&private_context->pending_list)) {
-        ret = hg_core_pending_list_cancel(private_context);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Cannot cancel list of pending entries");
-            goto done;
-        }
-    }
-#ifdef HG_HAS_SM_ROUTING
-    /* Check pending list and cancel posted handles */
-    if (!HG_LIST_IS_EMPTY(&private_context->sm_pending_list)) {
-        ret = hg_core_sm_pending_list_cancel(private_context);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Cannot cancel list of SM pending entries");
-            goto done;
-        }
-    }
-#endif
+    ret = hg_core_pending_list_cancel(private_context);
+    HG_CHECK_HG_ERROR(done, ret, "Cannot cancel list of pending entries");
 
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
     do {
         na_ret = NA_Trigger(context->na_context, 0, 1, NULL, &actual_count);
     } while ((na_ret == NA_SUCCESS) && actual_count);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
+        (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
+        NA_Error_to_string(na_ret));
 
 #ifdef HG_HAS_SM_ROUTING
     if (context->na_sm_context) {
@@ -3860,15 +3671,15 @@ HG_Core_context_destroy(hg_core_context_t *context)
             na_ret = NA_Trigger(context->na_sm_context, 0, 1, NULL,
                 &actual_count);
         } while ((na_ret == NA_SUCCESS) && actual_count);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
+            (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
+            NA_Error_to_string(na_ret));
     }
 #endif
 
     /* Check that operations have completed */
-    ret = hg_core_created_list_wait(private_context);
-    if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
-        HG_LOG_ERROR("Could not wait on HG core handle list");
-        goto done;
-    }
+    ret = hg_core_context_lists_wait(private_context);
+    HG_CHECK_HG_ERROR(done, ret, "Could not wait on HG core handle list");
 
     /* Number of handles for that context should be 0 */
     n_handles = hg_atomic_get32(&private_context->n_handles);
@@ -3882,42 +3693,32 @@ HG_Core_context_destroy(hg_core_context_t *context)
                 hg_core_handle);
         }
         hg_thread_spin_unlock(&private_context->created_list_lock);
-        ret = HG_PROTOCOL_ERROR;
+        ret = HG_BUSY;
         goto done;
     }
 
     /* Check that completion queue is empty now */
-    if (!hg_atomic_queue_is_empty(private_context->completion_queue)) {
-        HG_LOG_ERROR("Completion queue should be empty");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(!hg_atomic_queue_is_empty(private_context->completion_queue),
+        done, ret, HG_BUSY, "Completion queue should be empty");
     hg_atomic_queue_free(private_context->completion_queue);
 
     /* Check that completion queue is empty now */
     hg_thread_mutex_lock(&private_context->completion_queue_mutex);
-    if (!HG_QUEUE_IS_EMPTY(&private_context->backfill_queue)) {
-        HG_LOG_ERROR("Completion queue should be empty");
-        ret = HG_PROTOCOL_ERROR;
-        hg_thread_mutex_unlock(&private_context->completion_queue_mutex);
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&private_context->backfill_queue);
     hg_thread_mutex_unlock(&private_context->completion_queue_mutex);
+    HG_CHECK_ERROR(!empty, done, ret, HG_BUSY,
+        "Completion queue should be empty");
 
 #ifdef HG_HAS_SELF_FORWARD
     if (private_context->completion_queue_notify > 0) {
-        if (hg_poll_remove(private_context->poll_set,
-            private_context->completion_queue_notify) != HG_UTIL_SUCCESS) {
-            HG_LOG_ERROR("Could not remove self processing event from poll set");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
-        if (hg_event_destroy(private_context->completion_queue_notify)
-            != HG_UTIL_SUCCESS) {
-            HG_LOG_ERROR("Could not destroy self processing event");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        rc = hg_poll_remove(private_context->poll_set,
+            private_context->completion_queue_notify);
+        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
+            "Could not remove self processing event from poll set");
+
+        rc = hg_event_destroy(private_context->completion_queue_notify);
+        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
+            "Could not destroy self processing event");
     }
 #endif
 
@@ -3928,12 +3729,10 @@ HG_Core_context_destroy(hg_core_context_t *context)
         /* If NA plugin exposes fd, remove it from poll set */
         na_poll_fd = NA_Poll_get_fd(context->core_class->na_class,
             context->na_context);
-    if ((na_poll_fd >= 0)
-        && hg_poll_remove(private_context->poll_set, na_poll_fd)
-        != HG_UTIL_SUCCESS) {
-        HG_LOG_ERROR("Could not remove NA poll descriptor from poll set");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
+    if (na_poll_fd >= 0) {
+        rc = hg_poll_remove(private_context->poll_set, na_poll_fd);
+        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
+            "Could not remove NA poll descriptor from poll set");
     }
 
 #ifdef HG_HAS_SM_ROUTING
@@ -3945,38 +3744,34 @@ HG_Core_context_destroy(hg_core_context_t *context)
             /* If NA plugin exposes fd, remove it from poll set */
             na_poll_fd = NA_Poll_get_fd(context->core_class->na_sm_class,
                 context->na_sm_context);
-        if ((na_poll_fd >= 0)
-            && hg_poll_remove(private_context->poll_set, na_poll_fd)
-            != HG_UTIL_SUCCESS) {
-            HG_LOG_ERROR("Could not remove NA poll descriptor from poll set");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
+        if (na_poll_fd >= 0) {
+            rc = hg_poll_remove(private_context->poll_set, na_poll_fd);
+            HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
+                "Could not remove NA poll descriptor from poll set");
         }
     }
 #endif
 
     /* Destroy poll set */
-    if (hg_poll_destroy(private_context->poll_set) != HG_UTIL_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy poll set");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    rc = hg_poll_destroy(private_context->poll_set);
+    HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_FAULT,
+        "Could not destroy poll set");
 
     /* Destroy NA context */
-    if (context->na_context && NA_Context_destroy(context->core_class->na_class,
-            context->na_context) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy NA context");
-        ret = HG_NA_ERROR;
-        goto done;
+    if (context->na_context) {
+        na_ret = NA_Context_destroy(context->core_class->na_class,
+            context->na_context);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not destroy NA context (%s)", NA_Error_to_string(na_ret));
     }
 
 #ifdef HG_HAS_SM_ROUTING
     /* Destroy NA SM context */
-    if (context->na_sm_context && NA_Context_destroy(
-        context->core_class->na_sm_class, context->na_sm_context) != NA_SUCCESS) {
-        HG_LOG_ERROR("Could not destroy NA SM context");
-        ret = HG_NA_ERROR;
-        goto done;
+    if (context->na_sm_context) {
+        na_ret = NA_Context_destroy(context->core_class->na_sm_class,
+            context->na_sm_context);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+            "Could not destroy NA SM context");
     }
 #endif
 
@@ -3988,9 +3783,6 @@ HG_Core_context_destroy(hg_core_context_t *context)
     hg_thread_mutex_destroy(&private_context->completion_queue_mutex);
     hg_thread_cond_destroy(&private_context->completion_queue_cond);
     hg_thread_spin_destroy(&private_context->pending_list_lock);
-#ifdef HG_HAS_SM_ROUTING
-    hg_thread_spin_destroy(&private_context->sm_pending_list_lock);
-#endif
     hg_thread_spin_destroy(&private_context->created_list_lock);
 
     /* Decrement context count of parent class */
@@ -4011,11 +3803,8 @@ HG_Core_context_set_handle_create_callback(hg_core_context_t *context,
         (struct hg_core_private_context *) context;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core context");
 
     private_context->handle_create = callback;
     private_context->handle_create_arg = arg;
@@ -4032,26 +3821,18 @@ HG_Core_context_post(hg_core_context_t *context, unsigned int request_count,
     hg_bool_t use_sm = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!request_count) {
-        HG_LOG_ERROR("Request count must be greater than 0");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core context");
+    HG_CHECK_ERROR(request_count == 0, done, ret, HG_INVALID_ARG,
+        "Request count must be greater than 0");
 
 #ifdef HG_HAS_SM_ROUTING
     do {
 #endif
         ret = hg_core_context_post((struct hg_core_private_context *) context,
             request_count, repost, use_sm);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not post requests on context");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not post requests on context");
+
 #ifdef HG_HAS_SM_ROUTING
         if (context->na_sm_context)
             use_sm = !use_sm;
@@ -4074,11 +3855,8 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
     hg_return_t ret = HG_SUCCESS;
     int hash_ret;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, error, ret, HG_INVALID_ARG,
+        "NULL HG core class");
 
     /* Check if registered and set RPC CB */
     hg_thread_spin_lock(&private_class->func_map_lock);
@@ -4091,21 +3869,15 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
     if (!hg_core_rpc_info) {
         /* Allocate the key */
         func_key = (hg_id_t *) malloc(sizeof(hg_id_t));
-        if (!func_key) {
-            HG_LOG_ERROR("Could not allocate ID");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(func_key == NULL, error, ret, HG_NOMEM,
+            "Could not allocate ID key");
         *func_key = id;
 
         /* Fill info and store it into the function map */
         hg_core_rpc_info = (struct hg_core_rpc_info *) malloc(
             sizeof(struct hg_core_rpc_info));
-        if (!hg_core_rpc_info) {
-            HG_LOG_ERROR("Could not allocate HG info");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(hg_core_rpc_info == NULL, error, ret, HG_NOMEM,
+            "Could not allocate HG info");
 
         hg_core_rpc_info->rpc_cb = rpc_cb;
         hg_core_rpc_info->data = NULL;
@@ -4115,18 +3887,16 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
         hash_ret = hg_hash_table_insert(private_class->func_map,
             (hg_hash_table_key_t) func_key, hg_core_rpc_info);
         hg_thread_spin_unlock(&private_class->func_map_lock);
-        if (!hash_ret) {
-            HG_LOG_ERROR("Could not insert RPC ID into function map (already registered?)");
-            ret = HG_INVALID_PARAM;
-            goto done;
-        }
+        HG_CHECK_ERROR(hash_ret == 0, error, ret, HG_INVALID_ARG,
+            "Could not insert RPC ID into function map (already registered?)");
     }
 
-done:
-    if (ret != HG_SUCCESS) {
-        free(func_key);
-        free(hg_core_rpc_info);
-    }
+    return ret;
+
+error:
+    free(func_key);
+    free(hg_core_rpc_info);
+
     return ret;
 }
 
@@ -4139,21 +3909,15 @@ HG_Core_deregister(hg_core_class_t *hg_core_class, hg_id_t id)
     hg_return_t ret = HG_SUCCESS;
     int hash_ret;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     hash_ret = hg_hash_table_remove(private_class->func_map,
         (hg_hash_table_key_t) &id);
     hg_thread_spin_unlock(&private_class->func_map_lock);
-    if (!hash_ret) {
-        HG_LOG_ERROR("Could not deregister RPC ID from function map");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hash_ret == 0, done, ret, HG_NOENTRY,
+        "Could not deregister RPC ID from function map");
 
 done:
     return ret;
@@ -4167,16 +3931,10 @@ HG_Core_registered(hg_core_class_t *hg_core_class, hg_id_t id, hg_bool_t *flag)
         (struct hg_core_private_class *) hg_core_class;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!flag) {
-        HG_LOG_ERROR("NULL flag");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+    HG_CHECK_ERROR(flag == NULL, done, ret, HG_INVALID_ARG,
+        "NULL flag");
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     *flag = (hg_bool_t) (hg_hash_table_lookup(private_class->func_map,
@@ -4197,24 +3955,18 @@ HG_Core_register_data(hg_core_class_t *hg_core_class, hg_id_t id, void *data,
     struct hg_core_rpc_info *hg_core_rpc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
         private_class->func_map, (hg_hash_table_key_t) &id);
     hg_thread_spin_unlock(&private_class->func_map_lock);
-    if (!hg_core_rpc_info) {
-        HG_LOG_ERROR("Could not find RPC ID in function map");
-        ret = HG_NO_MATCH;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_rpc_info == NULL, done, ret, HG_NOENTRY,
+        "Could not find RPC ID in function map");
 
-    if (hg_core_rpc_info->data)
-        HG_LOG_WARNING("Overriding data previously registered");
+    HG_CHECK_WARNING(hg_core_rpc_info->data,
+        "Overriding data previously registered");
     hg_core_rpc_info->data = data;
     hg_core_rpc_info->free_callback = free_callback;
 
@@ -4231,19 +3983,14 @@ HG_Core_registered_data(hg_core_class_t *hg_core_class, hg_id_t id)
     struct hg_core_rpc_info *hg_core_rpc_info = NULL;
     void *data = NULL;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_class == NULL, done, "NULL HG core class");
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
         private_class->func_map, (hg_hash_table_key_t) &id);
     hg_thread_spin_unlock(&private_class->func_map_lock);
-    if (!hg_core_rpc_info) {
-        HG_LOG_ERROR("Could not find RPC ID in function map");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(hg_core_rpc_info == NULL, done,
+        "Could not find RPC ID in function map");
 
     data = hg_core_rpc_info->data;
 
@@ -4258,28 +4005,16 @@ HG_Core_addr_lookup(hg_core_context_t *context, hg_core_cb_t callback,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!callback) {
-        HG_LOG_ERROR("NULL callback");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!name) {
-        HG_LOG_ERROR("NULL lookup name");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core context");
+    HG_CHECK_ERROR(callback == NULL, done, ret, HG_INVALID_ARG,
+        "NULL callback");
+    HG_CHECK_ERROR(name == NULL, done, ret, HG_INVALID_ARG,
+        "NULL lookup");
 
     ret = hg_core_addr_lookup((struct hg_core_private_context *) context,
         callback, arg, name, op_id);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not lookup address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not lookup address");
 
 done:
     return ret;
@@ -4291,25 +4026,16 @@ HG_Core_addr_create(hg_core_class_t *hg_core_class, hg_core_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (hg_core_class == NULL) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!addr) {
-        HG_LOG_ERROR("NULL pointer to address");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+    HG_CHECK_ERROR(addr == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to address");
 
     *addr = (hg_core_addr_t) hg_core_addr_create(
         (struct hg_core_private_class *) hg_core_class,
         hg_core_class->na_class);
-    if (*addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("Could not create address");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(*addr == HG_CORE_ADDR_NULL, done, ret, HG_NOMEM,
+        "Could not create address");
 
 done:
     return ret;
@@ -4321,18 +4047,33 @@ HG_Core_addr_free(hg_core_class_t *hg_core_class, hg_core_addr_t addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
 
     ret = hg_core_addr_free((struct hg_core_private_class *) hg_core_class,
         (struct hg_core_private_addr *) addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not free address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not free address");
+
+done:
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+hg_return_t
+HG_Core_addr_set_remove(hg_core_class_t *hg_core_class, hg_core_addr_t addr)
+{
+    struct hg_core_private_addr *hg_core_addr =
+        (struct hg_core_private_addr *) addr;
+    hg_return_t ret = HG_SUCCESS;
+    na_return_t na_ret;
+
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+
+    na_ret = NA_Addr_set_remove(hg_core_addr->core_addr.na_class,
+        hg_core_addr->core_addr.na_addr);
+    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
+        "Could not set address to be removed (%s)", NA_Error_to_string(na_ret));
 
 done:
     return ret;
@@ -4344,23 +4085,14 @@ HG_Core_addr_self(hg_core_class_t *hg_core_class, hg_core_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!addr) {
-        HG_LOG_ERROR("NULL pointer to address");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+    HG_CHECK_ERROR(addr == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to address");
 
     ret = hg_core_addr_self((struct hg_core_private_class *) hg_core_class,
         (struct hg_core_private_addr **) addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not get self address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not get self address");
 
 done:
     return ret;
@@ -4373,29 +4105,17 @@ HG_Core_addr_dup(hg_core_class_t *hg_core_class, hg_core_addr_t addr,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL addr");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!new_addr) {
-        HG_LOG_ERROR("NULL pointer to destination address");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+    HG_CHECK_ERROR(addr == HG_CORE_ADDR_NULL, done, ret, HG_INVALID_ARG,
+        "NULL addr");
+    HG_CHECK_ERROR(new_addr == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to dup addr");
 
     ret = hg_core_addr_dup((struct hg_core_private_class *) hg_core_class,
         (struct hg_core_private_addr *) addr,
         (struct hg_core_private_addr **) new_addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not duplicate address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not duplicate address");
 
 done:
     return ret;
@@ -4408,18 +4128,14 @@ HG_Core_addr_to_string(hg_core_class_t *hg_core_class, char *buf,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core class");
+    HG_CHECK_ERROR(buf_size == NULL, done, ret, HG_INVALID_ARG,
+        "NULL pointer to buffer size");
 
     ret = hg_core_addr_to_string((struct hg_core_private_class *) hg_core_class,
         buf, buf_size, (struct hg_core_private_addr *) addr);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not convert address to string");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not convert address to string");
 
 done:
     return ret;
@@ -4438,16 +4154,10 @@ HG_Core_create(hg_core_context_t *context, hg_core_addr_t addr, hg_id_t id,
     hg_bool_t use_sm = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, error, ret, HG_INVALID_ARG,
+        "NULL HG core context");
+    HG_CHECK_ERROR(handle == NULL, error, ret, HG_INVALID_ARG,
+        "NULL pointer to HG core handle");
 
 #ifdef HG_HAS_SM_ROUTING
     if (private_addr
@@ -4457,37 +4167,30 @@ HG_Core_create(hg_core_context_t *context, hg_core_addr_t addr, hg_id_t id,
 
     /* Create new handle */
     hg_core_handle = hg_core_create(private_context, use_sm);
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("Could not create HG core handle");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle == NULL, error, ret, HG_NOMEM,
+        "Could not create HG core handle");
 
     /* Set addr / RPC ID */
     ret = hg_core_set_rpc(hg_core_handle, private_addr, id);
-    if (ret != HG_SUCCESS) {
-        if (ret != HG_NO_MATCH) /* silence error if invalid ID is used */
-            HG_LOG_ERROR("Could not set rpc to handle");
-        goto done;
-    }
+    if (ret == HG_NOENTRY)
+        goto error;
+    HG_CHECK_HG_ERROR(error, ret, "Could not set rpc to handle");
 
     /* Execute class callback on handle, this allows upper layers to
      * allocate private data on handle creation */
     if (private_context->handle_create) {
         ret = private_context->handle_create((hg_core_handle_t) hg_core_handle,
             private_context->handle_create_arg);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Error in HG core handle create callback");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(error, ret, "Error in HG handle create callback");
     }
 
     *handle = (hg_core_handle_t) hg_core_handle;
 
-done:
-    if (ret != HG_SUCCESS) {
-        hg_core_destroy(hg_core_handle);
-    }
+    return ret;
+
+error:
+    hg_core_destroy(hg_core_handle);
+
     return ret;
 }
 
@@ -4499,21 +4202,15 @@ HG_Core_destroy(hg_core_handle_t handle)
         (struct hg_core_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        ret = HG_INVALID_PARAM;
+    if (hg_core_handle == NULL)
         goto done;
-    }
 
     /* Repost handle if we were listening, otherwise destroy it */
     if (hg_core_handle->repost
         && !HG_CORE_HANDLE_CONTEXT(hg_core_handle)->finalizing) {
         /* Repost handle */
         ret = hg_core_reset_post(hg_core_handle);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Cannot repost handle");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Cannot repost handle");
     } else
         hg_core_destroy(hg_core_handle);
 
@@ -4531,36 +4228,26 @@ HG_Core_reset(hg_core_handle_t handle, hg_core_addr_t addr, hg_id_t id)
         (struct hg_core_private_addr *) addr;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG core handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core handle");
+
     /* Not safe to reset
      * TODO could add the ability to defer the reset operation */
-    if (hg_atomic_get32(&hg_core_handle->in_use)) {
-        HG_LOG_ERROR("Cannot reset HG core handle, handle is still in use, "
-            "refcount: %d",
-            hg_atomic_get32(&hg_core_handle->ref_count));
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_atomic_get32(&hg_core_handle->in_use), done, ret,
+        HG_BUSY, "Cannot reset HG core handle, still in use, "
+            "refcount: %d", hg_atomic_get32(&hg_core_handle->ref_count));
 
 #ifdef HG_HAS_SM_ROUTING
     if (hg_core_addr
         && (hg_core_addr->core_addr.na_class != hg_core_handle->na_class)) {
         struct hg_core_private_context *private_context =
             (struct hg_core_private_context *) hg_core_handle->core_handle.info.context;
-        hg_bool_t use_sm =
-            (private_context->core_context.core_class->na_sm_class
-                == hg_core_addr->core_addr.na_class);
+        hg_bool_t use_sm = (private_context->core_context.core_class->na_sm_class
+            == hg_core_addr->core_addr.na_class);
         /* In that case, we must free and re-allocate NA resources */
         hg_core_free_na(hg_core_handle);
         ret = hg_core_alloc_na(hg_core_handle, use_sm);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not re-allocate handle NA resources");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not re-allocate NA resources");
     }
 #endif
 
@@ -4569,9 +4256,9 @@ HG_Core_reset(hg_core_handle_t handle, hg_core_addr_t addr, hg_id_t id)
 
     /* Set addr / RPC ID */
     ret = hg_core_set_rpc(hg_core_handle, hg_core_addr, id);
-    if (ret != HG_SUCCESS) {
+    if (ret == HG_NOENTRY)
         goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not set rpc to handle");
 
 done:
     return ret;
@@ -4583,15 +4270,14 @@ HG_Core_ref_incr(hg_core_handle_t handle)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) handle;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
+    hg_return_t ret = HG_SUCCESS;
+
+    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core handle");
     hg_atomic_incr32(&hg_core_handle->ref_count);
 
-    return HG_SUCCESS;
+done:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4600,13 +4286,14 @@ HG_Core_ref_get(hg_core_handle_t handle)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) handle;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return -1;
-    }
-#endif
-    return (hg_int32_t) hg_atomic_get32(&hg_core_handle->ref_count);
+    hg_int32_t ret;
+
+    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, -1,
+        "NULL HG core handle");
+    ret = (hg_int32_t) hg_atomic_get32(&hg_core_handle->ref_count);
+
+done:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4617,39 +4304,40 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) handle;
     hg_size_t header_size;
+    hg_bool_t in_use;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (hg_core_handle->core_handle.info.addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL target addr");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-    if (!hg_core_handle->core_handle.info.id) {
-        HG_LOG_ERROR("NULL RPC ID");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core handle");
+    HG_CHECK_ERROR(hg_core_handle->core_handle.info.addr == HG_CORE_ADDR_NULL,
+        done, ret, HG_INVALID_ARG, "NULL target addr");
+    HG_CHECK_ERROR(hg_core_handle->core_handle.info.id == 0, done, ret,
+        HG_INVALID_ARG, "NULL RPC ID");
+
 #ifndef HG_HAS_SELF_FORWARD
-    if (hg_core_handle->is_self) {
-        HG_LOG_ERROR("Not enabled, please enable HG_USE_SELF_FORWARD");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->is_self, done, ret, HG_INVALID_PARAM,
+        "Forward to self not enabled, please enable HG_USE_SELF_FORWARD");
 #endif
-    if (hg_atomic_cas32(&hg_core_handle->in_use, HG_FALSE, HG_TRUE)
-        != HG_UTIL_TRUE) {
-        /* Not safe to reset
-         * TODO could add the ability to defer the reset operation */
-        HG_LOG_ERROR("Not safe to use HG core handle, handle is still in use, "
-            "refcount: %d", hg_atomic_get32(
-                &hg_core_handle->ref_count));
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
+    in_use = (hg_atomic_cas32(&hg_core_handle->in_use, HG_FALSE, HG_TRUE)
+        != HG_UTIL_TRUE);
+    /* Not safe to reset
+     * TODO could add the ability to defer the reset operation */
+    HG_CHECK_ERROR(in_use, done, ret, HG_BUSY,
+        "Not safe to use HG core handle, handle is still in use, refcount: %d",
+        hg_atomic_get32(&hg_core_handle->ref_count));
+
+    /* Make sure any cancelation has been processed on this handle before
+     * re-using it */
+    while (hg_atomic_get32(&hg_core_handle->canceling)) {
+        int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
+        unsigned int trigger_count = 0;
+        na_return_t na_ret;
+
+        na_ret = NA_Trigger(hg_core_handle->na_context, 0,
+            HG_CORE_MAX_TRIGGER_COUNT, cb_ret, &trigger_count);
+        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
+            (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
+            NA_Error_to_string(na_ret));
     }
 
 #ifdef HG_HAS_COLLECT_STATS
@@ -4661,19 +4349,20 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     hg_core_handle->na_op_count = 1; /* Default (no response) */
     hg_atomic_set32(&hg_core_handle->na_op_completed_count, 0);
 
+    /* Increase ref count here so that a call to HG_Destroy does not free the
+     * handle but only schedules its completion
+     */
+    hg_atomic_incr32(&hg_core_handle->ref_count);
+
     /* Set header size */
     header_size = hg_core_header_request_get_size() +
         hg_core_handle->core_handle.na_in_header_offset;
 
     /* Set the actual size of the msg that needs to be transmitted */
     hg_core_handle->in_buf_used = header_size + payload_size;
-    if (hg_core_handle->in_buf_used > hg_core_handle->core_handle.in_buf_size) {
-        HG_LOG_ERROR("Exceeding input buffer size");
-        ret = HG_SIZE_ERROR;
-        /* Handle is no longer in use */
-        hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->in_buf_used
+        > hg_core_handle->core_handle.in_buf_size, error, ret, HG_MSGSIZE,
+        "Exceeding input buffer size");
 
     /* Parse flags */
     if (flags & HG_CORE_NO_RESPONSE)
@@ -4699,32 +4388,26 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     /* Encode request header */
     ret = hg_core_proc_header_request(&hg_core_handle->core_handle,
         &hg_core_handle->in_header, HG_ENCODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode header");
-        /* Handle is no longer in use */
-        hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
-        goto done;
-    }
-
-    /* Increase ref count here so that a call to HG_Destroy does not free the
-     * handle but only schedules its completion
-     */
-    hg_atomic_incr32(&hg_core_handle->ref_count);
+    HG_CHECK_HG_ERROR(error, ret, "Could not encode header");
 
     /* If addr is self, forward locally, otherwise send the encoded buffer
      * through NA and pre-post response */
     ret = hg_core_handle->forward(hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not forward buffer");
-        /* Handle is no longer in use */
-        hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
-        /* Rollback ref_count taken above */
-        hg_atomic_decr32(&hg_core_handle->ref_count);
-        goto done;
-    }
+    if (ret == HG_AGAIN)
+        goto error;
+
+    HG_CHECK_HG_ERROR(error, ret, "Could not forward buffer");
 
 done:
-     return ret;
+    return ret;
+
+error:
+    /* Handle is no longer in use */
+    hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
+    /* Rollback ref_count taken above */
+    hg_atomic_decr32(&hg_core_handle->ref_count);
+
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4737,25 +4420,12 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     hg_size_t header_size;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_core_handle) {
-        HG_LOG_ERROR("NULL handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-#ifndef HG_HAS_SELF_FORWARD
-    if (NA_Addr_is_self(hg_core_handle->core_handle.info.addr->na_class,
-        hg_core_handle->core_handle.info.addr->na_addr)) {
-        HG_LOG_ERROR("Not enabled, please enable HG_USE_SELF_FORWARD");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-#endif
+    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core handle");
+
     /* Cannot respond if no_response flag set */
-    if (hg_core_handle->no_response) {
-        HG_LOG_ERROR("Sending response was disabled on that RPC");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->no_response, done, ret, HG_OPNOTSUPPORTED,
+        "Sending response was disabled on that RPC");
 
     /* Set header size */
     header_size = hg_core_header_response_get_size() +
@@ -4763,12 +4433,9 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
 
     /* Set the actual size of the msg that needs to be transmitted */
     hg_core_handle->out_buf_used = header_size + payload_size;
-    if (hg_core_handle->out_buf_used
-        > hg_core_handle->core_handle.out_buf_size) {
-        HG_LOG_ERROR("Exceeding output buffer size");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_core_handle->out_buf_used
+        > hg_core_handle->core_handle.out_buf_size, done, ret, HG_MSGSIZE,
+        "Exceeding output buffer size");
 
     /* Set callback, keep request and response callbacks separate so that
      * they do not get overwritten when forwarding to ourself */
@@ -4783,18 +4450,12 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     /* Encode response header */
     ret = hg_core_proc_header_response(&hg_core_handle->core_handle,
         &hg_core_handle->out_header, HG_ENCODE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not encode header");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not encode header");
 
     /* If addr is self, forward locally, otherwise send the encoded buffer
      * through NA and pre-post response */
     ret = hg_core_handle->respond(hg_core_handle);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not respond");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not respond");
 
 done:
     return ret;
@@ -4808,18 +4469,13 @@ HG_Core_progress(hg_core_context_t *context, unsigned int timeout)
         (struct hg_core_private_context *) context;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core context");
 
     /* Make progress on the HG layer */
     ret = private_context->progress(private_context, timeout);
-    if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
-        HG_LOG_ERROR("Could not make progress");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        "Could not make progress");
 
 done:
     return ret;
@@ -4832,18 +4488,13 @@ HG_Core_trigger(hg_core_context_t *context, unsigned int timeout,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core context");
 
     ret = hg_core_trigger((struct hg_core_private_context *) context, timeout,
         max_count, actual_count);
-    if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
-        HG_LOG_ERROR("Could not trigger callbacks");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
+        "Could not trigger callbacks");
 
 done:
     return ret;
@@ -4855,17 +4506,11 @@ HG_Core_cancel(hg_core_handle_t handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (!handle) {
-        HG_LOG_ERROR("NULL handle");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(handle == HG_CORE_HANDLE_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG core handle");
 
     ret = hg_core_cancel((struct hg_core_private_handle *) handle);
-    if (ret != HG_SUCCESS && ret != HG_CANCEL_ERROR) {
-        HG_LOG_ERROR("Could not cancel handle");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle");
 
 done:
     return ret;
diff --git a/src/mercury_core.h b/src/mercury_core.h
index 072a865..46ca770 100644
--- a/src/mercury_core.h
+++ b/src/mercury_core.h
@@ -13,7 +13,6 @@
 
 #include "mercury_core_types.h"
 #include "mercury_core_header.h"
-#include "mercury_error.h"
 
 #include "na.h"
 
@@ -32,8 +31,8 @@ struct hg_core_info {
     hg_core_class_t *core_class;    /* HG core class */
     hg_core_context_t *context;     /* HG core context */
     hg_core_addr_t addr;            /* HG address at target/origin */
-    hg_uint8_t context_id;          /* Context ID at target/origin */
     hg_id_t id;                     /* RPC ID */
+    hg_uint8_t context_id;          /* Context ID at target/origin */
 };
 
 /* Callback info structs */
@@ -50,14 +49,14 @@ struct hg_core_cb_info_respond {
 };
 
 struct hg_core_cb_info {
-    void *arg;                  /* User data */
-    hg_return_t ret;            /* Return value */
-    hg_cb_type_t type;          /* Callback type */
     union {                     /* Union of callback info structures */
         struct hg_core_cb_info_lookup lookup;
         struct hg_core_cb_info_forward forward;
         struct hg_core_cb_info_respond respond;
     } info;
+    void *arg;                  /* User data */
+    hg_cb_type_t type;          /* Callback type */
+    hg_return_t ret;            /* Return value */
 };
 
 /* RPC / HG callbacks */
@@ -97,7 +96,7 @@ extern "C" {
  *
  * \return Pointer to HG core class or NULL in case of failure
  */
-HG_EXPORT hg_core_class_t *
+HG_PUBLIC hg_core_class_t *
 HG_Core_init(
         const char *na_info_string,
         hg_bool_t na_listen
@@ -116,7 +115,7 @@ HG_Core_init(
  *
  * \return Pointer to HG core class or NULL in case of failure
  */
-HG_EXPORT hg_core_class_t *
+HG_PUBLIC hg_core_class_t *
 HG_Core_init_opt(
         const char *na_info_string,
         hg_bool_t na_listen,
@@ -130,7 +129,7 @@ HG_Core_init_opt(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_finalize(
         hg_core_class_t *hg_core_class
         );
@@ -141,7 +140,7 @@ HG_Core_finalize(
  * to HG_Finalize(), this routine gives a chance to programs that terminate
  * abnormally to easily clean up those resources.
  */
-HG_EXPORT void
+HG_PUBLIC void
 HG_Core_cleanup(
         void
         );
@@ -161,7 +160,7 @@ HG_Core_cleanup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_set_more_data_callback(
         struct hg_core_class *hg_core_class,
         hg_return_t (*more_data_acquire_callback)(hg_core_handle_t, hg_op_t,
@@ -293,7 +292,7 @@ HG_Core_class_get_data(
  *
  * \return Pointer to HG core context or NULL in case of failure
  */
-HG_EXPORT hg_core_context_t *
+HG_PUBLIC hg_core_context_t *
 HG_Core_context_create(
         hg_core_class_t *hg_core_class
         );
@@ -309,7 +308,7 @@ HG_Core_context_create(
  *
  * \return Pointer to HG core context or NULL in case of failure
  */
-HG_EXPORT hg_core_context_t *
+HG_PUBLIC hg_core_context_t *
 HG_Core_context_create_id(
         hg_core_class_t *hg_core_class,
         hg_uint8_t id
@@ -322,7 +321,7 @@ HG_Core_context_create_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_context_destroy(
         hg_core_context_t *context
         );
@@ -418,7 +417,7 @@ HG_Core_context_get_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_context_set_handle_create_callback(
         hg_core_context_t *context,
         hg_return_t (*callback)(hg_core_handle_t, void *),
@@ -438,7 +437,7 @@ HG_Core_context_set_handle_create_callback(
  *
  * \return the associated class
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_context_post(
         hg_core_context_t *context,
         unsigned int request_count,
@@ -455,7 +454,7 @@ HG_Core_context_post(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_register(
         hg_core_class_t *hg_core_class,
         hg_id_t id,
@@ -472,7 +471,7 @@ HG_Core_register(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_deregister(
         hg_core_class_t *hg_core_class,
         hg_id_t id
@@ -487,7 +486,7 @@ HG_Core_deregister(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_registered(
         hg_core_class_t *hg_core_class,
         hg_id_t id,
@@ -506,7 +505,7 @@ HG_Core_registered(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_register_data(
         hg_core_class_t *hg_core_class,
         hg_id_t id,
@@ -523,7 +522,7 @@ HG_Core_register_data(
  *
  * \return Pointer to data or NULL
  */
-HG_EXPORT void *
+HG_PUBLIC void *
 HG_Core_registered_data(
         hg_core_class_t *hg_core_class,
         hg_id_t id
@@ -542,7 +541,7 @@ HG_Core_registered_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_lookup(
         hg_core_context_t *context,
         hg_core_cb_t callback,
@@ -559,7 +558,7 @@ HG_Core_addr_lookup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_create(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t *addr
@@ -573,12 +572,29 @@ HG_Core_addr_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_free(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t addr
         );
 
+/**
+ * Hint that the address is no longer valid. This may happen if the peer is
+ * no longer responding. This can be used to force removal of the
+ * peer address from the list of the peers, before freeing it and reclaim
+ * resources.
+ *
+ * \param hg_core_class [IN]    pointer to HG core class
+ * \param addr [IN]             abstract address
+ *
+ * \return HG_SUCCESS or corresponding HG error code
+ */
+HG_PUBLIC hg_return_t
+HG_Core_addr_set_remove(
+        hg_core_class_t *hg_core_class,
+        hg_core_addr_t addr
+        );
+
 /**
  * Set the underlying NA address to a HG address.
  *
@@ -625,7 +641,7 @@ HG_Core_addr_get_na_class(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_self(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t *addr
@@ -642,7 +658,7 @@ HG_Core_addr_self(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_dup(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t addr,
@@ -663,7 +679,7 @@ HG_Core_addr_dup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_addr_to_string(
         hg_core_class_t *hg_core_class,
         char *buf,
@@ -684,7 +700,7 @@ HG_Core_addr_to_string(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_create(
         hg_core_context_t *context,
         hg_core_addr_t addr,
@@ -700,7 +716,7 @@ HG_Core_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_destroy(
         hg_core_handle_t handle
         );
@@ -717,7 +733,7 @@ HG_Core_destroy(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_reset(
         hg_core_handle_t handle,
         hg_core_addr_t addr,
@@ -731,7 +747,7 @@ HG_Core_reset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_ref_incr(
         hg_core_handle_t handle
         );
@@ -743,7 +759,7 @@ HG_Core_ref_incr(
  *
  * \return Non-negative value or negative if the handle is not valid
  */
-HG_EXPORT hg_int32_t
+HG_PUBLIC hg_int32_t
 HG_Core_ref_get(
         hg_core_handle_t handle
         );
@@ -871,7 +887,7 @@ HG_Core_get_output(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_forward(
         hg_core_handle_t handle,
         hg_core_cb_t callback,
@@ -893,7 +909,7 @@ HG_Core_forward(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_respond(
         hg_core_handle_t handle,
         hg_core_cb_t callback,
@@ -914,7 +930,7 @@ HG_Core_respond(
  *
  * \return HG_SUCCESS if any completion has occurred / HG error code otherwise
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_progress(
         hg_core_context_t *context,
         unsigned int timeout
@@ -932,7 +948,7 @@ HG_Core_progress(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_trigger(
         hg_core_context_t *context,
         unsigned int timeout,
@@ -947,7 +963,7 @@ HG_Core_trigger(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Core_cancel(
         hg_core_handle_t handle
         );
@@ -973,9 +989,9 @@ struct hg_core_context {
 #ifdef HG_HAS_SM_ROUTING
     na_context_t *na_sm_context;        /* NA SM context */
 #endif
-    hg_uint8_t id;                      /* Context ID */
     void *data;                         /* User data */
     void (*data_free_callback)(void *); /* User data free callback */
+    hg_uint8_t id;                      /* Context ID */
 };
 
 /* HG core addr */
@@ -998,26 +1014,20 @@ struct hg_core_rpc_info {
 struct hg_core_handle {
     struct hg_core_info info;           /* HG info */
     struct hg_core_rpc_info *rpc_info;  /* Associated RPC registration info */
+    void *data;                         /* User data */
+    void (*data_free_callback)(void *); /* User data free callback */
     void *in_buf;                       /* Input buffer */
     void *out_buf;                      /* Output buffer */
     na_size_t in_buf_size;              /* Input buffer size */
     na_size_t out_buf_size;             /* Output buffer size */
     na_size_t na_in_header_offset;      /* Input NA header offset */
     na_size_t na_out_header_offset;     /* Output NA header offset */
-    void *data;                         /* User data */
-    void (*data_free_callback)(void *); /* User data free callback */
 };
 
 /*---------------------------------------------------------------------------*/
 static HG_INLINE const char *
 HG_Core_class_get_name(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return NULL;
-    }
-#endif
     return NA_Get_class_name(hg_core_class->na_class);
 }
 
@@ -1025,12 +1035,6 @@ HG_Core_class_get_name(const hg_core_class_t *hg_core_class)
 static HG_INLINE const char *
 HG_Core_class_get_protocol(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return NULL;
-    }
-#endif
     return NA_Get_class_protocol(hg_core_class->na_class);
 }
 
@@ -1038,12 +1042,6 @@ HG_Core_class_get_protocol(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_bool_t
 HG_Core_class_is_listening(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return HG_FALSE;
-    }
-#endif
     return NA_Is_listening(hg_core_class->na_class);
 }
 
@@ -1051,12 +1049,6 @@ HG_Core_class_is_listening(const hg_core_class_t *hg_core_class)
 static HG_INLINE na_class_t *
 HG_Core_class_get_na(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return NULL;
-    }
-#endif
     return hg_core_class->na_class;
 }
 
@@ -1065,12 +1057,6 @@ HG_Core_class_get_na(const hg_core_class_t *hg_core_class)
 static HG_INLINE na_class_t *
 HG_Core_class_get_na_sm(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return NULL;
-    }
-#endif
     return hg_core_class->na_sm_class;
 }
 #endif
@@ -1079,15 +1065,8 @@ HG_Core_class_get_na_sm(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_size_t
 HG_Core_class_get_input_eager_size(const hg_core_class_t *hg_core_class)
 {
-    hg_size_t unexp, header;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (hg_core_class == NULL) {
-        HG_LOG_ERROR("NULL HG core class");
-        return 0;
-    }
-#endif
-    unexp  = NA_Msg_get_max_unexpected_size(hg_core_class->na_class);
-    header = hg_core_header_request_get_size() +
+    hg_size_t unexp = NA_Msg_get_max_unexpected_size(hg_core_class->na_class),
+        header = hg_core_header_request_get_size() +
         NA_Msg_get_unexpected_header_size(hg_core_class->na_class);
 
     return (unexp > header) ? unexp - header : 0;
@@ -1097,15 +1076,8 @@ HG_Core_class_get_input_eager_size(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_size_t
 HG_Core_class_get_output_eager_size(const hg_core_class_t *hg_core_class)
 {
-    hg_size_t exp, header;
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (hg_core_class == NULL) {
-        HG_LOG_ERROR("NULL HG core class");
-        return 0;
-    }
-#endif
-    exp    = NA_Msg_get_max_expected_size(hg_core_class->na_class);
-    header = hg_core_header_response_get_size() +
+    hg_size_t exp = NA_Msg_get_max_expected_size(hg_core_class->na_class),
+        header = hg_core_header_response_get_size() +
         NA_Msg_get_expected_header_size(hg_core_class->na_class);
 
     return (exp > header) ? exp - header : 0;
@@ -1116,12 +1088,6 @@ static HG_INLINE hg_return_t
 HG_Core_class_set_data(hg_core_class_t *hg_core_class, void *data,
     void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return HG_INVALID_PARAM;
-    }
-#endif
     hg_core_class->data = data;
     hg_core_class->data_free_callback = free_callback;
 
@@ -1132,12 +1098,6 @@ HG_Core_class_set_data(hg_core_class_t *hg_core_class, void *data,
 static HG_INLINE void *
 HG_Core_class_get_data(const hg_core_class_t *hg_core_class)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!hg_core_class) {
-        HG_LOG_ERROR("NULL HG core class");
-        return NULL;
-    }
-#endif
     return hg_core_class->data;
 }
 
@@ -1145,12 +1105,6 @@ HG_Core_class_get_data(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_core_class_t *
 HG_Core_context_get_class(const hg_core_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return NULL;
-    }
-#endif
     return context->core_class;
 }
 
@@ -1158,12 +1112,6 @@ HG_Core_context_get_class(const hg_core_context_t *context)
 static HG_INLINE na_context_t *
 HG_Core_context_get_na(const hg_core_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return NULL;
-    }
-#endif
     return context->na_context;
 }
 
@@ -1172,12 +1120,6 @@ HG_Core_context_get_na(const hg_core_context_t *context)
 static HG_INLINE na_context_t *
 HG_Core_context_get_na_sm(const hg_core_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return NULL;
-    }
-#endif
     return context->na_sm_context;
 }
 #endif
@@ -1186,12 +1128,6 @@ HG_Core_context_get_na_sm(const hg_core_context_t *context)
 static HG_INLINE hg_uint8_t
 HG_Core_context_get_id(const hg_core_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return HG_INVALID_PARAM;
-    }
-#endif
     return context->id;
 }
 
@@ -1200,12 +1136,6 @@ static HG_INLINE hg_return_t
 HG_Core_context_set_data(hg_core_context_t *context, void *data,
     void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return HG_INVALID_PARAM;
-    }
-#endif
     context->data = data;
     context->data_free_callback = free_callback;
 
@@ -1216,12 +1146,6 @@ HG_Core_context_set_data(hg_core_context_t *context, void *data,
 static HG_INLINE void *
 HG_Core_context_get_data(const hg_core_context_t *context)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!context) {
-        HG_LOG_ERROR("NULL HG core context");
-        return NULL;
-    }
-#endif
     return context->data;
 }
 
@@ -1229,12 +1153,6 @@ HG_Core_context_get_data(const hg_core_context_t *context)
 static HG_INLINE hg_return_t
 HG_Core_addr_set_na(hg_core_addr_t core_addr, na_addr_t na_addr)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (core_addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL HG core address");
-        return HG_INVALID_PARAM;
-    }
-#endif
     core_addr->na_addr = na_addr;
 
     return HG_SUCCESS;
@@ -1244,12 +1162,6 @@ HG_Core_addr_set_na(hg_core_addr_t core_addr, na_addr_t na_addr)
 static HG_INLINE na_addr_t
 HG_Core_addr_get_na(hg_core_addr_t addr)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL addr");
-        return NA_ADDR_NULL;
-    }
-#endif
     return addr->na_addr;
 }
 
@@ -1257,12 +1169,6 @@ HG_Core_addr_get_na(hg_core_addr_t addr)
 static HG_INLINE na_class_t *
 HG_Core_addr_get_na_class(hg_core_addr_t addr)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (addr == HG_CORE_ADDR_NULL) {
-        HG_LOG_ERROR("NULL addr");
-        return NULL;
-    }
-#endif
     return addr->na_class;
 }
 
@@ -1271,12 +1177,6 @@ static HG_INLINE hg_return_t
 HG_Core_set_data(hg_core_handle_t handle, void *data,
     void (*free_callback)(void *))
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
     handle->data = data;
     handle->data_free_callback = free_callback;
 
@@ -1287,12 +1187,6 @@ HG_Core_set_data(hg_core_handle_t handle, void *data,
 static HG_INLINE void *
 HG_Core_get_data(hg_core_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return NULL;
-    }
-#endif
     return handle->data;
 }
 
@@ -1300,12 +1194,6 @@ HG_Core_get_data(hg_core_handle_t handle)
 static HG_INLINE const struct hg_core_info *
 HG_Core_get_info(hg_core_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return NULL;
-    }
-#endif
     return &handle->info;
 }
 
@@ -1313,12 +1201,6 @@ HG_Core_get_info(hg_core_handle_t handle)
 static HG_INLINE const void *
 HG_Core_get_rpc_data(hg_core_handle_t handle)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL pointer to HG core handle");
-        return NULL;
-    }
-#endif
     return (handle->rpc_info) ? handle->rpc_info->data : NULL;
 }
 
@@ -1326,12 +1208,6 @@ HG_Core_get_rpc_data(hg_core_handle_t handle)
 static HG_INLINE hg_return_t
 HG_Core_set_target_id(hg_core_handle_t handle, hg_uint8_t id)
 {
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL HG core handle");
-        return HG_INVALID_PARAM;
-    }
-#endif
     handle->info.context_id = id;
 
     return HG_SUCCESS;
@@ -1342,21 +1218,7 @@ static HG_INLINE hg_return_t
 HG_Core_get_input(hg_core_handle_t handle, void **in_buf,
     hg_size_t *in_buf_size)
 {
-    hg_size_t header_offset;
-
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL handle");
-        return HG_INVALID_PARAM;
-    }
-
-    if (!in_buf || !in_buf_size) {
-        HG_LOG_ERROR("NULL pointer");
-        return HG_INVALID_PARAM;
-    }
-#endif
-
-    header_offset = hg_core_header_request_get_size() +
+    hg_size_t header_offset = hg_core_header_request_get_size() +
         handle->na_in_header_offset;
 
     /* Space must be left for request header */
@@ -1371,21 +1233,7 @@ static HG_INLINE hg_return_t
 HG_Core_get_output(hg_core_handle_t handle, void **out_buf,
     hg_size_t *out_buf_size)
 {
-    hg_size_t header_offset;
-
-#ifdef HG_HAS_VERBOSE_ERROR
-    if (!handle) {
-        HG_LOG_ERROR("NULL handle");
-        return HG_INVALID_PARAM;
-    }
-
-    if (!out_buf || !out_buf_size) {
-        HG_LOG_ERROR("NULL pointer");
-        return HG_INVALID_PARAM;
-    }
-#endif
-
-    header_offset = hg_core_header_response_get_size() +
+    hg_size_t header_offset = hg_core_header_response_get_size() +
         handle->na_out_header_offset;
 
     /* Space must be left for response header */
diff --git a/src/mercury_core_header.c b/src/mercury_core_header.c
index 8794f69..04e1c8f 100644
--- a/src/mercury_core_header.c
+++ b/src/mercury_core_header.c
@@ -160,11 +160,8 @@ hg_core_header_request_proc(hg_proc_op_t op, void *buf, size_t buf_size,
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-    if (buf_size < sizeof(struct hg_core_header_request)) {
-        HG_LOG_ERROR("Invalid buffer size");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(buf_size < sizeof(struct hg_core_header_request), done,
+        ret, HG_INVALID_ARG, "Invalid buffer size");
 
 #ifdef HG_HAS_CHECKSUMS
     /* Reset header checksum first */
@@ -195,12 +192,9 @@ hg_core_header_request_proc(hg_proc_op_t op, void *buf, size_t buf_size,
     hg_proc_buf_memcpy(buf_ptr, &n_hash_header, sizeof(n_hash_header), op);
     if (op == HG_DECODE) {
         hg_uint16_t h_hash_header = ntohs(n_hash_header);
-        if (header->hash.header != h_hash_header) {
-            HG_LOG_ERROR("checksum 0x%04X does not match (expected 0x%04X!)",
-                header->hash.header, h_hash_header);
-            ret = HG_CHECKSUM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(header->hash.header != h_hash_header, done, ret,
+            HG_CHECKSUM_ERROR,
+            "checksum 0x%04X does not match (expected 0x%04X!)");
     }
 #endif
 
@@ -220,11 +214,8 @@ hg_core_header_response_proc(hg_proc_op_t op, void *buf, size_t buf_size,
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-    if (buf_size < sizeof(struct hg_core_header_response)) {
-        HG_LOG_ERROR("Invalid buffer size");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(buf_size < sizeof(struct hg_core_header_response), done, ret,
+        HG_OVERFLOW, "Invalid buffer size");
 
 #ifdef HG_HAS_CHECKSUMS
     /* Reset header checksum first */
@@ -249,12 +240,9 @@ hg_core_header_response_proc(hg_proc_op_t op, void *buf, size_t buf_size,
     hg_proc_buf_memcpy(buf_ptr, &n_hash_header, sizeof(n_hash_header), op);
     if (op == HG_DECODE) {
         hg_uint16_t h_hash_header = ntohs(n_hash_header);
-        if (header->hash.header != h_hash_header) {
-            HG_LOG_ERROR("checksum 0x%04X does not match (expected 0x%04X!)",
-                header->hash.header, h_hash_header);
-            ret = HG_CHECKSUM_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(header->hash.header != h_hash_header, done, ret,
+            HG_CHECKSUM_ERROR,
+            "checksum 0x%04X does not match (expected 0x%04X!)");
     }
 #endif
 
@@ -270,18 +258,12 @@ hg_core_header_request_verify(const struct hg_core_header *hg_core_header)
     hg_return_t ret = HG_SUCCESS;
 
     /* Must match HG */
-    if ((((header->hg >> 1)  & 'H') != 'H') ||
-        (((header->hg)       & 'G') != 'G')) {
-        HG_LOG_ERROR("Invalid HG byte");
-        ret = HG_NO_MATCH;
-        goto done;
-    }
+    HG_CHECK_ERROR(
+        (((header->hg >> 1) & 'H') != 'H') || (((header->hg) & 'G') != 'G'),
+        done, ret, HG_PROTOCOL_ERROR, "Invalid HG byte");
 
-    if (header->protocol != HG_CORE_PROTOCOL_VERSION) {
-        HG_LOG_ERROR("Invalid protocol version");
-        ret = HG_NO_MATCH;
-        goto done;
-    }
+    HG_CHECK_ERROR(header->protocol != HG_CORE_PROTOCOL_VERSION, done, ret,
+        HG_PROTONOSUPPORT, "Invalid protocol version");
 
 done:
     return ret;
@@ -294,9 +276,8 @@ hg_core_header_response_verify(const struct hg_core_header *hg_core_header)
     const struct hg_core_header_response *header = &hg_core_header->msg.response;
     hg_return_t ret = HG_SUCCESS;
 
-    if (header->ret_code)
-        HG_LOG_WARNING("Response return code: %s",
-            HG_Error_to_string((hg_return_t) header->ret_code));
+    HG_CHECK_WARNING(header->ret_code, "Response return code: %s",
+        HG_Error_to_string((hg_return_t) header->ret_code));
 
     return ret;
 }
diff --git a/src/mercury_core_header.h b/src/mercury_core_header.h
index a72e24f..a742da4 100644
--- a/src/mercury_core_header.h
+++ b/src/mercury_core_header.h
@@ -132,7 +132,7 @@ hg_core_header_response_get_size(void)
  * \param hg_core_header [IN/OUT]   pointer to request header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_request_init(
         struct hg_core_header *hg_core_header
         );
@@ -143,7 +143,7 @@ hg_core_header_request_init(
  * \param hg_core_header [IN/OUT]   pointer to response header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_response_init(
         struct hg_core_header *hg_core_header
         );
@@ -154,7 +154,7 @@ hg_core_header_response_init(
  * \param hg_core_header [IN/OUT]   pointer to request header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_request_finalize(
         struct hg_core_header *hg_core_header
         );
@@ -165,7 +165,7 @@ hg_core_header_request_finalize(
  * \param hg_core_header [IN/OUT]   pointer to response header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_response_finalize(
         struct hg_core_header *hg_core_header
         );
@@ -176,7 +176,7 @@ hg_core_header_response_finalize(
  * \param hg_core_header [IN/OUT]   pointer to request header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_request_reset(
         struct hg_core_header *hg_core_header
         );
@@ -187,7 +187,7 @@ hg_core_header_request_reset(
  * \param hg_core_header [IN/OUT]   pointer to response header structure
  *
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_core_header_response_reset(
         struct hg_core_header *hg_core_header
         );
@@ -202,7 +202,7 @@ hg_core_header_response_reset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PRIVATE hg_return_t
 hg_core_header_request_proc(
         hg_proc_op_t op,
         void *buf,
@@ -220,7 +220,7 @@ hg_core_header_request_proc(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PRIVATE hg_return_t
 hg_core_header_response_proc(
         hg_proc_op_t op,
         void *buf,
@@ -235,7 +235,7 @@ hg_core_header_response_proc(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PRIVATE hg_return_t
 hg_core_header_request_verify(
         const struct hg_core_header *hg_core_header
         );
@@ -247,7 +247,7 @@ hg_core_header_request_verify(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PRIVATE hg_return_t
 hg_core_header_response_verify(
         const struct hg_core_header *hg_core_header
         );
diff --git a/src/mercury_core_types.h b/src/mercury_core_types.h
index 4bec24a..244e0fe 100644
--- a/src/mercury_core_types.h
+++ b/src/mercury_core_types.h
@@ -30,21 +30,42 @@ struct hg_init_info {
 };
 
 /* Error return codes:
- * Functions return 0 for success or HG_XXX_ERROR for failure */
-typedef enum hg_return {
-    HG_SUCCESS = 0,     /*!< operation succeeded */
-    HG_NA_ERROR,        /*!< error in NA layer */
-    HG_TIMEOUT,         /*!< reached timeout */
-    HG_INVALID_PARAM,   /*!< invalid parameter */
-    HG_SIZE_ERROR,      /*!< size error */
-    HG_NOMEM_ERROR,     /*!< no memory error */
-    HG_PROTOCOL_ERROR,  /*!< protocol does not match */
-    HG_NO_MATCH,        /*!< no function match */
-    HG_CHECKSUM_ERROR,  /*!< checksum error */
-    HG_CANCELED,        /*!< operation was canceled */
-    HG_CANCEL_ERROR,    /*!< operation could not be canceled */
-    HG_OTHER_ERROR      /*!< error from mercury_util or external to mercury */
-} hg_return_t;
+ * Functions return 0 for success or corresponding return code */
+#define HG_RETURN_VALUES                                                    \
+    X(HG_SUCCESS)           /*!< operation succeeded */                     \
+    X(HG_PERMISSION)        /*!< operation not permitted */                 \
+    X(HG_NOENTRY)           /*!< no such file or directory */               \
+    X(HG_INTERRUPT)         /*!< operation interrupted */                   \
+    X(HG_AGAIN)             /*!< operation must be retried */               \
+    X(HG_NOMEM)             /*!< out of memory */                           \
+    X(HG_ACCESS)            /*!< permission denied */                       \
+    X(HG_FAULT)             /*!< bad address */                             \
+    X(HG_BUSY)              /*!< device or resource busy */                 \
+    X(HG_NODEV)             /*!< no such device */                          \
+    X(HG_INVALID_ARG)       /*!< invalid argument */                        \
+    X(HG_PROTOCOL_ERROR)    /*!< protocol error */                          \
+    X(HG_OVERFLOW)          /*!< value too large */                         \
+    X(HG_MSGSIZE)           /*!< message size too long */                   \
+    X(HG_PROTONOSUPPORT)    /*!< protocol not supported */                  \
+    X(HG_OPNOTSUPPORTED)    /*!< operation not supported on endpoint */     \
+    X(HG_ADDRINUSE)         /*!< address already in use */                  \
+    X(HG_ADDRNOTAVAIL)      /*!< cannot assign requested address */         \
+    X(HG_TIMEOUT)           /*!< operation reached timeout */               \
+    X(HG_CANCELED)          /*!< operation canceled */                      \
+    X(HG_CHECKSUM_ERROR)    /*!< checksum error */                          \
+    X(HG_NA_ERROR)          /*!< generic NA error */                        \
+    X(HG_OTHER_ERROR)       /*!< generic HG error */                        \
+    X(HG_RETURN_MAX)
+
+#define X(a) a,
+typedef enum hg_return { HG_RETURN_VALUES } hg_return_t;
+#undef X
+
+/* Compat return codes */
+#define HG_INVALID_PARAM    HG_INVALID_ARG
+#define HG_SIZE_ERROR       HG_MSGSIZE
+#define HG_NOMEM_ERROR      HG_NOMEM
+#define HG_NO_MATCH         HG_NOENTRY
 
 /* Callback operation type */
 typedef enum hg_cb_type {
diff --git a/src/mercury_error.h b/src/mercury_error.h
index 5b49a1b..75262c2 100644
--- a/src/mercury_error.h
+++ b/src/mercury_error.h
@@ -19,18 +19,85 @@
 
 /* Default error macro */
 #ifdef HG_HAS_VERBOSE_ERROR
-  #include <mercury_log.h>
-  #define HG_LOG_MODULE_NAME "HG"
-  #define HG_LOG_ERROR(...)                                 \
-      HG_LOG_WRITE_ERROR(HG_LOG_MODULE_NAME, __VA_ARGS__)
-  #define HG_LOG_DEBUG(...)                                 \
-      HG_LOG_WRITE_DEBUG(HG_LOG_MODULE_NAME, __VA_ARGS__)
-  #define HG_LOG_WARNING(...)                               \
-      HG_LOG_WRITE_WARNING(HG_LOG_MODULE_NAME, __VA_ARGS__)
+# include <mercury_log.h>
+# define HG_LOG_MASK hg_log_mask
+/* Log mask will be initialized in init routine */
+extern HG_PRIVATE unsigned int HG_LOG_MASK;
+# define HG_LOG_MODULE_NAME    "HG"
+# define HG_LOG_ERROR(...) do {                                 \
+    if (HG_LOG_MASK & HG_LOG_TYPE_ERROR)                        \
+        HG_LOG_WRITE_ERROR(HG_LOG_MODULE_NAME, __VA_ARGS__);    \
+} while (0)
+# define HG_LOG_DEBUG(...) do {                                 \
+    if (HG_LOG_MASK & HG_LOG_TYPE_DEBUG)                        \
+        HG_LOG_WRITE_DEBUG(HG_LOG_MODULE_NAME, __VA_ARGS__);    \
+} while (0)
+# define HG_LOG_WARNING(...) do {                               \
+    if (HG_LOG_MASK & HG_LOG_TYPE_WARNING)                      \
+        HG_LOG_WRITE_WARNING(HG_LOG_MODULE_NAME, __VA_ARGS__);  \
+} while (0)
 #else
-  #define HG_LOG_ERROR(...) (void)0
-  #define HG_LOG_DEBUG(...) (void)0
-  #define HG_LOG_WARNING(...) (void)0
+# define HG_LOG_ERROR(...)      (void)0
+# define HG_LOG_DEBUG(...)      (void)0
+# define HG_LOG_WARNING(...)    (void)0
 #endif
 
+/* Branch predictor hints */
+#ifndef _WIN32
+# define likely(x)       __builtin_expect(!!(x), 1)
+# define unlikely(x)     __builtin_expect(!!(x), 0)
+#else
+# define likely(x)       (x)
+# define unlikely(x)     (x)
+#endif
+
+/* Error macros */
+#define HG_GOTO_DONE(label, ret, ret_val) do {                  \
+    ret = ret_val;                                              \
+    goto label;                                                 \
+} while (0)
+
+#define HG_GOTO_ERROR(label, ret, err_val, ...) do {            \
+    HG_LOG_ERROR(__VA_ARGS__);                                  \
+    ret = err_val;                                              \
+    goto label;                                                 \
+} while (0)
+
+/* Check for hg_ret value and goto label */
+#define HG_CHECK_HG_ERROR(label, hg_ret, ...) do {              \
+    if (unlikely(hg_ret != HG_SUCCESS)) {                       \
+        HG_LOG_ERROR(__VA_ARGS__);                              \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+/* Check for cond, set ret to err_val and goto label */
+#define HG_CHECK_ERROR(cond, label, ret, err_val, ...) do {     \
+    if (unlikely(cond)) {                                       \
+        HG_LOG_ERROR(__VA_ARGS__);                              \
+        ret = err_val;                                          \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define HG_CHECK_ERROR_NORET(cond, label, ...) do {             \
+    if (unlikely(cond)) {                                       \
+        HG_LOG_ERROR(__VA_ARGS__);                              \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define HG_CHECK_ERROR_DONE(cond, ...) do {                     \
+    if (unlikely(cond)) {                                       \
+        HG_LOG_ERROR(__VA_ARGS__);                              \
+    }                                                           \
+} while (0)
+
+/* Check for cond and print warning */
+#define HG_CHECK_WARNING(cond, ...) do {                        \
+    if (unlikely(cond)) {                                       \
+        HG_LOG_WARNING(__VA_ARGS__);                            \
+    }                                                           \
+} while (0)
+
 #endif /* MERCURY_ERROR_H */
diff --git a/src/mercury_header.c b/src/mercury_header.c
index 296092b..a281eaf 100644
--- a/src/mercury_header.c
+++ b/src/mercury_header.c
@@ -92,29 +92,21 @@ hg_header_proc(hg_proc_op_t op, void *buf, size_t buf_size,
 
     switch (hg_header->op) {
         case HG_INPUT:
-            if (buf_size < sizeof(struct hg_header_input)) {
-                HG_LOG_ERROR("Invalid buffer size");
-                ret = HG_INVALID_PARAM;
-                goto done;
-            }
+            HG_CHECK_ERROR(buf_size < sizeof(struct hg_header_input), done, ret,
+                HG_INVALID_ARG, "Invalid buffer size");
 #ifdef HG_HAS_CHECKSUMS
             header_hash = &hg_header->msg.input.hash;
 #endif
             break;
         case HG_OUTPUT:
-            if (buf_size < sizeof(struct hg_header_output)) {
-                HG_LOG_ERROR("Invalid buffer size");
-                ret = HG_SIZE_ERROR;
-                goto done;
-            }
+            HG_CHECK_ERROR(buf_size < sizeof(struct hg_header_output), done,
+                ret, HG_INVALID_ARG, "Invalid buffer size");
 #ifdef HG_HAS_CHECKSUMS
             header_hash = &hg_header->msg.output.hash;
 #endif
             break;
         default:
-            HG_LOG_ERROR("Invalid header op");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid header op");
     }
 
 #ifdef HG_HAS_CHECKSUMS
diff --git a/src/mercury_header.h b/src/mercury_header.h
index 74c458f..48d7de6 100644
--- a/src/mercury_header.h
+++ b/src/mercury_header.h
@@ -102,7 +102,7 @@ hg_header_get_size(hg_op_t op)
  * \param hg_header [IN/OUT]    pointer to header structure
  * \param op [IN]               HG operation type: HG_INPUT / HG_OUTPUT
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_header_init(
         struct hg_header *hg_header,
         hg_op_t op
@@ -113,7 +113,7 @@ hg_header_init(
  *
  * \param hg_header [IN/OUT]    pointer to header structure
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_header_finalize(
         struct hg_header *hg_header
         );
@@ -124,7 +124,7 @@ hg_header_finalize(
  * \param hg_header [IN/OUT]    pointer to header structure
  * \param op [IN]               HG operation type: HG_INPUT / HG_OUTPUT
  */
-HG_EXPORT void
+HG_PRIVATE void
 hg_header_reset(
         struct hg_header *hg_header,
         hg_op_t op
@@ -140,7 +140,7 @@ hg_header_reset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PRIVATE hg_return_t
 hg_header_proc(
         hg_proc_op_t op,
         void *buf,
diff --git a/src/mercury_hl.c b/src/mercury_hl.c
index 4cbd025..fdd6296 100644
--- a/src/mercury_hl.c
+++ b/src/mercury_hl.c
@@ -74,6 +74,11 @@ hg_request_class_t *HG_REQUEST_CLASS_DEFAULT = NULL;
 /* For convenience, register HG_Hl_finalize() */
 static hg_bool_t hg_atexit_g = HG_FALSE;
 
+/* Default error log mask */
+#ifdef HG_HAS_VERBOSE_ERROR
+unsigned int HG_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
+#endif
+
 /*---------------------------------------------------------------------------*/
 static int
 hg_hl_request_progress(unsigned int timeout, void *arg)
@@ -153,11 +158,9 @@ HG_Hl_init(const char *na_info_string, hg_bool_t na_listen)
 
     /* First register finalize function if not set */
     if (!hg_atexit_g) {
-        if (atexit(hg_hl_finalize) != 0) {
-            HG_LOG_ERROR("Cannot set exit function");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        int rc = atexit(hg_hl_finalize);
+        HG_CHECK_ERROR(rc != 0, done, ret, HG_INVALID_ARG,
+            "Cannot set exit function");
         hg_atexit_g = HG_TRUE;
     }
 
@@ -165,40 +168,29 @@ HG_Hl_init(const char *na_info_string, hg_bool_t na_listen)
     if (!na_info_string) {
         na_info_string = getenv(HG_PORT_NAME);
     }
-    if (!na_info_string) {
-        HG_LOG_ERROR(HG_PORT_NAME " environment variable must be set");
-        goto done;
-    }
+    HG_CHECK_ERROR(na_info_string == NULL, done, ret, HG_INVALID_ARG,
+        HG_PORT_NAME " environment variable must be set");
 
     /* Initialize HG */
     if (!HG_CLASS_DEFAULT) {
         HG_CLASS_DEFAULT = HG_Init(na_info_string, na_listen);
-        if (!HG_CLASS_DEFAULT) {
-            HG_LOG_ERROR("Could not initialize HG class");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_CLASS_DEFAULT == NULL, done, ret, HG_FAULT,
+            "Could not initialize HG class");
     }
 
     /* Create HG context */
     if (!HG_CONTEXT_DEFAULT) {
         HG_CONTEXT_DEFAULT = HG_Context_create(HG_CLASS_DEFAULT);
-        if (!HG_CONTEXT_DEFAULT) {
-            HG_LOG_ERROR("Could not create HG context");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_CONTEXT_DEFAULT == NULL, done, ret, HG_FAULT,
+            "Could not create HG context");
     }
 
     /* Initialize request class */
     if (!HG_REQUEST_CLASS_DEFAULT) {
         HG_REQUEST_CLASS_DEFAULT = hg_request_init(hg_hl_request_progress,
                 hg_hl_request_trigger, HG_CONTEXT_DEFAULT);
-        if (!HG_REQUEST_CLASS_DEFAULT) {
-            HG_LOG_ERROR("Could not create HG request class");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_REQUEST_CLASS_DEFAULT == NULL, done, ret,
+            HG_FAULT, "Could not create HG request class");
     }
 
 done:
@@ -214,43 +206,32 @@ HG_Hl_init_opt(const char *na_info_string, hg_bool_t na_listen,
 
     /* First register finalize function if not set */
     if (!hg_atexit_g) {
-        if (atexit(hg_hl_finalize) != 0) {
-            HG_LOG_ERROR("Cannot set exit function");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        int rc = atexit(hg_hl_finalize);
+        HG_CHECK_ERROR(rc != 0, done, ret, HG_INVALID_ARG,
+            "Cannot set exit function");
         hg_atexit_g = HG_TRUE;
     }
 
     /* Initialize HG */
     if (!HG_CLASS_DEFAULT) {
         HG_CLASS_DEFAULT = HG_Init_opt(na_info_string, na_listen, hg_init_info);
-        if (!HG_CLASS_DEFAULT) {
-            HG_LOG_ERROR("Could not initialize HG class");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_CLASS_DEFAULT == NULL, done, ret, HG_FAULT,
+            "Could not initialize HG class");
     }
 
     /* Create HG context */
     if (!HG_CONTEXT_DEFAULT) {
         HG_CONTEXT_DEFAULT = HG_Context_create(HG_CLASS_DEFAULT);
-        if (!HG_CONTEXT_DEFAULT) {
-            HG_LOG_ERROR("Could not create HG context");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_CONTEXT_DEFAULT == NULL, done, ret, HG_FAULT,
+            "Could not create HG context");
     }
 
     /* Initialize request class */
     if (!HG_REQUEST_CLASS_DEFAULT) {
         HG_REQUEST_CLASS_DEFAULT = hg_request_init(hg_hl_request_progress,
                 hg_hl_request_trigger, HG_CONTEXT_DEFAULT);
-        if (!HG_REQUEST_CLASS_DEFAULT) {
-            HG_LOG_ERROR("Could not create HG request class");
-            ret = HG_PROTOCOL_ERROR;
-            goto done;
-        }
+        HG_CHECK_ERROR(HG_REQUEST_CLASS_DEFAULT == NULL, done, ret, HG_FAULT,
+            "Could not create HG request class");
     }
 
 done:
@@ -272,20 +253,14 @@ HG_Hl_finalize(void)
     /* Destroy context */
     if (HG_CONTEXT_DEFAULT) {
         ret = HG_Context_destroy(HG_CONTEXT_DEFAULT);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not destroy HG context");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not destroy HG context");
         HG_CONTEXT_DEFAULT = NULL;
     }
 
     /* Finalize interface */
     if (HG_CLASS_DEFAULT) {
         ret = HG_Finalize(HG_CLASS_DEFAULT);
-        if (ret != HG_SUCCESS) {
-            HG_LOG_ERROR("Could not finalize HG class");
-            goto done;
-        }
+        HG_CHECK_HG_ERROR(done, ret, "Could not finalize HG class");
         HG_CLASS_DEFAULT = NULL;
     }
 
@@ -303,11 +278,8 @@ HG_Hl_addr_lookup_wait(hg_context_t *context, hg_request_class_t *request_class,
     unsigned int flag = 0;
     struct hg_lookup_request_arg request_args;
 
-    if (!request_class) {
-        HG_LOG_ERROR("Uninitialized request class");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(request_class == NULL, done, ret, HG_INVALID_ARG,
+        "Uninitialized request class");
 
     request = hg_request_create(request_class);
     request_args.addr_ptr = addr;
@@ -316,18 +288,12 @@ HG_Hl_addr_lookup_wait(hg_context_t *context, hg_request_class_t *request_class,
     /* Forward call to remote addr and get a new request */
     ret = HG_Addr_lookup(context, hg_hl_addr_lookup_cb, &request_args, name,
             HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not lookup address");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not lookup address");
 
     /* Wait for request to be marked completed */
     hg_request_wait(request, timeout, &flag);
-    if (!flag) {
-        HG_LOG_ERROR("Operation did not complete");
-        ret = HG_TIMEOUT;
-        goto done;
-    }
+    HG_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
+        "Operation did not complete");
 
     /* Free request */
     hg_request_destroy(request);
@@ -346,28 +312,19 @@ HG_Hl_forward_wait(hg_request_class_t *request_class, hg_handle_t handle,
     hg_return_t ret = HG_SUCCESS;
     unsigned int flag = 0;
 
-    if (!request_class) {
-        HG_LOG_ERROR("Uninitialized request class");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(request_class == NULL, done, ret, HG_INVALID_ARG,
+        "Uninitialized request class");
 
     request = hg_request_create(request_class);
 
     /* Forward call to remote addr and get a new request */
     ret = HG_Forward(handle, hg_hl_forward_cb, request, in_struct);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not forward call");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not forward call");
 
     /* Wait for request to be marked completed */
     hg_request_wait(request, timeout, &flag);
-    if (!flag) {
-        HG_LOG_ERROR("Operation did not complete");
-        ret = HG_TIMEOUT;
-        goto done;
-    }
+    HG_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
+        "Operation did not complete");
 
     /* Free request */
     hg_request_destroy(request);
@@ -388,11 +345,8 @@ HG_Hl_bulk_transfer_wait(hg_context_t *context,
     hg_return_t ret = HG_SUCCESS;
     unsigned int flag = 0;
 
-    if (!request_class) {
-        HG_LOG_ERROR("Uninitialized request class");
-        ret = HG_PROTOCOL_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(request_class == NULL, done, ret, HG_INVALID_ARG,
+        "Uninitialized request class");
 
     request = hg_request_create(request_class);
 
@@ -400,18 +354,12 @@ HG_Hl_bulk_transfer_wait(hg_context_t *context,
     ret = HG_Bulk_transfer(context, hg_hl_bulk_transfer_cb, request, op,
             origin_addr, origin_handle, origin_offset, local_handle,
             local_offset, size, HG_OP_ID_IGNORE);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not transfer data");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not transfer data");
 
     /* Wait for request to be marked completed */
     hg_request_wait(request, timeout, &flag);
-    if (!flag) {
-        HG_LOG_ERROR("Operation did not complete");
-        ret = HG_TIMEOUT;
-        goto done;
-    }
+    HG_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
+        "Operation did not complete");
 
     /* Free request */
     hg_request_destroy(request);
diff --git a/src/mercury_hl.h b/src/mercury_hl.h
index 27938f3..1709e48 100644
--- a/src/mercury_hl.h
+++ b/src/mercury_hl.h
@@ -37,9 +37,9 @@ extern "C" {
 /********************/
 
 /* HG default */
-extern HG_EXPORT hg_class_t *HG_CLASS_DEFAULT;
-extern HG_EXPORT hg_context_t *HG_CONTEXT_DEFAULT;
-extern HG_EXPORT hg_request_class_t *HG_REQUEST_CLASS_DEFAULT;
+extern HG_PUBLIC hg_class_t *HG_CLASS_DEFAULT;
+extern HG_PUBLIC hg_context_t *HG_CONTEXT_DEFAULT;
+extern HG_PUBLIC hg_request_class_t *HG_REQUEST_CLASS_DEFAULT;
 
 /*********************/
 /* Public Prototypes */
@@ -60,7 +60,7 @@ extern HG_EXPORT hg_request_class_t *HG_REQUEST_CLASS_DEFAULT;
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_init(
         const char *na_info_string,
         hg_bool_t na_listen
@@ -81,7 +81,7 @@ HG_Hl_init(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_init_opt(
         const char *na_info_string,
         hg_bool_t na_listen,
@@ -93,7 +93,7 @@ HG_Hl_init_opt(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_finalize(
         void
         );
@@ -104,7 +104,7 @@ HG_Hl_finalize(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_addr_lookup_wait(
         hg_context_t *context,
         hg_request_class_t *request_class,
@@ -120,7 +120,7 @@ HG_Hl_addr_lookup_wait(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_forward_wait(
         hg_request_class_t *request_class,
         hg_handle_t handle,
@@ -144,7 +144,7 @@ HG_Hl_forward_wait(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 HG_Hl_bulk_transfer_wait(
         hg_context_t *context,
         hg_request_class_t *request_class,
diff --git a/src/mercury_hl_macros.h b/src/mercury_hl_macros.h
index 49d983b..d527609 100644
--- a/src/mercury_hl_macros.h
+++ b/src/mercury_hl_macros.h
@@ -119,7 +119,6 @@
 #define HG_GET_OUTPUT(with_ret, ret_fail) \
         hg_ret = HG_Get_output(handle, &out_struct); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not get output"); \
             BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
             goto done; \
         }
@@ -128,7 +127,6 @@
 #define HG_FREE_OUTPUT(with_ret, ret_fail) \
         hg_ret = HG_Free_output(handle, &out_struct); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not free output"); \
             BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
             goto done; \
         }
@@ -157,7 +155,6 @@
                 BOOST_PP_IF(bulk_read, HG_BULK_READ_ONLY, HG_BULK_READWRITE), \
                 &bulk_handle); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not create HG bulk handle\n"); \
             BOOST_PP_IF(with_ret, ret = fail_ret;, BOOST_PP_EMPTY()) \
             goto done; \
         }
@@ -166,7 +163,6 @@
 #define HG_BULK_FREE(bulk_handle, with_ret, fail_ret) \
         hg_ret = HG_Bulk_free(bulk_handle); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not free HG bulk handle"); \
             BOOST_PP_IF(with_ret, ret = fail_ret;, BOOST_PP_EMPTY()) \
             goto done; \
         } \
@@ -194,7 +190,6 @@
 #define HG_BULK_LOCAL_FREE(local_bulk_handle) \
         hg_ret = HG_Bulk_free(local_bulk_handle); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not free block call"); \
             goto done; \
         } \
         free(HG_GEN_GET_NAME(BOOST_PP_SEQ_HEAD(HG_BULK_BUF)));
@@ -212,7 +207,6 @@
                 0, \
                 HG_GEN_GET_NAME(BOOST_PP_SEQ_HEAD(HG_BULK_COUNT))); \
         if (hg_ret != HG_SUCCESS) { \
-            HG_LOG_ERROR("Could not transfer bulk data"); \
             goto done; \
         }
 
@@ -280,7 +274,6 @@
             hg_ret = HG_Create(HG_CLASS_DEFAULT, HG_CONTEXT_DEFAULT, \
                     NA_ADDR_DEFAULT, id, &handle); \
             if (hg_ret != HG_SUCCESS) { \
-                HG_LOG_ERROR("Could not create HG handle"); \
                 BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
                 goto done; \
             } \
@@ -302,7 +295,6 @@
             hg_ret = HG_Hl_forward_wait(handle, \
                     BOOST_PP_IF(with_input, &in_struct, NULL)); \
             if (hg_ret != HG_SUCCESS) { \
-                HG_LOG_ERROR("Could not forward call"); \
                 BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
                 goto done; \
             } \
@@ -331,7 +323,6 @@
             /* Destroy handle */ \
             hg_ret = HG_Destroy(handle); \
             if (hg_ret != HG_SUCCESS) { \
-                HG_LOG_ERROR("Could not destroy HG handle"); \
                 BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
                 goto done; \
             } \
@@ -375,7 +366,6 @@
                 BOOST_PP_IF(with_input, \
                         hg_ret = HG_Get_input(handle, &in_struct); \
                         if (hg_ret != HG_SUCCESS) { \
-                            HG_LOG_ERROR("Could not get input"); \
                             goto done; \
                         } \
                         \
@@ -432,7 +422,6 @@
                                 &out_struct, \
                                 NULL) ); \
                 if (hg_ret != HG_SUCCESS) { \
-                    HG_LOG_ERROR("Could not respond"); \
                     goto done; \
                 } \
                 \
@@ -440,7 +429,6 @@
                 BOOST_PP_IF(with_input, \
                         hg_ret = HG_Free_input(handle, &in_struct); \
                         if (hg_ret != HG_SUCCESS) { \
-                            HG_LOG_ERROR("Could not free input"); \
                             goto done; \
                         } \
                         , BOOST_PP_EMPTY()) \
@@ -448,7 +436,6 @@
                 /* Destroy handle */ \
                 hg_ret = HG_Destroy(handle); \
                 if (hg_ret != HG_SUCCESS) { \
-                    HG_LOG_ERROR("Could not destroy HG handle"); \
                     goto done; \
                 } \
                 \
diff --git a/src/mercury_macros.h b/src/mercury_macros.h
index 8f4e330..98f48d9 100644
--- a/src/mercury_macros.h
+++ b/src/mercury_macros.h
@@ -53,7 +53,6 @@ typedef struct \
     ret = BOOST_PP_CAT(hg_proc_, HG_GEN_GET_TYPE(field) \
             (proc, &struct_name->HG_GEN_GET_NAME(field))); \
     if (ret != HG_SUCCESS) { \
-      HG_LOG_ERROR("Proc error"); \
       return ret; \
     }
 
diff --git a/src/mercury_private.h b/src/mercury_private.h
index 781d906..ef610d9 100644
--- a/src/mercury_private.h
+++ b/src/mercury_private.h
@@ -28,13 +28,13 @@ typedef enum {
 
 /* Completion queue entry */
 struct hg_completion_entry {
-    hg_op_type_t op_type;
     union {
         struct hg_core_op_id *hg_core_op_id;
         hg_core_handle_t hg_core_handle;
         struct hg_bulk_op_id *hg_bulk_op_id;
     } op_id;
     HG_QUEUE_ENTRY(hg_completion_entry) entry;
+    hg_op_type_t op_type;
 };
 
 #endif /* MERCURY_PRIVATE_H */
diff --git a/src/mercury_proc.c b/src/mercury_proc.c
index 94fd0ca..95853ad 100644
--- a/src/mercury_proc.c
+++ b/src/mercury_proc.c
@@ -10,11 +10,11 @@
 
 #include "mercury_proc.h"
 #include "mercury_proc_buf.h"
+#include "mercury_error.h"
 #include "mercury_mem.h"
 
 #ifdef HG_HAS_CHECKSUMS
 # include <mchecksum.h>
-# include <mchecksum_error.h>
 #endif
 
 /****************/
@@ -26,27 +26,27 @@
 /************************************/
 
 struct hg_proc_buf {
-    void *    buf;       /* Pointer to allocated buffer */
-    void *    buf_ptr;   /* Pointer to current position */
-    hg_size_t size;      /* Total buffer size */
-    hg_size_t size_left; /* Available size for user */
+    void *buf;              /* Pointer to allocated buffer */
+    void *buf_ptr;          /* Pointer to current position */
+    hg_size_t size;         /* Total buffer size */
+    hg_size_t size_left;    /* Available size for user */
     hg_bool_t is_mine;
 #ifdef HG_HAS_XDR
-    XDR      xdr;
+    XDR xdr;
 #endif
 };
 
 struct hg_proc {
-    hg_class_t *hg_class;               /* HG class */
-    hg_proc_op_t op;
     struct hg_proc_buf proc_buf;
     struct hg_proc_buf extra_buf;
+    hg_class_t *hg_class;           /* HG class */
     struct hg_proc_buf *current_buf;
 #ifdef HG_HAS_CHECKSUMS
     mchecksum_object_t checksum;    /* Checksum */
     void *checksum_hash;            /* Base checksum buf */
     size_t checksum_size;           /* Checksum size */
 #endif
+    hg_proc_op_t op;
 };
 
 /********************/
@@ -77,18 +77,13 @@ hg_proc_create(hg_class_t *hg_class, hg_proc_hash_t hash, hg_proc_t *proc)
     const char *hash_method;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_class) {
-        HG_LOG_ERROR("NULL HG class");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_class == NULL, error, ret, HG_INVALID_ARG,
+        "NULL HG class");
 
     hg_proc = (struct hg_proc *) malloc(sizeof(struct hg_proc));
-    if (!hg_proc) {
-        HG_LOG_ERROR("Could not allocate proc");
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(hg_proc == NULL, error, ret, HG_NOMEM,
+        "Could not allocate proc");
+
     memset(hg_proc, 0, sizeof(struct hg_proc));
     hg_proc->hg_class = hg_class;
 
@@ -108,34 +103,34 @@ hg_proc_create(hg_class_t *hg_class, hg_proc_hash_t hash, hg_proc_t *proc)
             break;
     }
 
-    if (hash_method) {
 #ifdef HG_HAS_CHECKSUMS
-        int checksum_ret;
-
-        checksum_ret = mchecksum_init(hash_method, &hg_proc->checksum);
-        if (checksum_ret != MCHECKSUM_SUCCESS) {
-            HG_LOG_ERROR("Could not initialize checksum");
-            ret = HG_CHECKSUM_ERROR;
-            goto done;
-        }
+    if (hash_method) {
+        int rc = mchecksum_init(hash_method, &hg_proc->checksum);
+        HG_CHECK_ERROR(rc < 0, error, ret, HG_CHECKSUM_ERROR,
+            "Could not initialize checksum");
 
         hg_proc->checksum_size = mchecksum_get_size(hg_proc->checksum);
         hg_proc->checksum_hash = (char *) malloc(hg_proc->checksum_size);
-        if (!hg_proc->checksum_hash) {
-            HG_LOG_ERROR("Could not allocate space for checksum hash");
-            ret = HG_NOMEM_ERROR;
-            goto done;
-        }
-#endif
+        HG_CHECK_ERROR(hg_proc->checksum_hash == NULL, error, ret,
+            HG_NOMEM, "Could not allocate space for checksum hash");
     }
+#endif
 
     /* Default to proc_buf */
     hg_proc->current_buf = &hg_proc->proc_buf;
 
     *proc = (struct hg_proc *) hg_proc;
 
-done:
-    if (ret != HG_SUCCESS) {
+    return ret;
+
+error:
+    if (hg_proc) {
+#ifdef HG_HAS_CHECKSUMS
+        if (hash_method && hg_proc->checksum != MCHECKSUM_OBJECT_NULL) {
+            free(hg_proc->checksum_hash);
+            mchecksum_destroy(hg_proc->checksum);
+        }
+#endif
         free(hg_proc);
     }
     return ret;
@@ -146,24 +141,23 @@ hg_return_t
 hg_proc_create_set(hg_class_t *hg_class, void *buf, hg_size_t buf_size,
     hg_proc_op_t op, hg_proc_hash_t hash, hg_proc_t *proc)
 {
-    hg_proc_t hg_proc;
+    hg_proc_t hg_proc = HG_PROC_NULL;
     hg_return_t ret = HG_SUCCESS;
 
     ret = hg_proc_create(hg_class, hash, &hg_proc);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not create proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not create proc");
 
     ret = hg_proc_reset(hg_proc, buf, buf_size, op);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not reset proc");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(error, ret, "Could not reset proc");
 
     *proc = hg_proc;
 
-done:
+    return ret;
+
+error:
+    if (hg_proc != HG_PROC_NULL)
+        hg_proc_free(hg_proc);
+
     return ret;
 }
 
@@ -174,19 +168,15 @@ hg_proc_free(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) goto done;
+    if (!hg_proc)
+        goto done;
 
 #ifdef HG_HAS_CHECKSUMS
     if (hg_proc->checksum != MCHECKSUM_OBJECT_NULL) {
-        int checksum_ret;
-
-        checksum_ret = mchecksum_destroy(hg_proc->checksum);
-        if (checksum_ret != MCHECKSUM_SUCCESS) {
-            HG_LOG_ERROR("Could not destroy checksum");
-            ret = HG_CHECKSUM_ERROR;
-        }
+        int rc = mchecksum_destroy(hg_proc->checksum);
+        HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
+            "Could not destroy checksum");
     }
-
     free(hg_proc->checksum_hash);
 #endif
 
@@ -208,13 +198,11 @@ hg_proc_reset(hg_proc_t proc, void *buf, hg_size_t buf_size, hg_proc_op_t op)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) goto done;
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "NULL HG proc");
+    HG_CHECK_ERROR(!buf && op != HG_FREE, done, ret, HG_INVALID_ARG,
+        "NULL buffer");
 
-    if (!buf && op != HG_FREE) {
-        HG_LOG_ERROR("NULL buffer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
     hg_proc->op = op;
 #ifdef HG_HAS_XDR
     switch (op) {
@@ -228,9 +216,8 @@ hg_proc_reset(hg_proc_t proc, void *buf, hg_size_t buf_size, hg_proc_op_t op)
             xdrmem_create(&hg_proc->proc_buf.xdr, (char *) buf, buf_size, XDR_FREE);
             break;
         default:
-            HG_LOG_ERROR("Unknown proc operation");
-            ret = HG_INVALID_PARAM;
-            goto done;
+            HG_GOTO_ERROR(done, ret, HG_INVALID_PARAM,
+                "Unknown proc operation");
     }
 #endif
 
@@ -254,13 +241,9 @@ hg_proc_reset(hg_proc_t proc, void *buf, hg_size_t buf_size, hg_proc_op_t op)
 #ifdef HG_HAS_CHECKSUMS
     /* Reset checksum */
     if (hg_proc->checksum != MCHECKSUM_OBJECT_NULL) {
-        int checksum_ret;
-
-        checksum_ret = mchecksum_reset(hg_proc->checksum);
-        if (checksum_ret != MCHECKSUM_SUCCESS) {
-            HG_LOG_ERROR("Could not reset checksum");
-            ret = HG_CHECKSUM_ERROR;
-        }
+        int rc = mchecksum_reset(hg_proc->checksum);
+        HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
+            "Could not reset checksum");
         memset(hg_proc->checksum_hash, 0, hg_proc->checksum_size);
     }
 #endif
@@ -276,10 +259,7 @@ hg_proc_get_class(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_class_t *hg_class = NULL;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     hg_class = hg_proc->hg_class;
 
@@ -294,10 +274,7 @@ hg_proc_get_op(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_proc_op_t proc_op = HG_ENCODE;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     proc_op = hg_proc->op;
 
@@ -312,10 +289,7 @@ hg_proc_get_size(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_size_t size = 0;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     size = hg_proc->proc_buf.size + hg_proc->extra_buf.size;
 
@@ -330,10 +304,7 @@ hg_proc_get_size_used(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_size_t size = 0;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     size = hg_proc->current_buf->size - hg_proc->current_buf->size_left;
 
@@ -351,31 +322,30 @@ hg_proc_set_size(hg_proc_t proc, hg_size_t req_buf_size)
     hg_size_t page_size = (hg_size_t) hg_mem_get_page_size();
     void *new_buf = NULL;
     ptrdiff_t current_pos;
+    hg_bool_t allocated = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, error, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
+
     /* Save current position */
     current_pos = (char *) hg_proc->current_buf->buf_ptr -
         (char *) hg_proc->current_buf->buf;
 
     /* Get one more page size buf */
     new_buf_size = ((hg_size_t)(req_buf_size / page_size) + 1) * page_size;
-    if (new_buf_size <= hg_proc_get_size(proc)) {
-        HG_LOG_ERROR("Buffer is already of the size requested");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(new_buf_size <= hg_proc_get_size(proc), error, ret,
+        HG_INVALID_ARG, "Buffer is already of the size requested");
 
     /* If was not using extra buffer init extra buffer */
-    if (!hg_proc->extra_buf.buf)
+    if (!hg_proc->extra_buf.buf) {
         /* Allocate buffer */
         new_buf = hg_mem_aligned_alloc(page_size, new_buf_size);
-    else
+        allocated = HG_TRUE;
+    } else
         new_buf = realloc(hg_proc->extra_buf.buf, new_buf_size);
-    if (!new_buf) {
-        HG_LOG_ERROR("Could not allocate buffer of size %zu", new_buf_size);
-        ret = HG_NOMEM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(new_buf == NULL, error, ret, HG_NOMEM,
+        "Could not allocate buffer of size %zu", new_buf_size);
 
     if (!hg_proc->extra_buf.buf) {
         /* Copy proc_buf (should be small) */
@@ -391,7 +361,11 @@ hg_proc_set_size(hg_proc_t proc, hg_size_t req_buf_size)
     hg_proc->extra_buf.size_left = hg_proc->extra_buf.size - (hg_size_t) current_pos;
     hg_proc->extra_buf.is_mine = HG_TRUE;
 
-done:
+    return ret;
+
+error:
+    if (new_buf && allocated)
+        hg_mem_aligned_free(new_buf);
     return ret;
 }
 
@@ -402,10 +376,7 @@ hg_proc_get_size_left(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_size_t size = 0;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     size = hg_proc->current_buf->size_left;
 
@@ -423,10 +394,7 @@ hg_proc_save_ptr(hg_proc_t proc, hg_size_t data_size)
     unsigned int cur_pos;
 #endif
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        goto done;
-    }
+    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
 
     /* If not enough space allocate extra space if encoding or
      * just get extra buffer if decoding */
@@ -470,10 +438,7 @@ hg_proc_restore_ptr(hg_proc_t proc, void *data, hg_size_t data_size)
 
 #ifdef HG_HAS_CHECKSUMS
     ret = hg_proc_checksum_update(proc, data, data_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not update checksum");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not update checksum");
 #else
     /* Silent warning */
     (void)proc;
@@ -511,10 +476,10 @@ hg_proc_set_extra_buf_is_mine(hg_proc_t proc, hg_bool_t theirs)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc->extra_buf.buf) {
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
+    HG_CHECK_ERROR(hg_proc->extra_buf.buf == NULL, done, ret, HG_INVALID_ARG,
+        "Extra buf is not set");
 
     hg_proc->extra_buf.is_mine = (hg_bool_t) (!theirs);
 
@@ -528,24 +493,18 @@ hg_proc_flush(hg_proc_t proc)
 {
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
 #ifdef HG_HAS_CHECKSUMS
-    int checksum_ret;
+    int rc;
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
 
 #ifdef HG_HAS_CHECKSUMS
-    checksum_ret = mchecksum_get(hg_proc->checksum, hg_proc->checksum_hash,
+    rc = mchecksum_get(hg_proc->checksum, hg_proc->checksum_hash,
         hg_proc->checksum_size, MCHECKSUM_FINALIZE);
-    if (checksum_ret != MCHECKSUM_SUCCESS) {
-        HG_LOG_ERROR("Could not get checksum");
-        ret = HG_CHECKSUM_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
+        "Could not get checksum");
 #endif
 
 done:
@@ -559,32 +518,26 @@ hg_proc_memcpy(hg_proc_t proc, void *data, hg_size_t data_size)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
 
-    if (hg_proc->op == HG_FREE) goto done;
+    if (hg_proc->op == HG_FREE)
+        goto done;
 
     /* If not enough space allocate extra space if encoding or
      * just get extra buffer if decoding */
     if (hg_proc->current_buf->size_left < data_size)
         hg_proc_set_size(proc, hg_proc->proc_buf.size +
-                hg_proc->extra_buf.size + data_size);
+            hg_proc->extra_buf.size + data_size);
 
     /* Process data */
-    hg_proc->current_buf->buf_ptr =
-            hg_proc_buf_memcpy(hg_proc->current_buf->buf_ptr, data, data_size,
-                    hg_proc->op);
+    hg_proc->current_buf->buf_ptr = hg_proc_buf_memcpy(
+        hg_proc->current_buf->buf_ptr, data, data_size, hg_proc->op);
     hg_proc->current_buf->size_left -= data_size;
 
 #ifdef HG_HAS_CHECKSUMS
     ret = hg_proc_checksum_update(proc, data, data_size);
-    if (ret != HG_SUCCESS) {
-        HG_LOG_ERROR("Could not update checksum");
-        goto done;
-    }
+    HG_CHECK_HG_ERROR(done, ret, "Could not update checksum");
 #endif
 
 done:
@@ -597,22 +550,16 @@ static HG_INLINE hg_return_t
 hg_proc_checksum_update(hg_proc_t proc, void *data, hg_size_t data_size)
 {
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
-    int checksum_ret;
     hg_return_t ret = HG_SUCCESS;
+    int rc;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
 
     /* Update checksum */
-    checksum_ret = mchecksum_update(hg_proc->checksum, data, data_size);
-    if (checksum_ret != MCHECKSUM_SUCCESS) {
-        HG_LOG_ERROR("Could not update checksum");
-        ret = HG_CHECKSUM_ERROR;
-        goto done;
-    }
+    rc = mchecksum_update(hg_proc->checksum, data, data_size);
+    HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
+        "Could not update checksum");
 
 done:
     return ret;
@@ -625,23 +572,12 @@ hg_proc_checksum_get(hg_proc_t proc, void *hash, hg_size_t hash_size)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (!hash) {
-        HG_LOG_ERROR("NULL hash pointer");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hash_size < hg_proc->checksum_size) {
-        HG_LOG_ERROR("Hash size passed is too small");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
+    HG_CHECK_ERROR(hash == NULL, done, ret, HG_INVALID_ARG,
+       "NULL hash pointer");
+    HG_CHECK_ERROR(hash_size < hg_proc->checksum_size, done, ret,
+        HG_INVALID_ARG, "Hash size passed is too small");
 
     memcpy(hash, hg_proc->checksum_hash, hg_proc->checksum_size);
 
@@ -656,17 +592,10 @@ hg_proc_checksum_verify(hg_proc_t proc, const void *hash, hg_size_t hash_size)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc) {
-        HG_LOG_ERROR("Proc is not initialized");
-        ret = HG_INVALID_PARAM;
-        goto done;
-    }
-
-    if (hash_size < hg_proc->checksum_size) {
-        HG_LOG_ERROR("Hash size is not valid");
-        ret = HG_SIZE_ERROR;
-        goto done;
-    }
+    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
+        "Proc is not initialized");
+    HG_CHECK_ERROR(hash_size < hg_proc->checksum_size, done, ret,
+        HG_INVALID_ARG, "Hash size passed is too small");
 
     /* Verify checksums */
     if (memcmp(hash, hg_proc->checksum_hash, hg_proc->checksum_size) != 0) {
diff --git a/src/mercury_proc.h b/src/mercury_proc.h
index 5553f7d..7b04069 100644
--- a/src/mercury_proc.h
+++ b/src/mercury_proc.h
@@ -12,7 +12,6 @@
 #define MERCURY_PROC_H
 
 #include "mercury_types.h"
-#include "mercury_error.h"
 
 #include <stdlib.h>
 #include <string.h>
@@ -72,7 +71,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_create(
         hg_class_t *hg_class,
         hg_proc_hash_t hash,
@@ -94,7 +93,7 @@ hg_proc_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_create_set(
         hg_class_t *hg_class,
         void *buf,
@@ -111,7 +110,7 @@ hg_proc_create_set(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_free(
         hg_proc_t proc
         );
@@ -127,7 +126,7 @@ hg_proc_free(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_reset(
         hg_proc_t proc,
         void *buf,
@@ -142,7 +141,7 @@ hg_proc_reset(
  *
  * \return HG class
  */
-HG_EXPORT hg_class_t *
+HG_PUBLIC hg_class_t *
 hg_proc_get_class(
         hg_proc_t proc
         );
@@ -154,7 +153,7 @@ hg_proc_get_class(
  *
  * \return Operation type
  */
-HG_EXPORT hg_proc_op_t
+HG_PUBLIC hg_proc_op_t
 hg_proc_get_op(
         hg_proc_t proc
         );
@@ -166,7 +165,7 @@ hg_proc_get_op(
  *
  * \return Non-negative size value
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 hg_proc_get_size(
         hg_proc_t proc
         );
@@ -178,7 +177,7 @@ hg_proc_get_size(
  *
  * \return Non-negative size value
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 hg_proc_get_size_used(
         hg_proc_t proc
         );
@@ -193,7 +192,7 @@ hg_proc_get_size_used(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_set_size(
         hg_proc_t proc,
         hg_size_t buf_size
@@ -206,7 +205,7 @@ hg_proc_set_size(
  *
  * \return Non-negative size value
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 hg_proc_get_size_left(
         hg_proc_t proc
         );
@@ -219,7 +218,7 @@ hg_proc_get_size_left(
  *
  * \return Buffer pointer
  */
-HG_EXPORT void *
+HG_PUBLIC void *
 hg_proc_save_ptr(
         hg_proc_t proc,
         hg_size_t data_size
@@ -233,7 +232,7 @@ hg_proc_save_ptr(
  *
  * \return XDR stream pointer
  */
-HG_EXPORT XDR *
+HG_PUBLIC XDR *
 hg_proc_get_xdr_ptr(
         hg_proc_t proc
         );
@@ -248,7 +247,7 @@ hg_proc_get_xdr_ptr(
  *
  * \return Buffer pointer
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_restore_ptr(
         hg_proc_t proc,
         void *data,
@@ -262,7 +261,7 @@ hg_proc_restore_ptr(
  *
  * \return Pointer to buffer or NULL if no extra buffer has been used
  */
-HG_EXPORT void *
+HG_PUBLIC void *
 hg_proc_get_extra_buf(
         hg_proc_t proc
         );
@@ -274,7 +273,7 @@ hg_proc_get_extra_buf(
  *
  * \return Size of buffer or 0 if no extra buffer has been used
  */
-HG_EXPORT hg_size_t
+HG_PUBLIC hg_size_t
 hg_proc_get_extra_size(
         hg_proc_t proc
         );
@@ -287,7 +286,7 @@ hg_proc_get_extra_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_set_extra_buf_is_mine(
         hg_proc_t proc,
         hg_bool_t mine
@@ -301,7 +300,7 @@ hg_proc_set_extra_buf_is_mine(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_flush(
         hg_proc_t proc
         );
@@ -316,7 +315,7 @@ hg_proc_flush(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_memcpy(
         hg_proc_t proc,
         void *data,
@@ -335,7 +334,7 @@ hg_proc_memcpy(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_checksum_get(
         hg_proc_t proc,
         void *hash,
@@ -353,7 +352,7 @@ hg_proc_checksum_get(
  *
  * \return HG_SUCCESS if matches or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_proc_checksum_verify(
         hg_proc_t proc,
         const void *hash,
diff --git a/src/mercury_proc_bulk.h b/src/mercury_proc_bulk.h
index fccbe9c..488c7c9 100644
--- a/src/mercury_proc_bulk.h
+++ b/src/mercury_proc_bulk.h
@@ -56,21 +56,18 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
             }
             /* Encode size */
             ret = hg_proc_uint64_t(proc, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
             if (!buf_size)
                 break;
             if (cached_ptr)
                 hg_proc_raw(proc, cached_ptr, buf_size);
             else {
                 buf = hg_proc_save_ptr(proc, buf_size);
-                ret = HG_Bulk_serialize(buf, buf_size, request_eager, *bulk_ptr);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Could not serialize bulk handle");
+                ret = HG_Bulk_serialize(buf, buf_size, request_eager,
+                    *bulk_ptr);
+                if (ret != HG_SUCCESS)
                     return ret;
-                }
                 hg_proc_restore_ptr(proc, buf, buf_size);
             }
             break;
@@ -80,10 +77,8 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
 
             /* Decode size */
             ret = hg_proc_uint64_t(proc, &buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
             if (!buf_size) {
                 /* If buf_size is 0, define handle to HG_BULK_NULL */
                 *bulk_ptr = HG_BULK_NULL;
@@ -92,16 +87,12 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
 
             buf = hg_proc_save_ptr(proc, buf_size);
             ret = HG_Bulk_deserialize(hg_class, bulk_ptr, buf, buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not deserialize bulk handle");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
             /* Cache serialize ptr to buf */
             ret = HG_Bulk_set_serialize_cached_ptr(*bulk_ptr, buf, buf_size);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not set serialize cached ptr");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
             hg_proc_restore_ptr(proc, buf, buf_size);
             break;
         }
@@ -113,16 +104,13 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
             }
             /* Set serialize ptr to NULL */
             ret = HG_Bulk_set_serialize_cached_ptr(*bulk_ptr, NULL, 0);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not set serialize cached ptr");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
+
             /* Decrement refcount on bulk handle */
             ret = HG_Bulk_free(*bulk_ptr);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not free bulk handle");
+            if (ret != HG_SUCCESS)
                 return ret;
-            }
             *bulk_ptr = HG_BULK_NULL;
             break;
         default:
diff --git a/src/mercury_types.h b/src/mercury_types.h
index d853875..6e7443c 100644
--- a/src/mercury_types.h
+++ b/src/mercury_types.h
@@ -30,8 +30,8 @@ struct hg_info {
     hg_class_t *hg_class;       /* HG class */
     hg_context_t *context;      /* HG context */
     hg_addr_t addr;             /* HG address at target/origin */
-    hg_uint8_t context_id;      /* Context ID at target/origin */
     hg_id_t id;                 /* RPC ID */
+    hg_uint8_t context_id;      /* Context ID at target/origin */
 };
 
 /**
@@ -62,15 +62,15 @@ struct hg_cb_info_bulk {
 };
 
 struct hg_cb_info {
-    void *arg;                  /* User data */
-    hg_return_t ret;            /* Return value */
-    hg_cb_type_t type;          /* Callback type */
     union {                     /* Union of callback info structures */
         struct hg_cb_info_lookup lookup;
         struct hg_cb_info_forward forward;
         struct hg_cb_info_respond respond;
         struct hg_cb_info_bulk bulk;
     } info;
+    void *arg;                  /* User data */
+    hg_cb_type_t type;          /* Callback type */
+    hg_return_t ret;            /* Return value */
 };
 
 /* RPC / HG callbacks */
diff --git a/src/na/CMakeLists.txt b/src/na/CMakeLists.txt
index c2ee09c..0b3e0e1 100644
--- a/src/na/CMakeLists.txt
+++ b/src/na/CMakeLists.txt
@@ -327,7 +327,6 @@ install(
 set(NA_HEADERS
   ${CMAKE_CURRENT_BINARY_DIR}/na_config.h
   ${CMAKE_CURRENT_SOURCE_DIR}/na.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/na_error.h
   ${CMAKE_CURRENT_SOURCE_DIR}/na_types.h
 )
 
diff --git a/src/na/na.c b/src/na/na.c
index 3c33da2..9cb8ecd 100644
--- a/src/na/na.c
+++ b/src/na/na.c
@@ -19,9 +19,6 @@
 /****************/
 /* Local Macros */
 /****************/
-/* Convert value to string */
-#define NA_ERROR_STRING_MACRO(def, value, string) \
-  if (value == def) string = #def
 
 #define NA_CLASS_DELIMITER "+" /* e.g. "class+protocol" */
 
@@ -46,18 +43,22 @@ struct na_private_class {
 /* Private context / do not expose private members to plugins */
 struct na_private_context {
     struct na_context context;                  /* Must remain as first field */
-    na_class_t *na_class;                       /* Pointer to NA class */
+    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
 #ifdef NA_HAS_MULTI_PROGRESS
-    hg_thread_mutex_t progress_mutex;           /* Progress mutex */
     hg_thread_cond_t  progress_cond;            /* Progress cond */
-    hg_atomic_int32_t progressing;              /* Progressing count */
 #endif
-    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
     hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
-    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
+#ifdef NA_HAS_MULTI_PROGRESS
+    hg_thread_mutex_t progress_mutex;           /* Progress mutex */
+#endif
     HG_QUEUE_HEAD(na_cb_completion_data) backfill_queue; /* Backfill completion queue */
+    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
+    na_class_t *na_class;                       /* Pointer to NA class */
     hg_atomic_int32_t backfill_queue_count;     /* Number of entries in backfill queue */
     hg_atomic_int32_t trigger_waiting;          /* Polling/waiting in trigger */
+#ifdef NA_HAS_MULTI_PROGRESS
+    hg_atomic_int32_t progressing;              /* Progressing count */
+#endif
 };
 
 /********************/
@@ -77,52 +78,52 @@ na_info_free(
     struct na_info *na_info
     );
 
-#ifdef NA_DEBUG
-/* Print NA info */
-static void
-na_info_print(struct na_info *na_info);
-#endif
-
 /*******************/
 /* Local Variables */
 /*******************/
 
-static const struct na_class_ops *na_class_table[] = {
+/* NA plugin class table */
+static const struct na_class_ops *const na_class_table[] = {
 #ifdef NA_HAS_SM
-    &na_sm_class_ops_g, /* Keep NA SM first for protocol selection */
+    &NA_PLUGIN_OPS(sm), /* Keep NA SM first for protocol selection */
+#endif
+#ifdef NA_HAS_OFI
+    &NA_PLUGIN_OPS(ofi),
 #endif
 #ifdef NA_HAS_BMI
-    &na_bmi_class_ops_g,
+    &NA_PLUGIN_OPS(bmi),
 #endif
 #ifdef NA_HAS_MPI
-    &na_mpi_class_ops_g,
+    &NA_PLUGIN_OPS(mpi),
 #endif
 #ifdef NA_HAS_CCI
-    &na_cci_class_ops_g,
-#endif
-#ifdef NA_HAS_OFI
-    &na_ofi_class_ops_g,
+    &NA_PLUGIN_OPS(cci),
 #endif
     NULL
 };
 
+/* Return code string table */
+#define X(a) #a,
+static const char *const na_return_name[] = { NA_RETURN_VALUES };
+#undef X
+
+/* Default error log mask */
+#ifdef NA_HAS_VERBOSE_ERROR
+unsigned int NA_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
+#endif
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 {
     struct na_info *na_info = NULL;
+    char *input_string = NULL, *token = NULL, *locator = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    char *input_string = NULL;
-    char *token = NULL;
-    char *locator = NULL;
-
     na_info = (struct na_info *) malloc(sizeof(struct na_info));
-    if (!na_info) {
-        NA_LOG_ERROR("Could not allocate NA info struct");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_info == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA info struct");
+
     /* Initialize NA info */
     na_info->class_name = NULL;
     na_info->protocol_name = NULL;
@@ -130,11 +131,8 @@ na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 
     /* Copy info string and work from that */
     input_string = strdup(info_string);
-    if (!input_string) {
-        NA_LOG_ERROR("Could not duplicate host string");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(input_string == NULL, error, ret, NA_NOMEM,
+        "Could not duplicate host string");
 
     /**
      * Strings can be of the format:
@@ -152,58 +150,44 @@ na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 
         /* Get NA class name */
         na_info->class_name = strdup(token);
-        if (!na_info->class_name) {
-            NA_LOG_ERROR("Could not duplicate NA info class name");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_info->class_name == NULL, error, ret, NA_NOMEM,
+            "Could not duplicate NA info class name");
 
         /* Get protocol name */
         na_info->protocol_name = strdup(_locator);
-        if (!na_info->protocol_name) {
-            NA_LOG_ERROR("Could not duplicate NA info protocol name");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_info->protocol_name == NULL, error, ret,
+            NA_NOMEM, "Could not duplicate NA info protocol name");
     } else {
         /* Get protocol name */
         na_info->protocol_name = strdup(token);
-        if (!na_info->protocol_name) {
-            NA_LOG_ERROR("Could not duplicate NA info protocol name");
-            ret = NA_NOMEM_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_info->protocol_name == NULL, error, ret,
+            NA_NOMEM, "Could not duplicate NA info protocol name");
     }
 
     /* Is the host string empty? */
-    if (!locator || locator[0] == '\0') {
+    if (!locator || locator[0] == '\0')
         goto done;
-    }
+
     /* Format sanity check ("://") */
-    else if (strncmp(locator, "//", 2) != 0) {
-        NA_LOG_ERROR("Bad address string format");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(strncmp(locator, "//", 2) != 0, error, ret,
+        NA_PROTONOSUPPORT, "Bad address string format");
+
     /* :// followed by empty hostname is allowed, explicitly check here */
-    else if (locator[2] == '\0') {
+    if (locator[2] == '\0')
         goto done;
-    }
-    else {
-        na_info->host_name = strdup(locator + 2);
-        if (!na_info->host_name) {
-            NA_LOG_ERROR("Could not duplicate NA info host name");
-            ret = NA_NOMEM_ERROR;
-        }
-    }
+
+    na_info->host_name = strdup(locator + 2);
+    NA_CHECK_ERROR(na_info->host_name == NULL, error, ret, NA_NOMEM,
+        "Could not duplicate NA info host name");
 
 done:
-    if (ret == NA_SUCCESS) {
-        *na_info_ptr = na_info;
-    }
-    else {
-        na_info_free(na_info);
-    }
+    *na_info_ptr = na_info;
+    free(input_string);
+
+    return ret;
+
+error:
+    na_info_free(na_info);
     free(input_string);
 
     return ret;
@@ -221,19 +205,6 @@ na_info_free(struct na_info *na_info)
     free(na_info);
 }
 
-/*---------------------------------------------------------------------------*/
-#ifdef NA_DEBUG
-static void
-na_info_print(struct na_info *na_info)
-{
-    if (!na_info) return;
-
-    printf("Class: %s\n", na_info->class_name);
-    printf("Protocol: %s\n", na_info->protocol_name);
-    printf("Hostname: %s\n", na_info->host_name);
-}
-#endif
-
 /*---------------------------------------------------------------------------*/
 na_class_t *
 NA_Initialize(const char *info_string, na_bool_t listen)
@@ -248,75 +219,66 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
 {
     struct na_private_class *na_private_class = NULL;
     struct na_info *na_info = NULL;
-    unsigned int plugin_index = 0;
-    unsigned int plugin_count = 0;
+    unsigned int plugin_index;
+    const unsigned int plugin_count =
+        sizeof(na_class_table) / sizeof(na_class_table[0]) - 1;
     na_bool_t plugin_found = NA_FALSE;
+#ifdef NA_HAS_VERBOSE_ERROR
+    const char *log_level = NULL;
+#endif
     na_return_t ret = NA_SUCCESS;
 
-    if (!info_string) {
-        NA_LOG_ERROR("NULL info string");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(info_string == NULL, error, ret, NA_INVALID_ARG,
+        "NULL info string");
+
+#ifdef NA_HAS_VERBOSE_ERROR
+    /* Set log level */
+    log_level = getenv("HG_NA_LOG_LEVEL");
+    if (log_level && (strcmp(log_level, "debug") == 0))
+        NA_LOG_MASK |= HG_LOG_TYPE_DEBUG;
+#endif
 
     na_private_class = (struct na_private_class *) malloc(
         sizeof(struct na_private_class));
-    if (!na_private_class) {
-        NA_LOG_ERROR("Could not allocate class");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_class == NULL, error, ret, NA_NOMEM,
+        "Could not allocate class");
     memset(na_private_class, 0, sizeof(struct na_private_class));
 
-    plugin_count = sizeof(na_class_table) / sizeof(na_class_table[0]) - 1;
-
     ret = na_info_parse(info_string, &na_info);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not parse host string");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not parse host string");
+
     na_info->na_init_info = na_init_info;
     if (na_init_info)
         na_private_class->na_class.progress_mode = na_init_info->progress_mode;
 
-#ifdef NA_DEBUG
-    na_info_print(na_info);
-#endif
+    /* Print debug info */
+    NA_LOG_DEBUG("Class: %s, Protocol: %s, Hostname: %s" , na_info->class_name,
+        na_info->protocol_name, na_info->host_name);
 
-    while (plugin_index < plugin_count) {
+    for (plugin_index = 0; plugin_index < plugin_count; plugin_index++) {
         na_bool_t verified = NA_FALSE;
 
-        if (!na_class_table[plugin_index]->class_name) {
-            NA_LOG_ERROR("class name is not defined");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_class_table[plugin_index]->class_name == NULL, error,
+            ret, NA_PROTONOSUPPORT, "class name is not defined");
 
-        if (!na_class_table[plugin_index]->check_protocol) {
-            NA_LOG_ERROR("check_protocol plugin callback is not defined");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(na_class_table[plugin_index]->check_protocol == NULL,
+            error, ret, NA_OPNOTSUPPORTED,
+            "check_protocol plugin callback is not defined");
 
         /* Skip check protocol if class name does not match */
         if (na_info->class_name) {
             if (strcmp(na_class_table[plugin_index]->class_name,
-                na_info->class_name) != 0) {
-                plugin_index++;
+                na_info->class_name) != 0)
                 continue;
-            }
         }
 
         /* Check that protocol is supported */
         verified = na_class_table[plugin_index]->check_protocol(
             na_info->protocol_name);
         if (!verified) {
-            if (na_info->class_name) {
-                NA_LOG_ERROR("Specified class name does not support requested protocol");
-                ret = NA_PROTOCOL_ERROR;
-                goto done;
-            }
-            plugin_index++;
+            NA_CHECK_ERROR(na_info->class_name, error, ret,
+                NA_PROTONOSUPPORT,
+                "Specified class name does not support requested protocol");
             continue;
         }
 
@@ -326,11 +288,8 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
             /* While we're here, dup the class_name */
             na_info->class_name = strdup(
                 na_class_table[plugin_index]->class_name);
-            if (!na_info->class_name) {
-                NA_LOG_ERROR("unable to dup class name string");
-                ret = NA_NOMEM_ERROR;
-                goto done;
-            }
+            NA_CHECK_ERROR(na_info->class_name == NULL, error, ret,
+                NA_NOMEM, "Unable to dup class name string");
         }
 
         /* All checks have passed */
@@ -338,42 +297,37 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
         break;
     }
 
-    if (!plugin_found) {
-        NA_LOG_ERROR("No suitable plugin found that matches %s", info_string);
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(!plugin_found, error, ret, NA_PROTONOSUPPORT,
+        "No suitable plugin found that matches %s", info_string);
 
     na_private_class->na_class.ops = na_class_table[plugin_index];
-    if (!na_private_class->na_class.ops->initialize) {
-        NA_LOG_ERROR("initialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_class->na_class.ops == NULL, error, ret,
+        NA_INVALID_ARG, "NULL NA class ops");
+
+    NA_CHECK_ERROR(na_private_class->na_class.ops->initialize == NULL, error,
+        ret, NA_OPNOTSUPPORTED, "initialize plugin callback is not defined");
+
     ret = na_private_class->na_class.ops->initialize(
         &na_private_class->na_class, na_info, listen);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not initialize plugin");
-        goto done;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not initialize plugin");
+
     na_private_class->na_class.protocol_name = strdup(na_info->protocol_name);
-    if (!na_private_class->na_class.protocol_name) {
-        NA_LOG_ERROR("Could not duplicate protocol name");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_class->na_class.protocol_name == NULL, error, ret,
+        NA_NOMEM, "Could not duplicate protocol name");
+
     na_private_class->na_class.listen = listen;
 
-done:
-    if (ret != NA_SUCCESS) {
-        if (na_private_class) {
-            free(na_private_class->na_class.protocol_name);
-        }
-        free(na_private_class);
-        na_private_class = NULL;
-    }
     na_info_free(na_info);
+
     return (na_class_t *) na_private_class;
+
+error:
+    na_info_free(na_info);
+    if (na_private_class) {
+        free(na_private_class->na_class.protocol_name);
+        free(na_private_class);
+    }
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -384,12 +338,13 @@ NA_Finalize(na_class_t *na_class)
         (struct na_private_class *) na_class;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_private_class) goto done;
-    if (!na_class->ops->finalize) {
-        NA_LOG_ERROR("finalize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
+    if (!na_private_class)
         goto done;
-    }
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->finalize == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "finalize plugin callback is not defined");
 
     ret = na_class->ops->finalize(&na_private_class->na_class);
 
@@ -430,37 +385,28 @@ NA_Context_create_id(na_class_t *na_class, na_uint8_t id)
     na_return_t ret = NA_SUCCESS;
     struct na_private_context *na_private_context = NULL;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, error, ret, NA_INVALID_ARG,
+        "NULL NA class");
 
     na_private_context = (struct na_private_context *) malloc(
         sizeof(struct na_private_context));
-    if (!na_private_context) {
-        NA_LOG_ERROR("Could not allocate context");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_context == NULL, error, ret, NA_NOMEM,
+        "Could not allocate context");
     na_private_context->na_class = na_class;
 
+    NA_CHECK_ERROR(na_class->ops == NULL, error, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
     if (na_class->ops->context_create) {
         ret = na_class->ops->context_create(na_class,
             &na_private_context->context.plugin_context, id);
-        if (ret != NA_SUCCESS) {
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(error, ret, "Could not create plugin context");
     }
 
     /* Initialize completion queue */
     na_private_context->completion_queue =
         hg_atomic_queue_alloc(NA_ATOMIC_QUEUE_SIZE);
-    if (!na_private_context->completion_queue) {
-        NA_LOG_ERROR("Could not allocate queue");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_private_context->completion_queue == NULL, error, ret,
+        NA_NOMEM, "Could not allocate queue");
     HG_QUEUE_INIT(&na_private_context->backfill_queue);
     hg_atomic_init32(&na_private_context->backfill_queue_count, 0);
 
@@ -476,12 +422,11 @@ NA_Context_create_id(na_class_t *na_class, na_uint8_t id)
     hg_atomic_init32(&na_private_context->progressing, 0);
 #endif
 
-done:
-    if (ret != NA_SUCCESS) {
-        free(na_private_context);
-        na_private_context = NULL;
-    }
     return (na_context_t *) na_private_context;
+
+error:
+    free(na_private_context);
+    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -490,44 +435,38 @@ NA_Context_destroy(na_class_t *na_class, na_context_t *context)
 {
     struct na_private_context *na_private_context =
         (struct na_private_context *) context;
+    na_bool_t empty;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    if (!context)
         goto done;
-    }
-    if (!context) goto done;
 
     /* Check that completion queue is empty now */
-    if (!hg_atomic_queue_is_empty(na_private_context->completion_queue)) {
-        NA_LOG_ERROR("Completion queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    empty = hg_atomic_queue_is_empty(na_private_context->completion_queue);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_BUSY,
+        "Completion queue should be empty");
     hg_atomic_queue_free(na_private_context->completion_queue);
 
     /* Check that backfill completion queue is empty now */
     hg_thread_mutex_lock(&na_private_context->completion_queue_mutex);
-    if (!HG_QUEUE_IS_EMPTY(&na_private_context->backfill_queue)) {
-        NA_LOG_ERROR("Completion queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        hg_thread_mutex_unlock(&na_private_context->completion_queue_mutex);
-        goto done;
-    }
+    empty = HG_QUEUE_IS_EMPTY(&na_private_context->backfill_queue);
     hg_thread_mutex_unlock(&na_private_context->completion_queue_mutex);
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_BUSY,
+        "Completion queue should be empty");
 
     /* Destroy completion queue mutex/cond */
     hg_thread_mutex_destroy(&na_private_context->completion_queue_mutex);
     hg_thread_cond_destroy(&na_private_context->completion_queue_cond);
 
     /* Destroy NA plugin context */
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
     if (na_class->ops->context_destroy) {
         ret = na_class->ops->context_destroy(na_class,
             na_private_context->context.plugin_context);
-        if (ret != NA_SUCCESS) {
-            goto done;
-        }
+        NA_CHECK_NA_ERROR(done, ret, "Could not destroy plugin context");
     }
 
 #ifdef NA_HAS_MULTI_PROGRESS
@@ -548,14 +487,10 @@ NA_Op_create(na_class_t *na_class)
 {
     na_op_id_t ret = NA_OP_ID_NULL;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!na_class->ops->op_create) {
-        /* Not provided */
-        goto done;
-    }
+    NA_CHECK_ERROR_NORET(na_class == NULL, done, "NULL NA class");
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, done, "NULL NA class ops");
+    NA_CHECK_ERROR_NORET(na_class->ops->op_create == NULL, done,
+        "op_create plugin callback is not defined");
 
     ret = na_class->ops->op_create(na_class);
 
@@ -569,19 +504,17 @@ NA_Op_destroy(na_class_t *na_class, na_op_id_t op_id)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (op_id == NA_OP_ID_NULL) {
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+
+    if (op_id == NA_OP_ID_NULL)
         /* Nothing to do */
         goto done;
-    }
-    if (!na_class->ops->op_destroy) {
-        /* Not provided */
-        goto done;
-    }
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->op_destroy == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "op_destroy plugin callback is not defined");
 
     ret = na_class->ops->op_destroy(na_class, op_id);
 
@@ -598,34 +531,22 @@ NA_Addr_lookup(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     char *short_name = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!name) {
-        NA_LOG_ERROR("Lookup name is NULL");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_lookup) {
-        NA_LOG_ERROR("addr_lookup plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_ARG,
+        "NULL context");
+    NA_CHECK_ERROR(name == NULL, done, ret, NA_INVALID_ARG,
+        "Lookup name is NULL");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_lookup == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_lookup plugin callback is not defined");
 
     /* Copy name and work from that */
     name_string = strdup(name);
-    if (!name_string) {
-        NA_LOG_ERROR("Could not duplicate string");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM,
+        "Could not duplicate string");
 
     /* If NA class name was specified, we can remove the name here:
      * ie. bmi+tcp://hostname:port -> tcp://hostname:port */
@@ -636,9 +557,48 @@ NA_Addr_lookup(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
     ret = na_class->ops->addr_lookup(na_class, context, callback, arg,
         short_name, op_id);
-    if (ret != NA_SUCCESS) {
+
+done:
+    free(name_string);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+na_return_t
+NA_Addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr)
+{
+    char *name_string = NULL;
+    char *short_name = NULL;
+    na_return_t ret = NA_SUCCESS;
+
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(name == NULL, done, ret, NA_INVALID_ARG,
+        "Lookup name is NULL");
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to na_addr_t");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (!na_class->ops->addr_lookup2)
+        /* Until we switch to new lookup, exit if no callback */
         goto done;
-    }
+//    NA_CHECK_ERROR(na_class->ops->addr_lookup2 == NULL, done, ret,
+//        NA_PROTOCOL_ERROR, "addr_lookup2 plugin callback is not defined");
+
+    /* Copy name and work from that */
+    name_string = strdup(name);
+    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM,
+        "Could not duplicate string");
+
+    /* If NA class name was specified, we can remove the name here:
+     * ie. bmi+tcp://hostname:port -> tcp://hostname:port */
+    if (strstr(name_string, NA_CLASS_DELIMITER) != NULL)
+        strtok_r(name_string, NA_CLASS_DELIMITER, &short_name);
+    else
+        short_name = name_string;
+
+    ret = na_class->ops->addr_lookup2(na_class, short_name, addr);
 
 done:
     free(name_string);
@@ -651,21 +611,15 @@ NA_Addr_self(na_class_t *na_class, na_addr_t *addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!addr) {
-        NA_LOG_ERROR("NULL pointer to na_addr_t");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_self) {
-        NA_LOG_ERROR("addr_self plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to na_addr_t");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_self == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_self plugin callback is not defined");
 
     ret = na_class->ops->addr_self(na_class, addr);
 
@@ -679,26 +633,17 @@ NA_Addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!new_addr) {
-        NA_LOG_ERROR("NULL pointer to NA addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_dup) {
-        NA_LOG_ERROR("addr_dup plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
+        "NULL addr");
+    NA_CHECK_ERROR(new_addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to NA addr");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_dup == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_dup plugin callback is not defined");
 
     ret = na_class->ops->addr_dup(na_class, addr, new_addr);
 
@@ -712,19 +657,16 @@ NA_Addr_free(na_class_t *na_class, na_addr_t addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
     if (addr == NA_ADDR_NULL)
         /* Nothing to do */
         goto done;
-    if (!na_class->ops->addr_free) {
-        NA_LOG_ERROR("addr_free plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_free == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_free plugin callback is not defined");
 
     ret = na_class->ops->addr_free(na_class, addr);
 
@@ -732,6 +674,27 @@ done:
     return ret;
 }
 
+/*---------------------------------------------------------------------------*/
+na_return_t
+NA_Addr_set_remove(na_class_t *na_class, na_addr_t addr)
+{
+    na_return_t ret = NA_SUCCESS;
+
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    if (addr == NA_ADDR_NULL)
+        /* Nothing to do */
+        goto done;
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (na_class->ops->addr_set_remove)
+        ret = na_class->ops->addr_set_remove(na_class, addr);
+
+done:
+    return ret;
+}
+
 /*---------------------------------------------------------------------------*/
 na_return_t
 NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
@@ -741,27 +704,18 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
     na_size_t buf_size_used = 0, plugin_buf_size = 0;
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
     /* buf can be NULL */
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_to_string) {
-        NA_LOG_ERROR("addr_to_string plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
+        "NULL addr");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_to_string == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_to_string plugin callback is not defined");
 
     /* Automatically prepend string by plugin name with class delimiter,
      * except for MPI plugin (special case, because of generated string) */
@@ -769,21 +723,17 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
         buf_size_used = 0;
         plugin_buf_size = *buf_size;
     } else {
-        buf_size_used = strlen(na_class->ops->class_name) + 1;
+        buf_size_used = strlen(na_class->ops->class_name)
+            + strlen(NA_CLASS_DELIMITER);
         if (buf_ptr) {
-            if (*buf_size > buf_size_used) {
-                strcpy(buf_ptr, na_class->ops->class_name);
-                strcat(buf_ptr, NA_CLASS_DELIMITER);
-                buf_ptr += buf_size_used;
-                plugin_buf_size = *buf_size - buf_size_used;
-            } else {
-                NA_LOG_ERROR("Buffer size too small to copy addr");
-                ret = NA_SIZE_ERROR;
-                goto done;
-            }
-        } else {
+            NA_CHECK_ERROR(buf_size_used >= *buf_size, done, ret, NA_OVERFLOW,
+                "Buffer size too small to copy addr");
+            strcpy(buf_ptr, na_class->ops->class_name);
+            strcat(buf_ptr, NA_CLASS_DELIMITER);
+            buf_ptr += buf_size_used;
+            plugin_buf_size = *buf_size - buf_size_used;
+        } else
             plugin_buf_size = 0;
-        }
     }
 
     ret = na_class->ops->addr_to_string(na_class, buf_ptr, &plugin_buf_size,
@@ -802,31 +752,19 @@ NA_Addr_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_serialize) {
-        NA_LOG_ERROR("addr_serialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
+        "NULL addr");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_serialize == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_serialize plugin callback is not defined");
 
     ret = na_class->ops->addr_serialize(na_class, buf, buf_size, addr);
 
@@ -841,31 +779,19 @@ NA_Addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!addr) {
-        NA_LOG_ERROR("NULL pointer to addr");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->addr_deserialize) {
-        NA_LOG_ERROR("addr_deserialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to addr");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->addr_deserialize == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "addr_deserialize plugin callback is not defined");
 
     ret = na_class->ops->addr_deserialize(na_class, addr, buf, buf_size);
 
@@ -879,29 +805,20 @@ NA_Msg_buf_alloc(na_class_t *na_class, na_size_t buf_size, void **plugin_data)
 {
     void *ret = NULL;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        goto done;
-    }
-    if (!plugin_data) {
-        NA_LOG_ERROR("NULL pointer to plugin data");
-        goto done;
-    }
+    NA_CHECK_ERROR_NORET(na_class == NULL, done, "NULL NA class");
+    NA_CHECK_ERROR_NORET(buf_size == 0, done, "NULL buffer size");
+    NA_CHECK_ERROR_NORET(plugin_data == NULL, done,
+        "NULL pointer to plugin data");
 
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, done, "NULL NA class ops");
     if (na_class->ops->msg_buf_alloc)
         ret = na_class->ops->msg_buf_alloc(na_class, buf_size, plugin_data);
     else {
         na_size_t page_size = (na_size_t) hg_mem_get_page_size();
 
         ret = hg_mem_aligned_alloc(page_size, buf_size);
-        if (!ret) {
-            NA_LOG_ERROR("Could not allocate %d bytes", (int) buf_size);
-            goto done;
-        }
+        NA_CHECK_ERROR_NORET(ret == NULL, done,
+            "Could not allocate %d bytes", (int) buf_size);
         memset(ret, 0, buf_size);
         *plugin_data = (void *)1; /* Sanity check on free */
     }
@@ -916,25 +833,18 @@ NA_Msg_buf_free(na_class_t *na_class, void *buf, void *plugin_data)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
 
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
     if (na_class->ops->msg_buf_free)
         ret = na_class->ops->msg_buf_free(na_class, buf, plugin_data);
     else {
-        if (plugin_data != (void *)1) {
-            NA_LOG_ERROR("Invalid plugin data value");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        NA_CHECK_ERROR(plugin_data != (void *)1, done, ret, NA_FAULT,
+            "Invalid plugin data value");
         hg_mem_aligned_free(buf);
     }
 
@@ -948,22 +858,15 @@ NA_Msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
 
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
     if (na_class->ops->msg_init_unexpected)
         ret = na_class->ops->msg_init_unexpected(na_class, buf, buf_size);
 
@@ -977,22 +880,15 @@ NA_Msg_init_expected(na_class_t *na_class, void *buf, na_size_t buf_size)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
 
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
     if (na_class->ops->msg_init_expected)
         ret = na_class->ops->msg_init_expected(na_class, buf, buf_size);
 
@@ -1007,26 +903,17 @@ NA_Mem_handle_create(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_create) {
-        NA_LOG_ERROR("mem_handle_create plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_create == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "mem_handle_create plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_create(na_class, buf, buf_size, flags,
         mem_handle);
@@ -1043,26 +930,18 @@ NA_Mem_handle_create_segments(na_class_t *na_class, struct na_segment *segments,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!segments) {
-        NA_LOG_ERROR("NULL pointer to segments");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!segment_count) {
-        NA_LOG_ERROR("NULL segment count");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_create_segments) {
-        NA_LOG_ERROR("mem_handle_create_segments plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(segments == NULL, done, ret, NA_INVALID_ARG,
+        "NULL pointer to segments");
+    NA_CHECK_ERROR(segment_count == 0, done, ret, NA_INVALID_ARG,
+        "NULL segment count");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_create_segments == NULL, done, ret,
+        NA_OPNOTSUPPORTED,
+        "mem_handle_create_segments plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_create_segments(na_class, segments,
         segment_count, flags, mem_handle);
@@ -1077,21 +956,15 @@ NA_Mem_handle_free(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_free) {
-        NA_LOG_ERROR("mem_handle_free plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_free == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "mem_handle_free plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_free(na_class, mem_handle);
 
@@ -1105,21 +978,16 @@ NA_Mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
 
-    if (na_class->ops->mem_register) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (na_class->ops->mem_register)
         /* Optional */
         ret = na_class->ops->mem_register(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1131,21 +999,16 @@ NA_Mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
 
-    if (na_class->ops->mem_deregister) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (na_class->ops->mem_deregister)
         /* Optional */
         ret = na_class->ops->mem_deregister(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1157,21 +1020,16 @@ NA_Mem_publish(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
 
-    if (na_class->ops->mem_publish) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (na_class->ops->mem_publish)
         /* Optional */
         ret = na_class->ops->mem_publish(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1183,21 +1041,16 @@ NA_Mem_unpublish(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
 
-    if (na_class->ops->mem_unpublish) {
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    if (na_class->ops->mem_unpublish)
         /* Optional */
         ret = na_class->ops->mem_unpublish(na_class, mem_handle);
-    }
 
 done:
     return ret;
@@ -1210,31 +1063,20 @@ NA_Mem_handle_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_serialize) {
-        NA_LOG_ERROR("mem_handle_serialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+    NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
+        NA_INVALID_ARG, "NULL memory handle");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_serialize == NULL, done, ret,
+        NA_OPNOTSUPPORTED,
+        "mem_handle_serialize plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_serialize(na_class, buf, buf_size,
         mem_handle);
@@ -1250,31 +1092,20 @@ NA_Mem_handle_deserialize(na_class_t *na_class, na_mem_handle_t *mem_handle,
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!mem_handle) {
-        NA_LOG_ERROR("NULL pointer to memory handle");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->mem_handle_deserialize) {
-        NA_LOG_ERROR("mem_handle_deserialize plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(mem_handle == NULL, done, ret,
+        NA_INVALID_ARG, "NULL pointer to memory handle");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        "NULL buffer");
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+        "NULL buffer size");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->mem_handle_deserialize == NULL, done, ret,
+        NA_OPNOTSUPPORTED,
+        "mem_handle_deserialize plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_deserialize(na_class, mem_handle, buf,
         buf_size);
@@ -1289,31 +1120,29 @@ NA_Poll_try_wait(na_class_t *na_class, na_context_t *context)
 {
     struct na_private_context *na_private_context =
         (struct na_private_context *) context;
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_FALSE;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_FALSE;
-    }
-#endif
+    na_bool_t ret = NA_FALSE;
+
+    NA_CHECK_ERROR_NORET(na_class == NULL, error, "NULL NA class");
+    NA_CHECK_ERROR_NORET(context == NULL, error, "NULL context");
+
     /* Do not try to wait if NA_NO_BLOCK is set */
     if (na_class->progress_mode == NA_NO_BLOCK)
         return NA_FALSE;
 
     /* Something is in one of the completion queues */
     if (!hg_atomic_queue_is_empty(na_private_context->completion_queue) ||
-        hg_atomic_get32(&na_private_context->backfill_queue_count)) {
+        hg_atomic_get32(&na_private_context->backfill_queue_count))
         return NA_FALSE;
-    }
 
     /* Check plugin try wait */
+    NA_CHECK_ERROR_NORET(na_class->ops == NULL, error, "NULL NA class ops");
     if (na_class->ops->na_poll_try_wait)
         return na_class->ops->na_poll_try_wait(na_class, context);
 
     return NA_TRUE;
+
+error:
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1330,28 +1159,21 @@ NA_Progress(na_class_t *na_class, na_context_t *context, unsigned int timeout)
 #endif
     na_return_t ret = NA_TIMEOUT;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_private_context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->progress) {
-        NA_LOG_ERROR("progress plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(na_private_context == NULL, done, ret, NA_INVALID_ARG,
+        "NULL context");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->progress == NULL, done, ret,
+        NA_OPNOTSUPPORTED, "progress plugin callback is not defined");
 
     /* Do not block if NA_NO_BLOCK option is passed */
-    if (na_private_class->na_class.progress_mode == NA_NO_BLOCK) {
+    if (na_private_class->na_class.progress_mode == NA_NO_BLOCK)
         remaining = 0;
-    } else {
+    else
         remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
-    }
 
 #ifdef NA_HAS_MULTI_PROGRESS
     hg_atomic_incr32(&na_private_context->progressing);
@@ -1444,20 +1266,16 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
     na_return_t ret = NA_SUCCESS;
     unsigned int count = 0;
 
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_ARG,
+        "NULL context");
 
     /* Do not block if NA_NO_BLOCK option is passed */
     na_private_class = (struct na_private_class *) na_private_context->na_class;
     if (na_private_class->na_class.progress_mode == NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
-    } else {
+    } else
         remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
-    }
 
     while (count < max_count) {
         struct na_cb_completion_data *completion_data = NULL;
@@ -1477,7 +1295,7 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
                 hg_thread_mutex_unlock(
                     &na_private_context->completion_queue_mutex);
                 if (!completion_data)
-                    continue; /* Give another change to grab it */
+                    continue; /* Give another chance to grab it */
             } else {
                 hg_time_t t1, t2;
 
@@ -1518,16 +1336,13 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
 
                 hg_time_get_current(&t2);
                 remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
-                continue; /* Give another change to grab it */
+                continue; /* Give another chance to grab it */
             }
         }
 
-        /* Completion queue should not be empty now */
-        if (!completion_data) {
-            NA_LOG_ERROR("NULL completion data");
-            ret = NA_PROTOCOL_ERROR;
-            goto done;
-        }
+        /* Completion data should be valid */
+        NA_CHECK_ERROR(completion_data == NULL, done, ret, NA_INVALID_ARG,
+            "NULL completion data");
 
         /* Execute callback */
         if (completion_data->callback) {
@@ -1550,9 +1365,10 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
         count++;
     }
 
-done:
-    if ((ret == NA_SUCCESS || ret == NA_TIMEOUT) && actual_count)
+    if (actual_count)
         *actual_count = count;
+
+done:
     return ret;
 }
 
@@ -1562,26 +1378,17 @@ NA_Cancel(na_class_t *na_class, na_context_t *context, na_op_id_t op_id)
 {
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (op_id == NA_OP_ID_NULL) {
-        NA_LOG_ERROR("NULL operation ID");
-        ret = NA_INVALID_PARAM;
-        goto done;
-    }
-    if (!na_class->ops->cancel) {
-        NA_LOG_ERROR("cancel plugin callback is not defined");
-        ret = NA_PROTOCOL_ERROR;
-        goto done;
-    }
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class");
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_ARG,
+        "NULL context");
+    NA_CHECK_ERROR(op_id == NA_OP_ID_NULL, done, ret, NA_INVALID_ARG,
+        "NULL operation ID");
+
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+        "NULL NA class ops");
+    NA_CHECK_ERROR(na_class->ops->cancel == NULL, done, ret, NA_OPNOTSUPPORTED,
+        "cancel plugin callback is not defined");
 
     ret = na_class->ops->cancel(na_class, context, op_id);
 
@@ -1593,20 +1400,7 @@ done:
 const char *
 NA_Error_to_string(na_return_t errnum)
 {
-    const char *na_error_string = "UNDEFINED/UNRECOGNIZED NA ERROR";
-
-    NA_ERROR_STRING_MACRO(NA_SUCCESS, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_CANCELED, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_TIMEOUT, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_INVALID_PARAM, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_SIZE_ERROR, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_ALIGNMENT_ERROR, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_PERMISSION_ERROR, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_NOMEM_ERROR, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_PROTOCOL_ERROR, errnum, na_error_string);
-    NA_ERROR_STRING_MACRO(NA_ADDRINUSE_ERROR, errnum, na_error_string);
-
-    return na_error_string;
+    return na_return_name[errnum];
 }
 
 /*---------------------------------------------------------------------------*/
diff --git a/src/na/na.h b/src/na/na.h
index ada6784..b3a3d7d 100644
--- a/src/na/na.h
+++ b/src/na/na.h
@@ -12,7 +12,6 @@
 #define NA_H
 
 #include "na_types.h"
-#include "na_error.h"
 
 /*************************************/
 /* Public Type and Struct Definition */
@@ -45,7 +44,7 @@ extern "C" {
  *
  * \return Pointer to NA class or NULL in case of failure
  */
-NA_EXPORT na_class_t *
+NA_PUBLIC na_class_t *
 NA_Initialize(
         const char *info_string,
         na_bool_t   listen
@@ -63,7 +62,7 @@ NA_Initialize(
  *
  * \return Pointer to NA class or NULL in case of failure
  */
-NA_EXPORT na_class_t *
+NA_PUBLIC na_class_t *
 NA_Initialize_opt(
         const char                *info_string,
         na_bool_t                  listen,
@@ -77,7 +76,7 @@ NA_Initialize_opt(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Finalize(
         na_class_t *na_class
         );
@@ -89,7 +88,7 @@ NA_Finalize(
  * abnormally to easily clean up those resources. This includes instances
  * from all plugins.
  */
-NA_EXPORT void
+NA_PUBLIC void
 NA_Cleanup(
         void
         );
@@ -137,7 +136,7 @@ NA_Is_listening(
  *
  * \return Pointer to NA context or NULL in case of failure
  */
-NA_EXPORT na_context_t *
+NA_PUBLIC na_context_t *
 NA_Context_create(
         na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -150,7 +149,7 @@ NA_Context_create(
  *
  * \return Pointer to NA context or NULL in case of failure
  */
-NA_EXPORT na_context_t *
+NA_PUBLIC na_context_t *
 NA_Context_create_id(
         na_class_t *na_class,
         na_uint8_t id
@@ -164,7 +163,7 @@ NA_Context_create_id(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Context_destroy(
         na_class_t   *na_class,
         na_context_t *context
@@ -182,7 +181,7 @@ NA_Context_destroy(
  *
  * \return valid operation ID or NA_OP_ID_NULL
  */
-NA_EXPORT na_op_id_t
+NA_PUBLIC na_op_id_t
 NA_Op_create(
         na_class_t *na_class
         );
@@ -196,7 +195,7 @@ NA_Op_create(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Op_destroy(
         na_class_t *na_class,
         na_op_id_t op_id
@@ -221,7 +220,7 @@ NA_Op_destroy(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_lookup(
         na_class_t   *na_class,
         na_context_t *context,
@@ -231,6 +230,25 @@ NA_Addr_lookup(
         na_op_id_t   *op_id
         );
 
+/**
+ * Lookup an addr from a peer address/name. Addresses need to be
+ * freed by calling NA_Addr_free().
+ *
+ * \remark This is the immediate version of NA_Addr_lookup().
+ *
+ * \param na_class [IN/OUT]     pointer to NA class
+ * \param name [IN]             lookup name
+ * \param addr [OUT]            pointer to abstract address
+ *
+ * \return NA_SUCCESS or corresponding NA error code
+ */
+NA_PUBLIC na_return_t
+NA_Addr_lookup2(
+        na_class_t *na_class,
+        const char *name,
+        na_addr_t  *addr
+        );
+
 /**
  * Free the addr from the list of peers.
  *
@@ -239,12 +257,29 @@ NA_Addr_lookup(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_free(
         na_class_t *na_class,
         na_addr_t   addr
         );
 
+/**
+ * Hint that the address is no longer valid. This may happen if the peer is
+ * no longer responding. This can be used to force removal of the
+ * peer address from the list of the peers, before freeing it and reclaim
+ * resources.
+ *
+ * \param na_class [IN/OUT]     pointer to NA class
+ * \param addr [IN]             abstract address
+ *
+ * \return NA_SUCCESS or corresponding NA error code
+ */
+NA_PUBLIC na_return_t
+NA_Addr_set_remove(
+        na_class_t *na_class,
+        na_addr_t   addr
+        );
+
 /**
  * Access self address.
  *
@@ -253,7 +288,7 @@ NA_Addr_free(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_self(
         na_class_t *na_class,
         na_addr_t  *addr
@@ -270,7 +305,7 @@ NA_Addr_self(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_dup(
         na_class_t *na_class,
         na_addr_t   addr,
@@ -305,7 +340,7 @@ NA_Addr_is_self(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_to_string(
         na_class_t *na_class,
         char       *buf,
@@ -337,7 +372,7 @@ NA_Addr_get_serialize_size(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_serialize(
         na_class_t  *na_class,
         void        *buf,
@@ -356,7 +391,7 @@ NA_Addr_serialize(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Addr_deserialize(
         na_class_t      *na_class,
         na_addr_t       *addr,
@@ -441,7 +476,7 @@ NA_Msg_get_max_tag(
  *
  * \return Pointer to allocated memory or NULL in case of failure
  */
-NA_EXPORT void *
+NA_PUBLIC void *
 NA_Msg_buf_alloc(
         na_class_t *na_class,
         na_size_t buf_size,
@@ -459,7 +494,7 @@ NA_Msg_buf_alloc(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Msg_buf_free(
         na_class_t *na_class,
         void *buf,
@@ -478,7 +513,7 @@ NA_Msg_buf_free(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Msg_init_unexpected(
         na_class_t *na_class,
         void *buf,
@@ -580,7 +615,7 @@ NA_Msg_recv_unexpected(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Msg_init_expected(
         na_class_t *na_class,
         void *buf,
@@ -691,7 +726,7 @@ NA_Msg_recv_expected(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_handle_create(
         na_class_t      *na_class,
         void            *buf,
@@ -719,7 +754,7 @@ NA_Mem_handle_create(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_handle_create_segments(
         na_class_t        *na_class,
         struct na_segment *segments,
@@ -736,7 +771,7 @@ NA_Mem_handle_create_segments(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_handle_free(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -752,7 +787,7 @@ NA_Mem_handle_free(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_register(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -766,7 +801,7 @@ NA_Mem_register(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_deregister(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -782,7 +817,7 @@ NA_Mem_deregister(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_publish(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -796,7 +831,7 @@ NA_Mem_publish(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_unpublish(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -832,7 +867,7 @@ NA_Mem_handle_get_serialize_size(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_handle_serialize(
         na_class_t      *na_class,
         void            *buf,
@@ -850,7 +885,7 @@ NA_Mem_handle_serialize(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Mem_handle_deserialize(
         na_class_t      *na_class,
         na_mem_handle_t *mem_handle,
@@ -967,7 +1002,7 @@ NA_Poll_get_fd(
  *
  * \return NA_TRUE if it is safe to block or NA_FALSE otherwise
  */
-NA_EXPORT na_bool_t
+NA_PUBLIC na_bool_t
 NA_Poll_try_wait(
         na_class_t      *na_class,
         na_context_t    *context
@@ -986,7 +1021,7 @@ NA_Poll_try_wait(
  *
  * \return NA_SUCCESS if any completion has occurred / NA error code otherwise
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Progress(
         na_class_t   *na_class,
         na_context_t *context,
@@ -1006,7 +1041,7 @@ NA_Progress(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Trigger(
         na_context_t *context,
         unsigned int  timeout,
@@ -1024,7 +1059,7 @@ NA_Trigger(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_Cancel(
         na_class_t   *na_class,
         na_context_t *context,
@@ -1038,7 +1073,7 @@ NA_Cancel(
  *
  * \return String
  */
-NA_EXPORT const char *
+NA_PUBLIC const char *
 NA_Error_to_string(
         na_return_t errnum
         ) NA_WARN_UNUSED_RESULT;
@@ -1059,10 +1094,10 @@ struct na_info {
 /* NA class definition */
 struct na_class {
     const struct na_class_ops *ops;             /* Class operations */
+    void *plugin_class;                         /* Plugin private class */
     char *protocol_name;                        /* Name of protocol */
-    na_bool_t listen;                           /* Listen for connections */
     na_progress_mode_t progress_mode;           /* NA progress mode */
-    void *plugin_class;                         /* Plugin private class */
+    na_bool_t listen;                           /* Listen for connections */
 };
 
 /* NA context definition */
@@ -1121,11 +1156,22 @@ struct na_class_ops {
             na_op_id_t   *op_id
             );
     na_return_t
+    (*addr_lookup2)(
+            na_class_t *na_class,
+            const char *name,
+            na_addr_t  *addr
+            );
+    na_return_t
     (*addr_free)(
             na_class_t *na_class,
             na_addr_t   addr
             );
     na_return_t
+    (*addr_set_remove)(
+            na_class_t *na_class,
+            na_addr_t   addr
+            );
+    na_return_t
     (*addr_self)(
             na_class_t *na_class,
             na_addr_t  *addr
@@ -1382,12 +1428,6 @@ struct na_class_ops {
 static NA_INLINE const char *
 NA_Get_class_name(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NULL;
-    }
-#endif
     return na_class->ops->class_name;
 }
 
@@ -1395,12 +1435,6 @@ NA_Get_class_name(const na_class_t *na_class)
 static NA_INLINE const char *
 NA_Get_class_protocol(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NULL;
-    }
-#endif
     return na_class->protocol_name;
 }
 
@@ -1408,12 +1442,6 @@ NA_Get_class_protocol(const na_class_t *na_class)
 static NA_INLINE na_bool_t
 NA_Is_listening(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_FALSE;
-    }
-#endif
     return na_class->listen;
 }
 
@@ -1421,16 +1449,6 @@ NA_Is_listening(const na_class_t *na_class)
 static NA_INLINE na_bool_t
 NA_Addr_is_self(na_class_t *na_class, na_addr_t addr)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_FALSE;
-    }
-    if (!na_class->ops->addr_is_self) {
-        NA_LOG_ERROR("addr_is_self plugin callback is not defined");
-        return NA_FALSE;
-    }
-#endif
     return na_class->ops->addr_is_self(na_class, addr);
 }
 
@@ -1438,20 +1456,6 @@ NA_Addr_is_self(na_class_t *na_class, na_addr_t addr)
 static NA_INLINE na_size_t
 NA_Addr_get_serialize_size(na_class_t *na_class, na_addr_t addr)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        return 0;
-    }
-    if (!na_class->ops->addr_get_serialize_size) {
-        NA_LOG_ERROR("addr_get_serialize_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->addr_get_serialize_size(na_class, addr);
 }
 
@@ -1459,16 +1463,6 @@ NA_Addr_get_serialize_size(na_class_t *na_class, na_addr_t addr)
 static NA_INLINE na_size_t
 NA_Msg_get_max_unexpected_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (!na_class->ops->msg_get_max_unexpected_size) {
-        NA_LOG_ERROR("msg_get_max_unexpected_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->msg_get_max_unexpected_size(na_class);
 }
 
@@ -1476,16 +1470,6 @@ NA_Msg_get_max_unexpected_size(const na_class_t *na_class)
 static NA_INLINE na_size_t
 NA_Msg_get_max_expected_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (!na_class->ops->msg_get_max_expected_size) {
-        NA_LOG_ERROR("msg_get_max_expected_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->msg_get_max_expected_size(na_class);
 }
 
@@ -1493,12 +1477,6 @@ NA_Msg_get_max_expected_size(const na_class_t *na_class)
 static NA_INLINE na_size_t
 NA_Msg_get_unexpected_header_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-#endif
     return (na_class->ops->msg_get_unexpected_header_size) ?
         na_class->ops->msg_get_unexpected_header_size(na_class) : 0;
 }
@@ -1507,12 +1485,6 @@ NA_Msg_get_unexpected_header_size(const na_class_t *na_class)
 static NA_INLINE na_size_t
 NA_Msg_get_expected_header_size(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-#endif
     return (na_class->ops->msg_get_expected_header_size) ?
         na_class->ops->msg_get_expected_header_size(na_class) : 0;
 }
@@ -1521,16 +1493,6 @@ NA_Msg_get_expected_header_size(const na_class_t *na_class)
 static NA_INLINE na_tag_t
 NA_Msg_get_max_tag(const na_class_t *na_class)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (!na_class->ops->msg_get_max_tag) {
-        NA_LOG_ERROR("msg_get_max_tag plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->msg_get_max_tag(na_class);
 }
 
@@ -1541,32 +1503,6 @@ NA_Msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (dest_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_send_unexpected) {
-        NA_LOG_ERROR("msg_send_unexpected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_send_unexpected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, dest_addr, dest_id, tag, op_id);
 }
@@ -1577,28 +1513,6 @@ NA_Msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
     void *plugin_data, na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_recv_unexpected) {
-        NA_LOG_ERROR("msg_recv_unexpected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_recv_unexpected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, op_id);
 }
@@ -1610,32 +1524,6 @@ NA_Msg_send_expected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (dest_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_send_expected) {
-        NA_LOG_ERROR("msg_send_expected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_send_expected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, dest_addr, dest_id, tag, op_id);
 }
@@ -1647,32 +1535,6 @@ NA_Msg_recv_expected(na_class_t *na_class, na_context_t *context,
     void *plugin_data, na_addr_t source_addr, na_uint8_t source_id,
     na_tag_t tag, na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf) {
-        NA_LOG_ERROR("NULL buffer");
-        return NA_INVALID_PARAM;
-    }
-    if (!buf_size) {
-        NA_LOG_ERROR("NULL buffer size");
-        return NA_INVALID_PARAM;
-    }
-    if (source_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL NA address");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->msg_recv_expected) {
-        NA_LOG_ERROR("msg_recv_expected plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->msg_recv_expected(na_class, context, callback,
         arg, buf, buf_size, plugin_data, source_addr, source_id, tag, op_id);
 }
@@ -1682,20 +1544,6 @@ static NA_INLINE na_size_t
 NA_Mem_handle_get_serialize_size(na_class_t *na_class,
     na_mem_handle_t mem_handle)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return 0;
-    }
-    if (mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return 0;
-    }
-    if (!na_class->ops->mem_handle_get_serialize_size) {
-        NA_LOG_ERROR("mem_handle_get_serialize_size plugin callback is not defined");
-        return 0;
-    }
-#endif
     return na_class->ops->mem_handle_get_serialize_size(na_class, mem_handle);
 }
 
@@ -1707,36 +1555,6 @@ NA_Put(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
     na_size_t data_size, na_addr_t remote_addr, na_uint8_t remote_id,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (local_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (!data_size) {
-        NA_LOG_ERROR("NULL data size");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->put) {
-        NA_LOG_ERROR("put plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->put(na_class, context, callback, arg,
         local_mem_handle, local_offset, remote_mem_handle, remote_offset,
         data_size, remote_addr, remote_id, op_id);
@@ -1750,36 +1568,6 @@ NA_Get(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
     na_size_t data_size, na_addr_t remote_addr, na_uint8_t remote_id,
     na_op_id_t *op_id)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return NA_INVALID_PARAM;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return NA_INVALID_PARAM;
-    }
-    if (local_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_mem_handle == NA_MEM_HANDLE_NULL) {
-        NA_LOG_ERROR("NULL memory handle");
-        return NA_INVALID_PARAM;
-    }
-    if (!data_size) {
-        NA_LOG_ERROR("NULL data size");
-        return NA_INVALID_PARAM;
-    }
-    if (remote_addr == NA_ADDR_NULL) {
-        NA_LOG_ERROR("NULL addr");
-        return NA_INVALID_PARAM;
-    }
-    if (!na_class->ops->get) {
-        NA_LOG_ERROR("get plugin callback is not defined");
-        return NA_PROTOCOL_ERROR;
-    }
-#endif
     return na_class->ops->get(na_class, context, callback, arg,
         local_mem_handle, local_offset, remote_mem_handle, remote_offset,
         data_size, remote_addr, remote_id, op_id);
@@ -1789,16 +1577,6 @@ NA_Get(na_class_t *na_class, na_context_t *context, na_cb_t callback, void *arg,
 static NA_INLINE int
 NA_Poll_get_fd(na_class_t *na_class, na_context_t *context)
 {
-#ifdef NA_HAS_VERBOSE_ERROR
-    if (!na_class) {
-        NA_LOG_ERROR("NULL NA class");
-        return -1;
-    }
-    if (!context) {
-        NA_LOG_ERROR("NULL context");
-        return -1;
-    }
-#endif
     return (na_class->ops->na_poll_get_fd) ?
         na_class->ops->na_poll_get_fd(na_class, context) : -1;
 }
diff --git a/src/na/na_bmi.c b/src/na/na_bmi.c
index 84daf0f..6eedcbe 100644
--- a/src/na/na_bmi.c
+++ b/src/na/na_bmi.c
@@ -23,6 +23,13 @@
 /* Local Macros */
 /****************/
 
+/* Error compat */
+#define NA_INVALID_PARAM    NA_INVALID_ARG
+#define NA_SIZE_ERROR       NA_MSGSIZE
+#define NA_NOMEM_ERROR      NA_NOMEM
+#define NA_PERMISSION_ERROR NA_PERMISSION
+#define NA_ADDRINUSE_ERROR  NA_ADDRINUSE
+
 /* Max addr name */
 #define NA_BMI_MAX_ADDR_NAME 256
 
@@ -502,7 +509,7 @@ na_bmi_cancel(
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN_OPS(bmi) = {
+const struct na_class_ops NA_PLUGIN_OPS(bmi) = {
         "bmi",                                /* name */
         na_bmi_check_protocol,                /* check_protocol */
         na_bmi_initialize,                    /* initialize */
@@ -513,7 +520,9 @@ NA_PLUGIN_OPS(bmi) = {
         na_bmi_op_create,                     /* op_create */
         na_bmi_op_destroy,                    /* op_destroy */
         na_bmi_addr_lookup,                   /* addr_lookup */
+        NULL,                                 /* addr_lookup2 */
         na_bmi_addr_free,                     /* addr_free */
+        NULL,                                 /* addr_set_remove */
         na_bmi_addr_self,                     /* addr_self */
         na_bmi_addr_dup,                      /* addr_dup */
         na_bmi_addr_is_self,                  /* addr_is_self */
diff --git a/src/na/na_cci.c b/src/na/na_cci.c
index 2758ad8..6ce6c9e 100644
--- a/src/na/na_cci.c
+++ b/src/na/na_cci.c
@@ -28,6 +28,14 @@
 /****************/
 /* Local Macros */
 /****************/
+
+/* Error compat */
+#define NA_INVALID_PARAM    NA_INVALID_ARG
+#define NA_SIZE_ERROR       NA_MSGSIZE
+#define NA_NOMEM_ERROR      NA_NOMEM
+#define NA_PERMISSION_ERROR NA_PERMISSION
+#define NA_ADDRINUSE_ERROR  NA_ADDRINUSE
+
 /* Max tag */
 #define NA_CCI_MAX_TAG ((1 << 30) -1)
 
@@ -360,7 +368,7 @@ na_cci_cancel(na_class_t * na_class, na_context_t * context, na_op_id_t op_id);
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN_OPS(cci) = {
+const struct na_class_ops NA_PLUGIN_OPS(cci) = {
     "cci",                                  /* name */
     na_cci_check_protocol,                  /* check_protocol */
     na_cci_initialize,                      /* initialize */
@@ -371,7 +379,9 @@ NA_PLUGIN_OPS(cci) = {
     na_cci_op_create,                       /* op_create */
     na_cci_op_destroy,                      /* op_destroy */
     na_cci_addr_lookup,                     /* addr_lookup */
+    NULL,                                   /* addr_lookup2 */
     na_cci_addr_free,                       /* addr_free */
+    NULL,                                   /* addr_set_remove */
     na_cci_addr_self,                       /* addr_self */
     na_cci_addr_dup,                        /* addr_dup */
     na_cci_addr_is_self,                    /* addr_is_self */
diff --git a/src/na/na_config.h.in b/src/na/na_config.h.in
index effe390..d153909 100644
--- a/src/na/na_config.h.in
+++ b/src/na/na_config.h.in
@@ -13,21 +13,97 @@
 #ifndef NA_CONFIG_H
 #define NA_CONFIG_H
 
-/* Import/export declarations */
+/*************************************/
+/* Public Type and Struct Definition */
+/*************************************/
+
+/* Type definitions */
+#ifdef _WIN32
+  typedef signed   __int64 na_int64_t;
+  typedef signed   __int32 na_int32_t;
+  typedef signed   __int16 na_int16_t;
+  typedef signed   __int8  na_int8_t;
+  typedef unsigned __int64 na_uint64_t;
+  typedef unsigned __int32 na_uint32_t;
+  typedef unsigned __int16 na_uint16_t;
+  typedef unsigned __int8  na_uint8_t;
+#else
+# include <stdint.h>
+# include <stddef.h>
+  typedef int64_t  na_int64_t;
+  typedef int32_t  na_int32_t;
+  typedef int16_t  na_int16_t;
+  typedef int8_t   na_int8_t;
+  typedef uint64_t na_uint64_t;
+  typedef uint32_t na_uint32_t;
+  typedef uint16_t na_uint16_t;
+  typedef uint8_t  na_uint8_t;
+#endif
+typedef na_uint8_t   na_bool_t;
+typedef na_uint64_t  na_ptr_t;
+
+/* True / false */
+#define NA_TRUE     1
+#define NA_FALSE    0
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Visibility of symbols */
 #if defined(_WIN32)
-    #define NA_ABI_IMPORT __declspec(dllimport)
-    #define NA_ABI_EXPORT __declspec(dllexport)
-    #define NA_ABI_HIDDEN
+# define NA_ABI_IMPORT __declspec(dllimport)
+# define NA_ABI_EXPORT __declspec(dllexport)
+# define NA_ABI_HIDDEN
 #elif defined(__GNUC__) && (__GNUC__ >= 4)
-    #define NA_ABI_IMPORT __attribute__((visibility("default")))
-    #define NA_ABI_EXPORT __attribute__((visibility("default")))
-    #define NA_ABI_HIDDEN __attribute__((visibility("hidden")))
+# define NA_ABI_IMPORT __attribute__((visibility("default")))
+# define NA_ABI_EXPORT __attribute__((visibility("default")))
+# define NA_ABI_HIDDEN __attribute__((visibility("hidden")))
+#else
+# define NA_ABI_IMPORT
+# define NA_ABI_EXPORT
+# define NA_ABI_HIDDEN
+#endif
+
+/* Inline macro */
+#ifdef _WIN32
+# define NA_INLINE __inline
 #else
-    #define NA_ABI_IMPORT
-    #define NA_ABI_EXPORT
-    #define NA_ABI_HIDDEN
+# define NA_INLINE __inline__
 #endif
 
+/* Unused return values */
+#if defined(__GNUC__)
+# define NA_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
+#else
+# define NA_WARN_UNUSED_RESULT
+#endif
+
+/* Fallthrough macro */
+#if defined(__GNUC__) && (__GNUC__ >= 7)
+# define NA_FALLTHROUGH() __attribute__((fallthrough))
+#else
+# define NA_FALLTHROUGH()
+#endif
+
+/* Shared libraries */
+#cmakedefine NA_BUILD_SHARED_LIBS
+#ifdef NA_BUILD_SHARED_LIBS
+# ifdef na_EXPORTS
+#  define NA_PUBLIC NA_ABI_EXPORT
+# else
+#  define NA_PUBLIC NA_ABI_IMPORT
+# endif
+# define NA_PRIVATE NA_ABI_HIDDEN
+#else
+# define NA_PUBLIC
+# define NA_PRIVATE
+#endif
+
+/* Build Options */
+#cmakedefine NA_HAS_MULTI_PROGRESS
+#cmakedefine NA_HAS_VERBOSE_ERROR
+
 /* BMI */
 #cmakedefine NA_HAS_BMI
 
@@ -49,66 +125,4 @@
 #cmakedefine NA_SM_SHM_PREFIX "@NA_SM_SHM_PREFIX@"
 #cmakedefine NA_SM_TMP_DIRECTORY "@NA_SM_TMP_DIRECTORY@"
 
-/* Build Options */
-#cmakedefine NA_HAS_MULTI_PROGRESS
-#cmakedefine NA_HAS_VERBOSE_ERROR
-
-/* Define if build shared libraries */
-#cmakedefine NA_BUILD_SHARED_LIBS
-
-/* Define export declaration */
-#ifdef NA_BUILD_SHARED_LIBS
-    #ifdef na_EXPORTS
-      #define NA_EXPORT NA_ABI_EXPORT
-    #else
-      #define NA_EXPORT NA_ABI_IMPORT
-    #endif
-#else
-    #define NA_EXPORT
-#endif
-
-/* Standard types */
-#ifdef _WIN32
-    typedef signed   __int64 na_int64_t;
-    typedef signed   __int32 na_int32_t;
-    typedef signed   __int16 na_int16_t;
-    typedef signed   __int8  na_int8_t;
-    typedef unsigned __int64 na_uint64_t;
-    typedef unsigned __int32 na_uint32_t;
-    typedef unsigned __int16 na_uint16_t;
-    typedef unsigned __int8  na_uint8_t;
-#else
-    #include <stdint.h>
-    #include <stddef.h>
-    typedef int64_t  na_int64_t;
-    typedef int32_t  na_int32_t;
-    typedef int16_t  na_int16_t;
-    typedef int8_t   na_int8_t;
-    typedef uint64_t na_uint64_t;
-    typedef uint32_t na_uint32_t;
-    typedef uint16_t na_uint16_t;
-    typedef uint8_t  na_uint8_t;
-#endif
-typedef na_uint8_t   na_bool_t;
-typedef na_uint64_t  na_ptr_t;
-
-/* Inline declarations */
-#ifdef _WIN32
-   #define NA_INLINE __inline
-#else
-   #define NA_INLINE __inline__
-#endif
-
-/* Unused return values */
-#if defined(__GNUC__)
-    #define NA_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
-#else
-    #define NA_WARN_UNUSED_RESULT
-#endif
-
-/* Return codes */
-#define NA_TRUE     1
-#define NA_FALSE    0
-
 #endif /* NA_CONFIG_H */
-
diff --git a/src/na/na_error.h b/src/na/na_error.h
index f04adb0..f661211 100644
--- a/src/na/na_error.h
+++ b/src/na/na_error.h
@@ -15,18 +15,85 @@
 
 /* Default error macro */
 #ifdef NA_HAS_VERBOSE_ERROR
-  #include <mercury_log.h>
-  #define NA_LOG_MODULE_NAME "NA"
-  #define NA_LOG_ERROR(...)                                 \
-      HG_LOG_WRITE_ERROR(NA_LOG_MODULE_NAME, __VA_ARGS__)
-  #define NA_LOG_DEBUG(...)                                 \
-      HG_LOG_WRITE_DEBUG(NA_LOG_MODULE_NAME, __VA_ARGS__)
-  #define NA_LOG_WARNING(...)                               \
-      HG_LOG_WRITE_WARNING(NA_LOG_MODULE_NAME, __VA_ARGS__)
+# include <mercury_log.h>
+# define NA_LOG_MASK na_log_mask
+/* Log mask will be initialized in init routine */
+extern NA_PRIVATE unsigned int NA_LOG_MASK;
+# define NA_LOG_MODULE_NAME "NA"
+# define NA_LOG_ERROR(...) do {                                 \
+    if (NA_LOG_MASK & HG_LOG_TYPE_ERROR)                        \
+        HG_LOG_WRITE_ERROR(NA_LOG_MODULE_NAME, __VA_ARGS__);    \
+} while (0)
+# define NA_LOG_DEBUG(...) do {                                 \
+    if (NA_LOG_MASK & HG_LOG_TYPE_DEBUG)                        \
+        HG_LOG_WRITE_DEBUG(NA_LOG_MODULE_NAME, __VA_ARGS__);    \
+} while (0)
+# define NA_LOG_WARNING(...) do {                               \
+    if (NA_LOG_MASK & HG_LOG_TYPE_WARNING)                      \
+        HG_LOG_WRITE_WARNING(NA_LOG_MODULE_NAME, __VA_ARGS__);  \
+} while (0)
 #else
-  #define NA_LOG_ERROR(...) (void)0
-  #define NA_LOG_DEBUG(...) (void)0
-  #define NA_LOG_WARNING(...) (void)0
+# define NA_LOG_ERROR(...)      (void)0
+# define NA_LOG_DEBUG(...)      (void)0
+# define NA_LOG_WARNING(...)    (void)0
 #endif
 
+/* Branch predictor hints */
+#ifndef _WIN32
+# define likely(x)       __builtin_expect(!!(x), 1)
+# define unlikely(x)     __builtin_expect(!!(x), 0)
+#else
+# define likely(x)       (x)
+# define unlikely(x)     (x)
+#endif
+
+/* Error macros */
+#define NA_GOTO_DONE(label, ret, ret_val) do {                  \
+    ret = ret_val;                                              \
+    goto label;                                                 \
+} while (0)
+
+#define NA_GOTO_ERROR(label, ret, err_val, ...) do {            \
+    NA_LOG_ERROR(__VA_ARGS__);                                  \
+    ret = err_val;                                              \
+    goto label;                                                 \
+} while (0)
+
+/* Check for na_ret value and goto label */
+#define NA_CHECK_NA_ERROR(label, na_ret, ...) do {              \
+    if (unlikely(na_ret != NA_SUCCESS)) {                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+/* Check for cond, set ret to err_val and goto label */
+#define NA_CHECK_ERROR(cond, label, ret, err_val, ...) do {     \
+    if (unlikely(cond)) {                                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+        ret = err_val;                                          \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define NA_CHECK_ERROR_NORET(cond, label, ...) do {             \
+    if (unlikely(cond)) {                                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+        goto label;                                             \
+    }                                                           \
+} while (0)
+
+#define NA_CHECK_ERROR_DONE(cond, ...) do {                     \
+    if (unlikely(cond)) {                                       \
+        NA_LOG_ERROR(__VA_ARGS__);                              \
+    }                                                           \
+} while (0)
+
+/* Check for cond and print warning */
+#define NA_CHECK_WARNING(cond, ...) do {                        \
+    if (unlikely(cond)) {                                       \
+        NA_LOG_WARNING(__VA_ARGS__);                            \
+    }                                                           \
+} while (0)
+
 #endif /* NA_ERROR_H */
diff --git a/src/na/na_mpi.c b/src/na/na_mpi.c
index 2ad315a..03137cd 100644
--- a/src/na/na_mpi.c
+++ b/src/na/na_mpi.c
@@ -25,6 +25,12 @@
 /* Local Macros */
 /****************/
 
+/* Error compat */
+#define NA_INVALID_PARAM    NA_INVALID_ARG
+#define NA_SIZE_ERROR       NA_MSGSIZE
+#define NA_NOMEM_ERROR      NA_NOMEM
+#define NA_PERMISSION_ERROR NA_PERMISSION
+
 /* MPI initialization flags */
 #define MPI_INIT_SERVER 0x01 /* set up to listen for unexpected messages */
 #define MPI_INIT_STATIC 0x10 /* set up static inter-communicator */
@@ -141,7 +147,8 @@ struct na_mpi_op_id {
     na_cb_type_t type;
     na_cb_t callback; /* Callback */
     void *arg;
-    na_bool_t completed; /* Operation completed */
+    hg_atomic_int32_t ref_count;    /* Ref count */
+    hg_atomic_int32_t completed;    /* Operation completed */
     na_bool_t canceled;  /* Operation canceled */
     union {
       struct na_mpi_info_lookup lookup;
@@ -262,6 +269,19 @@ na_mpi_finalize(
         na_class_t *na_class
         );
 
+/* op_create */
+static na_op_id_t
+na_mpi_op_create(
+        na_class_t      *na_class
+        );
+
+/* op_destroy */
+static na_return_t
+na_mpi_op_destroy(
+        na_class_t      *na_class,
+        na_op_id_t       op_id
+        );
+
 /* addr_lookup */
 static na_return_t
 na_mpi_addr_lookup(
@@ -531,7 +551,7 @@ na_mpi_cancel(
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN_OPS(mpi) = {
+const struct na_class_ops NA_PLUGIN_OPS(mpi) = {
         "mpi",                                /* name */
         na_mpi_check_protocol,                /* check_protocol */
         na_mpi_initialize,                    /* initialize */
@@ -539,10 +559,12 @@ NA_PLUGIN_OPS(mpi) = {
         NULL,                                 /* cleanup */
         NULL,                                 /* context_create */
         NULL,                                 /* context_destroy */
-        NULL,                                 /* op_create */
-        NULL,                                 /* op_destroy */
+        na_mpi_op_create,                     /* op_create */
+        na_mpi_op_destroy,                    /* op_destroy */
         na_mpi_addr_lookup,                   /* addr_lookup */
+        NULL,                                 /* addr_lookup2 */
         na_mpi_addr_free,                     /* addr_free */
+        NULL,                                 /* addr_set_remove */
         na_mpi_addr_self,                     /* addr_self */
         NULL,                                 /* addr_dup */
         na_mpi_addr_is_self,                  /* addr_is_self */
@@ -1214,6 +1236,43 @@ na_mpi_finalize(na_class_t *na_class)
     return ret;
 }
 
+/*---------------------------------------------------------------------------*/
+static na_op_id_t
+na_mpi_op_create(na_class_t NA_UNUSED *na_class)
+{
+    struct na_mpi_op_id *na_mpi_op_id = NULL;
+
+    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    if (!na_mpi_op_id) {
+        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
+        goto done;
+    }
+    memset(na_mpi_op_id, 0, sizeof(struct na_mpi_op_id));
+    hg_atomic_init32(&na_mpi_op_id->ref_count, 1);
+    /* Completed by default */
+    hg_atomic_init32(&na_mpi_op_id->completed, 1);
+
+done:
+    return (na_op_id_t) na_mpi_op_id;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_mpi_op_destroy(na_class_t NA_UNUSED *na_class, na_op_id_t op_id)
+{
+    struct na_mpi_op_id *na_mpi_op_id = (struct na_mpi_op_id *) op_id;
+    na_return_t ret = NA_SUCCESS;
+
+    if (hg_atomic_decr32(&na_mpi_op_id->ref_count)) {
+        /* Cannot free yet */
+        goto done;
+    }
+    free(na_mpi_op_id);
+
+done:
+    return ret;
+}
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
@@ -1224,18 +1283,13 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     int mpi_ret;
 
-    /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_LOOKUP;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
 
     /* Allocate addr */
@@ -1256,9 +1310,6 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
     /* get port_name and remote server rank */
     na_mpi_get_port_info(name, na_mpi_addr->port_name, &na_mpi_addr->rank);
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     /* Try to connect, must prevent concurrent threads to
      * create new communicators */
     hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->accept_mutex);
@@ -1327,7 +1378,7 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
 done:
     if (ret != NA_SUCCESS) {
         free(na_mpi_addr);
-        free(na_mpi_op_id);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
 
     return ret;
@@ -1486,24 +1537,16 @@ na_mpi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     int mpi_ret;
 
-    /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_SEND_UNEXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.send_unexpected.data_request = MPI_REQUEST_NULL;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     mpi_ret = MPI_Isend(buf, mpi_buf_size, MPI_BYTE, mpi_addr->rank,
             mpi_tag, mpi_addr->comm,
             &na_mpi_op_id->info.send_unexpected.data_request);
@@ -1521,7 +1564,7 @@ na_mpi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1536,25 +1579,18 @@ na_mpi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
 
     /* Allocate na_op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_RECV_UNEXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.recv_unexpected.buf = buf;
     na_mpi_op_id->info.recv_unexpected.buf_size = (int) buf_size;
     na_mpi_op_id->info.recv_unexpected.remote_addr = NULL;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     /* Add op_id to queue of pending unexpected recv ops and make some progress
      * in case messages are already arrived */
     ret = na_mpi_msg_unexpected_op_push(na_class, na_mpi_op_id);
@@ -1577,7 +1613,7 @@ na_mpi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1597,23 +1633,16 @@ na_mpi_msg_send_expected(na_class_t *na_class, na_context_t *context,
     int mpi_ret;
 
     /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_SEND_EXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.send_expected.data_request = MPI_REQUEST_NULL;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     mpi_ret = MPI_Isend(buf, mpi_buf_size, MPI_BYTE, mpi_addr->rank,
             mpi_tag, mpi_addr->comm,
             &na_mpi_op_id->info.send_expected.data_request);
@@ -1631,7 +1660,7 @@ na_mpi_msg_send_expected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1651,25 +1680,18 @@ na_mpi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     int mpi_ret;
 
     /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_RECV_EXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.recv_expected.buf_size = mpi_buf_size;
     na_mpi_op_id->info.recv_expected.actual_size = 0;
     na_mpi_op_id->info.recv_expected.data_request = MPI_REQUEST_NULL;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     mpi_ret = MPI_Irecv(buf, mpi_buf_size, MPI_BYTE, mpi_addr->rank,
             mpi_tag, mpi_addr->comm,
             &na_mpi_op_id->info.recv_expected.data_request);
@@ -1687,7 +1709,7 @@ na_mpi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1846,18 +1868,13 @@ na_mpi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
             goto done;
     }
 
-    /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_PUT;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.put.rma_request = MPI_REQUEST_NULL;
     na_mpi_op_id->info.put.data_request = MPI_REQUEST_NULL;
@@ -1879,9 +1896,6 @@ na_mpi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_mpi_rma_info->tag = na_mpi_gen_rma_tag(na_class);
     na_mpi_op_id->info.put.rma_info = na_mpi_rma_info;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     /* Post the MPI send request */
     mpi_ret = MPI_Isend(na_mpi_rma_info, sizeof(struct na_mpi_rma_info),
             MPI_BYTE, na_mpi_addr->rank, NA_MPI_RMA_REQUEST_TAG,
@@ -1910,8 +1924,8 @@ na_mpi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
         free(na_mpi_rma_info);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1952,18 +1966,13 @@ na_mpi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
             goto done;
     }
 
-    /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        ret = NA_NOMEM_ERROR;
-        goto done;
-    }
+    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
+    hg_atomic_incr32(&na_mpi_op_id->ref_count);
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_GET;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.get.rma_request = MPI_REQUEST_NULL;
     na_mpi_op_id->info.get.data_request = MPI_REQUEST_NULL;
@@ -1985,9 +1994,6 @@ na_mpi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_mpi_rma_info->tag = na_mpi_gen_rma_tag(na_class);
     na_mpi_op_id->info.get.rma_info = na_mpi_rma_info;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
-
     /* Post the MPI send request */
     mpi_ret = MPI_Isend(na_mpi_rma_info, sizeof(struct na_mpi_rma_info),
             MPI_BYTE, na_mpi_addr->rank, NA_MPI_RMA_REQUEST_TAG,
@@ -2016,8 +2022,8 @@ na_mpi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
         free(na_mpi_rma_info);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -2216,7 +2222,7 @@ na_mpi_progress_unexpected_rma(na_class_t *na_class, na_context_t *context,
     }
 
     /* Allocate na_op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    na_mpi_op_id = (struct na_mpi_op_id *) na_mpi_op_create(na_class);
     if (!na_mpi_op_id) {
         NA_LOG_ERROR("Could not allocate NA MPI operation ID");
         ret = NA_NOMEM_ERROR;
@@ -2226,7 +2232,7 @@ na_mpi_progress_unexpected_rma(na_class_t *na_class, na_context_t *context,
     na_mpi_op_id->context = context;
     na_mpi_op_id->callback = NULL;
     na_mpi_op_id->arg = NULL;
-    na_mpi_op_id->completed = NA_FALSE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 0);
     na_mpi_op_id->canceled = NA_FALSE;
 
     switch (na_mpi_rma_info->op) {
@@ -2283,8 +2289,8 @@ na_mpi_progress_unexpected_rma(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        free(na_mpi_op_id);
         free(na_mpi_rma_info);
+        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -2309,7 +2315,7 @@ na_mpi_progress_expected(na_class_t *na_class, na_context_t NA_UNUSED *context,
         MPI_Status *status = MPI_STATUS_IGNORE;
 
         /* If the op_id is marked as completed, something is wrong */
-        if (na_mpi_op_id->completed) {
+        if (hg_atomic_get32(&na_mpi_op_id->completed)) {
             NA_LOG_ERROR("Op ID should not have completed yet");
             ret = NA_PROTOCOL_ERROR;
             goto done;
@@ -2389,7 +2395,7 @@ na_mpi_progress_expected(na_class_t *na_class, na_context_t NA_UNUSED *context,
         /* If internal operation call release directly otherwise add callback
          * to completion queue */
         if (internal) {
-            na_mpi_op_id->completed = NA_TRUE;
+            hg_atomic_set32(&na_mpi_op_id->completed, 1);
             /* Remove entry from list */
             HG_LIST_REMOVE(na_mpi_op_id, entry);
 
@@ -2428,7 +2434,7 @@ na_mpi_complete(struct na_mpi_op_id *na_mpi_op_id)
     int mpi_ret;
 
     /* Mark op id as completed */
-    na_mpi_op_id->completed = NA_TRUE;
+    hg_atomic_set32(&na_mpi_op_id->completed, 1);
 
     /* Init callback info */
     callback_info = &na_mpi_op_id->completion_data.callback_info;
@@ -2551,10 +2557,10 @@ na_mpi_release(void *arg)
 {
     struct na_mpi_op_id *na_mpi_op_id = (struct na_mpi_op_id *) arg;
 
-    if (na_mpi_op_id && !na_mpi_op_id->completed) {
-        NA_LOG_ERROR("Releasing resources from an uncompleted operation");
+    if (na_mpi_op_id && !hg_atomic_get32(&na_mpi_op_id->completed)) {
+        NA_LOG_WARNING("Releasing resources from an uncompleted operation");
     }
-    free(na_mpi_op_id);
+    na_mpi_op_destroy(NULL, (na_op_id_t) na_mpi_op_id);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2566,8 +2572,8 @@ na_mpi_cancel(na_class_t *na_class, na_context_t NA_UNUSED *context,
     na_return_t ret = NA_SUCCESS;
     int mpi_ret;
 
-    /* TODO make this atomic */
-    if (na_mpi_op_id->completed) goto done;
+    if (hg_atomic_get32(&na_mpi_op_id->completed))
+        goto done;
 
     switch (na_mpi_op_id->type) {
         case NA_CB_LOOKUP:
diff --git a/src/na/na_mpi.h b/src/na/na_mpi.h
index 7014760..cc9ae46 100644
--- a/src/na/na_mpi.h
+++ b/src/na/na_mpi.h
@@ -28,7 +28,7 @@ extern "C" {
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_EXPORT na_return_t
+NA_PUBLIC na_return_t
 NA_MPI_Set_init_intra_comm(MPI_Comm intra_comm);
 
 /**
@@ -39,7 +39,7 @@ NA_MPI_Set_init_intra_comm(MPI_Comm intra_comm);
  *
  * \return Pointer to string
  */
-NA_EXPORT const char *
+NA_PUBLIC const char *
 NA_MPI_Get_port_name(
         na_class_t *na_class
         );
diff --git a/src/na/na_ofi.c b/src/na/na_ofi.c
index aca1919..5c13067 100644
--- a/src/na/na_ofi.c
+++ b/src/na/na_ofi.c
@@ -99,17 +99,17 @@
  * provider) 
  */
 /* requires domain verification in addition to provider match */
-#define NA_OFI_VERIFY_PROV_DOM (1<<0) 
+#define NA_OFI_VERIFY_PROV_DOM          (1 << 0)
 /* supports FI_WAIT_SET */
-#define NA_OFI_WAIT_SET        (1<<1)
+#define NA_OFI_WAIT_SET                 (1 << 1)
 /* supports FI_WAIT_FD */
-#define NA_OFI_WAIT_FD         (1<<2)
+#define NA_OFI_WAIT_FD                  (1 << 2)
 /* workaround to prevent calling fi_signal() for this provider */
-#define NA_OFI_SKIP_SIGNAL     (1<<4)
+#define NA_OFI_SKIP_SIGNAL              (1 << 4)
 /* workaround to serialize access to ofi domain */
-#define NA_OFI_DOMAIN_LOCK     (1<<5)
+#define NA_OFI_DOMAIN_LOCK              (1 << 5)
 /* disable scalable endpoint support */
-#define NA_OFI_NO_SEP          (1<<6)
+#define NA_OFI_NO_SEP                   (1 << 6)
 
 /* X-macro to define the following for each supported provider:
  * - enum type
@@ -130,7 +130,7 @@
         "",                                                             \
         FI_SOCKADDR_IN,                                                 \
         FI_PROGRESS_AUTO,                                               \
-        FI_DIRECTED_RECV,                                               \
+        (FI_SOURCE | FI_DIRECTED_RECV),                                 \
         (NA_OFI_VERIFY_PROV_DOM | NA_OFI_WAIT_FD)                       \
     )                                                                   \
     X(NA_OFI_PROV_TCP,                                                  \
@@ -138,7 +138,7 @@
         "tcp",                                                          \
         FI_SOCKADDR_IN,                                                 \
         FI_PROGRESS_MANUAL,                                             \
-        FI_DIRECTED_RECV,                                               \
+        (FI_SOURCE | FI_DIRECTED_RECV),                                 \
         (NA_OFI_WAIT_FD | NA_OFI_NO_SEP | NA_OFI_SKIP_SIGNAL)           \
     )                                                                   \
     X(NA_OFI_PROV_PSM2,                                                 \
@@ -154,7 +154,7 @@
         "verbs",                                                        \
         FI_SOCKADDR_IN,                                                 \
         FI_PROGRESS_MANUAL,                                             \
-        (FI_DIRECTED_RECV),                                             \
+        (FI_SOURCE | FI_DIRECTED_RECV),                                 \
         (NA_OFI_VERIFY_PROV_DOM | NA_OFI_WAIT_FD | NA_OFI_NO_SEP | NA_OFI_SKIP_SIGNAL)   \
     )                                                                   \
     X(NA_OFI_PROV_GNI,                                                  \
@@ -171,10 +171,10 @@
 enum na_ofi_prov_type { NA_OFI_PROV_TYPES };
 #undef X
 #define X(a, b, c, d, e, f, g) b,
-static char * const na_ofi_prov_name[] = { NA_OFI_PROV_TYPES };
+static const char * const na_ofi_prov_name[] = { NA_OFI_PROV_TYPES };
 #undef X
 #define X(a, b, c, d, e, f, g) c,
-static char * const na_ofi_prov_alt_name[] = { NA_OFI_PROV_TYPES };
+static const char *const na_ofi_prov_alt_name[] = { NA_OFI_PROV_TYPES };
 #undef X
 #define X(a, b, c, d, e, f, g) d,
 static na_uint32_t const na_ofi_prov_addr_format[] = { NA_OFI_PROV_TYPES };
@@ -191,42 +191,45 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 
 /* Address / URI max len */
 #define NA_OFI_MAX_URI_LEN              (128)
-#define NA_OFI_GNI_AV_STR_ADDR_VERSION  1
+#define NA_OFI_GNI_AV_STR_ADDR_VERSION  (1)
 #define NA_OFI_GNI_IFACE_DEFAULT        "ipogif0"
 
 /* Memory pool (enabled by default, comment out to disable) */
 #define NA_OFI_HAS_MEM_POOL
-#define NA_OFI_MEM_BLOCK_COUNT  (256)
+#define NA_OFI_MEM_BLOCK_COUNT          (256)
 
 /* Max tag */
-#define NA_OFI_MAX_TAG          ((1 << 30) -1)
+#define NA_OFI_MAX_TAG                  ((1 << 30) -1)
 
 /* Unexpected size */
-#define NA_OFI_UNEXPECTED_SIZE          4096
+#define NA_OFI_UNEXPECTED_SIZE          (4096)
 #define NA_OFI_EXPECTED_TAG_FLAG        (0x100000000ULL)
 #define NA_OFI_UNEXPECTED_TAG_IGNORE    (0x0FFFFFFFFULL)
 
 /* Number of CQ event provided for fi_cq_read() */
-#define NA_OFI_CQ_EVENT_NUM     (16)
+#define NA_OFI_CQ_EVENT_NUM             (16)
 /* CQ depth (the socket provider's default value is 256 */
-#define NA_OFI_CQ_DEPTH         (8192)
+#define NA_OFI_CQ_DEPTH                 (8192)
 /* CQ max err data size (fix to 48 to work around bug in gni provider code) */
-#define NA_OFI_CQ_MAX_ERR_DATA_SIZE (48)
+#define NA_OFI_CQ_MAX_ERR_DATA_SIZE     (48)
 
-/* The magic number for na_ofi_op_id verification */
-#define NA_OFI_OP_ID_MAGIC_1    (0x1928374655627384ULL)
-#define NA_OFI_OP_ID_MAGIC_2    (0x8171615141312111ULL)
+/* Number of retries when receiving FI_EINTR error */
+#define NA_OFI_MAX_EINTR_RETRY          (1000)
 
 /* The predefined RMA KEY for MR_SCALABLE */
-#define NA_OFI_RMA_KEY          (0x0F1B0F1BULL)
+#define NA_OFI_RMA_KEY                  (0x0F1B0F1BULL)
 
 /* Receive context bits for SEP */
-#define NA_OFI_SEP_RX_CTX_BITS  (8)
+#define NA_OFI_SEP_RX_CTX_BITS          (8)
+
+/* Op ID status bits */
+#define NA_OFI_OP_COMPLETED             (1 << 0)
+#define NA_OFI_OP_CANCELED              (1 << 1)
 
 /* Private data access */
-#define NA_OFI_CLASS(na_class) \
+#define NA_OFI_CLASS(na_class)      \
     ((struct na_ofi_class *)((na_class)->plugin_class))
-#define NA_OFI_CONTEXT(na_context)    \
+#define NA_OFI_CONTEXT(na_context)  \
     ((struct na_ofi_context *)((na_context)->plugin_context))
 
 /************************************/
@@ -235,13 +238,15 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 
 /* Address */
 struct na_ofi_addr {
-    void *addr;                 /* Native address */
-    na_size_t addrlen;          /* Native address len */
-    char *uri;                  /* Generated URI */
-    fi_addr_t fi_addr;          /* FI address */
-    hg_atomic_int32_t refcount; /* Reference counter (dup/free)  */
-    na_bool_t self;             /* Boolean for self */
-    na_bool_t unexpected;       /* Boolean for unexpected (no uri/addr) */
+    struct na_ofi_domain *domain;           /* Domain                   */
+    void *addr;                             /* Native address           */
+    na_size_t addrlen;                      /* Native address len       */
+    char *uri;                              /* Generated URI            */
+    fi_addr_t fi_addr;                      /* FI address               */
+    na_uint64_t ht_key;                     /* Key in hash-table        */
+    hg_atomic_int32_t refcount;             /* Reference counter        */
+    na_bool_t self;                         /* Boolean for self         */
+    na_bool_t remove;                       /* Remove from AV on free   */
 };
 
 /* SIN address */
@@ -258,17 +263,17 @@ struct na_ofi_psm2_addr {
 /* GNI address */
 struct na_ofi_gni_addr {
     struct {
-        na_uint32_t device_addr;        /* physical NIC address */
-        na_uint32_t cdm_id;             /* user supplied id */
+        na_uint32_t device_addr;            /* physical NIC address     */
+        na_uint32_t cdm_id;                 /* user supplied id         */
     };
     struct {
-        na_uint32_t name_type : 8;      /* bound, unbound, SEP name types */
-        na_uint32_t cm_nic_cdm_id : 24; /* CM nic ID */
-        na_uint32_t cookie;             /* communication domain identifier */
+        na_uint32_t name_type : 8;          /* bound, unbound           */
+        na_uint32_t cm_nic_cdm_id : 24;     /* CM nic ID                */
+        na_uint32_t cookie;                 /* CDM identifier           */
     };
     struct {
-        na_uint32_t rx_ctx_cnt : 8;     /* number of contexts */
-        na_uint32_t key_offset : 12;    /* auth key offset */
+        na_uint32_t rx_ctx_cnt : 8;         /* number of contexts       */
+        na_uint32_t key_offset : 12;        /* auth key offset          */
         na_uint32_t unused1 : 12;
         na_uint32_t unused2;
     };
@@ -277,121 +282,107 @@ struct na_ofi_gni_addr {
 
 /* Memory handle */
 struct na_ofi_mem_desc {
-    na_uint64_t mr_key;                 /* FI MR key */
-    na_ptr_t    base;                   /* Base address of memory */
-    na_size_t   size;                   /* Size of registered region */
-    na_uint8_t  attr;                   /* Flag of operation access */
+    na_uint64_t fi_mr_key;                  /* FI MR key                */
+    na_ptr_t    base;                       /* Base address of memory   */
+    na_size_t   size;                       /* Size of region           */
+    na_uint8_t  attr;                       /* Flag of operation access */
 };
 
 struct na_ofi_mem_handle {
-    struct na_ofi_mem_desc desc;        /* Memory descriptor */
-    struct fid_mr *mr_hdl;              /* FI MR handle */
+    struct na_ofi_mem_desc desc;            /* Memory descriptor        */
+    struct fid_mr *fi_mr;                   /* FI MR handle             */
 };
 
 /* Lookup info */
 struct na_ofi_info_lookup {
-    na_addr_t noi_addr;
+    na_addr_t addr;
 };
 
 /* Unexpected recv info */
 struct na_ofi_info_recv_unexpected {
-    void *noi_buf;
-    na_size_t noi_buf_size;
-    na_size_t noi_msg_size;
-    na_tag_t noi_tag;
+    void *buf;
+    na_size_t buf_size;
+    na_size_t msg_size;
+    na_tag_t tag;
 };
 
 /* Expected recv info */
 struct na_ofi_info_recv_expected {
-    void *noi_buf;
-    na_size_t noi_buf_size;
-    na_size_t noi_msg_size;
-    na_tag_t noi_tag;
+    void *buf;
+    na_size_t buf_size;
+    na_size_t msg_size;
+    na_tag_t tag;
 };
 
 /* Operation ID */
 struct na_ofi_op_id {
-    /* noo_magic_1 and noo_magic_2 are for data verification */
-    na_uint64_t noo_magic_1;
-    na_context_t *noo_context;
-    struct fi_context noo_fi_ctx;
-    struct na_cb_completion_data noo_completion_data;
-    struct na_ofi_addr *noo_addr;
-    hg_atomic_int32_t noo_completed;/* Operation completed */
-    hg_atomic_int32_t noo_canceled; /* Operation canceled  */
+    struct na_cb_completion_data completion_data; /* Completion data    */
     union {
-        struct na_ofi_info_lookup noo_lookup;
-        struct na_ofi_info_recv_unexpected noo_recv_unexpected;
-        struct na_ofi_info_recv_expected noo_recv_expected;
-    } noo_info;
-    hg_atomic_int32_t noo_refcount; /* Ref count */
-    HG_QUEUE_ENTRY(na_ofi_op_id) noo_entry;
-    na_uint64_t noo_magic_2;
+        struct na_ofi_info_lookup lookup;
+        struct na_ofi_info_recv_unexpected recv_unexpected;
+        struct na_ofi_info_recv_expected recv_expected;
+    } info;                                 /* Op info                  */
+    struct fi_context fi_ctx;               /* Context handle           */
+    na_context_t *context;                  /* NA context associated    */
+    struct na_ofi_addr *addr;               /* Address associated       */
+    HG_QUEUE_ENTRY(na_ofi_op_id) entry;     /* Entry in queue           */
+    hg_atomic_int32_t status;               /* Operation status         */
+    hg_atomic_int32_t refcount;             /* Refcount                 */
 };
 
 /* Op queue */
 struct na_ofi_queue {
-    hg_thread_spin_t noq_lock;
-    HG_QUEUE_HEAD(na_ofi_op_id) noq_queue;
+    HG_QUEUE_HEAD(na_ofi_op_id) queue;
+    hg_thread_spin_t lock;
 };
 
 /* Context */
 struct na_ofi_context {
-    na_uint8_t      noc_idx; /* context index, [0, nop_max_contexts - 1] */
-    struct fid_ep   *noc_tx; /* Transmit context */
-    struct fid_ep   *noc_rx; /* Receive context */
-    struct fid_cq   *noc_cq; /* CQ for basic ep or tx/rx context for sep */
-    struct fid_wait *noc_wait;  /* Wait set handle */
-    /* Unexpected op queue per context for scalable endpoint, for regular
-     * endpoint just a reference to per class op queue. */
-    struct na_ofi_queue *noc_unexpected_op_queue;
+    struct fid_ep *fi_tx;                    /* Transmit context handle  */
+    struct fid_ep *fi_rx;                    /* Receive context handle   */
+    struct fid_cq *fi_cq;                    /* CQ handle                */
+    struct fid_wait *fi_wait;                /* Wait set handle          */
+    struct na_ofi_queue *unexpected_op_queue;/* Unexpected op queue     */
+    na_uint8_t idx;                         /* Context index            */
 };
 
 /* Endpoint */
 struct na_ofi_endpoint {
-    struct na_ofi_addr *noe_addr;/* Endpoint address */
-    struct fi_info *noe_prov;   /* OFI provider info */
-    struct fid_ep *noe_ep;      /* Endpoint to communicate on */
-    struct fid_cq *noe_cq;      /* Completion queue handle, invalid for sep */
-    struct fid_wait *noe_wait;  /* Wait set handle, invalid for sep */
-    /* Unexpected op queue for regular endpoint */
-    struct na_ofi_queue *noe_unexpected_op_queue;
-    na_bool_t noe_sep;          /* True for SEP, false for basic EP */
+    struct na_ofi_addr *src_addr;           /* Endpoint address         */
+    struct fi_info *fi_prov;                /* Provider info            */
+    struct fid_ep *fi_ep;                   /* Endpoint handle          */
+    struct fid_wait *fi_wait;               /* Wait set handle          */
+    struct fid_cq *fi_cq;                   /* CQ handle                */
+    struct na_ofi_queue *unexpected_op_queue;/* Unexpected op queue     */
+    na_bool_t sep;                          /* Scalable endpoint        */
 };
 
 /* Domain */
 struct na_ofi_domain {
-    enum na_ofi_prov_type nod_prov_type;    /* OFI provider type */
-    char *nod_prov_name;                    /* OFI provider name */
+    hg_thread_mutex_t mutex;                /* Mutex for AV etc         */
+    hg_thread_rwlock_t rwlock;              /* RW lock for addr_ht      */
+    HG_LIST_ENTRY(na_ofi_domain) entry;     /* Entry in domain list     */
 #ifdef NA_OFI_HAS_EXT_GNI_H
-    struct fi_gni_auth_key fi_gni_auth_key; /* GNI auth key */
+    struct fi_gni_auth_key fi_gni_auth_key; /* GNI auth key             */
 #endif
-    struct fi_info *nod_prov;               /* OFI provider info */
-    struct fid_fabric *nod_fabric;          /* Fabric domain handle */
-    struct fid_domain *nod_domain;          /* Access domain handle */
-    /* Memory region handle, only valid for MR_SCALABLE */
-    struct fid_mr *nod_mr;
-    na_uint64_t nod_mr_key;                 /* FI MR key */
-    struct fid_av *nod_av;                  /* Address vector handle */
-    /* mutex to protect per domain resource like av */
-    hg_thread_mutex_t nod_mutex;
-    /*
-     * Address hash-table, to map the source-side address to fi_addr_t.
-     * The key is 64bits value serialized from source-side IP+Port (see
-     * na_ofi_reqhdr_2_key), the value is fi_addr_t.
-     */
-    hg_hash_table_t *nod_addr_ht;
-    hg_thread_rwlock_t nod_rwlock;          /* RW lock to protect nod_addr_ht */
-    hg_atomic_int32_t nod_refcount;         /* Refcount of this domain */
-    HG_LIST_ENTRY(na_ofi_domain) nod_entry; /* Entry in nog_domain_list */
+    struct fid_fabric *fi_fabric;           /* Fabric handle            */
+    struct fid_domain *fi_domain;           /* Domain handle            */
+    struct fi_info *fi_prov;                /* Provider info            */
+    struct fid_mr *fi_mr;                   /* Global MR handle         */
+    na_uint64_t fi_mr_key;                  /* Global MR key            */
+    struct fid_av *fi_av;                   /* Address vector handle    */
+    hg_hash_table_t *addr_ht;               /* Address hash_table       */
+    char *prov_name;                        /* Provider name            */
+    enum na_ofi_prov_type prov_type;        /* Provider type            */
+    hg_atomic_int32_t refcount;             /* Refcount of this domain  */
 };
 
 /**
  * Memory node (points to actual data).
  */
 struct na_ofi_mem_node {
-    HG_QUEUE_ENTRY(na_ofi_mem_node) entry;  /* Entry in node_list */
-    char *block;                            /* Must be last */
+    HG_QUEUE_ENTRY(na_ofi_mem_node) entry;  /* Entry in node_list       */
+    char *block;                            /* Must be last             */
 };
 
 /**
@@ -400,25 +391,24 @@ struct na_ofi_mem_node {
  * functions.
  */
 struct na_ofi_mem_pool {
-    HG_QUEUE_ENTRY(na_ofi_mem_pool) entry;      /* Entry in pool list */
-    struct fid_mr *mr_hdl;                      /* MR handle */
-    na_size_t block_size;                       /* Node block size */
-    hg_thread_spin_t node_list_lock;            /* Node list lock */
-    HG_QUEUE_HEAD(na_ofi_mem_node) node_list;   /* Node list */
+    HG_QUEUE_HEAD(na_ofi_mem_node) node_list;   /* Node list            */
+    HG_QUEUE_ENTRY(na_ofi_mem_pool) entry;  /* Entry in pool list       */
+    struct fid_mr *mr_hdl;                  /* MR handle                */
+    na_size_t block_size;                   /* Node block size          */
+    hg_thread_spin_t node_list_lock;        /* Node list lock           */
 };
 
 /* Private data */
 struct na_ofi_class {
-    struct na_ofi_domain *nop_domain; /* Point back to access domain */
-    struct na_ofi_endpoint *nop_endpoint;
-    na_bool_t nop_listen; /* flag of listening, true for server */
-    na_uint8_t nop_contexts; /* number of context */
-    na_uint8_t nop_max_contexts; /* max number of contexts */
-    /* nop_mutex only used for verbs provider as it is not thread safe now */
-    hg_thread_mutex_t nop_mutex;
-    HG_QUEUE_HEAD(na_ofi_mem_pool) nop_buf_pool;    /* Msg buf pool head */
-    hg_thread_spin_t nop_buf_pool_lock;             /* Buf pool lock */
-    na_bool_t no_wait; /* Ignore wait object */
+    hg_thread_mutex_t mutex;                /* Mutex (for verbs prov)   */
+    HG_QUEUE_HEAD(na_ofi_mem_pool) buf_pool;/* Msg buf pool head        */
+    struct na_ofi_domain *domain;           /* Domain pointer           */
+    struct na_ofi_endpoint *endpoint;       /* Endpoint pointer         */
+    hg_thread_spin_t buf_pool_lock;         /* Buf pool lock            */
+    na_uint8_t contexts;                    /* Number of context        */
+    na_uint8_t max_contexts;                /* Max number of contexts   */
+    na_bool_t listen;                       /* Listening flag           */
+    na_bool_t no_wait;                      /* Ignore wait object       */
 };
 
 /********************/
@@ -504,13 +494,28 @@ na_ofi_addr_ht_key_equal(hg_hash_table_key_t vlocation1,
  * already exist.
  */
 static na_return_t
-na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
-    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr);
+na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
+    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key);
+
+/**
+ * Remove an addr from the AV and the hash-table.
+ */
+static na_return_t
+na_ofi_addr_ht_remove(struct na_ofi_domain *domain, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key);
+
+/**
+ * Lookup an FI addr from the AV.
+ */
+static na_return_t
+na_ofi_av_lookup(struct na_ofi_domain *na_ofi_domain, fi_addr_t fi_addr,
+    void **addr_ptr, size_t *addrlen_ptr);
 
 /**
  * Get info caps from providers and return matching providers.
  */
-static int
+static na_return_t
 na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers);
 
 /**
@@ -601,7 +606,7 @@ na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr);
  * Allocate address.
  */
 static struct na_ofi_addr *
-na_ofi_addr_alloc(void);
+na_ofi_addr_alloc(struct na_ofi_domain *na_ofi_domain);
 
 /**
  * Increment address refcount.
@@ -665,12 +670,6 @@ na_ofi_op_id_addref(struct na_ofi_op_id *na_ofi_op_id);
 static NA_INLINE void
 na_ofi_op_id_decref(struct na_ofi_op_id *na_ofi_op_id);
 
-/**
- * OP ID is valid.
- */
-static NA_INLINE na_bool_t
-na_ofi_op_id_valid(struct na_ofi_op_id *na_ofi_op_id);
-
 /**
  * Push OP ID to unexpected queue.
  */
@@ -685,20 +684,13 @@ static NA_INLINE void
 na_ofi_msg_unexpected_op_remove(na_context_t *context,
     struct na_ofi_op_id *na_ofi_op_id);
 
-/**
- * Pop and return first OP ID from unexpected queue.
- */
-static NA_INLINE struct na_ofi_op_id *
-na_ofi_msg_unexpected_op_pop(na_context_t *context);
-
 /**
  * Read from CQ.
  */
 static na_return_t
-na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
-    size_t max_count, struct fi_cq_tagged_entry cq_events[],
-    fi_addr_t src_addrs[], void **src_err_addr, size_t *src_err_addrlen,
-    size_t *actual_count);
+na_ofi_cq_read(na_context_t *context, size_t max_count,
+    struct fi_cq_tagged_entry cq_events[], fi_addr_t src_addrs[],
+    void **src_err_addr, size_t *src_err_addrlen, size_t *actual_count);
 
 /**
  * Process event from CQ.
@@ -786,6 +778,10 @@ static na_return_t
 na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const char *name, na_op_id_t *op_id);
 
+/* addr_lookup2 */
+static na_return_t
+na_ofi_addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr);
+
 /* addr_self */
 static NA_INLINE na_return_t
 na_ofi_addr_self(na_class_t *na_class, na_addr_t *addr);
@@ -798,6 +794,10 @@ na_ofi_addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr);
 static NA_INLINE na_return_t
 na_ofi_addr_free(na_class_t *na_class, na_addr_t addr);
 
+/* addr_set_remove */
+static NA_INLINE na_return_t
+na_ofi_addr_set_remove(na_class_t *na_class, na_addr_t addr);
+
 /* addr_is_self */
 static NA_INLINE na_bool_t
 na_ofi_addr_is_self(na_class_t *na_class, na_addr_t addr);
@@ -940,7 +940,7 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context, na_op_id_t op_id);
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN_OPS(ofi) = {
+const struct na_class_ops NA_PLUGIN_OPS(ofi) = {
     "ofi",                                  /* name */
     na_ofi_check_protocol,                  /* check_protocol */
     na_ofi_initialize,                      /* initialize */
@@ -951,7 +951,9 @@ NA_PLUGIN_OPS(ofi) = {
     na_ofi_op_create,                       /* op_create */
     na_ofi_op_destroy,                      /* op_destroy */
     na_ofi_addr_lookup,                     /* addr_lookup */
+    na_ofi_addr_lookup2,                    /* addr_lookup2 */
     na_ofi_addr_free,                       /* addr_free */
+    na_ofi_addr_set_remove,                 /* addr_set_remove */
     na_ofi_addr_self,                       /* addr_self */
     na_ofi_addr_dup,                        /* addr_dup */
     na_ofi_addr_is_self,                    /* addr_is_self */
@@ -1017,34 +1019,34 @@ na_ofi_prov_name_to_type(const char *prov_name)
 static NA_INLINE void
 na_ofi_domain_lock(struct na_ofi_domain *domain)
 {
-    if (na_ofi_prov_flags[domain->nod_prov_type] & NA_OFI_DOMAIN_LOCK)
-        hg_thread_mutex_lock(&domain->nod_mutex);
+    if (na_ofi_prov_flags[domain->prov_type] & NA_OFI_DOMAIN_LOCK)
+        hg_thread_mutex_lock(&domain->mutex);
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE void
 na_ofi_domain_unlock(struct na_ofi_domain *domain)
 {
-    if (na_ofi_prov_flags[domain->nod_prov_type] & NA_OFI_DOMAIN_LOCK)
-        hg_thread_mutex_unlock(&domain->nod_mutex);
+    if (na_ofi_prov_flags[domain->prov_type] & NA_OFI_DOMAIN_LOCK)
+        hg_thread_mutex_unlock(&domain->mutex);
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
 na_ofi_with_sep(const na_class_t *na_class)
 {
-    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->nop_endpoint;
+    struct na_ofi_endpoint *ep = NA_OFI_CLASS(na_class)->endpoint;
 
-    return ep->noe_sep;
+    return ep->sep;
 }
 
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
 na_ofi_with_msg_hdr(const na_class_t *na_class)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
 
-    return (na_ofi_prov_addr_format[domain->nod_prov_type] == FI_SOCKADDR_IN);
+    return (na_ofi_prov_addr_format[domain->prov_type] == FI_SOCKADDR_IN);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1077,7 +1079,7 @@ na_ofi_str_to_addr(const char *str, na_uint32_t addr_format, void **addr,
             return na_ofi_str_to_gni(str, addr, len);
         default:
             NA_LOG_ERROR("Unsupported address format");
-            return NA_PROTOCOL_ERROR;
+            return NA_PROTONOSUPPORT;
     }
 }
 
@@ -1087,47 +1089,36 @@ na_ofi_str_to_sin(const char *str, void **addr, na_size_t *len)
 {
     struct na_ofi_sin_addr *sin_addr;
     char ip[16];
-    int ret;
+    na_return_t ret = NA_SUCCESS;
 
     *len = sizeof(*sin_addr);
     sin_addr = calloc(1, *len);
-    if (!sin_addr) {
-        NA_LOG_ERROR("Could not allocate sin address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(sin_addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate sin address");
 
     sin_addr->sin.sin_family = AF_INET;
-    ret = sscanf(str, "%*[^:]://:%" SCNu16, &sin_addr->sin.sin_port);
-    if (ret == 1)
-        goto match_port;
-
-    ret = sscanf(str, "%*[^:]://%15[^:]:%" SCNu16, ip, &sin_addr->sin.sin_port);
-    if (ret == 2)
-        goto match_ip;
-
-    ret = sscanf(str, "%*[^:]://%15[^:/]", ip);
-    if (ret == 1)
-        goto match_ip;
-
-    NA_LOG_ERROR("Malformed FI_ADDR_STR: %s\n", str);
+    if (sscanf(str, "%*[^:]://:%" SCNu16, &sin_addr->sin.sin_port) == 1) {
+        /* nothing */
+    } else if ((sscanf(str, "%*[^:]://%15[^:]:%" SCNu16, ip, &sin_addr->sin.sin_port) == 2)
+        || (sscanf(str, "%*[^:]://%15[^:/]", ip) == 1)) {
+        int rc;
 
-err:
-    free(sin_addr);
-    return NA_PROTOCOL_ERROR;
-
-match_ip:
-    ip[sizeof(ip) - 1] = '\0';
-    ret = inet_pton(AF_INET, ip, &sin_addr->sin.sin_addr);
-    if (ret != 1) {
-        NA_LOG_ERROR("Unable to convert IPv4 address: %s\n", ip);
-        goto err;
-    }
+        ip[sizeof(ip) - 1] = '\0';
+        rc = inet_pton(AF_INET, ip, &sin_addr->sin.sin_addr);
+        NA_CHECK_ERROR(rc != 1, error, ret, NA_PROTONOSUPPORT,
+            "Unable to convert IPv4 address: %s\n", ip);
+    } else
+        NA_GOTO_ERROR(error, ret, NA_PROTONOSUPPORT,
+            "Malformed FI_ADDR_STR: %s\n", str);
 
-match_port:
     sin_addr->sin.sin_port = htons(sin_addr->sin.sin_port);
     *addr = sin_addr;
 
-    return NA_SUCCESS;
+    return ret;
+
+error:
+    free(sin_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1135,26 +1126,26 @@ static na_return_t
 na_ofi_str_to_psm2(const char *str, void **addr, na_size_t *len)
 {
     struct na_ofi_psm2_addr *psm2_addr;
-    int ret;
+    na_return_t ret = NA_SUCCESS;
+    int rc;
 
     *len = sizeof(*psm2_addr);
     psm2_addr = calloc(1, *len);
-    if (!psm2_addr) {
-        NA_LOG_ERROR("Could not allocate psm2 address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(psm2_addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate psm2 address");
 
-    ret = sscanf(str, "%*[^:]://%" SCNx64 ":%" SCNx64,
+    rc = sscanf(str, "%*[^:]://%" SCNx64 ":%" SCNx64,
         (uint64_t *) &psm2_addr->addr0, (uint64_t *) &psm2_addr->addr1);
-    if (ret != 2) {
-        NA_LOG_ERROR("Could not convert addr string to PSM2 addr format");
-        free(psm2_addr);
-        return NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 2, error, ret, NA_PROTONOSUPPORT,
+        "Could not convert addr string to PSM2 addr format");
 
     *addr = psm2_addr;
 
-    return NA_SUCCESS;
+    return ret;
+
+error:
+    free(psm2_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1164,28 +1155,21 @@ na_ofi_str_to_gni(const char *str, void **addr, na_size_t *len)
     struct na_ofi_gni_addr *gni_addr;
     unsigned int version, name_type, rx_ctx_cnt;
     na_uint32_t device_addr, cdm_id, cm_nic_cdm_id, cookie;
-    int ret;
+    na_return_t ret = NA_SUCCESS;
+    int rc;
 
     *len = sizeof(*gni_addr);
     gni_addr = calloc(1, *len);
-    if (!gni_addr) {
-        NA_LOG_ERROR("Could not allocate gni address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(gni_addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate gni address");
 
-    ret = sscanf(str, "%*[^:]://%04u:0x%08" PRIx32 ":0x%08" PRIx32 ":%02u:0x%06"
+    rc = sscanf(str, "%*[^:]://%04u:0x%08" PRIx32 ":0x%08" PRIx32 ":%02u:0x%06"
         PRIx32 ":0x%08" PRIx32 ":%02u", &version, &device_addr, &cdm_id,
         &name_type, &cm_nic_cdm_id, &cookie, &rx_ctx_cnt);
-    if (ret != 7) {
-        NA_LOG_ERROR("Could not convert addr string to GNI addr format");
-        free(gni_addr);
-        return NA_PROTOCOL_ERROR;
-    }
-    if (version != NA_OFI_GNI_AV_STR_ADDR_VERSION) {
-        NA_LOG_ERROR("Unsupported GNI string addr format");
-        free(gni_addr);
-        return NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 7, error, ret, NA_PROTONOSUPPORT,
+            "Could not convert addr string to GNI addr format");
+    NA_CHECK_ERROR(version != NA_OFI_GNI_AV_STR_ADDR_VERSION, error, ret,
+        NA_PROTONOSUPPORT, "Unsupported GNI string addr format");
 
     gni_addr->device_addr = device_addr;
     gni_addr->cdm_id = cdm_id;
@@ -1193,16 +1177,18 @@ na_ofi_str_to_gni(const char *str, void **addr, na_size_t *len)
     gni_addr->cm_nic_cdm_id = cm_nic_cdm_id & 0xffffff;
     gni_addr->cookie = cookie;
     gni_addr->rx_ctx_cnt = rx_ctx_cnt & 0xff;
-    /*
     NA_LOG_DEBUG("GNI addr is: device_addr=%x, cdm_id=%x, name_type=%x, "
         "cm_nic_cdm_id=%x, cookie=%x, rx_ctx_cnt=%u",
         gni_addr->device_addr, gni_addr->cdm_id, gni_addr->name_type,
         gni_addr->cm_nic_cdm_id, gni_addr->cookie, gni_addr->rx_ctx_cnt);
-     */
 
     *addr = gni_addr;
 
-    return NA_SUCCESS;
+    return ret;
+
+error:
+    free(gni_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1271,95 +1257,143 @@ na_ofi_addr_ht_key_equal(hg_hash_table_key_t vlocation1,
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_addr_ht_lookup(na_class_t *na_class, na_uint32_t addr_format,
-    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr)
+na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
+    const void *addr, na_size_t addrlen, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
-    na_uint64_t addr_key;
-    hg_hash_table_key_t ht_key = NULL;
+    hg_hash_table_key_t ht_key = addr_key;
     hg_hash_table_value_t ht_value = NULL;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
     /* Generate key */
-    addr_key = na_ofi_addr_to_key(addr_format, addr, addrlen);
-    if (!addr_key) {
-        NA_LOG_ERROR("Could not generate key from addr");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    *addr_key = na_ofi_addr_to_key(addr_format, addr, addrlen);
+    NA_CHECK_ERROR(*addr_key == 0, out, ret, NA_PROTONOSUPPORT,
+        "Could not generate key from addr");
 
     /* Lookup key */
-    hg_thread_rwlock_rdlock(&domain->nod_rwlock);
-    ht_value = hg_hash_table_lookup(domain->nod_addr_ht, &addr_key);
+    hg_thread_rwlock_rdlock(&domain->rwlock);
+    ht_value = hg_hash_table_lookup(domain->addr_ht, ht_key);
+    hg_thread_rwlock_release_rdlock(&domain->rwlock);
     if (ht_value != HG_HASH_TABLE_NULL) {
+        /* Found */
         *fi_addr = *(fi_addr_t *) ht_value;
-        hg_thread_rwlock_release_rdlock(&domain->nod_rwlock);
-        return ret;
+        goto out;
     }
-    hg_thread_rwlock_release_rdlock(&domain->nod_rwlock);
 
     /* Insert addr into AV if key not found */
     na_ofi_domain_lock(domain);
-    rc = fi_av_insert(domain->nod_av, addr, 1, fi_addr, 0 /* flags */,
-        NULL /* context */);
+    rc = fi_av_insert(domain->fi_av, addr, 1, fi_addr, 0 /* flags */, NULL);
     na_ofi_domain_unlock(domain);
-    if (rc < 1) {
-        NA_LOG_ERROR("fi_av_insert failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc < 1, out, ret, NA_PROTOCOL_ERROR,
+        "fi_av_insert() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+
+    hg_thread_rwlock_wrlock(&domain->rwlock);
 
-    hg_thread_rwlock_wrlock(&domain->nod_rwlock);
-    /* in race condition, use addr in HT and remove the new addr from AV */
-    ht_value = hg_hash_table_lookup(domain->nod_addr_ht, &addr_key);
+    ht_value = hg_hash_table_lookup(domain->addr_ht, ht_key);
     if (ht_value != HG_HASH_TABLE_NULL) {
-        fi_av_remove(domain->nod_av, fi_addr, 1, 0);
-        hg_thread_rwlock_release_wrlock(&domain->nod_rwlock);
+        /* in race condition, use addr in HT and remove the new addr from AV */
+        rc = fi_av_remove(domain->fi_av, fi_addr, 1, 0 /* flags */);
+        NA_CHECK_ERROR(rc != 0, unlock, ret, NA_PROTOCOL_ERROR,
+            "fi_av_remove() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
         *fi_addr = *(fi_addr_t *) ht_value;
-        return ret;
+        goto unlock;
     }
 
     /* Allocate new key */
     ht_key = malloc(sizeof(na_uint64_t));
-    if (!ht_key) {
-        NA_LOG_ERROR("cannot allocate memory for ht_key");
-        ret = NA_NOMEM_ERROR;
-        goto unlock;
-    }
+    NA_CHECK_ERROR(ht_key == NULL, error, ret, NA_NOMEM,
+        "Cannot allocate memory for ht_key");
 
     /* Allocate new value */
     ht_value = malloc(sizeof(*fi_addr));
-    if (!ht_value) {
-        NA_LOG_ERROR("cannot allocate memory for ht_key");
-        ret = NA_NOMEM_ERROR;
-        goto unlock;
-    }
+    NA_CHECK_ERROR(ht_value == NULL, error, ret, NA_NOMEM,
+        "cannot allocate memory for ht_key");
 
-    *((na_uint64_t *) ht_key) = addr_key;
+    *((na_uint64_t *) ht_key) = *addr_key;
     *((na_uint64_t *) ht_value) = *fi_addr;
 
     /* Insert new value */
-    if (!hg_hash_table_insert(domain->nod_addr_ht, ht_key, ht_value)) {
-        NA_LOG_ERROR("hg_hash_table_insert() failed.");
-        ret = NA_NOMEM_ERROR;
-        goto unlock;
-    }
+    rc = hg_hash_table_insert(domain->addr_ht, ht_key, ht_value);
+    NA_CHECK_ERROR(rc == 0, error, ret, NA_NOMEM,
+        "hg_hash_table_insert() failed");
 
 unlock:
-    hg_thread_rwlock_release_wrlock(&domain->nod_rwlock);
+    hg_thread_rwlock_release_wrlock(&domain->rwlock);
 
 out:
-    if (ret != NA_SUCCESS) {
-        free(ht_key);
-        free(ht_value);
+    return ret;
+
+error:
+    hg_thread_rwlock_release_wrlock(&domain->rwlock);
+    free(ht_key);
+    free(ht_value);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ofi_addr_ht_remove(struct na_ofi_domain *domain, fi_addr_t *fi_addr,
+    na_uint64_t *addr_key)
+{
+    na_return_t ret = NA_SUCCESS;
+    int rc;
+
+    hg_thread_rwlock_wrlock(&domain->rwlock);
+    rc = hg_hash_table_remove(domain->addr_ht, (hg_hash_table_key_t) addr_key);
+    NA_CHECK_ERROR(rc != 1, unlock, ret, NA_NOENTRY,
+        "hg_hash_table_remove() failed");
+
+    rc = fi_av_remove(domain->fi_av, fi_addr, 1, 0 /* flags */);
+    NA_CHECK_ERROR(rc != 0, unlock, ret, NA_PROTOCOL_ERROR,
+        "fi_av_remove() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+
+unlock:
+    hg_thread_rwlock_release_wrlock(&domain->rwlock);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ofi_av_lookup(struct na_ofi_domain *na_ofi_domain, fi_addr_t fi_addr,
+    void **addr_ptr, size_t *addrlen_ptr)
+{
+    void *addr = NULL;
+    size_t addrlen = na_ofi_domain->fi_prov->src_addrlen;
+    na_bool_t retried = NA_FALSE;
+    na_return_t ret = NA_SUCCESS;
+    int rc;
+
+retry:
+    addr = malloc(addrlen);
+    NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate %zu bytes for address", addrlen);
+
+    /* Lookup address from AV */
+    na_ofi_domain_lock(na_ofi_domain);
+    rc = fi_av_lookup(na_ofi_domain->fi_av, fi_addr, addr, &addrlen);
+    na_ofi_domain_unlock(na_ofi_domain);
+    if (rc == -FI_ETOOSMALL && retried == NA_FALSE) {
+        retried = NA_TRUE;
+        free(addr);
+        goto retry;
     }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_av_lookup() failed, rc: %d(%s)", rc,
+        fi_strerror((int ) -rc));
+
+    *addr_ptr = addr;
+    *addrlen_ptr = addrlen;
+
+    return ret;
+
+error:
+    free(addr);
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
-static int
+static na_return_t
 na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers)
 {
     struct fi_info *hints = NULL;
@@ -1370,19 +1404,13 @@ na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers)
       * Hints to query && filter providers.
       */
     hints = fi_allocinfo();
-    if (!hints) {
-        NA_LOG_ERROR("fi_allocinfo failed.\n");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM,
+        "fi_allocinfo() failed");
 
     /* Protocol name is provider name, filter out providers within libfabric */
     hints->fabric_attr->prov_name = strdup(na_ofi_prov_name[prov_type]);
-    if (!hints->fabric_attr->prov_name) {
-        NA_LOG_ERROR("Could not duplicate name");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(hints->fabric_attr->prov_name == NULL, cleanup, ret,
+        NA_NOMEM, "Could not duplicate name");
 
     /* mode: operational mode, NA_OFI passes in context for communication calls. */
     /* FI_ASYNC_IOV mode indicates  that  the  application  must  provide  the
@@ -1444,18 +1472,15 @@ na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers)
                     0ULL,  /* Optional flag */
                     hints, /* In: Hints to filter providers */
                     providers); /* Out: List of matching providers */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_getinfo failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, cleanup, ret, NA_PROTOCOL_ERROR,
+        "fi_getinfo() failed, rc: %d(%s)", rc, fi_strerror(-rc));
+
+cleanup:
+    free(hints->fabric_attr->prov_name);
+    hints->fabric_attr->prov_name = NULL;
+    fi_freeinfo(hints);
 
 out:
-    if (hints) {
-        free(hints->fabric_attr->prov_name);
-        hints->fabric_attr->prov_name = NULL;
-        fi_freeinfo(hints);
-    }
     return ret;
 }
 
@@ -1474,10 +1499,8 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
 
     /* Allocate new sin addr to store result */
     na_ofi_sin_addr = calloc(1, sizeof(*na_ofi_sin_addr));
-    if (!na_ofi_sin_addr) {
-        NA_LOG_ERROR("Could not allocate sin address");
-        return NA_NOMEM_ERROR;
-    }
+    NA_CHECK_ERROR(na_ofi_sin_addr == NULL, out, ret, NA_NOMEM,
+        "Could not allocate sin address");
     na_ofi_sin_addr->sin.sin_family = AF_INET;
     na_ofi_sin_addr->sin.sin_port = htons(port & 0xffff);
 
@@ -1491,27 +1514,25 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
     if (s == 0) {
         struct addrinfo *rp;
 
+        /* Get IP */
         for (rp = hostname_res; rp != NULL; rp = rp->ai_next) {
-            /* Get IP */
-            if (!inet_ntop(rp->ai_addr->sa_family,
+            const char *ptr = inet_ntop(rp->ai_addr->sa_family,
                 &((struct sockaddr_in *) rp->ai_addr)->sin_addr, ip_res,
-                INET_ADDRSTRLEN)) {
-                NA_LOG_ERROR("IP could not be resolved");
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
+                INET_ADDRSTRLEN);
+            NA_CHECK_ERROR(ptr == NULL, out, ret, NA_ADDRNOTAVAIL,
+                "IP could not be resolved");
             break;
         }
     }
 
     /* Check and compare interfaces */
-    if (getifaddrs(&ifaddrs) == -1) {
-        NA_LOG_ERROR("getifaddrs() failed");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    s = getifaddrs(&ifaddrs);
+    NA_CHECK_ERROR(s == -1, out, ret, NA_ADDRNOTAVAIL,
+        "getifaddrs() failed");
+
     for (ifaddr = ifaddrs; ifaddr != NULL; ifaddr = ifaddr->ifa_next) {
         char ip[INET_ADDRSTRLEN] = {'\0'}; /* This restricts to ipv4 addresses */
+        const char *ptr;
 
         if (ifaddr->ifa_addr == NULL)
             continue;
@@ -1520,13 +1541,11 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
             continue;
 
         /* Get IP */
-        if (!inet_ntop(ifaddr->ifa_addr->sa_family,
+        ptr = inet_ntop(ifaddr->ifa_addr->sa_family,
             &((struct sockaddr_in *) ifaddr->ifa_addr)->sin_addr, ip,
-            INET_ADDRSTRLEN)) {
-            NA_LOG_ERROR("IP could not be resolved for: %s", ifaddr->ifa_name);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+            INET_ADDRSTRLEN);
+        NA_CHECK_ERROR(ptr == NULL, out, ret, NA_ADDRNOTAVAIL,
+            "IP could not be resolved for: %s", ifaddr->ifa_name);
 
         /* Compare hostnames / device names */
         if (!strcmp(ip, ip_res) || !strcmp(ifaddr->ifa_name, hostname)) {
@@ -1541,10 +1560,8 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
         *na_ofi_sin_addr_ptr = na_ofi_sin_addr;
         if (ifa_name) {
             *ifa_name = strdup(ifaddr->ifa_name);
-            if (!*ifa_name) {
-                NA_LOG_ERROR("Could not dup ifa_name");
-                ret = NA_NOMEM_ERROR;
-            }
+            NA_CHECK_ERROR(*ifa_name == NULL, out, ret, NA_NOMEM,
+                "Could not dup ifa_name");
         }
     }
 
@@ -1554,6 +1571,7 @@ out:
     freeifaddrs(ifaddrs);
     if (hostname_res)
         freeaddrinfo(hostname_res);
+
     return ret;
 }
 
@@ -1562,26 +1580,21 @@ static NA_INLINE na_bool_t
 na_ofi_verify_provider(enum na_ofi_prov_type prov_type, const char *domain_name,
     const struct fi_info *fi_info)
 {
-    na_bool_t ret = NA_FALSE;
-
     /* Does not match provider name */
     if (strcmp(na_ofi_prov_name[prov_type], fi_info->fabric_attr->prov_name))
-        goto out;
+        return NA_FALSE;
 
     /* for some providers the provider name is ambiguous and we must check
      * the domain name as well
      */
-    if(na_ofi_prov_flags[prov_type] & NA_OFI_VERIFY_PROV_DOM) {
+    if (na_ofi_prov_flags[prov_type] & NA_OFI_VERIFY_PROV_DOM) {
         /* Does not match domain name */
         if (domain_name && strcmp("\0", domain_name)
             && strcmp(domain_name, fi_info->domain_attr->name))
-            goto out;
+            return NA_FALSE;
     }
 
-    ret = NA_TRUE;
-
-out:
-    return ret;
+    return NA_TRUE;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1594,20 +1607,14 @@ na_ofi_gni_set_domain_op_value(struct na_ofi_domain *na_ofi_domain, int op,
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    rc = fi_open_ops(&na_ofi_domain->nod_domain->fid, FI_GNI_DOMAIN_OPS_1,
+    rc = fi_open_ops(&na_ofi_domain->fi_domain->fid, FI_GNI_DOMAIN_OPS_1,
         0, (void **) &gni_domain_ops, NULL);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_open_ops failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_open_ops() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-    rc = gni_domain_ops->set_val(&na_ofi_domain->nod_domain->fid, op, value);
-    if (rc != 0) {
-        NA_LOG_ERROR("set_val failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = gni_domain_ops->set_val(&na_ofi_domain->fi_domain->fid, op, value);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "gni_domain_ops->set_val() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
 out:
     return ret;
@@ -1616,8 +1623,7 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_domain_open(struct na_ofi_class *priv,
-    enum na_ofi_prov_type prov_type,
+na_ofi_domain_open(struct na_ofi_class *priv, enum na_ofi_prov_type prov_type,
     const char *domain_name, const char *auth_key,
     struct na_ofi_domain **na_ofi_domain_p)
 {
@@ -1634,114 +1640,85 @@ na_ofi_domain_open(struct na_ofi_class *priv,
      * na_ofi_domain.
      */
     hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
-    HG_LIST_FOREACH(na_ofi_domain, &na_ofi_domain_list_g, nod_entry) {
+    HG_LIST_FOREACH(na_ofi_domain, &na_ofi_domain_list_g, entry) {
         if (na_ofi_verify_provider(prov_type, domain_name,
-            na_ofi_domain->nod_prov)) {
-            hg_atomic_incr32(&na_ofi_domain->nod_refcount);
+            na_ofi_domain->fi_prov)) {
+            hg_atomic_incr32(&na_ofi_domain->refcount);
             domain_found = NA_TRUE;
             break;
         }
     }
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
     if (domain_found) {
-        /*
-        NA_LOG_DEBUG("Found existing domain (%s)",
-            na_ofi_domain->nod_prov_name);
-        */
+        NA_LOG_DEBUG("Found existing domain (%s)", na_ofi_domain->prov_name);
         *na_ofi_domain_p = na_ofi_domain;
-        goto out;
+        return ret;
     }
 
     /* If no pre-existing domain, get OFI providers info */
     ret = na_ofi_getinfo(prov_type, &providers);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_getinfo failed, ret: %d.", ret);
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "na_ofi_getinfo() failed");
 
     /* Try to find provider that matches protocol and domain/host name */
     prov = providers;
     while (prov != NULL) {
         if (na_ofi_verify_provider(prov_type, domain_name, prov)) {
-            /*
             NA_LOG_DEBUG("mode 0x%llx, fabric_attr -> prov_name: %s, name: %s; "
-                         "domain_attr -> name: %s, threading: %d.",
-                         prov->mode, prov->fabric_attr->prov_name,
-                         prov->fabric_attr->name, prov->domain_attr->name,
-                         prov->domain_attr->threading);
-            */
+                "domain_attr -> name: %s, threading: %d.", prov->mode,
+                prov->fabric_attr->prov_name, prov->fabric_attr->name,
+                prov->domain_attr->name, prov->domain_attr->threading);
             prov_found = NA_TRUE;
             break;
         }
         prov = prov->next;
     }
-    if (!prov_found) {
-        NA_LOG_ERROR("No provider found for \"%s\" provider on domain \"%s\"",
-                     na_ofi_prov_name[prov_type], domain_name);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(!prov_found, error, ret, NA_NOENTRY,
+        "No provider found for \"%s\" provider on domain \"%s\"",
+        na_ofi_prov_name[prov_type], domain_name);
 
     na_ofi_domain = (struct na_ofi_domain *) malloc(
         sizeof(struct na_ofi_domain));
-    if (na_ofi_domain == NULL) {
-        NA_LOG_ERROR("Could not allocate na_ofi_domain");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_domain == NULL, error, ret, NA_NOMEM,
+        "Could not allocate na_ofi_domain");
     memset(na_ofi_domain, 0, sizeof(struct na_ofi_domain));
-    hg_atomic_set32(&na_ofi_domain->nod_refcount, 1);
+    hg_atomic_init32(&na_ofi_domain->refcount, 1);
 
     /* Init mutex */
-    rc = hg_thread_mutex_init(&na_ofi_domain->nod_mutex);
-    if (rc != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_thread_mutex_init failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    rc = hg_thread_mutex_init(&na_ofi_domain->mutex);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_NOMEM,
+        "hg_thread_mutex_init() failed");
 
     /* Init rw lock */
-    rc = hg_thread_rwlock_init(&na_ofi_domain->nod_rwlock);
-    if (rc != HG_UTIL_SUCCESS) {
-        NA_LOG_ERROR("hg_thread_rwlock_init failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    rc = hg_thread_rwlock_init(&na_ofi_domain->rwlock);
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_NOMEM,
+        "hg_thread_rwlock_init() failed");
 
     /* Keep fi_info */
-    na_ofi_domain->nod_prov = fi_dupinfo(prov);
-    if (!na_ofi_domain->nod_prov) {
-        NA_LOG_ERROR("Could not duplicate fi_info");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_domain->fi_prov = fi_dupinfo(prov);
+    NA_CHECK_ERROR(na_ofi_domain->fi_prov == NULL, error, ret,
+        NA_NOMEM, "Could not duplicate fi_info");
 
     /* Dup provider name */
-    na_ofi_domain->nod_prov_name = strdup(prov->fabric_attr->prov_name);
-    if (!na_ofi_domain->nod_prov_name) {
-        NA_LOG_ERROR("Could not duplicate name");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_domain->prov_name = strdup(prov->fabric_attr->prov_name);
+    NA_CHECK_ERROR(na_ofi_domain->prov_name == NULL, error, ret,
+        NA_NOMEM, "Could not duplicate name");
 
-    na_ofi_domain->nod_prov_type = prov_type;
+    na_ofi_domain->prov_type = prov_type;
 
-    if(prov_type == NA_OFI_PROV_GNI) {
 #if defined(NA_OFI_HAS_EXT_GNI_H)
-        if (auth_key) {
-            na_ofi_domain->fi_gni_auth_key.type = GNIX_AKT_RAW;
-            na_ofi_domain->fi_gni_auth_key.raw.protection_key =
-                (uint32_t) strtoul(auth_key, NULL, 10);
-
-            na_ofi_domain->nod_prov->domain_attr->auth_key =
-                (void *) &na_ofi_domain->fi_gni_auth_key;
-            na_ofi_domain->nod_prov->domain_attr->auth_key_size =
-                sizeof(na_ofi_domain->fi_gni_auth_key);
-        }
+    if (prov_type == NA_OFI_PROV_GNI && auth_key) {
+        na_ofi_domain->fi_gni_auth_key.type = GNIX_AKT_RAW;
+        na_ofi_domain->fi_gni_auth_key.raw.protection_key =
+            (uint32_t) strtoul(auth_key, NULL, 10);
+
+        na_ofi_domain->fi_prov->domain_attr->auth_key =
+            (void *) &na_ofi_domain->fi_gni_auth_key;
+        na_ofi_domain->fi_prov->domain_attr->auth_key_size =
+            sizeof(na_ofi_domain->fi_gni_auth_key);
+    }
 #else
-        (void) auth_key;
+    (void) auth_key;
 #endif
-    }
 
     /* Force no wait if do not support FI_WAIT_FD/FI_WAIT_SET */
     if (!(na_ofi_prov_flags[prov_type] & (NA_OFI_WAIT_SET | NA_OFI_WAIT_FD)))
@@ -1749,129 +1726,120 @@ na_ofi_domain_open(struct na_ofi_class *priv,
 
     /* Force manual progress if no wait is set */
     if (priv->no_wait) {
-        na_ofi_domain->nod_prov->domain_attr->control_progress = FI_PROGRESS_MANUAL;
-        na_ofi_domain->nod_prov->domain_attr->data_progress = FI_PROGRESS_MANUAL;
+        na_ofi_domain->fi_prov->domain_attr->control_progress = FI_PROGRESS_MANUAL;
+        na_ofi_domain->fi_prov->domain_attr->data_progress = FI_PROGRESS_MANUAL;
     }
 
     /* Open fi fabric */
-    rc = fi_fabric(na_ofi_domain->nod_prov->fabric_attr,/* In:  Fabric attributes */
-                   &na_ofi_domain->nod_fabric,          /* Out: Fabric handle */
-                   NULL);                               /* Optional context for fabric events */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_fabric failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_fabric(na_ofi_domain->fi_prov->fabric_attr,/* In:  Fabric attributes */
+                   &na_ofi_domain->fi_fabric,          /* Out: Fabric handle */
+                   NULL);                              /* Optional context for fabric events */
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_fabric() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Create the fi access domain */
-    rc = fi_domain(na_ofi_domain->nod_fabric,   /* In:  Fabric object */
-                   na_ofi_domain->nod_prov,     /* In:  Provider */
-                   &na_ofi_domain->nod_domain,  /* Out: Domain object */
-                   NULL);                       /* Optional context for domain events */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_domain failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-    if (priv->nop_max_contexts > 1) {
+    rc = fi_domain(na_ofi_domain->fi_fabric,  /* In:  Fabric object */
+                   na_ofi_domain->fi_prov,    /* In:  Provider */
+                   &na_ofi_domain->fi_domain, /* Out: Domain object */
+                   NULL);                     /* Optional context for domain events */
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_domain() failed, rc: %d(%s)", rc, fi_strerror(-rc));
+
+    if (priv->max_contexts > 1) {
         size_t min_ctx_cnt =
-            MIN(na_ofi_domain->nod_prov->domain_attr->tx_ctx_cnt,
-                na_ofi_domain->nod_prov->domain_attr->rx_ctx_cnt);
-        if (priv->nop_max_contexts > min_ctx_cnt) {
-            NA_LOG_ERROR("Maximum number of requested contexts (%d) exceeds "
-                "provider limitation (%d).", priv->nop_max_contexts,
-                min_ctx_cnt);
-            ret = NA_INVALID_PARAM;
-            goto out;
-        }
-//        NA_LOG_DEBUG("fi_domain created, tx_ctx_cnt %d, rx_ctx_cnt %d.",
-//            na_ofi_domain->nod_prov->domain_attr->tx_ctx_cnt,
-//            na_ofi_domain->nod_prov->domain_attr->rx_ctx_cnt);
+            MIN(na_ofi_domain->fi_prov->domain_attr->tx_ctx_cnt,
+                na_ofi_domain->fi_prov->domain_attr->rx_ctx_cnt);
+        NA_CHECK_ERROR(priv->max_contexts > min_ctx_cnt, error, ret,
+            NA_INVALID_ARG, "Maximum number of requested contexts (%d) "
+            "exceeds provider limitation (%d)", priv->max_contexts,
+            min_ctx_cnt);
+        NA_LOG_DEBUG("fi_domain created, tx_ctx_cnt %d, rx_ctx_cnt %d",
+            na_ofi_domain->fi_prov->domain_attr->tx_ctx_cnt,
+            na_ofi_domain->fi_prov->domain_attr->rx_ctx_cnt);
     }
 
 #ifdef NA_OFI_HAS_EXT_GNI_H
-    if (na_ofi_domain->nod_prov_type == NA_OFI_PROV_GNI) {
-        int enable = 1;
+    if (na_ofi_domain->prov_type == NA_OFI_PROV_GNI) {
+        int32_t enable = 1;
 # ifdef NA_OFI_GNI_HAS_UDREG
         char *other_reg_type = "udreg";
+        int32_t udreg_limit = 1024;
 
         /* Enable use of udreg instead of internal MR cache */
         ret = na_ofi_gni_set_domain_op_value(na_ofi_domain, GNI_MR_CACHE,
             &other_reg_type);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not set domain op value for GNI_MR_CACHE");
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(error, ret,
+            "Could not set domain op value for GNI_MR_CACHE");
+
+        /* Experiments on Theta showed default value of 2048 too high if
+         * launching multiple clients on one node */
+        ret = na_ofi_gni_set_domain_op_value(na_ofi_domain,
+            GNI_MR_UDREG_REG_LIMIT, &udreg_limit);
+        NA_CHECK_NA_ERROR(error, ret,
+            "Could not set domain op value for GNI_MR_UDREG_REG_LIMIT");
 # endif
 
         /* Enable lazy deregistration in MR cache */
         ret = na_ofi_gni_set_domain_op_value(na_ofi_domain,
             GNI_MR_CACHE_LAZY_DEREG, &enable);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not set domain op value for GNI_MR_CACHE_LAZY_DEREG");
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(error, ret,
+            "Could not set domain op value for GNI_MR_CACHE_LAZY_DEREG");
     }
 #endif
 
     /* If memory does not need to be backed up by physical pages at the time of
      * registration, export all memory range for RMA
      * (this is equivalent to FI_MR_SCALABLE) */
-    if (!(na_ofi_domain->nod_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
+    if (!(na_ofi_domain->fi_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
         uint64_t requested_key =
-            (!(na_ofi_domain->nod_prov->domain_attr->mr_mode & FI_MR_PROV_KEY))
+            (!(na_ofi_domain->fi_prov->domain_attr->mr_mode & FI_MR_PROV_KEY))
             ? NA_OFI_RMA_KEY : 0;
 
-        rc = fi_mr_reg(na_ofi_domain->nod_domain, NULL, UINT64_MAX,
+        rc = fi_mr_reg(na_ofi_domain->fi_domain, NULL, UINT64_MAX,
             FI_REMOTE_READ | FI_REMOTE_WRITE | FI_SEND | FI_RECV
             | FI_READ | FI_WRITE, 0 /* offset */, requested_key, 0 /* flags */,
-            &na_ofi_domain->nod_mr, NULL /* context */);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_mr_reg failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+            &na_ofi_domain->fi_mr, NULL /* context */);
+        NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_mr_reg failed(), rc: %d(%s)", rc, fi_strerror(-rc));
+
         /* Requested key may not be the same, currently RxM provider forces
          * the underlying provider to provide keys and ignores user-provided
          * key.
          */
-        na_ofi_domain->nod_mr_key = fi_mr_key(na_ofi_domain->nod_mr);
+        na_ofi_domain->fi_mr_key = fi_mr_key(na_ofi_domain->fi_mr);
     }
 
     /* Open fi address vector */
     av_attr.type = FI_AV_MAP;
     av_attr.rx_ctx_bits = NA_OFI_SEP_RX_CTX_BITS;
-    rc = fi_av_open(na_ofi_domain->nod_domain, &av_attr, &na_ofi_domain->nod_av,
+    rc = fi_av_open(na_ofi_domain->fi_domain, &av_attr, &na_ofi_domain->fi_av,
         NULL);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_av_open failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_av_open() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Create addr hash-table */
-    na_ofi_domain->nod_addr_ht = hg_hash_table_new(na_ofi_addr_ht_key_hash,
+    na_ofi_domain->addr_ht = hg_hash_table_new(na_ofi_addr_ht_key_hash,
         na_ofi_addr_ht_key_equal);
-    if (na_ofi_domain->nod_addr_ht == NULL) {
-        NA_LOG_ERROR("hg_hash_table_new failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    hg_hash_table_register_free_functions(na_ofi_domain->nod_addr_ht,
-        free, free);
+        NA_CHECK_ERROR(na_ofi_domain->addr_ht == NULL, error, ret,
+            NA_NOMEM, "hg_hash_table_new() failed");
+    hg_hash_table_register_free_functions(na_ofi_domain->addr_ht, free, free);
 
     /* Insert to global domain list */
     hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
-    HG_LIST_INSERT_HEAD(&na_ofi_domain_list_g, na_ofi_domain, nod_entry);
+    HG_LIST_INSERT_HEAD(&na_ofi_domain_list_g, na_ofi_domain, entry);
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
 
     *na_ofi_domain_p = na_ofi_domain;
 
-out:
-    if (ret != NA_SUCCESS)
-       na_ofi_domain_close(na_ofi_domain);
+    fi_freeinfo(providers);
+
+    return ret;
+
+error:
+    na_ofi_domain_close(na_ofi_domain);
     if (providers)
         fi_freeinfo(providers);
+
     return ret;
 }
 
@@ -1882,86 +1850,69 @@ na_ofi_domain_close(struct na_ofi_domain *na_ofi_domain)
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    if (!na_ofi_domain) goto out;
+    if (!na_ofi_domain)
+        goto out;
 
     /* Remove from global domain list if not used anymore */
-    hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
-    if (hg_atomic_decr32(&na_ofi_domain->nod_refcount)) {
+    if (hg_atomic_decr32(&na_ofi_domain->refcount))
         /* Cannot free yet */
-        hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
         goto out;
-    }
-    /* inserted to na_ofi_domain_list_g after nod_addr_ht created */
-    if (na_ofi_domain->nod_addr_ht != NULL)
-        HG_LIST_REMOVE(na_ofi_domain, nod_entry);
+
+    /* Remove from domain list (won't remove if not inserted) */
+    hg_thread_mutex_lock(&na_ofi_domain_list_mutex_g);
+    HG_LIST_REMOVE(na_ofi_domain, entry);
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
 
     /* Close MR */
-    if (na_ofi_domain->nod_mr) {
-        rc = fi_close(&na_ofi_domain->nod_mr->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close MR failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_mr = NULL;
+    if (na_ofi_domain->fi_mr) {
+        rc = fi_close(&na_ofi_domain->fi_mr->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() MR failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_mr = NULL;
     }
 
     /* Close AV */
-    if (na_ofi_domain->nod_av) {
-        rc = fi_close(&na_ofi_domain->nod_av->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close AV failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_av = NULL;
+    if (na_ofi_domain->fi_av) {
+        rc = fi_close(&na_ofi_domain->fi_av->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() AV failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_av = NULL;
     }
 
     /* Close domain */
-    if (na_ofi_domain->nod_domain) {
-        rc = fi_close(&na_ofi_domain->nod_domain->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close domain failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_domain = NULL;
+    if (na_ofi_domain->fi_domain) {
+        rc = fi_close(&na_ofi_domain->fi_domain->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() domain failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_domain = NULL;
     }
 
     /* Close fabric */
-    if (na_ofi_domain->nod_fabric) {
-        rc = fi_close(&na_ofi_domain->nod_fabric->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close fabric failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_domain->nod_fabric = NULL;
+    if (na_ofi_domain->fi_fabric) {
+        rc = fi_close(&na_ofi_domain->fi_fabric->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() fabric failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_domain->fi_fabric = NULL;
     }
 
     /* Free OFI info */
-    if (na_ofi_domain->nod_prov) {
+    if (na_ofi_domain->fi_prov) {
         /* Prevent fi_freeinfo from attempting to free the key */
-        if (na_ofi_domain->nod_prov->domain_attr->auth_key)
-            na_ofi_domain->nod_prov->domain_attr->auth_key = NULL;
-        if (na_ofi_domain->nod_prov->domain_attr->auth_key_size)
-            na_ofi_domain->nod_prov->domain_attr->auth_key_size = 0;
-        fi_freeinfo(na_ofi_domain->nod_prov);
-        na_ofi_domain->nod_prov = NULL;
+        if (na_ofi_domain->fi_prov->domain_attr->auth_key)
+            na_ofi_domain->fi_prov->domain_attr->auth_key = NULL;
+        if (na_ofi_domain->fi_prov->domain_attr->auth_key_size)
+            na_ofi_domain->fi_prov->domain_attr->auth_key_size = 0;
+        fi_freeinfo(na_ofi_domain->fi_prov);
+        na_ofi_domain->fi_prov = NULL;
     }
 
-    if (na_ofi_domain->nod_addr_ht)
-        hg_hash_table_free(na_ofi_domain->nod_addr_ht);
+    if (na_ofi_domain->addr_ht)
+        hg_hash_table_free(na_ofi_domain->addr_ht);
 
-    hg_thread_mutex_destroy(&na_ofi_domain->nod_mutex);
-    hg_thread_rwlock_destroy(&na_ofi_domain->nod_rwlock);
+    hg_thread_mutex_destroy(&na_ofi_domain->mutex);
+    hg_thread_rwlock_destroy(&na_ofi_domain->rwlock);
 
-    free(na_ofi_domain->nod_prov_name);
+    free(na_ofi_domain->prov_name);
     free(na_ofi_domain);
 
 out:
@@ -1983,25 +1934,19 @@ na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
 
     na_ofi_endpoint = (struct na_ofi_endpoint *) malloc(
         sizeof(struct na_ofi_endpoint));
-    if (na_ofi_endpoint == NULL) {
-        NA_LOG_ERROR("Could not allocate na_ofi_endpoint");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_endpoint == NULL, out, ret, NA_NOMEM,
+        "Could not allocate na_ofi_endpoint");
     memset(na_ofi_endpoint, 0, sizeof(struct na_ofi_endpoint));
 
     /* Dup fi_info */
-    hints = fi_dupinfo(na_ofi_domain->nod_prov);
-    if (!hints) {
-        NA_LOG_ERROR("Could not duplicate fi_info");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    hints = fi_dupinfo(na_ofi_domain->fi_prov);
+    NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM,
+        "Could not duplicate fi_info");
 
     if (src_addr) {
         /* Set src addr hints (FI_SOURCE must not be set in that case) */
         free(hints->src_addr);
-        hints->addr_format = na_ofi_prov_addr_format[na_ofi_domain->nod_prov_type];
+        hints->addr_format = na_ofi_prov_addr_format[na_ofi_domain->prov_type];
         hints->src_addr = src_addr;
         hints->src_addrlen = src_addrlen;
     }
@@ -2011,27 +1956,17 @@ na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
     hints->ep_attr->rx_ctx_cnt = max_contexts;
 
     rc = fi_getinfo(NA_OFI_VERSION, node, NULL, flags, hints,
-        &na_ofi_endpoint->noe_prov);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_getinfo(%s) failed, rc: %d(%s).", node,
-            rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+        &na_ofi_endpoint->fi_prov);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_getinfo(%s) failed, rc: %d(%s)", node, rc, fi_strerror(-rc));
 
-    if ((na_ofi_prov_flags[na_ofi_domain->nod_prov_type] & NA_OFI_NO_SEP)
+    if ((na_ofi_prov_flags[na_ofi_domain->prov_type] & NA_OFI_NO_SEP)
         || max_contexts < 2) {
         ret = na_ofi_basic_ep_open(na_ofi_domain, no_wait, na_ofi_endpoint);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("na_ofi_basic_ep_open failed, ret: %d.", ret);
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(out, ret, "na_ofi_basic_ep_open() failed");
     } else {
         ret = na_ofi_sep_open(na_ofi_domain, na_ofi_endpoint);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("na_ofi_sep_open failed, ret: %d.", ret);
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(out, ret, "na_ofi_sep_open() failed");
     }
 
     *na_ofi_endpoint_p = na_ofi_endpoint;
@@ -2060,82 +1995,60 @@ na_ofi_basic_ep_open(const struct na_ofi_domain *na_ofi_domain,
     int rc;
 
     /* Create a transport level communication endpoint */
-    rc = fi_endpoint(na_ofi_domain->nod_domain, /* In:  Domain object */
-                     na_ofi_endpoint->noe_prov, /* In:  Provider */
-                     &na_ofi_endpoint->noe_ep,  /* Out: Endpoint object */
+    rc = fi_endpoint(na_ofi_domain->fi_domain,  /* In:  Domain object */
+                     na_ofi_endpoint->fi_prov,  /* In:  Provider */
+                     &na_ofi_endpoint->fi_ep,   /* Out: Endpoint object */
                      NULL);                     /* Optional context */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_endpoint failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_endpoint() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Initialize queue / mutex */
-    na_ofi_endpoint->noe_unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
-    if (!na_ofi_endpoint->noe_unexpected_op_queue) {
-        NA_LOG_ERROR("Could not allocate noe_unexpected_op_queue");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    HG_QUEUE_INIT(&na_ofi_endpoint->noe_unexpected_op_queue->noq_queue);
-    hg_thread_spin_init(&na_ofi_endpoint->noe_unexpected_op_queue->noq_lock);
+    na_ofi_endpoint->unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
+    NA_CHECK_ERROR(na_ofi_endpoint->unexpected_op_queue == NULL, out,
+        ret, NA_NOMEM, "Could not allocate unexpected_op_queue");
+    HG_QUEUE_INIT(&na_ofi_endpoint->unexpected_op_queue->queue);
+    hg_thread_spin_init(&na_ofi_endpoint->unexpected_op_queue->lock);
 
     if (!no_wait) {
-        if (na_ofi_prov_flags[na_ofi_domain->nod_prov_type] & NA_OFI_WAIT_FD)
+        if (na_ofi_prov_flags[na_ofi_domain->prov_type] & NA_OFI_WAIT_FD)
             cq_attr.wait_obj = FI_WAIT_FD; /* Wait on fd */
         else {
             struct fi_wait_attr wait_attr = {0};
 
             /* Open wait set for other providers. */
             wait_attr.wait_obj = FI_WAIT_UNSPEC;
-            rc = fi_wait_open(na_ofi_domain->nod_fabric, &wait_attr,
-                &na_ofi_endpoint->noe_wait);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_wait_open failed, rc: %d(%s).", rc,
-                    fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
+            rc = fi_wait_open(na_ofi_domain->fi_fabric, &wait_attr,
+                &na_ofi_endpoint->fi_wait);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_wait_open() failed, rc: %d(%s)", rc, fi_strerror(-rc));
             cq_attr.wait_obj = FI_WAIT_SET; /* Wait on wait set */
-            cq_attr.wait_set = na_ofi_endpoint->noe_wait;
+            cq_attr.wait_set = na_ofi_endpoint->fi_wait;
         }
     }
     cq_attr.wait_cond = FI_CQ_COND_NONE;
     cq_attr.format = FI_CQ_FORMAT_TAGGED;
     cq_attr.size = NA_OFI_CQ_DEPTH;
-    rc = fi_cq_open(na_ofi_domain->nod_domain, &cq_attr,
-        &na_ofi_endpoint->noe_cq, NULL);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_cq_open failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_cq_open(na_ofi_domain->fi_domain, &cq_attr, &na_ofi_endpoint->fi_cq,
+        NULL);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_cq_open failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Bind the CQ and AV to the endpoint */
-    rc = fi_ep_bind(na_ofi_endpoint->noe_ep, &na_ofi_endpoint->noe_cq->fid,
+    rc = fi_ep_bind(na_ofi_endpoint->fi_ep, &na_ofi_endpoint->fi_cq->fid,
         FI_TRANSMIT | FI_RECV);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_ep_bind failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_ep_bind() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-    rc = fi_ep_bind(na_ofi_endpoint->noe_ep, &na_ofi_domain->nod_av->fid, 0);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_ep_bind failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_ep_bind(na_ofi_endpoint->fi_ep, &na_ofi_domain->fi_av->fid, 0);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_ep_bind() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Enable the endpoint for communication, and commits the bind operations */
-    rc = fi_enable(na_ofi_endpoint->noe_ep);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_enable failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_enable(na_ofi_endpoint->fi_ep);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_enable() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-    na_ofi_endpoint->noe_sep = NA_FALSE;
+    na_ofi_endpoint->sep = NA_FALSE;
 
 out:
     return ret;
@@ -2150,34 +2063,24 @@ na_ofi_sep_open(const struct na_ofi_domain *na_ofi_domain,
     int rc;
 
     /* Create a transport level communication endpoint (sep) */
-    rc = fi_scalable_ep(na_ofi_domain->nod_domain, /* In:  Domain object */
-                        na_ofi_endpoint->noe_prov, /* In:  Provider */
-                        &na_ofi_endpoint->noe_ep,  /* Out: Endpoint object */
-                        NULL);                     /* Optional context */
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_scalable_ep failed, rc: %d(%s).",
-                     rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-
-    rc = fi_scalable_ep_bind(na_ofi_endpoint->noe_ep,
-        &na_ofi_domain->nod_av->fid, 0);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_ep_bind failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    rc = fi_scalable_ep(na_ofi_domain->fi_domain, /* In:  Domain object */
+                        na_ofi_endpoint->fi_prov, /* In:  Provider */
+                        &na_ofi_endpoint->fi_ep,  /* Out: Endpoint object */
+                        NULL);                    /* Optional context */
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_scalable_ep() failed, rc: %d(%s)", rc, fi_strerror(-rc));
+
+    rc = fi_scalable_ep_bind(na_ofi_endpoint->fi_ep, &na_ofi_domain->fi_av->fid,
+        0);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_ep_bind() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Enable the endpoint for communication, and commits the bind operations */
-    ret = fi_enable(na_ofi_endpoint->noe_ep);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_enable failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    ret = fi_enable(na_ofi_endpoint->fi_ep);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_enable() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-    na_ofi_endpoint->noe_sep = NA_TRUE;
+    na_ofi_endpoint->sep = NA_TRUE;
 
 out:
     return ret;
@@ -2190,64 +2093,52 @@ na_ofi_endpoint_close(struct na_ofi_endpoint *na_ofi_endpoint)
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    if (!na_ofi_endpoint) goto out;
+    if (!na_ofi_endpoint)
+        goto out;
 
     /* When not using SEP */
-    if (na_ofi_endpoint->noe_unexpected_op_queue) {
+    if (na_ofi_endpoint->unexpected_op_queue) {
         /* Check that unexpected op queue is empty */
-        if (!HG_QUEUE_IS_EMPTY(
-            &na_ofi_endpoint->noe_unexpected_op_queue->noq_queue)) {
-            NA_LOG_ERROR("Unexpected op queue should be empty");
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        hg_thread_spin_destroy(
-            &na_ofi_endpoint->noe_unexpected_op_queue->noq_lock);
-        free(na_ofi_endpoint->noe_unexpected_op_queue);
+        na_bool_t empty = HG_QUEUE_IS_EMPTY(
+            &na_ofi_endpoint->unexpected_op_queue->queue);
+        NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_BUSY,
+            "Unexpected op queue should be empty");
+        hg_thread_spin_destroy(&na_ofi_endpoint->unexpected_op_queue->lock);
+        free(na_ofi_endpoint->unexpected_op_queue);
     }
 
     /* Close endpoint */
-    if (na_ofi_endpoint->noe_ep) {
-        rc = fi_close(&na_ofi_endpoint->noe_ep->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close endpoint failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_endpoint->noe_ep = NULL;
+    if (na_ofi_endpoint->fi_ep) {
+        rc = fi_close(&na_ofi_endpoint->fi_ep->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() endpoint failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_endpoint->fi_ep = NULL;
     }
 
     /* Close completion queue */
-    if (na_ofi_endpoint->noe_cq) {
-        rc = fi_close(&na_ofi_endpoint->noe_cq->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close CQ failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_endpoint->noe_cq = NULL;
+    if (na_ofi_endpoint->fi_cq) {
+        rc = fi_close(&na_ofi_endpoint->fi_cq->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() CQ failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_endpoint->fi_cq = NULL;
     }
 
     /* Close wait set */
-    if (na_ofi_endpoint->noe_wait) {
-        rc = fi_close(&na_ofi_endpoint->noe_wait->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close wait failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
-        na_ofi_endpoint->noe_wait = NULL;
+    if (na_ofi_endpoint->fi_wait) {
+        rc = fi_close(&na_ofi_endpoint->fi_wait->fid);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+            "fi_close() wait failed, rc: %d(%s)", rc, fi_strerror(-rc));
+        na_ofi_endpoint->fi_wait = NULL;
     }
 
     /* Free OFI info */
-    if (na_ofi_endpoint->noe_prov) {
-        fi_freeinfo(na_ofi_endpoint->noe_prov);
-        na_ofi_endpoint->noe_prov = NULL;
+    if (na_ofi_endpoint->fi_prov) {
+        fi_freeinfo(na_ofi_endpoint->fi_prov);
+        na_ofi_endpoint->fi_prov = NULL;
     }
 
-    if (na_ofi_endpoint->noe_addr)
-        na_ofi_addr_decref(na_ofi_endpoint->noe_addr);
+    if (na_ofi_endpoint->src_addr)
+        na_ofi_addr_decref(na_ofi_endpoint->src_addr);
     free(na_ofi_endpoint);
 
 out:
@@ -2259,43 +2150,33 @@ static na_return_t
 na_ofi_get_ep_addr(na_class_t *na_class, struct na_ofi_addr **na_ofi_addr_ptr)
 {
     struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_domain *na_ofi_domain = priv->nop_domain;
-    struct na_ofi_endpoint *na_ofi_endpoint = priv->nop_endpoint;
+    struct na_ofi_domain *na_ofi_domain = priv->domain;
+    struct na_ofi_endpoint *na_ofi_endpoint = priv->endpoint;
     struct na_ofi_addr *na_ofi_addr = NULL;
     void *addr = NULL;
-    size_t addrlen = na_ofi_domain->nod_prov->src_addrlen;
+    size_t addrlen = na_ofi_domain->fi_prov->src_addrlen;
     na_bool_t retried = NA_FALSE;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("Could not allocate NA OFI addr");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_addr = na_ofi_addr_alloc(priv->domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate NA OFI addr");
 
-retry_getname:
-    if (retried)
-        free(addr);
+retry:
     addr = malloc(addrlen);
-    if (addr == NULL) {
-        NA_LOG_ERROR("Could not allocate addr.");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate addr");
 
-    rc = fi_getname(&na_ofi_endpoint->noe_ep->fid, addr, &addrlen);
-    if (rc != FI_SUCCESS) {
-        if (rc == -FI_ETOOSMALL && retried == NA_FALSE) {
-            retried = NA_TRUE;
-            goto retry_getname;
-        }
-        NA_LOG_ERROR("fi_getname failed, rc: %d(%s), addrlen: %zu.",
-                     rc, fi_strerror(-rc), addrlen);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
+    rc = fi_getname(&na_ofi_endpoint->fi_ep->fid, addr, &addrlen);
+    if (rc == -FI_ETOOSMALL && retried == NA_FALSE) {
+        retried = NA_TRUE;
+        free(addr);
+        goto retry;
     }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_getname() failed, rc: %d(%s), addrlen: %zu", rc, fi_strerror(-rc),
+        addrlen);
 
     na_ofi_addr->addr = addr;
     na_ofi_addr->addrlen = addrlen;
@@ -2303,19 +2184,17 @@ retry_getname:
 
     /* Get URI from address */
     ret = na_ofi_get_uri(na_class, na_ofi_addr->addr, &na_ofi_addr->uri);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not get URI from endpoint address");
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not get URI from endpoint address");
 
     /* TODO check address size */
    *na_ofi_addr_ptr = na_ofi_addr;
 
-out:
-    if (ret != NA_SUCCESS) {
-        free(addr);
-        free(na_ofi_addr);
-    }
+    return ret;
+
+error:
+    free(addr);
+    free(na_ofi_addr);
+
     return ret;
 }
 
@@ -2323,8 +2202,7 @@ out:
 static na_return_t
 na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_domain *na_ofi_domain = priv->nop_domain;
+    struct na_ofi_domain *na_ofi_domain = NA_OFI_CLASS(na_class)->domain;
     char addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         fi_addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         *fi_addr_str_ptr, *uri = NULL;
@@ -2333,42 +2211,31 @@ na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
     int rc;
 
     /* Convert FI address to a printable string */
-    fi_av_straddr(na_ofi_domain->nod_av, addr, fi_addr_str, &fi_addr_strlen);
-    if (fi_addr_strlen > NA_OFI_MAX_URI_LEN) {
-        NA_LOG_ERROR("fi_av_straddr() address truncated, addrlen: %zu",
-            fi_addr_strlen);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    fi_av_straddr(na_ofi_domain->fi_av, addr, fi_addr_str, &fi_addr_strlen);
+    NA_CHECK_ERROR(fi_addr_strlen > NA_OFI_MAX_URI_LEN, out, ret,
+        NA_PROTOCOL_ERROR, "fi_av_straddr() address truncated, addrlen: %zu",
+        fi_addr_strlen);
 
     /* Remove unnecessary "://" prefix from string if present */
     if (strstr(fi_addr_str, "://")) {
         strtok_r(fi_addr_str, ":", &fi_addr_str_ptr);
-        if (strncmp(fi_addr_str_ptr, "//", 2) != 0) {
-            NA_LOG_ERROR("Bad address string format");
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = strncmp(fi_addr_str_ptr, "//", 2);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTONOSUPPORT,
+            "Bad address string format");
         fi_addr_str_ptr += 2;
     } else
         fi_addr_str_ptr = fi_addr_str;
 
     /* Generate URI */
     rc = snprintf(addr_str, NA_OFI_MAX_URI_LEN, "%s://%s",
-        na_ofi_domain->nod_prov->fabric_attr->prov_name, fi_addr_str_ptr);
-    if (rc < 0 || rc > NA_OFI_MAX_URI_LEN) {
-        NA_LOG_ERROR("snprintf failed or name truncated, rc: %d.", rc);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+        na_ofi_domain->fi_prov->fabric_attr->prov_name, fi_addr_str_ptr);
+    NA_CHECK_ERROR(rc < 0 || rc > NA_OFI_MAX_URI_LEN, out, ret,
+        NA_OVERFLOW, "snprintf() failed or name truncated, rc: %d", rc);
 
     /* Dup URI */
     uri = strdup(addr_str);
-    if (uri == NULL) {
-        NA_LOG_ERROR("Could not strdup EP address string.");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(uri == NULL, out, ret, NA_NOMEM,
+        "Could not strdup address string");
 
     *uri_ptr = uri;
 
@@ -2378,19 +2245,22 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static struct na_ofi_addr *
-na_ofi_addr_alloc(void)
+na_ofi_addr_alloc(struct na_ofi_domain *na_ofi_domain)
 {
     struct na_ofi_addr *na_ofi_addr;
 
     na_ofi_addr = (struct na_ofi_addr *)calloc(1, sizeof(*na_ofi_addr));
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("Could not allocate addr");
-        return NULL;
-    }
+    NA_CHECK_ERROR_NORET(na_ofi_addr == NULL, out,
+        "Could not allocate addr");
+
+    /* Keep reference to domain */
+    na_ofi_addr->domain = na_ofi_domain;
+    hg_atomic_incr32(&na_ofi_domain->refcount);
 
     /* One refcount for the caller to hold until addr_free */
-    hg_atomic_set32(&na_ofi_addr->refcount, 1);
+    hg_atomic_init32(&na_ofi_addr->refcount, 1);
 
+out:
     return na_ofi_addr;
 }
 
@@ -2412,7 +2282,15 @@ na_ofi_addr_decref(struct na_ofi_addr *na_ofi_addr)
     if (hg_atomic_decr32(&na_ofi_addr->refcount))
         return;
 
-    /* TODO need to fi_av_remove? */
+    /* Do not call fi_av_remove() here to prevent multiple insert/remove calls
+     * into AV */
+    if (na_ofi_addr->remove) {
+        NA_LOG_DEBUG("fi_addr=%" SCNx64 " ht_key=%" SCNx64,
+            na_ofi_addr->fi_addr, na_ofi_addr->ht_key);
+        na_ofi_addr_ht_remove(na_ofi_addr->domain, &na_ofi_addr->fi_addr,
+            &na_ofi_addr->ht_key);
+    }
+    na_ofi_domain_close(na_ofi_addr->domain);
     free(na_ofi_addr->addr);
     free(na_ofi_addr->uri);
     free(na_ofi_addr);
@@ -2428,16 +2306,13 @@ na_ofi_mem_pool_create(na_class_t *na_class, na_size_t block_size,
         + sizeof(struct na_ofi_mem_pool)
         + block_count * (offsetof(struct na_ofi_mem_node, block));
     struct fid_mr *mr_hdl = NULL;
-    char *mem_ptr = NULL;
     na_size_t i;
 
-    mem_ptr = (char *) na_ofi_mem_alloc(na_class, pool_size, &mr_hdl);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate %d bytes", (int) pool_size);
-        goto out;
-    }
+    na_ofi_mem_pool = (struct na_ofi_mem_pool *) na_ofi_mem_alloc(na_class,
+        pool_size, &mr_hdl);
+    NA_CHECK_ERROR_NORET(na_ofi_mem_pool == NULL, out,
+        "Could not allocate %d bytes", (int) pool_size);
 
-    na_ofi_mem_pool = (struct na_ofi_mem_pool *) mem_ptr;
     HG_QUEUE_INIT(&na_ofi_mem_pool->node_list);
     hg_thread_spin_init(&na_ofi_mem_pool->node_list_lock);
     na_ofi_mem_pool->mr_hdl = mr_hdl;
@@ -2446,7 +2321,8 @@ na_ofi_mem_pool_create(na_class_t *na_class, na_size_t block_size,
     /* Assign nodes and insert them to free list */
     for (i = 0; i < block_count; i++) {
         struct na_ofi_mem_node *na_ofi_mem_node =
-            (struct na_ofi_mem_node *) (mem_ptr + sizeof(struct na_ofi_mem_pool)
+            (struct na_ofi_mem_node *) ((char *) na_ofi_mem_pool
+                + sizeof(struct na_ofi_mem_pool)
                 + i * (offsetof(struct na_ofi_mem_node, block) + block_size));
         HG_QUEUE_PUSH_TAIL(&na_ofi_mem_pool->node_list, na_ofi_mem_node, entry);
     }
@@ -2467,29 +2343,27 @@ na_ofi_mem_pool_destroy(struct na_ofi_mem_pool *na_ofi_mem_pool)
 static NA_INLINE void *
 na_ofi_mem_alloc(na_class_t *na_class, na_size_t size, struct fid_mr **mr_hdl)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     na_size_t page_size = (na_size_t) hg_mem_get_page_size();
     void *mem_ptr = NULL;
 
     /* Allocate backend buffer */
     mem_ptr = hg_mem_aligned_alloc(page_size, size);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate %d bytes", (int) size);
-        goto out;
-    }
+    NA_CHECK_ERROR_NORET(mem_ptr == NULL, out,
+        "Could not allocate %d bytes", (int) size);
     memset(mem_ptr, 0, size);
 
     /* Register memory if FI_MR_LOCAL is set and provider uses it */
-    if (domain->nod_prov->domain_attr->mr_mode & FI_MR_LOCAL) {
+    if (domain->fi_prov->domain_attr->mr_mode & FI_MR_LOCAL) {
         int rc;
 
-        rc = fi_mr_reg(domain->nod_domain, mem_ptr, size, FI_REMOTE_READ
+        rc = fi_mr_reg(domain->fi_domain, mem_ptr, size, FI_REMOTE_READ
             | FI_REMOTE_WRITE | FI_SEND | FI_RECV | FI_READ | FI_WRITE, 0 /* offset */,
             0 /* requested key */, 0 /* flags */, mr_hdl, NULL /* context */);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_mr_reg failed, rc: %d (%s).", rc, fi_strerror(-rc));
+        if (unlikely(rc != 0)) {
             hg_mem_aligned_free(mem_ptr);
-            goto out;
+            NA_GOTO_ERROR(out, mem_ptr, NULL,
+                "fi_mr_reg() failed, rc: %d (%s)", rc, fi_strerror(-rc));
         }
     }
 
@@ -2503,16 +2377,14 @@ na_ofi_mem_free(void *mem_ptr, struct fid_mr *mr_hdl)
 {
     /* Release MR handle is there was any */
     if (mr_hdl) {
-        int rc;
-
-        rc = fi_close(&mr_hdl->fid);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_close mr_hdl failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-        }
+        int rc = fi_close(&mr_hdl->fid);
+        NA_CHECK_ERROR_NORET(rc != 0, out,
+            "fi_close() mr_hdl failed, rc: %d(%s)", rc, fi_strerror(-rc));
     }
 
+out:
     hg_mem_aligned_free(mem_ptr);
+    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2527,16 +2399,16 @@ na_ofi_mem_pool_alloc(na_class_t *na_class, na_size_t size,
 
 retry:
     /* Check whether we can get a block from one of the pools */
-    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
     HG_QUEUE_FOREACH(na_ofi_mem_pool,
-        &NA_OFI_CLASS(na_class)->nop_buf_pool, entry) {
+        &NA_OFI_CLASS(na_class)->buf_pool, entry) {
         hg_thread_spin_lock(&na_ofi_mem_pool->node_list_lock);
         found = !HG_QUEUE_IS_EMPTY(&na_ofi_mem_pool->node_list);
         hg_thread_spin_unlock(&na_ofi_mem_pool->node_list_lock);
         if (found)
             break;
     }
-    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
 
     /* If not, allocate and register a new pool */
     if (!found) {
@@ -2544,16 +2416,14 @@ retry:
             na_ofi_mem_pool_create(na_class,
                 na_ofi_msg_get_max_unexpected_size(na_class),
                 NA_OFI_MEM_BLOCK_COUNT);
-        hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
-        HG_QUEUE_PUSH_TAIL(&NA_OFI_CLASS(na_class)->nop_buf_pool,
+        hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
+        HG_QUEUE_PUSH_TAIL(&NA_OFI_CLASS(na_class)->buf_pool,
             na_ofi_mem_pool, entry);
-        hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+        hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
     }
 
-    if (size > na_ofi_mem_pool->block_size) {
-        NA_LOG_ERROR("Block size is too small for requested size");
-        goto out;
-    }
+    NA_CHECK_ERROR(size > na_ofi_mem_pool->block_size, out, mem_ptr, NULL,
+        "Block size is too small for requested size");
 
     /* Pick a node from one of the available pools */
     hg_thread_spin_lock(&na_ofi_mem_pool->node_list_lock);
@@ -2580,9 +2450,9 @@ na_ofi_mem_pool_free(na_class_t *na_class, void *mem_ptr, struct fid_mr *mr_hdl)
         container_of(mem_ptr, struct na_ofi_mem_node, block);
 
     /* Put the node back to the pool */
-    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
     HG_QUEUE_FOREACH(na_ofi_mem_pool,
-        &NA_OFI_CLASS(na_class)->nop_buf_pool, entry) {
+        &NA_OFI_CLASS(na_class)->buf_pool, entry) {
         /* If MR handle is NULL, it does not really matter which pool we push
          * the node back to.
          */
@@ -2593,7 +2463,7 @@ na_ofi_mem_pool_free(na_class_t *na_class, void *mem_ptr, struct fid_mr *mr_hdl)
             break;
         }
     }
-    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_unlock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2601,8 +2471,8 @@ static NA_INLINE void
 na_ofi_op_id_addref(struct na_ofi_op_id *na_ofi_op_id)
 {
     /* init as 1 when op_create */
-    assert(hg_atomic_get32(&na_ofi_op_id->noo_refcount));
-    hg_atomic_incr32(&na_ofi_op_id->noo_refcount);
+    assert(hg_atomic_get32(&na_ofi_op_id->refcount));
+    hg_atomic_incr32(&na_ofi_op_id->refcount);
 
     return;
 }
@@ -2614,36 +2484,18 @@ na_ofi_op_id_decref(struct na_ofi_op_id *na_ofi_op_id)
     if (na_ofi_op_id == NULL)
         return;
 
-    assert(hg_atomic_get32(&na_ofi_op_id->noo_refcount) > 0);
+    assert(hg_atomic_get32(&na_ofi_op_id->refcount) > 0);
 
     /* If there are more references, return */
-    if (hg_atomic_decr32(&na_ofi_op_id->noo_refcount))
+    if (hg_atomic_decr32(&na_ofi_op_id->refcount))
         return;
 
     /* No more references, cleanup */
-    na_ofi_op_id->noo_magic_1 = 0;
-    na_ofi_op_id->noo_magic_2 = 0;
     free(na_ofi_op_id);
 
     return;
 }
 
-/*---------------------------------------------------------------------------*/
-static NA_INLINE na_bool_t
-na_ofi_op_id_valid(struct na_ofi_op_id *na_ofi_op_id)
-{
-    if (na_ofi_op_id == NULL)
-        return NA_FALSE;
-
-    if (na_ofi_op_id->noo_magic_1 != NA_OFI_OP_ID_MAGIC_1 ||
-        na_ofi_op_id->noo_magic_2 != NA_OFI_OP_ID_MAGIC_2) {
-        NA_LOG_ERROR("invalid magic number for na_ofi_op_id.");
-        return NA_FALSE;
-    }
-
-    return NA_TRUE;
-}
-
 /*---------------------------------------------------------------------------*/
 static NA_INLINE void
 na_ofi_msg_unexpected_op_push(na_context_t *context,
@@ -2651,10 +2503,9 @@ na_ofi_msg_unexpected_op_push(na_context_t *context,
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
 
-    hg_thread_spin_lock(&ctx->noc_unexpected_op_queue->noq_lock);
-    HG_QUEUE_PUSH_TAIL(&ctx->noc_unexpected_op_queue->noq_queue, na_ofi_op_id,
-        noo_entry);
-    hg_thread_spin_unlock(&ctx->noc_unexpected_op_queue->noq_lock);
+    hg_thread_spin_lock(&ctx->unexpected_op_queue->lock);
+    HG_QUEUE_PUSH_TAIL(&ctx->unexpected_op_queue->queue, na_ofi_op_id, entry);
+    hg_thread_spin_unlock(&ctx->unexpected_op_queue->lock);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2664,127 +2515,90 @@ na_ofi_msg_unexpected_op_remove(na_context_t *context,
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
 
-    hg_thread_spin_lock(&ctx->noc_unexpected_op_queue->noq_lock);
-    HG_QUEUE_REMOVE(&ctx->noc_unexpected_op_queue->noq_queue, na_ofi_op_id,
-        na_ofi_op_id, noo_entry);
-    hg_thread_spin_unlock(&ctx->noc_unexpected_op_queue->noq_lock);
-}
-
-/*---------------------------------------------------------------------------*/
-static NA_INLINE struct na_ofi_op_id *
-na_ofi_msg_unexpected_op_pop(na_context_t *context)
-{
-    struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct na_ofi_op_id *na_ofi_op_id;
-
-    hg_thread_spin_lock(&ctx->noc_unexpected_op_queue->noq_lock);
-    na_ofi_op_id = HG_QUEUE_FIRST(&ctx->noc_unexpected_op_queue->noq_queue);
-    HG_QUEUE_POP_HEAD(&ctx->noc_unexpected_op_queue->noq_queue, noo_entry);
-    hg_thread_spin_unlock(&ctx->noc_unexpected_op_queue->noq_lock);
-
-    return na_ofi_op_id;
+    hg_thread_spin_lock(&ctx->unexpected_op_queue->lock);
+    HG_QUEUE_REMOVE(&ctx->unexpected_op_queue->queue, na_ofi_op_id,
+        na_ofi_op_id, entry);
+    hg_thread_spin_unlock(&ctx->unexpected_op_queue->lock);
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_cq_read(na_class_t *na_class, na_context_t *context,
-    size_t max_count, struct fi_cq_tagged_entry cq_events[],
-    fi_addr_t src_addrs[], void **src_err_addr, size_t *src_err_addrlen,
-    size_t *actual_count)
+na_ofi_cq_read(na_context_t *context, size_t max_count,
+    struct fi_cq_tagged_entry cq_events[], fi_addr_t src_addrs[],
+    void **src_err_addr, size_t *src_err_addrlen, size_t *actual_count)
 {
-    struct fid_cq *cq_hdl = NA_OFI_CONTEXT(context)->noc_cq;
-    char err_data[NA_OFI_CQ_MAX_ERR_DATA_SIZE];
+    struct fid_cq *cq_hdl = NA_OFI_CONTEXT(context)->fi_cq;
     struct fi_cq_err_entry cq_err;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
     rc = fi_cq_readfrom(cq_hdl, cq_events, max_count, src_addrs);
     if (rc > 0) { /* events available */
+        *src_err_addrlen = 0;
         *actual_count = (size_t) rc;
         goto out;
     }
     if (rc == -FI_EAGAIN) { /* no event available */
+        *src_err_addrlen = 0;
         *actual_count = 0;
         goto out;
     }
-    if (rc != -FI_EAVAIL) { /* no error available */
-        NA_LOG_ERROR("fi_cq_readfrom() failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != -FI_EAVAIL, out, ret, NA_PROTOCOL_ERROR,
+        "fi_cq_readfrom() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
     memset(&cq_err, 0, sizeof(cq_err));
-    memset(&err_data, 0, sizeof(err_data));
+
     /* Prevent provider from internally allocating resources */
-    cq_err.err_data = err_data;
-    cq_err.err_data_size = NA_OFI_CQ_MAX_ERR_DATA_SIZE;
+    cq_err.err_data = *src_err_addr;
+    cq_err.err_data_size = *src_err_addrlen;
 
     /* Read error entry */
     rc = fi_cq_readerr(cq_hdl, &cq_err, 0 /* flags */);
-    if (rc != 1) {
-        NA_LOG_ERROR("fi_cq_readerr() failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 1, out, ret, NA_PROTOCOL_ERROR,
+        "fi_cq_readerr() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
     switch (cq_err.err) {
-        case FI_ECANCELED:
-//            NA_LOG_DEBUG("got a FI_ECANCELED event, cq_event.flags 0x%x.",
-//                         cq_err.flags);
-            goto out;
-
-        case FI_EADDRNOTAVAIL: {
-            struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-            struct fid_av *av_hdl = priv->nop_domain->nod_av;
-            void *err_addr = NULL;
-            size_t err_addrlen;
-
-            /* Copy addr information */
-            err_addr = malloc(cq_err.err_data_size);
-            if (!err_addr) {
-                NA_LOG_ERROR("Could not allocate err_addr");
-                ret = NA_NOMEM_ERROR;
-                goto out;
-            }
-            err_addrlen = cq_err.err_data_size;
-            memcpy(err_addr, cq_err.err_data, err_addrlen);
-
-            na_ofi_domain_lock(priv->nop_domain);
-            /* Insert new source addr into AV if address was not found */
-            rc = fi_av_insert(av_hdl, err_addr, 1, &src_addrs[0],
-                0 /* flags */, NULL /* context */);
-            na_ofi_domain_unlock(priv->nop_domain);
-            if (rc < 1) {
-                NA_LOG_ERROR("fi_av_insert failed, rc: %d(%s).",
-                    rc, fi_strerror((int) -rc));
-                ret = NA_PROTOCOL_ERROR;
-                free(err_addr);
-                goto out;
+        case FI_ECANCELED: {
+            struct na_ofi_op_id *na_ofi_op_id = container_of(
+                cq_err.op_context, struct na_ofi_op_id, fi_ctx);
+
+            NA_CHECK_ERROR(na_ofi_op_id == NULL, out, ret, NA_INVALID_ARG,
+                "Invalid operation ID");
+            NA_CHECK_ERROR(
+                hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED,
+                out, ret, NA_FAULT, "Operation ID was completed");
+            NA_LOG_DEBUG("FI_ECANCELED event on operation ID %p", na_ofi_op_id);
+            NA_CHECK_ERROR(
+                !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_CANCELED),
+                out, ret, NA_FAULT, "Operation ID was not canceled");
+
+            if (na_ofi_op_id->completion_data.callback_info.type
+                == NA_CB_RECV_UNEXPECTED) {
+                /* Remove OP ID from OP queue if canceled */
+                na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
             }
+
+            /* Complete operation in canceled state */
+            ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
+            NA_CHECK_NA_ERROR(out, ret, "Unable to complete operation");
+         }
+            break;
+
+        case FI_EADDRNOTAVAIL:
             /* Only one error event processed in that case */
             memcpy(&cq_events[0], &cq_err, sizeof(cq_events[0]));
+            *src_err_addr = cq_err.err_data;
+            *src_err_addrlen = cq_err.err_data_size;
             *actual_count = 1;
-            *src_err_addr = err_addr;
-            *src_err_addrlen = err_addrlen;
             break;
-        }
-        case FI_EIO:
-            NA_LOG_ERROR("fi_cq_readerr got err: %d(%s), "
-                "prov_errno: %d(%s).",
-                cq_err.err, fi_strerror(cq_err.err),
-                cq_err.prov_errno,
-                fi_strerror(-cq_err.prov_errno));
-            goto out;
+
         default:
-            NA_LOG_ERROR("fi_cq_readerr got err: %d(%s), "
-                "prov_errno: %d(%s).",
-                cq_err.err, fi_strerror(cq_err.err),
-                cq_err.prov_errno,
+            /* Ignore errors from OFI that we cannot handle */
+            NA_LOG_WARNING(
+                "fi_cq_readerr() got err: %d(%s), prov_errno: %d(%s)",
+                cq_err.err, fi_strerror(cq_err.err), cq_err.prov_errno,
                 fi_strerror(-cq_err.prov_errno));
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
+            break;
     }
 
 out:
@@ -2798,65 +2612,41 @@ na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
     void *src_err_addr, size_t src_err_addrlen)
 {
     struct na_ofi_op_id *na_ofi_op_id = container_of(
-        cq_event->op_context, struct na_ofi_op_id, noo_fi_ctx);
+        cq_event->op_context, struct na_ofi_op_id, fi_ctx);
     na_return_t ret = NA_SUCCESS;
 
-    if (!na_ofi_op_id_valid(na_ofi_op_id)) {
-        NA_LOG_ERROR("Bad na_ofi_op_id, ignoring event.");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-    if (hg_atomic_get32(&na_ofi_op_id->noo_canceled)) {
-        ret = NA_CANCELED;
-        goto complete;
-    }
-    if (hg_atomic_get32(&na_ofi_op_id->noo_completed)) {
-        NA_LOG_ERROR("Ignoring CQ event as the op is completed.");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_op_id == NULL, out, ret, NA_INVALID_ARG,
+        "Invalid operation ID");
+    /* Cannot have an already completed operation ID, sanity check */
+    NA_CHECK_ERROR(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED,
+        out, ret, NA_FAULT, "Operation ID was completed");
 
     if (cq_event->flags & FI_SEND) {
         ret = na_ofi_cq_process_send_event(na_ofi_op_id);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not process send event");
-            goto out;
-        }
+        NA_CHECK_NA_ERROR(out, ret, "Could not process send event");
     } else if (cq_event->flags & FI_RECV) {
         if (cq_event->tag & ~NA_OFI_UNEXPECTED_TAG_IGNORE) {
             ret = na_ofi_cq_process_recv_expected_event(na_ofi_op_id,
                 cq_event->tag, cq_event->len);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not process expected recv event");
-                goto out;
-            }
+            NA_CHECK_NA_ERROR(out, ret,
+                "Could not process expected recv event");
         } else {
             ret = na_ofi_cq_process_recv_unexpected_event(na_class, context,
                 na_ofi_op_id, src_addr, src_err_addr, src_err_addrlen,
                 cq_event->tag, cq_event->len);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not process unexpected recv event");
-                goto out;
-            }
+            NA_CHECK_NA_ERROR(out, ret,
+                "Could not process unexpected recv event");
         }
     } else if (cq_event->flags & FI_RMA) {
         ret = na_ofi_cq_process_rma_event(na_ofi_op_id);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not process rma event");
-            goto out;
-        }
-    } else {
-        NA_LOG_ERROR("bad cq event flags: 0x%x.", cq_event->flags);
-        goto out;
-    }
+        NA_CHECK_NA_ERROR(out, ret, "Could not process rma event");
+    } else
+        NA_GOTO_ERROR(out, ret, NA_PROTONOSUPPORT,
+            "Unsupported CQ event flags: 0x%x.", cq_event->flags);
 
-complete:
     /* Complete operation */
     ret = na_ofi_complete(na_ofi_op_id, ret);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Unable to complete operation");
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(out, ret, "Unable to complete operation");
 
 out:
     return ret;
@@ -2866,15 +2656,12 @@ out:
 static NA_INLINE na_return_t
 na_ofi_cq_process_send_event(struct na_ofi_op_id *na_ofi_op_id)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_SEND_EXPECTED && cb_type != NA_CB_SEND_UNEXPECTED) {
-        NA_LOG_ERROR("ignore the send_event as cb_type %d mismatched with "
-            "NA_CB_SEND_EXPECTED/_UNEXPECTED.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_SEND_EXPECTED
+        && cb_type != NA_CB_SEND_UNEXPECTED, out, ret, NA_PROTOCOL_ERROR,
+        "Invalid cb_type %d, expected NA_CB_SEND_EXPECTED/UNEXPECTED", cb_type);
 
 out:
     return ret;
@@ -2887,52 +2674,56 @@ na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
     fi_addr_t src_addr, void *src_err_addr, size_t src_err_addrlen,
     uint64_t tag, size_t len)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_RECV_UNEXPECTED) {
-        NA_LOG_ERROR("ignore the recv_event as cb_type %d mismatched with "
-            "NA_CB_RECV_UNEXPECTED.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_RECV_UNEXPECTED, out, ret,
+        NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_RECV_UNEXPECTED",
+        cb_type);
+    NA_CHECK_ERROR(tag > NA_OFI_MAX_TAG, out, ret, NA_OVERFLOW,
+        "Invalid tag value");
 
     /* Allocate new address */
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("na_ofi_addr_alloc failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    na_ofi_addr->addr = src_err_addr; /* may be NULL */
-    na_ofi_addr->addrlen = src_err_addrlen;
-    /* Unexpected address may not have addr/addrlen info */
-    na_ofi_addr->unexpected = NA_TRUE;
-
-    /* Process address info from msg header */
-    if (na_ofi_with_msg_hdr(na_class)) {
-        ret = na_ofi_addr_ht_lookup(na_class, FI_SOCKADDR_IN,
-            na_ofi_op_id->noo_info.noo_recv_unexpected.noi_buf,
-            sizeof(struct na_ofi_sin_addr), &src_addr);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("na_ofi_addr_ht_lookup_reqhdr failed, ret: %d.", ret);
-            na_ofi_addr_decref(na_ofi_addr);
-            goto out;
-        }
-    }
-    na_ofi_addr->fi_addr = src_addr;
-    /* For unexpected msg, take one extra ref to be released by addr_free() */
-    na_ofi_addr_addref(na_ofi_addr);
+    na_ofi_addr = na_ofi_addr_alloc(domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM,
+        "na_ofi_addr_alloc() failed");
+    /* Unexpected addresses do not need to set addr/addrlen info, fi_av_lookup()
+     * can be used when needed. */
+
+    /* Use src_addr when available */
+    if (src_addr != FI_ADDR_UNSPEC)
+        na_ofi_addr->fi_addr = src_addr;
+    else if (src_err_addr && src_err_addrlen) { /* addr from error info */
+        /* We do not need to keep a copy of src_err_addr */
+        ret = na_ofi_addr_ht_lookup(domain,
+            na_ofi_prov_addr_format[domain->prov_type], src_err_addr,
+            src_err_addrlen, &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
+        NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
+    } else if (na_ofi_with_msg_hdr(na_class)) { /* addr from msg header */
+        /* We do not need to keep a copy of msg header */
+        ret = na_ofi_addr_ht_lookup(domain, FI_SOCKADDR_IN,
+            na_ofi_op_id->info.recv_unexpected.buf,
+            sizeof(struct na_ofi_sin_addr), &na_ofi_addr->fi_addr,
+            &na_ofi_addr->ht_key);
+        NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
+    } else
+        NA_GOTO_ERROR(error, ret, NA_PROTONOSUPPORT,
+            "Insufficient address information");
 
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    /* TODO check max tag */
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_tag = (na_tag_t) tag;
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_msg_size = len;
+    na_ofi_addr_addref(na_ofi_addr); /* decref in addr_free() */
+    na_ofi_op_id->addr = na_ofi_addr;
+    na_ofi_op_id->info.recv_unexpected.tag = (na_tag_t) tag;
+    na_ofi_op_id->info.recv_unexpected.msg_size = len;
     na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
 
 out:
     return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2940,26 +2731,19 @@ static NA_INLINE na_return_t
 na_ofi_cq_process_recv_expected_event(struct na_ofi_op_id *na_ofi_op_id,
     uint64_t tag, size_t len)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_RECV_EXPECTED) {
-        NA_LOG_ERROR("ignore the recv_event as cb_type %d mismatched with "
-            "NA_CB_RECV_EXPECTED.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
-    if (na_ofi_op_id->noo_info.noo_recv_expected.noi_tag
-        != (tag & ~NA_OFI_EXPECTED_TAG_FLAG)) {
-        NA_LOG_ERROR("ignore the recv_event as noi_tag 0x%x mismatch with "
-            "cq_event->tag: 0x%x.",
-            na_ofi_op_id->noo_info.noo_recv_expected.noi_tag,
-            tag & ~NA_OFI_EXPECTED_TAG_FLAG);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_RECV_EXPECTED, out, ret,
+        NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_RECV_EXPECTED",
+        cb_type);
+    NA_CHECK_ERROR(na_ofi_op_id->info.recv_expected.tag
+        != (tag & ~NA_OFI_EXPECTED_TAG_FLAG), out, ret, NA_INVALID_ARG,
+        "Invalid tag 0x%x, expected 0x%x",
+        na_ofi_op_id->info.recv_expected.tag,
+        tag & ~NA_OFI_EXPECTED_TAG_FLAG);
 
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_msg_size = len;
+    na_ofi_op_id->info.recv_expected.msg_size = len;
 
 out:
     return ret;
@@ -2969,15 +2753,12 @@ out:
 static NA_INLINE na_return_t
 na_ofi_cq_process_rma_event(struct na_ofi_op_id *na_ofi_op_id)
 {
-    na_cb_type_t cb_type = na_ofi_op_id->noo_completion_data.callback_info.type;
+    na_cb_type_t cb_type = na_ofi_op_id->completion_data.callback_info.type;
     na_return_t ret = NA_SUCCESS;
 
-    if (cb_type != NA_CB_PUT && cb_type != NA_CB_GET) {
-        NA_LOG_ERROR("ignore the send_event as cb_type %d mismatched with "
-            "NA_CB_PUT/_GET.", cb_type);
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(cb_type != NA_CB_PUT && cb_type != NA_CB_GET, out, ret,
+        NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_PUT/GET",
+        cb_type);
 
 out:
     return ret;
@@ -2987,58 +2768,70 @@ out:
 static na_return_t
 na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id, na_return_t op_ret)
 {
-    struct na_ofi_addr *na_ofi_addr = na_ofi_op_id->noo_addr;
+    struct na_ofi_addr *na_ofi_addr = na_ofi_op_id->addr;
     struct na_cb_info *callback_info = NULL;
+#if defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
+    hg_util_int32_t status;
+#endif
     na_return_t ret = NA_SUCCESS;
 
-    /* Mark op id as completed */
-    if (!hg_atomic_cas32(&na_ofi_op_id->noo_completed, 0, 1))
-        return ret;
+#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
+    /* Mark op id as completed before checking for cancelation */
+    hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
+#else
+    do {
+        status = hg_atomic_get32(&na_ofi_op_id->status);
+    } while (!hg_atomic_cas32(&na_ofi_op_id->status, status,
+        (status | NA_OFI_OP_COMPLETED)));
+#endif
+
+    /* If it was canceled while being processed, set callback ret accordingly */
+    if (hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_CANCELED) {
+        NA_LOG_DEBUG("Operation ID %p was canceled", na_ofi_op_id);
+        op_ret = (op_ret == NA_SUCCESS) ? NA_CANCELED : op_ret;
+    }
 
     /* Init callback info */
-    callback_info = &na_ofi_op_id->noo_completion_data.callback_info;
+    callback_info = &na_ofi_op_id->completion_data.callback_info;
     callback_info->ret = op_ret;
 
     switch (callback_info->type) {
-    case NA_CB_LOOKUP:
-        callback_info->info.lookup.addr =
-            na_ofi_op_id->noo_info.noo_lookup.noi_addr;
-        break;
-    case NA_CB_RECV_UNEXPECTED:
-        /* Fill callback info */
-        callback_info->info.recv_unexpected.actual_buf_size =
-            na_ofi_op_id->noo_info.noo_recv_unexpected.noi_msg_size;
-        callback_info->info.recv_unexpected.source =
-            na_ofi_op_id->noo_addr;
-        callback_info->info.recv_unexpected.tag =
-            na_ofi_op_id->noo_info.noo_recv_unexpected.noi_tag;
-        break;
-    case NA_CB_RECV_EXPECTED:
-        /* Check buf_size and msg_size */
-        if (na_ofi_op_id->noo_info.noo_recv_expected.noi_msg_size >
-            na_ofi_op_id->noo_info.noo_recv_expected.noi_buf_size) {
-            NA_LOG_ERROR("Expected recv too large for buffer");
-            ret = NA_SIZE_ERROR;
-            goto out;
-        }
-        break;
-    case NA_CB_SEND_UNEXPECTED:
-    case NA_CB_SEND_EXPECTED:
-    case NA_CB_PUT:
-    case NA_CB_GET:
-        break;
-    default:
-        NA_LOG_ERROR("Operation type %d not supported.", callback_info->type);
-        ret = NA_INVALID_PARAM;
-        break;
+        case NA_CB_LOOKUP:
+            callback_info->info.lookup.addr =
+                na_ofi_op_id->info.lookup.addr;
+            break;
+        case NA_CB_RECV_UNEXPECTED:
+            /* Fill callback info */
+            callback_info->info.recv_unexpected.actual_buf_size =
+                na_ofi_op_id->info.recv_unexpected.msg_size;
+            callback_info->info.recv_unexpected.source =
+                na_ofi_op_id->addr;
+            callback_info->info.recv_unexpected.tag =
+                na_ofi_op_id->info.recv_unexpected.tag;
+            break;
+        case NA_CB_RECV_EXPECTED:
+            /* Check buf_size and msg_size */
+            NA_CHECK_ERROR(
+                na_ofi_op_id->info.recv_expected.msg_size >
+            na_ofi_op_id->info.recv_expected.buf_size, out, ret,
+            NA_MSGSIZE, "Expected recv msg size too large for buffer");
+            break;
+        case NA_CB_SEND_UNEXPECTED:
+        case NA_CB_SEND_EXPECTED:
+        case NA_CB_PUT:
+        case NA_CB_GET:
+            break;
+        default:
+            NA_GOTO_ERROR(out, ret, NA_INVALID_ARG,
+                "Operation type %d not supported", callback_info->type);
+            break;
     }
 
     /* Add OP to NA completion queue */
-    ret = na_cb_completion_add(na_ofi_op_id->noo_context,
-       &na_ofi_op_id->noo_completion_data);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not add callback to completion queue");
-    }
+    ret = na_cb_completion_add(na_ofi_op_id->context,
+        &na_ofi_op_id->completion_data);
+    NA_CHECK_NA_ERROR(out, ret,
+        "Could not add callback to completion queue");
 
 out:
     if (na_ofi_addr)
@@ -3052,8 +2845,9 @@ na_ofi_release(void *arg)
 {
     struct na_ofi_op_id *na_ofi_op_id = (struct na_ofi_op_id *) arg;
 
-    if (na_ofi_op_id && !hg_atomic_get32(&na_ofi_op_id->noo_completed))
-        NA_LOG_WARNING("Releasing resources from an uncompleted operation");
+    NA_CHECK_WARNING(na_ofi_op_id &&
+        (!(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED)),
+        "Releasing resources from an uncompleted operation");
 
     na_ofi_op_id_decref(na_ofi_op_id);
 }
@@ -3071,25 +2865,20 @@ na_ofi_check_protocol(const char *protocol_name)
     enum na_ofi_prov_type type;
 
     type = na_ofi_prov_name_to_type(protocol_name);
-    if(type == NA_OFI_PROV_NULL) {
-        NA_LOG_ERROR("protocol %s not supported", protocol_name);
-        goto out;
-    }
+    NA_CHECK_ERROR(type == NA_OFI_PROV_NULL, out, ret, NA_PROTONOSUPPORT,
+        "Protocol %s not supported", protocol_name);
 
     /* Get info from provider */
     ret = na_ofi_getinfo(type, &providers);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_getinfo failed, ret: %d.", ret);
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(out, ret, "na_ofi_getinfo() failed");
 
     prov = providers;
     while (prov != NULL) {
-        /*
         NA_LOG_DEBUG("fabric_attr - prov_name %s, name - %s, "
-                     "domain_attr - name %s, mode: 0x%llx, domain_attr->mode 0x%llx, caps: 0x%llx.", prov->fabric_attr->prov_name,
-                     prov->fabric_attr->name, prov->domain_attr->name, prov->mode, prov->domain_attr->mode, prov->caps);
-        */
+            "domain_attr - name %s, mode: 0x%llx, domain_attr->mode 0x%llx, "
+            "caps: 0x%llx", prov->fabric_attr->prov_name,
+            prov->fabric_attr->name, prov->domain_attr->name, prov->mode,
+            prov->domain_attr->mode, prov->caps);
         if (!strcmp(na_ofi_prov_name[type], prov->fabric_attr->prov_name)) {
             accept = NA_TRUE;
             break;
@@ -3097,9 +2886,9 @@ na_ofi_check_protocol(const char *protocol_name)
         prov = prov->next;
     }
 
+    fi_freeinfo(providers);
+
 out:
-    if (providers)
-        fi_freeinfo(providers);
     return accept;
 }
 
@@ -3112,9 +2901,11 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     void *src_addr = NULL;
     na_size_t src_addrlen = 0;
     char *resolve_name = NULL;
+    char *host_name = NULL;
     unsigned int port = 0;
     const char *node_ptr = NULL;
     char node[NA_OFI_MAX_URI_LEN] = {'\0'};
+    char *domain_name_ptr = NULL;
     char domain_name[NA_OFI_MAX_URI_LEN] = {'\0'};
     na_bool_t no_wait = NA_FALSE;
     na_uint8_t max_contexts = 1; /* Default */
@@ -3122,57 +2913,48 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     na_return_t ret = NA_SUCCESS;
     enum na_ofi_prov_type prov_type;
 
-    /*
-    NA_LOG_DEBUG("Entering na_ofi_initialize class_name %s, protocol_name %s, "
-                 "host_name %s.\n", na_info->class_name, na_info->protocol_name,
-                 na_info->host_name);
-    */
+    NA_LOG_DEBUG("Entering na_ofi_initialize() class_name %s, protocol_name %s,"
+        " host_name %s", na_info->class_name, na_info->protocol_name,
+        na_info->host_name);
 
     prov_type = na_ofi_prov_name_to_type(na_info->protocol_name);
-    if(prov_type == NA_OFI_PROV_NULL) {
-        NA_LOG_ERROR("protocol %s not supported", na_info->protocol_name);
-        ret = NA_INVALID_PARAM;
-        goto out;
-    }
+    NA_CHECK_ERROR(prov_type == NA_OFI_PROV_NULL, out, ret,
+        NA_INVALID_ARG, "Protocol %s not supported", na_info->protocol_name);
 
 #if defined(NA_OFI_HAS_EXT_GNI_H) && defined(NA_OFI_GNI_HAS_UDREG)
     /* In case of GNI using udreg, we check to see whether MPICH_GNI_NDREG_ENTRIES
      * environment variable is set or not.  If not, this code is not likely
      * to work if Cray MPI is also used. Print error msg suggesting workaround.
      */
-    if (prov_type == NA_OFI_PROV_GNI && !getenv("MPICH_GNI_NDREG_ENTRIES"))
-    {
-        NA_LOG_ERROR("ofi+gni provider requested, but the MPICH_GNI_NDREG_ENTRIES environment variable is not set.");
-        NA_LOG_ERROR("Please run this executable with \"export MPICH_GNI_NDREG_ENTRIES=1024\" to ensure compatibility.");
-        ret = NA_INVALID_PARAM;
-        goto out;
-    }
+    NA_CHECK_ERROR(prov_type == NA_OFI_PROV_GNI
+        && !getenv("MPICH_GNI_NDREG_ENTRIES"), out, ret, NA_INVALID_ARG,
+        "ofi+gni provider requested, but the MPICH_GNI_NDREG_ENTRIES "
+        "environment variable is not set.\n" "Please run this executable with "
+        "\"export MPICH_GNI_NDREG_ENTRIES=1024\" to ensure compatibility."
+    );
 #endif
 
     /* Use default interface name if no hostname was passed */
     if (na_info->host_name) {
-        resolve_name = strdup(na_info->host_name);
-        if (!resolve_name) {
-            NA_LOG_ERROR("strdup() of host_name failed");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
+        host_name = strdup(na_info->host_name);
+        NA_CHECK_ERROR(host_name == NULL, out, ret, NA_NOMEM,
+            "strdup() of host_name failed");
 
         /* Extract hostname */
-        if (strstr(resolve_name, ":")) {
+        if (strstr(host_name, ":")) {
             char *port_str = NULL;
-
-            strtok_r(resolve_name, ":", &port_str);
+            strtok_r(host_name, ":", &port_str);
             port = (unsigned int) strtoul(port_str, NULL, 10);
         }
-    } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI) {
-        resolve_name = strdup(NA_OFI_GNI_IFACE_DEFAULT);
-        if (!resolve_name) {
-            NA_LOG_ERROR("strdup() of NA_OFI_GNI_IFACE_DEFAULT failed");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
+
+        /* Extract domain (if specified) */
+        if (strstr(host_name, "/")) {
+            strtok_r(host_name, "/", &resolve_name);
+            domain_name_ptr = host_name;
+        } else
+            resolve_name = host_name;
+    } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI)
+        resolve_name = NA_OFI_GNI_IFACE_DEFAULT;
 
     /* Get hostname/port info if available */
     if (resolve_name) {
@@ -3183,43 +2965,40 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
             /* Try to get matching IP/device */
             ret = na_ofi_check_interface(resolve_name, port, &ifa_name,
                 &na_ofi_sin_addr);
-            if (ret != NA_SUCCESS) {
-                NA_LOG_ERROR("Could not check interfaces");
-                goto out;
-            }
+            NA_CHECK_NA_ERROR(out, ret, "Could not check interfaces");
 
             /* Set SIN addr if found */
             if (na_ofi_sin_addr && ifa_name) {
                 src_addr = na_ofi_sin_addr;
                 src_addrlen = sizeof(*na_ofi_sin_addr);
-                /* Make sure we are using the right domain */
-                strncpy(domain_name, ifa_name, NA_OFI_MAX_URI_LEN - 1);
+                if (!domain_name_ptr) {
+                    /* Attempt to pass domain name as ifa_name if not set */
+                    strncpy(domain_name, ifa_name, NA_OFI_MAX_URI_LEN - 1);
+                    domain_name_ptr = domain_name;
+                }
                 free(ifa_name);
-            } else {
-                /* Allow for passing domain name directly */
+            } else if (!domain_name_ptr) {
+                /* Pass domain name as hostname if not set */
                 strncpy(domain_name, resolve_name, NA_OFI_MAX_URI_LEN - 1);
+                domain_name_ptr = domain_name;
             }
         } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI) {
             struct na_ofi_sin_addr *na_ofi_sin_addr = NULL;
+            const char *ptr;
 
             /* Try to get matching IP/device (do not use port) */
             ret = na_ofi_check_interface(resolve_name, 0, NULL,
                 &na_ofi_sin_addr);
-            if (ret != NA_SUCCESS || !na_ofi_sin_addr) {
-                NA_LOG_ERROR("Could not check interfaces");
-                goto out;
-            }
+            NA_CHECK_ERROR(ret != NA_SUCCESS || !na_ofi_sin_addr, out, ret,
+                NA_ADDRNOTAVAIL, "Could not check interfaces");
 
             /* Node must match IP resolution */
-            if (!inet_ntop(na_ofi_sin_addr->sin.sin_family,
-                &na_ofi_sin_addr->sin.sin_addr, node, sizeof(node))) {
-                NA_LOG_ERROR("Could not convert IP to string");
-                free(na_ofi_sin_addr);
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            node_ptr = node;
+            ptr = inet_ntop(na_ofi_sin_addr->sin.sin_family,
+                &na_ofi_sin_addr->sin.sin_addr, node, sizeof(node));
             free(na_ofi_sin_addr);
+            NA_CHECK_ERROR(ptr == NULL, out, ret, NA_ADDRNOTAVAIL,
+                "Could not convert IP to string");
+            node_ptr = node;
         } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_PSMX2) {
             /* Nothing to do */
         }
@@ -3239,48 +3018,37 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     /* Create private data */
     na_class->plugin_class = (struct na_ofi_class *) malloc(
         sizeof(struct na_ofi_class));
-    if (!na_class->plugin_class) {
-        NA_LOG_ERROR("Could not allocate NA private data class");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_class->plugin_class == NULL, out, ret, NA_NOMEM,
+        "Could not allocate NA private data class");
     memset(na_class->plugin_class, 0, sizeof(struct na_ofi_class));
     priv = NA_OFI_CLASS(na_class);
     priv->no_wait = no_wait;
-    priv->nop_listen = listen;
-    priv->nop_max_contexts = max_contexts;
-    priv->nop_contexts = 0;
+    priv->listen = listen;
+    priv->max_contexts = max_contexts;
+    priv->contexts = 0;
 
     /* Initialize queue / mutex */
-    hg_thread_mutex_init(&priv->nop_mutex);
+    hg_thread_mutex_init(&priv->mutex);
 
     /* Initialize buf pool */
-    hg_thread_spin_init(&priv->nop_buf_pool_lock);
-    HG_QUEUE_INIT(&priv->nop_buf_pool);
+    hg_thread_spin_init(&priv->buf_pool_lock);
+    HG_QUEUE_INIT(&priv->buf_pool);
 
     /* Create domain */
-    ret = na_ofi_domain_open(na_class->plugin_class, prov_type, domain_name,
-        auth_key, &priv->nop_domain);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not open domain for %s, %s", na_ofi_prov_name[prov_type],
-            domain_name);
-        goto out;
-    }
+    ret = na_ofi_domain_open(na_class->plugin_class, prov_type, domain_name_ptr,
+        auth_key, &priv->domain);
+    NA_CHECK_NA_ERROR(out, ret, "Could not open domain for %s, %s",
+        na_ofi_prov_name[prov_type], domain_name_ptr);
 
     /* Create endpoint */
-    ret = na_ofi_endpoint_open(priv->nop_domain, node_ptr, src_addr, src_addrlen,
-        priv->no_wait, priv->nop_max_contexts, &priv->nop_endpoint);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not create endpoint for %s", resolve_name);
-        goto out;
-    }
+    ret = na_ofi_endpoint_open(priv->domain, node_ptr, src_addr, src_addrlen,
+        priv->no_wait, priv->max_contexts, &priv->endpoint);
+    NA_CHECK_NA_ERROR(out, ret, "Could not create endpoint for %s",
+        resolve_name);
 
     /* Get address from endpoint */
-    ret = na_ofi_get_ep_addr(na_class, &priv->nop_endpoint->noe_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not get address from endpoint");
-        goto out;
-    }
+    ret = na_ofi_get_ep_addr(na_class, &priv->endpoint->src_addr);
+    NA_CHECK_NA_ERROR(out, ret, "Could not get address from endpoint");
 
 out:
     if (ret != NA_SUCCESS) {
@@ -3290,7 +3058,7 @@ out:
         }
     }
     free(src_addr);
-    free(resolve_name);
+    free(host_name);
     return ret;
 }
 
@@ -3305,38 +3073,32 @@ na_ofi_finalize(na_class_t *na_class)
         goto out;
 
     /* Close endpoint */
-    if (priv->nop_endpoint) {
-        ret = na_ofi_endpoint_close(priv->nop_endpoint);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not close endpoint");
-            goto out;
-        }
-        priv->nop_endpoint = NULL;
+    if (priv->endpoint) {
+        ret = na_ofi_endpoint_close(priv->endpoint);
+        NA_CHECK_NA_ERROR(out, ret, "Could not close endpoint");
+        priv->endpoint = NULL;
     }
 
     /* Free memory pool (must be done before trying to close the domain as
      * the pool is holding memory handles) */
-    while (!HG_QUEUE_IS_EMPTY(&priv->nop_buf_pool)) {
+    while (!HG_QUEUE_IS_EMPTY(&priv->buf_pool)) {
         struct na_ofi_mem_pool *na_ofi_mem_pool =
-            HG_QUEUE_FIRST(&priv->nop_buf_pool);
-        HG_QUEUE_POP_HEAD(&priv->nop_buf_pool, entry);
+            HG_QUEUE_FIRST(&priv->buf_pool);
+        HG_QUEUE_POP_HEAD(&priv->buf_pool, entry);
 
         na_ofi_mem_pool_destroy(na_ofi_mem_pool);
     }
-    hg_thread_spin_destroy(&NA_OFI_CLASS(na_class)->nop_buf_pool_lock);
+    hg_thread_spin_destroy(&NA_OFI_CLASS(na_class)->buf_pool_lock);
 
     /* Close domain */
-    if (priv->nop_domain) {
-        ret = na_ofi_domain_close(priv->nop_domain);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not close domain");
-            goto out;
-        }
-        priv->nop_domain = NULL;
+    if (priv->domain) {
+        ret = na_ofi_domain_close(priv->domain);
+        NA_CHECK_NA_ERROR(out, ret, "Could not close domain");
+        priv->domain = NULL;
     }
 
     /* Close mutex / free private data */
-    hg_thread_mutex_destroy(&priv->nop_mutex);
+    hg_thread_mutex_destroy(&priv->mutex);
     free(priv);
     na_class->plugin_class = NULL;
 
@@ -3349,152 +3111,104 @@ static na_return_t
 na_ofi_context_create(na_class_t *na_class, void **context, na_uint8_t id)
 {
     struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_domain *domain = priv->nop_domain;
-    struct na_ofi_endpoint *ep = priv->nop_endpoint;
+    struct na_ofi_domain *domain = priv->domain;
+    struct na_ofi_endpoint *ep = priv->endpoint;
     struct na_ofi_context *ctx = NULL;
     struct fi_cq_attr cq_attr = {0};
     na_return_t ret = NA_SUCCESS;
     int rc = 0;
 
     ctx = (struct na_ofi_context *)calloc(1, sizeof(struct na_ofi_context));
-    if (!ctx) {
-        NA_LOG_ERROR("Could not allocate na_ofi_context.");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    ctx->noc_idx = id;
+    NA_CHECK_ERROR(ctx == NULL, out, ret, NA_NOMEM,
+        "Could not allocate na_ofi_context");
+    ctx->idx = id;
 
     /* If not using SEP, just point to endpoint objects */
-    hg_thread_mutex_lock(&priv->nop_mutex);
+    hg_thread_mutex_lock(&priv->mutex);
+
     if (!na_ofi_with_sep(na_class)) {
-        ctx->noc_tx = ep->noe_ep;
-        ctx->noc_rx = ep->noe_ep;
-        ctx->noc_cq = ep->noe_cq;
-        ctx->noc_wait = ep->noe_wait;
-        ctx->noc_unexpected_op_queue = ep->noe_unexpected_op_queue;
+        ctx->fi_tx = ep->fi_ep;
+        ctx->fi_rx = ep->fi_ep;
+        ctx->fi_cq = ep->fi_cq;
+        ctx->fi_wait = ep->fi_wait;
+        ctx->unexpected_op_queue = ep->unexpected_op_queue;
     } else {
+        ctx->unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
+        NA_CHECK_ERROR(ctx->unexpected_op_queue == NULL, error, ret,
+            NA_NOMEM, "Could not allocate unexpected_op_queue/_lock");
+
         /* Initialize queue / mutex */
-        ctx->noc_unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
-        if (!ctx->noc_unexpected_op_queue) {
-            NA_LOG_ERROR("Could not allocate noc_unexpected_op_queue/_lock");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-        HG_QUEUE_INIT(&ctx->noc_unexpected_op_queue->noq_queue);
-        hg_thread_spin_init(&ctx->noc_unexpected_op_queue->noq_lock);
-
-        if (priv->nop_contexts >= priv->nop_max_contexts ||
-            id >= priv->nop_max_contexts) {
-            NA_LOG_ERROR("nop_contexts %d, context id %d, nop_max_contexts %d "
-                "could not create context.", priv->nop_contexts,
-                id, priv->nop_max_contexts);
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        HG_QUEUE_INIT(&ctx->unexpected_op_queue->queue);
+        hg_thread_spin_init(&ctx->unexpected_op_queue->lock);
+
+        NA_CHECK_ERROR(priv->contexts >= priv->max_contexts ||
+            id >= priv->max_contexts, error, ret, NA_OPNOTSUPPORTED,
+            "contexts %d, context id %d, max_contexts %d",
+            priv->contexts, id, priv->max_contexts);
 
         if (!priv->no_wait) {
-            if (na_ofi_prov_flags[domain->nod_prov_type] & NA_OFI_WAIT_FD)
+            if (na_ofi_prov_flags[domain->prov_type] & NA_OFI_WAIT_FD)
                 cq_attr.wait_obj = FI_WAIT_FD; /* Wait on fd */
             else {
                 struct fi_wait_attr wait_attr = {0};
 
                 /* Open wait set for other providers. */
                 wait_attr.wait_obj = FI_WAIT_UNSPEC;
-                rc = fi_wait_open(domain->nod_fabric, &wait_attr,
-                    &ctx->noc_wait);
-                if (rc != 0) {
-                    NA_LOG_ERROR("fi_wait_open failed, rc: %d(%s).", rc,
-                        fi_strerror(-rc));
-                    hg_thread_mutex_unlock(&priv->nop_mutex);
-                    ret = NA_PROTOCOL_ERROR;
-                    goto out;
-                }
+                rc = fi_wait_open(domain->fi_fabric, &wait_attr,
+                    &ctx->fi_wait);
+                NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+                    "fi_wait_open() failed, rc: %d(%s)", rc, fi_strerror(-rc));
                 cq_attr.wait_obj = FI_WAIT_SET; /* Wait on wait set */
-                cq_attr.wait_set = ctx->noc_wait;
+                cq_attr.wait_set = ctx->fi_wait;
             }
         }
         cq_attr.wait_cond = FI_CQ_COND_NONE;
         cq_attr.format = FI_CQ_FORMAT_TAGGED;
         cq_attr.size = NA_OFI_CQ_DEPTH;
-        rc = fi_cq_open(domain->nod_domain, &cq_attr, &ctx->noc_cq, NULL);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_cq_open failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_cq_open(domain->fi_domain, &cq_attr, &ctx->fi_cq, NULL);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_cq_open() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_tx_context(ep->noe_ep, id, NULL, &ctx->noc_tx, NULL);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_tx_context failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_tx_context(ep->fi_ep, id, NULL, &ctx->fi_tx, NULL);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_tx_context() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_rx_context(ep->noe_ep, id, NULL, &ctx->noc_rx, NULL);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_rx_context failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_rx_context(ep->fi_ep, id, NULL, &ctx->fi_rx, NULL);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_rx_context() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_ep_bind(ctx->noc_tx, &ctx->noc_cq->fid, FI_TRANSMIT);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_ep_bind noc_tx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_ep_bind(ctx->fi_tx, &ctx->fi_cq->fid, FI_TRANSMIT);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_ep_bind() noc_tx failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_ep_bind(ctx->noc_rx, &ctx->noc_cq->fid, FI_RECV);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_ep_bind noc_rx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_ep_bind(ctx->fi_rx, &ctx->fi_cq->fid, FI_RECV);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_ep_bind() noc_rx failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_enable(ctx->noc_tx);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_enable noc_tx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_enable(ctx->fi_tx);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_enable() noc_tx failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = fi_enable(ctx->noc_rx);
-        if (rc < 0) {
-            NA_LOG_ERROR("fi_enable noc_rx failed, rc: %d(%s).",
-                rc, fi_strerror(-rc));
-            hg_thread_mutex_unlock(&priv->nop_mutex);
-            ret = NA_PROTOCOL_ERROR;
-            goto out;
-        }
+        rc = fi_enable(ctx->fi_rx);
+        NA_CHECK_ERROR(rc < 0, error, ret, NA_PROTOCOL_ERROR,
+            "fi_enable() noc_rx failed, rc: %d(%s)", rc, fi_strerror(-rc));
     }
 
-    priv->nop_contexts++;
-    hg_thread_mutex_unlock(&priv->nop_mutex);
+    priv->contexts++;
+    hg_thread_mutex_unlock(&priv->mutex);
 
     *context = ctx;
 
 out:
-    if (ret != NA_SUCCESS && ctx) {
-        if (na_ofi_with_sep(na_class) && ctx->noc_unexpected_op_queue) {
-            hg_thread_spin_destroy(&ctx->noc_unexpected_op_queue->noq_lock);
-            free(ctx->noc_unexpected_op_queue);
-        }
-        free(ctx);
-    }
+    return ret;
 
+error:
+    hg_thread_mutex_unlock(&priv->mutex);
+    if (na_ofi_with_sep(na_class) && ctx->unexpected_op_queue) {
+        hg_thread_spin_destroy(&ctx->unexpected_op_queue->lock);
+        free(ctx->unexpected_op_queue);
+    }
+    free(ctx);
     return ret;
 }
 
@@ -3508,69 +3222,53 @@ na_ofi_context_destroy(na_class_t *na_class, void *context)
     int rc;
 
     /* Check that unexpected op queue is empty */
-    if (na_ofi_with_sep(na_class) &&
-        !HG_QUEUE_IS_EMPTY(&ctx->noc_unexpected_op_queue->noq_queue)) {
-        NA_LOG_ERROR("Unexpected op queue should be empty");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
+    if (na_ofi_with_sep(na_class)) {
+        na_bool_t empty = HG_QUEUE_IS_EMPTY(&ctx->unexpected_op_queue->queue);
+        NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_BUSY,
+            "Unexpected op queue should be empty");
     }
 
     if (na_ofi_with_sep(na_class)) {
-        if (ctx->noc_tx) {
-            rc = fi_close(&ctx->noc_tx->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close noc_tx failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_tx = NULL;
+        if (ctx->fi_tx) {
+            rc = fi_close(&ctx->fi_tx->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() noc_tx failed, rc: %d(%s)", rc, fi_strerror(-rc));
+            ctx->fi_tx = NULL;
         }
 
-        if (ctx->noc_rx) {
-            rc = fi_close(&ctx->noc_rx->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close noc_rx failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_rx = NULL;
+        if (ctx->fi_rx) {
+            rc = fi_close(&ctx->fi_rx->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() noc_rx failed, rc: %d(%s)", rc, fi_strerror(-rc));
+            ctx->fi_rx = NULL;
         }
 
         /* Close wait set */
-        if (ctx->noc_wait) {
-            rc = fi_close(&ctx->noc_wait->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close wait failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_wait = NULL;
+        if (ctx->fi_wait) {
+            rc = fi_close(&ctx->fi_wait->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() wait failed, rc: %d(%s)", rc, fi_strerror(-rc));
+            ctx->fi_wait = NULL;
         }
 
         /* Close completion queue */
-        if (ctx->noc_cq) {
-            rc = fi_close(&ctx->noc_cq->fid);
-            if (rc != 0) {
-                NA_LOG_ERROR("fi_close CQ failed, rc: %d(%s).",
-                             rc, fi_strerror(-rc));
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            ctx->noc_cq = NULL;
+        if (ctx->fi_cq) {
+            rc = fi_close(&ctx->fi_cq->fid);
+            NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                "fi_close() CQ failed, rc: %d(%s)", rc, fi_strerror(-rc));
+            ctx->fi_cq = NULL;
         }
 
-        hg_thread_spin_destroy(&ctx->noc_unexpected_op_queue->noq_lock);
-        free(ctx->noc_unexpected_op_queue);
+        hg_thread_spin_destroy(&ctx->unexpected_op_queue->lock);
+        free(ctx->unexpected_op_queue);
     }
 
-    hg_thread_mutex_lock(&priv->nop_mutex);
-    priv->nop_contexts--;
-    hg_thread_mutex_unlock(&priv->nop_mutex);
+    hg_thread_mutex_lock(&priv->mutex);
+    priv->contexts--;
+    hg_thread_mutex_unlock(&priv->mutex);
 
     free(ctx);
+
 out:
     return ret;
 }
@@ -3582,21 +3280,15 @@ na_ofi_op_create(na_class_t NA_UNUSED *na_class)
     struct na_ofi_op_id *na_ofi_op_id = NULL;
 
     na_ofi_op_id = (struct na_ofi_op_id *)calloc(1, sizeof(struct na_ofi_op_id));
-    if (!na_ofi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA OFI operation ID");
-        goto out;
-    }
-    hg_atomic_init32(&na_ofi_op_id->noo_refcount, 1);
+    NA_CHECK_ERROR_NORET(na_ofi_op_id == NULL, out,
+        "Could not allocate NA OFI operation ID");
+    hg_atomic_init32(&na_ofi_op_id->refcount, 1);
     /* Completed by default */
-    hg_atomic_init32(&na_ofi_op_id->noo_completed, NA_TRUE);
-
-    /* Set op ID verification magic */
-    na_ofi_op_id->noo_magic_1 = NA_OFI_OP_ID_MAGIC_1;
-    na_ofi_op_id->noo_magic_2 = NA_OFI_OP_ID_MAGIC_2;
+    hg_atomic_init32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
 
     /* Set op ID release callbacks */
-    na_ofi_op_id->noo_completion_data.plugin_callback = na_ofi_release;
-    na_ofi_op_id->noo_completion_data.plugin_callback_args = na_ofi_op_id;
+    na_ofi_op_id->completion_data.plugin_callback = na_ofi_release;
+    na_ofi_op_id->completion_data.plugin_callback_args = na_ofi_op_id;
 
 out:
     return (na_op_id_t) na_ofi_op_id;
@@ -3618,94 +3310,89 @@ static na_return_t
 na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const char *name, na_op_id_t *op_id)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_op_id *na_ofi_op_id = NULL;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    /* Check provider from name */
-    if (na_ofi_addr_prov(name) != priv->nop_domain->nod_prov_type) {
-        NA_LOG_ERROR("Unrecognized provider type found from: %s", name);
-        ret = NA_INVALID_PARAM;
-        goto out;
-    }
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_LOOKUP;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    /* Take one refcount to be released in na_ofi_complete->na_ofi_release */
-    hg_atomic_set32(&na_ofi_op_id->noo_refcount, 1);
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_LOOKUP;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
+
+    /* Lookup addr */
+    ret = na_ofi_addr_lookup2(na_class, name, (na_addr_t *) &na_ofi_addr);
+    NA_CHECK_NA_ERROR(error, ret, "Could not lookup %s", name);
 
-    /* Allocate addr */
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("na_ofi_addr_alloc failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
-    na_ofi_addr->uri = strdup(name);
-    if (!na_ofi_addr->uri) {
-        NA_LOG_ERROR("strdup() of URI failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
     /* One extra refcount to be decref in na_ofi_complete(). */
     na_ofi_addr_addref(na_ofi_addr);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    na_ofi_op_id->noo_info.noo_lookup.noi_addr = (na_addr_t) na_ofi_addr;
+    na_ofi_op_id->addr = na_ofi_addr;
+    na_ofi_op_id->info.lookup.addr = (na_addr_t) na_ofi_addr;
 
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    /* As the fi_av_insert is blocking, always complete here */
+    ret = na_ofi_complete(na_ofi_op_id, ret);
+    NA_CHECK_NA_ERROR(error, ret, "Could not complete operation");
+
+out:
+    return ret;
+
+error:
+    na_ofi_op_id_decref(na_ofi_op_id);
+    if (na_ofi_addr) {
+        na_ofi_addr_decref(na_ofi_addr);
+        na_ofi_addr_decref(na_ofi_addr);
+    }
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static na_return_t
+na_ofi_addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr)
+{
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
+    struct na_ofi_addr *na_ofi_addr = NULL;
+    na_return_t ret = NA_SUCCESS;
+
+    /* Check provider from name */
+    NA_CHECK_ERROR(na_ofi_addr_prov(name) != domain->prov_type, out, ret,
+        NA_INVALID_ARG, "Unrecognized provider type found from: %s", name);
+
+    /* Allocate addr */
+    na_ofi_addr = na_ofi_addr_alloc(domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM,
+        "na_ofi_addr_alloc() failed");
+    na_ofi_addr->uri = strdup(name);
+    NA_CHECK_ERROR(na_ofi_addr->uri == NULL, error, ret, NA_NOMEM,
+        "strdup() of URI failed");
 
     /* Convert name to address */
-    ret = na_ofi_str_to_addr(name,
-        na_ofi_prov_addr_format[priv->nop_domain->nod_prov_type],
+    ret = na_ofi_str_to_addr(name, na_ofi_prov_addr_format[domain->prov_type],
         &na_ofi_addr->addr, &na_ofi_addr->addrlen);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not convert string to address");
-        goto out;
-    }
+    NA_CHECK_NA_ERROR(error, ret, "Could not convert string to address");
 
     /* Lookup address */
-    ret = na_ofi_addr_ht_lookup(na_class,
-        na_ofi_prov_addr_format[priv->nop_domain->nod_prov_type],
-        na_ofi_addr->addr, na_ofi_addr->addrlen, &na_ofi_addr->fi_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_addr_ht_lookup(%s) failed, ret: %d.", name, ret);
-        goto out;
-    }
+    ret = na_ofi_addr_ht_lookup(domain,
+        na_ofi_prov_addr_format[domain->prov_type], na_ofi_addr->addr,
+        na_ofi_addr->addrlen, &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
+    NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup(%s) failed", name);
 
-    /* As the fi_av_insert is blocking, always complete here */
-    ret = na_ofi_complete(na_ofi_op_id, ret);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not complete operation");
-        goto out;
-    }
+    *addr = (na_addr_t) na_ofi_addr;
 
 out:
-    if (ret != NA_SUCCESS) {
-        if (na_ofi_addr) {
-            free(na_ofi_addr->addr);
-            free(na_ofi_addr->uri);
-            free(na_ofi_addr);
-        }
-        free(na_ofi_op_id);
+    return ret;
+
+error:
+    if (na_ofi_addr) {
+        free(na_ofi_addr->addr);
+        free(na_ofi_addr->uri);
+        free(na_ofi_addr);
     }
     return ret;
 }
@@ -3715,10 +3402,10 @@ static NA_INLINE na_return_t
 na_ofi_addr_self(na_class_t *na_class, na_addr_t *addr)
 {
     struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
-    struct na_ofi_endpoint *ep = priv->nop_endpoint;
+    struct na_ofi_endpoint *ep = priv->endpoint;
 
-    na_ofi_addr_addref(ep->noe_addr); /* decref in na_ofi_addr_free() */
-    *addr = ep->noe_addr;
+    na_ofi_addr_addref(ep->src_addr); /* decref in na_ofi_addr_free() */
+    *addr = ep->src_addr;
 
     return NA_SUCCESS;
 }
@@ -3737,7 +3424,7 @@ na_ofi_addr_dup(na_class_t NA_UNUSED *na_class, na_addr_t addr,
 }
 
 /*---------------------------------------------------------------------------*/
-static na_return_t
+static NA_INLINE na_return_t
 na_ofi_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t addr)
 {
     na_ofi_addr_decref((struct na_ofi_addr *) addr);
@@ -3745,6 +3432,15 @@ na_ofi_addr_free(na_class_t NA_UNUSED *na_class, na_addr_t addr)
     return NA_SUCCESS;
 }
 
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_return_t
+na_ofi_addr_set_remove(na_class_t NA_UNUSED *na_class, na_addr_t addr)
+{
+    ((struct na_ofi_addr *) addr)->remove = NA_TRUE;
+
+    return NA_SUCCESS;
+}
+
 /*---------------------------------------------------------------------------*/
 static NA_INLINE na_bool_t
 na_ofi_addr_is_self(na_class_t NA_UNUSED *na_class, na_addr_t addr)
@@ -3761,20 +3457,27 @@ na_ofi_addr_to_string(na_class_t NA_UNUSED *na_class, char *buf,
     na_size_t str_len;
     na_return_t ret = NA_SUCCESS;
 
-    if (na_ofi_addr->unexpected) {
-        NA_LOG_ERROR("Addr to string is not available on unexpected addresses");
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
+    /* If there is no URI for address, attempt to reconstruct one */
+    if (!na_ofi_addr->uri) {
+        NA_CHECK_ERROR(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out, ret,
+            NA_ADDRNOTAVAIL, "Addr is not initialized");
+
+        /* If we don't have the addr either, look it up from AV */
+        if (!na_ofi_addr->addr) {
+            ret = na_ofi_av_lookup(na_ofi_addr->domain, na_ofi_addr->fi_addr,
+                &na_ofi_addr->addr, &na_ofi_addr->addrlen);
+            NA_CHECK_NA_ERROR(out, ret, "Could not get addr from AV");
+        }
+
+        ret = na_ofi_get_uri(na_class, na_ofi_addr->addr, &na_ofi_addr->uri);
+        NA_CHECK_NA_ERROR(out, ret, "Could not get URI for address");
     }
 
     str_len = strlen(na_ofi_addr->uri);
     if (buf) {
-        if (str_len >= *buf_size) {
-            NA_LOG_ERROR("Buffer size too small to copy addr");
-            ret = NA_SIZE_ERROR;
-        } else {
-            strcpy(buf, na_ofi_addr->uri);
-        }
+        NA_CHECK_ERROR(str_len >= *buf_size, out, ret, NA_OVERFLOW,
+            "Buffer size too small to copy addr");
+        strcpy(buf, na_ofi_addr->uri);
     }
     *buf_size = str_len + 1;
 
@@ -3788,8 +3491,25 @@ na_ofi_addr_get_serialize_size(na_class_t NA_UNUSED *na_class,
     na_addr_t addr)
 {
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) addr;
+    na_size_t size = 0;
+
+    if (!na_ofi_addr->addr) {
+        na_return_t ret;
 
-    return (na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen));
+        NA_CHECK_ERROR_NORET(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out,
+            "Addr is not initialized");
+
+        /* If we don't have the addr, look it up from AV */
+        ret = na_ofi_av_lookup(na_ofi_addr->domain, na_ofi_addr->fi_addr,
+            &na_ofi_addr->addr, &na_ofi_addr->addrlen);
+        NA_CHECK_ERROR_NORET(ret != NA_SUCCESS, out,
+            "Could not get addr from AV");
+    }
+
+    size = na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen);
+
+out:
+    return size;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3801,13 +3521,20 @@ na_ofi_addr_serialize(na_class_t NA_UNUSED *na_class, void *buf,
     na_size_t len;
     na_return_t ret = NA_SUCCESS;
 
-    len = na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen);
-    if (buf_size < len) {
-        NA_LOG_ERROR("Buffer size too small for serializing address");
-        ret = NA_SIZE_ERROR;
-        goto out;
+    if (!na_ofi_addr->addr) {
+        NA_CHECK_ERROR(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out, ret,
+            NA_ADDRNOTAVAIL, "Addr is not initialized");
+
+        /* If we don't have the addr, look it up from AV */
+        ret = na_ofi_av_lookup(na_ofi_addr->domain, na_ofi_addr->fi_addr,
+            &na_ofi_addr->addr, &na_ofi_addr->addrlen);
+        NA_CHECK_NA_ERROR(out, ret, "Could not get addr from AV");
     }
 
+    len = na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen);
+    NA_CHECK_ERROR(buf_size < len, out, ret, NA_OVERFLOW,
+        "Buffer size too small for serializing address");
+
     /* TODO could skip the addrlen but include it for sanity check */
     memcpy(buf, &na_ofi_addr->addrlen, sizeof(na_ofi_addr->addrlen));
     memcpy((na_uint8_t *) buf + sizeof(na_ofi_addr->addrlen), na_ofi_addr->addr,
@@ -3822,46 +3549,39 @@ static na_return_t
 na_ofi_addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
     na_size_t NA_UNUSED buf_size)
 {
-    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     struct na_ofi_addr *na_ofi_addr = NULL;
     na_return_t ret = NA_SUCCESS;
 
     /* Allocate addr */
-    na_ofi_addr = na_ofi_addr_alloc();
-    if (!na_ofi_addr) {
-        NA_LOG_ERROR("na_ofi_addr_alloc failed");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    na_ofi_addr = na_ofi_addr_alloc(domain);
+    NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM,
+        "na_ofi_addr_alloc() failed");
     memcpy(&na_ofi_addr->addrlen, buf, sizeof(na_ofi_addr->addrlen));
 
     na_ofi_addr->addr = malloc(na_ofi_addr->addrlen);
-    if (!na_ofi_addr->addr) {
-        NA_LOG_ERROR("Could not allocate %zu bytes for address",
-            na_ofi_addr->addrlen);
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_addr->addr == NULL, error, ret, NA_NOMEM,
+        "Could not allocate %zu bytes for address", na_ofi_addr->addrlen);
     memcpy(na_ofi_addr->addr,
         (const na_uint8_t *) buf + sizeof(na_ofi_addr->addrlen),
         na_ofi_addr->addrlen);
 
-    /* TODO Skip URI generation? */
+    /* Skip URI generation, URI will only be generated when needed */
 
     /* Lookup address */
-    ret = na_ofi_addr_ht_lookup(na_class,
-        na_ofi_prov_addr_format[priv->nop_domain->nod_prov_type],
-        na_ofi_addr->addr, na_ofi_addr->addrlen, &na_ofi_addr->fi_addr);
-    if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("na_ofi_addr_ht_lookup(%s) failed, ret: %d.", "", ret);
-        goto out;
-    }
+    ret = na_ofi_addr_ht_lookup(domain,
+        na_ofi_prov_addr_format[domain->prov_type], na_ofi_addr->addr,
+        na_ofi_addr->addrlen, &na_ofi_addr->fi_addr, &na_ofi_addr->ht_key);
+    NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
 
     *addr = na_ofi_addr;
 
 out:
-    if (ret != NA_SUCCESS && na_ofi_addr)
-        free(na_ofi_addr);
+    return ret;
+
+error:
+    free(na_ofi_addr->addr);
+    free(na_ofi_addr);
     return ret;
 }
 
@@ -3871,25 +3591,22 @@ na_ofi_msg_get_max_unexpected_size(const na_class_t NA_UNUSED *na_class)
 {
     na_size_t max_unexpected_size = NA_OFI_UNEXPECTED_SIZE;
 #ifdef NA_OFI_HAS_EXT_GNI_H
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
 
-    if (domain->nod_prov_type == NA_OFI_PROV_GNI) {
+    if (domain->prov_type == NA_OFI_PROV_GNI) {
         struct fi_gni_ops_domain *gni_domain_ops;
         int rc;
 
-        rc = fi_open_ops(&domain->nod_domain->fid, FI_GNI_DOMAIN_OPS_1,
+        rc = fi_open_ops(&domain->fi_domain->fid, FI_GNI_DOMAIN_OPS_1,
             0, (void **) &gni_domain_ops, NULL);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_open_ops failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            goto out;
-        }
+        NA_CHECK_ERROR(rc != 0, out, max_unexpected_size, 0,
+            "fi_open_ops() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
-        rc = gni_domain_ops->get_val(&domain->nod_domain->fid,
+        rc = gni_domain_ops->get_val(&domain->fi_domain->fid,
             GNI_MBOX_MSG_MAX_SIZE, &max_unexpected_size);
-        if (rc != 0) {
-            NA_LOG_ERROR("get_val failed, rc: %d(%s).", rc, fi_strerror(-rc));
-            goto out;
-        }
+        NA_CHECK_ERROR(rc != 0, out, max_unexpected_size, 0,
+            "gni_domain_ops->get_val() failed, rc: %d(%s)", rc,
+            fi_strerror(-rc));
     }
 
 out:
@@ -3930,16 +3647,12 @@ na_ofi_msg_buf_alloc(na_class_t *na_class, na_size_t size, void **plugin_data)
 
 #ifdef NA_OFI_HAS_MEM_POOL
     mem_ptr = na_ofi_mem_pool_alloc(na_class, size, &mr_hdl);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate buffer from pool");
-        goto out;
-    }
+    NA_CHECK_ERROR_NORET(mem_ptr == NULL, out,
+        "Could not allocate buffer from pool");
 #else
     mem_ptr = na_ofi_mem_alloc(na_class, size, &mr_hdl);
-    if (!mem_ptr) {
-        NA_LOG_ERROR("Could not allocate %d bytes", (int) size);
-        goto out;
-    }
+    NA_CHECK_ERROR_NORET(mem_ptr == NULL, out,
+        "Could not allocate %d bytes", (int) size);
 #endif
     *plugin_data = mr_hdl;
 
@@ -3974,7 +3687,7 @@ na_ofi_msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
     if (na_ofi_with_msg_hdr(na_class)) {
         struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
         struct na_ofi_sin_addr *na_ofi_sin_addr =
-            (struct na_ofi_sin_addr *) priv->nop_endpoint->noe_addr->addr;
+            (struct na_ofi_sin_addr *) priv->endpoint->src_addr->addr;
 
         assert(buf_size > sizeof(*na_ofi_sin_addr));
         memcpy(buf, na_ofi_sin_addr, sizeof(*na_ofi_sin_addr));
@@ -3985,13 +3698,13 @@ na_ofi_msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
-    void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
-    na_op_id_t *op_id)
+na_ofi_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
+    na_context_t *context, na_cb_t callback, void *arg, const void *buf,
+    na_size_t buf_size, void *plugin_data, na_addr_t dest_addr,
+    na_uint8_t dest_id, na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
+    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) dest_addr;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
     struct fid_mr *mr_hdl = plugin_data;
@@ -3999,134 +3712,112 @@ na_ofi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_SEND_UNEXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
     na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
+    na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_SEND_UNEXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    /* Specify target receive context */
+    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
 
     /* Post the FI unexpected send request */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
     do {
-        rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-                      tag, &na_ofi_op_id->noo_fi_ctx);
-        /* for EAGAIN, progress and do it again */
+        rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr, tag,
+            &na_ofi_op_id->fi_ctx);
+//        if (rc == -FI_EAGAIN)
+//            NA_GOTO_DONE(error, ret, NA_AGAIN);
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_tsend(unexpected) failed, rc: %d(%s)",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_tsend() unexpected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
+    return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
-    void *plugin_data, na_op_id_t *op_id)
+na_ofi_msg_recv_unexpected(na_class_t NA_UNUSED *na_class,
+    na_context_t *context, na_cb_t callback, void *arg, void *buf,
+    na_size_t buf_size, void *plugin_data, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_rx;
+    struct fid_ep *ep_hdl = ctx->fi_rx;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
     struct fid_mr *mr_hdl = plugin_data;
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_RECV_UNEXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    na_ofi_op_id->noo_addr = NULL; /* Make sure the addr is reset */
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_buf = buf;
-    na_ofi_op_id->noo_info.noo_recv_unexpected.noi_buf_size = buf_size;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_RECV_UNEXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    na_ofi_op_id->addr = NULL; /* Make sure the addr is reset */
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    na_ofi_op_id->info.recv_unexpected.buf = buf;
+    na_ofi_op_id->info.recv_unexpected.buf_size = buf_size;
 
     na_ofi_msg_unexpected_op_push(context, na_ofi_op_id);
 
     /* Post the FI unexpected recv request */
     do {
         rc = fi_trecv(ep_hdl, buf, buf_size, mr_hdl, FI_ADDR_UNSPEC,
-                      1 /* tag */, NA_OFI_UNEXPECTED_TAG_IGNORE,
-                      &na_ofi_op_id->noo_fi_ctx);
-        /* for EAGAIN, progress and do it again */
+            1 /* tag */, NA_OFI_UNEXPECTED_TAG_IGNORE, &na_ofi_op_id->fi_ctx);
+//        if (rc == -FI_EAGAIN)
+//            NA_GOTO_DONE(error, ret, NA_AGAIN);
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_trecv(unexpected) failed, rc: %d(%s)",
-                     rc, fi_strerror((int) -rc));
-        na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_trecv() unexpected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS && na_ofi_op_id != NULL)
-        na_ofi_op_id_decref(na_ofi_op_id);
+    return ret;
+
+error:
+    na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_send_expected(na_class_t *na_class, na_context_t *context,
+na_ofi_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
     void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
+    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) dest_addr;
     struct fid_mr *mr_hdl = plugin_data;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
@@ -4134,68 +3825,57 @@ na_ofi_msg_send_expected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_SEND_EXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
     na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
+    na_ofi_op_id->addr = na_ofi_addr;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_SEND_EXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    /* Specify target receive context */
+    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
 
     /* Post the FI expected send request */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
     do {
         rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-                NA_OFI_EXPECTED_TAG_FLAG | tag, &na_ofi_op_id->noo_fi_ctx);
-        /* for EAGAIN, progress and do it again */
+            NA_OFI_EXPECTED_TAG_FLAG | tag, &na_ofi_op_id->fi_ctx);
+//        if (rc == -FI_EAGAIN)
+//            NA_GOTO_DONE(error, ret, NA_AGAIN);
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_tsend(expected) failed, rc: %d(%s)",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_tsend() expected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
+    return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
+na_ofi_msg_recv_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
     na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
     void *plugin_data, na_addr_t source_addr, na_uint8_t source_id,
     na_tag_t tag, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_rx;
+    struct fid_ep *ep_hdl = ctx->fi_rx;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) source_addr;
     struct fid_mr *mr_hdl = plugin_data;
     struct na_ofi_op_id *na_ofi_op_id = NULL;
@@ -4203,60 +3883,48 @@ na_ofi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_RECV_EXPECTED;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
     na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
+    na_ofi_op_id->addr = na_ofi_addr;
+    na_ofi_op_id->info.recv_expected.buf = buf;
+    na_ofi_op_id->info.recv_expected.buf_size = buf_size;
+    na_ofi_op_id->info.recv_expected.tag = tag;
 
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *)na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_RECV_EXPECTED;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_buf = buf;
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_buf_size = buf_size;
-    na_ofi_op_id->noo_info.noo_recv_expected.noi_tag = tag;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    /* Specify target receive context */
+    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, source_id, NA_OFI_SEP_RX_CTX_BITS);
 
     /* Post the FI expected recv request */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, source_id, NA_OFI_SEP_RX_CTX_BITS);
     do {
         rc = fi_trecv(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-            NA_OFI_EXPECTED_TAG_FLAG | tag, 0 /* ignore */,
-            &na_ofi_op_id->noo_fi_ctx);
-        /* for EAGAIN, progress and do it again */
+            NA_OFI_EXPECTED_TAG_FLAG | tag, 0 /* ignore */, &na_ofi_op_id->fi_ctx);
+//        if (rc == -FI_EAGAIN)
+//            NA_GOTO_DONE(error, ret, NA_AGAIN);
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_trecv(expected) failed, rc: %d(%s)",
-            rc, fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_trecv() expected failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
+    return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
@@ -4271,11 +3939,8 @@ na_ofi_mem_handle_create(na_class_t NA_UNUSED *na_class, void *buf,
     /* Allocate memory handle */
     na_ofi_mem_handle = (struct na_ofi_mem_handle *) calloc(1,
         sizeof(struct na_ofi_mem_handle));
-    if (!na_ofi_mem_handle) {
-        NA_LOG_ERROR("Could not allocate NA OFI memory handle");
-        ret = NA_NOMEM_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_mem_handle == NULL, out, ret, NA_NOMEM,
+        "Could not allocate NA OFI memory handle");
 
     na_ofi_mem_handle->desc.base = (na_ptr_t)buf;
     na_ofi_mem_handle->desc.size = buf_size;
@@ -4302,7 +3967,7 @@ static na_return_t
 na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     struct na_ofi_mem_handle *na_ofi_mem_handle = mem_handle;
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     const void *base;
     na_uint64_t access;
     int rc = 0;
@@ -4310,11 +3975,11 @@ na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 
     /* Nothing to do for providers that do not need physically backed
      * virtual addresses (FI_MR_SCALABLE) */
-    if (!(domain->nod_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
+    if (!(domain->fi_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)) {
         /* Use global handle and key */
-        na_ofi_mem_handle->mr_hdl = domain->nod_mr;
-        na_ofi_mem_handle->desc.mr_key = domain->nod_mr_key;
-        return NA_SUCCESS;
+        na_ofi_mem_handle->fi_mr = domain->fi_mr;
+        na_ofi_mem_handle->desc.fi_mr_key = domain->fi_mr_key;
+        goto out;
     }
 
     /* Set access mode */
@@ -4329,26 +3994,23 @@ na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
             access = FI_READ | FI_WRITE | FI_REMOTE_READ | FI_REMOTE_WRITE;
             break;
         default:
-            NA_LOG_ERROR("Invalid memory access flag");
-            ret = NA_INVALID_PARAM;
-            goto out;
+            NA_GOTO_ERROR(out, ret, NA_INVALID_ARG,
+                "Invalid memory access flag");
+            break;
     }
 
     /* Register region */
-    base = (domain->nod_prov->domain_attr->mr_mode & FI_MR_VIRT_ADDR) ?
+    base = (domain->fi_prov->domain_attr->mr_mode & FI_MR_VIRT_ADDR) ?
         (const void *) na_ofi_mem_handle->desc.base : NULL;
-    rc = fi_mr_reg(domain->nod_domain, base,
+    rc = fi_mr_reg(domain->fi_domain, base,
         (size_t) na_ofi_mem_handle->desc.size, access, 0 /* offset */,
-        0 /* requested key */, 0 /* flags */, &na_ofi_mem_handle->mr_hdl,
+        0 /* requested key */, 0 /* flags */, &na_ofi_mem_handle->fi_mr,
         NULL /* context */);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_mr_reg failed, rc: %d(%s).", rc, fi_strerror(-rc));
-        ret = NA_PROTOCOL_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_mr_reg() failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
     /* Retrieve key */
-    na_ofi_mem_handle->desc.mr_key = fi_mr_key(na_ofi_mem_handle->mr_hdl);
+    na_ofi_mem_handle->desc.fi_mr_key = fi_mr_key(na_ofi_mem_handle->fi_mr);
 
 out:
     return ret;
@@ -4358,22 +4020,19 @@ out:
 static na_return_t
 na_ofi_mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->nop_domain;
+    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     struct na_ofi_mem_handle *na_ofi_mem_handle = mem_handle;
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    if (!(domain->nod_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)
-        || !na_ofi_mem_handle->mr_hdl)
+    if (!(domain->fi_prov->domain_attr->mr_mode & FI_MR_ALLOCATED)
+        || !na_ofi_mem_handle->fi_mr)
         goto out;
 
     /* close MR handle */
-    rc = fi_close(&na_ofi_mem_handle->mr_hdl->fid);
-    if (rc != 0) {
-        NA_LOG_ERROR("fi_close mr_hdl failed, rc: %d(%s).",
-                     rc, fi_strerror(-rc));
-        return NA_PROTOCOL_ERROR;
-    }
+    rc = fi_close(&na_ofi_mem_handle->fi_mr->fid);
+    NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+        "fi_close() mr_hdl failed, rc: %d(%s)", rc, fi_strerror(-rc));
 
 out:
     return ret;
@@ -4396,11 +4055,8 @@ na_ofi_mem_handle_serialize(na_class_t NA_UNUSED *na_class, void *buf,
             (struct na_ofi_mem_handle *) mem_handle;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size < sizeof(struct na_ofi_mem_desc)) {
-        NA_LOG_ERROR("Buffer size too small for serializing handle");
-        ret = NA_SIZE_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(buf_size < sizeof(struct na_ofi_mem_desc), out, ret,
+        NA_OVERFLOW, "Buffer size too small for serializing handle");
 
     /* Copy struct */
     memcpy(buf, &na_ofi_mem_handle->desc, sizeof(na_ofi_mem_handle->desc));
@@ -4417,23 +4073,17 @@ na_ofi_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
     struct na_ofi_mem_handle *na_ofi_mem_handle = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    if (buf_size < sizeof(struct na_ofi_mem_desc)) {
-        NA_LOG_ERROR("Buffer size too small for deserializing handle");
-        ret = NA_SIZE_ERROR;
-        goto out;
-    }
+    NA_CHECK_ERROR(buf_size < sizeof(struct na_ofi_mem_desc), out, ret,
+        NA_OVERFLOW, "Buffer size too small for deserializing handle");
 
     na_ofi_mem_handle = (struct na_ofi_mem_handle *)
             malloc(sizeof(struct na_ofi_mem_handle));
-    if (!na_ofi_mem_handle) {
-          NA_LOG_ERROR("Could not allocate NA OFI memory handle");
-          ret = NA_NOMEM_ERROR;
-          goto out;
-    }
+    NA_CHECK_ERROR(na_ofi_mem_handle == NULL, out, ret, NA_NOMEM,
+        "Could not allocate NA OFI memory handle");
 
     /* Copy struct */
     memcpy(&na_ofi_mem_handle->desc, buf, sizeof(na_ofi_mem_handle->desc));
-    na_ofi_mem_handle->mr_hdl = NULL;
+    na_ofi_mem_handle->fi_mr = NULL;
 
     *mem_handle = (na_mem_handle_t) na_ofi_mem_handle;
 
@@ -4443,20 +4093,20 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
-    void *arg, na_mem_handle_t local_mem_handle, na_offset_t local_offset,
-    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset,
-    na_size_t length, na_addr_t remote_addr, na_uint8_t remote_id,
-    na_op_id_t *op_id)
+na_ofi_put(na_class_t NA_UNUSED *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, na_mem_handle_t local_mem_handle,
+    na_offset_t local_offset, na_mem_handle_t remote_mem_handle,
+    na_offset_t remote_offset, na_size_t length, na_addr_t remote_addr,
+    na_uint8_t remote_id, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
+    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_mem_handle *ofi_local_mem_handle =
         (struct na_ofi_mem_handle *) local_mem_handle;
     struct na_ofi_mem_handle *ofi_remote_mem_handle =
         (struct na_ofi_mem_handle *) remote_mem_handle;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) remote_addr;
-    void *local_desc = fi_mr_desc(ofi_local_mem_handle->mr_hdl);
+    void *local_desc = fi_mr_desc(ofi_local_mem_handle->fi_mr);
     struct iovec local_iov = {
         .iov_base = (char *)ofi_local_mem_handle->desc.base + local_offset,
         .iov_len = length
@@ -4464,7 +4114,7 @@ na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     struct fi_rma_iov remote_iov = {
         .addr = (na_uint64_t)ofi_remote_mem_handle->desc.base + remote_offset,
         .len = length,
-        .key = ofi_remote_mem_handle->desc.mr_key
+        .key = ofi_remote_mem_handle->desc.fi_mr_key
     };
     struct fi_msg_rma msg_rma = {
         .msg_iov = &local_iov,
@@ -4480,78 +4130,65 @@ na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_PUT;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
     na_ofi_addr_addref(na_ofi_addr); /* for na_ofi_complete() */
-
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *) na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_PUT;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    na_ofi_op_id->addr = na_ofi_addr;
 
     /* Assign context */
-    msg_rma.context = &na_ofi_op_id->noo_fi_ctx;
+    msg_rma.context = &na_ofi_op_id->fi_ctx;
 
-    /* Post the OFI RMA write */
+    /* Post the OFI RMA write.
+     * For writes, FI_DELIVERY_COMPLETE guarantees that the operation
+     * has been processed by the destination */
     do {
-        /* For writes, FI_DELIVERY_COMPLETE guarantees that the operation
-         * has been processed by the destination */
         rc = fi_writemsg(ep_hdl, &msg_rma, FI_COMPLETION | FI_DELIVERY_COMPLETE);
-        /* for EAGAIN, progress and do it again */
+//        if (rc == -FI_EAGAIN)
+//            NA_GOTO_DONE(error, ret, NA_AGAIN);
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_writemsg() failed, rc: %d(%s)", rc,
-            fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_writemsg() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
+    return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
-    void *arg, na_mem_handle_t local_mem_handle, na_offset_t local_offset,
-    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset,
-    na_size_t length, na_addr_t remote_addr, na_uint8_t remote_id,
-    na_op_id_t *op_id)
+na_ofi_get(na_class_t NA_UNUSED *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, na_mem_handle_t local_mem_handle,
+    na_offset_t local_offset, na_mem_handle_t remote_mem_handle,
+    na_offset_t remote_offset, na_size_t length, na_addr_t remote_addr,
+    na_uint8_t remote_id, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
-    struct fid_ep *ep_hdl = ctx->noc_tx;
+    struct fid_ep *ep_hdl = ctx->fi_tx;
     struct na_ofi_mem_handle *ofi_local_mem_handle =
         (struct na_ofi_mem_handle *) local_mem_handle;
     struct na_ofi_mem_handle *ofi_remote_mem_handle =
         (struct na_ofi_mem_handle *) remote_mem_handle;
     struct na_ofi_addr *na_ofi_addr = (struct na_ofi_addr *) remote_addr;
-    void *local_desc = fi_mr_desc(ofi_local_mem_handle->mr_hdl);
+    void *local_desc = fi_mr_desc(ofi_local_mem_handle->fi_mr);
     struct iovec local_iov = {
         .iov_base = (void *)(ofi_local_mem_handle->desc.base + local_offset),
         .iov_len = length
@@ -4559,7 +4196,7 @@ na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     struct fi_rma_iov remote_iov = {
         .addr = (uint64_t)(ofi_remote_mem_handle->desc.base + remote_offset),
         .len = length,
-        .key = ofi_remote_mem_handle->desc.mr_key
+        .key = ofi_remote_mem_handle->desc.fi_mr_key
     };
     struct fi_msg_rma msg_rma = {
         .msg_iov = &local_iov,
@@ -4575,57 +4212,44 @@ na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_return_t ret = NA_SUCCESS;
     ssize_t rc;
 
+    /* Check op_id */
+    NA_CHECK_ERROR(
+        op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
+        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+
+    na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
+    na_ofi_op_id_addref(na_ofi_op_id);
+    na_ofi_op_id->context = context;
+    na_ofi_op_id->completion_data.callback_info.type = NA_CB_GET;
+    na_ofi_op_id->completion_data.callback = callback;
+    na_ofi_op_id->completion_data.callback_info.arg = arg;
+    hg_atomic_set32(&na_ofi_op_id->status, 0);
     na_ofi_addr_addref(na_ofi_addr); /* for na_ofi_complete() */
-
-    /* Allocate op_id if not provided */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id != NA_OP_ID_NULL) {
-        na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
-        na_ofi_op_id_addref(na_ofi_op_id);
-    } else {
-        na_ofi_op_id = (struct na_ofi_op_id *) na_ofi_op_create(na_class);
-        if (!na_ofi_op_id) {
-            NA_LOG_ERROR("Could not create NA OFI operation ID");
-            ret = NA_NOMEM_ERROR;
-            goto out;
-        }
-    }
-
-    na_ofi_op_id->noo_context = context;
-    na_ofi_op_id->noo_completion_data.callback_info.type = NA_CB_GET;
-    na_ofi_op_id->noo_completion_data.callback = callback;
-    na_ofi_op_id->noo_completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->noo_completed, NA_FALSE);
-    hg_atomic_set32(&na_ofi_op_id->noo_canceled, NA_FALSE);
-    na_ofi_op_id->noo_addr = na_ofi_addr;
-
-    /* Assign op_id */
-    if (op_id && op_id != NA_OP_ID_IGNORE && *op_id == NA_OP_ID_NULL)
-        *op_id = (na_op_id_t) na_ofi_op_id;
+    na_ofi_op_id->addr = na_ofi_addr;
 
     /* Assign context */
-    msg_rma.context = &na_ofi_op_id->noo_fi_ctx;
+    msg_rma.context = &na_ofi_op_id->fi_ctx;
 
     /* Post the OFI RMA read */
     do {
         rc = fi_readmsg(ep_hdl, &msg_rma, FI_COMPLETION);
-        /* for EAGAIN, progress and do it again */
+//        if (rc == -FI_EAGAIN)
+//            NA_GOTO_DONE(error, ret, NA_AGAIN);
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
             break;
     } while (1);
-    if (rc) {
-        NA_LOG_ERROR("fi_readmsg() failed, rc: %d(%s)", rc,
-            fi_strerror((int) -rc));
-        ret = NA_PROTOCOL_ERROR;
-    }
+    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
+        "fi_readmsg() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
 out:
-    if (ret != NA_SUCCESS) {
-        na_ofi_addr_decref(na_ofi_addr);
-        if (na_ofi_op_id != NULL)
-            na_ofi_op_id_decref(na_ofi_op_id);
-    }
+    return ret;
+
+error:
+    na_ofi_addr_decref(na_ofi_addr);
+    na_ofi_op_id_decref(na_ofi_op_id);
+
     return ret;
 }
 
@@ -4638,17 +4262,14 @@ na_ofi_poll_get_fd(na_class_t *na_class, na_context_t *context)
     int fd = -1, rc;
 
     if (priv->no_wait ||
-        (na_ofi_prov_flags[priv->nop_domain->nod_prov_type] & NA_OFI_WAIT_SET))
+        (na_ofi_prov_flags[priv->domain->prov_type] & NA_OFI_WAIT_SET))
         goto out;
 
-    rc = fi_control(&ctx->noc_cq->fid, FI_GETWAIT, &fd);
-    if (rc < 0 && rc != -FI_ENOSYS)
-        NA_LOG_ERROR("fi_control() failed, rc: %d(%s).",
-            rc, fi_strerror((int) -rc));
-    if (fd < 0) {
-        NA_LOG_ERROR("Returned fd is not valid (%d), will not block", fd);
-        goto out;
-    }
+    rc = fi_control(&ctx->fi_cq->fid, FI_GETWAIT, &fd);
+    NA_CHECK_ERROR_NORET(rc != 0 && rc != -FI_ENOSYS, out,
+        "fi_control() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+    NA_CHECK_ERROR_NORET(fd < 0, out,
+        "Returned fd is not valid (%d), will not block", fd);
 
 out:
     return fd;
@@ -4667,20 +4288,20 @@ na_ofi_poll_try_wait(na_class_t *na_class, na_context_t *context)
         return NA_FALSE;
 
     /* Assume it is safe to block if provider is using wait set */
-    if ((na_ofi_prov_flags[priv->nop_domain->nod_prov_type] & NA_OFI_WAIT_SET)
+    if ((na_ofi_prov_flags[priv->domain->prov_type] & NA_OFI_WAIT_SET)
         /* PSM2 shows very slow performance with fi_trywait() */
-        || priv->nop_domain->nod_prov_type == NA_OFI_PROV_PSM2)
+        || priv->domain->prov_type == NA_OFI_PROV_PSM2)
            return NA_TRUE;
 
-    fids[0] = &ctx->noc_cq->fid;
+    fids[0] = &ctx->fi_cq->fid;
     /* Check whether it is safe to block on that fd */
-    rc = fi_trywait(priv->nop_domain->nod_fabric, fids, 1);
+    rc = fi_trywait(priv->domain->fi_fabric, fids, 1);
     if (rc == FI_SUCCESS)
         return NA_TRUE;
     else if (rc == -FI_EAGAIN)
         return NA_FALSE;
     else {
-        NA_LOG_ERROR("fi_trywait() failed, rc: %d(%s).",
+        NA_LOG_ERROR("fi_trywait() failed, rc: %d(%s)",
             rc, fi_strerror((int) -rc));
         return NA_FALSE;
     }
@@ -4698,60 +4319,58 @@ na_ofi_progress(na_class_t *na_class, na_context_t *context,
     do {
         struct fi_cq_tagged_entry cq_events[NA_OFI_CQ_EVENT_NUM];
         fi_addr_t src_addrs[NA_OFI_CQ_EVENT_NUM] = {FI_ADDR_UNSPEC};
-        void *src_err_addr = NULL;
-        size_t src_err_addrlen = 0;
+        char src_err_addr[NA_OFI_CQ_MAX_ERR_DATA_SIZE] = {0};
+        void *src_err_addr_ptr = src_err_addr;
+        size_t src_err_addrlen = NA_OFI_CQ_MAX_ERR_DATA_SIZE;
         size_t i, actual_count = 0;
         hg_time_t t1, t2;
 
         if (timeout) {
-            struct fid_wait *wait_hdl = NA_OFI_CONTEXT(context)->noc_wait;
+            struct fid_wait *wait_hdl = NA_OFI_CONTEXT(context)->fi_wait;
 
             hg_time_get_current(&t1);
 
             if (wait_hdl) {
                 /* Wait in wait set if provider does not support wait on FDs */
-                int rc = fi_wait(wait_hdl, (int) (remaining * 1000.0));
+                int rc = 0, retry_cnt = 0;
+                do {
+                    rc = fi_wait(wait_hdl, (int) (remaining * 1000.0));
+                } while (rc == -FI_EINTR && retry_cnt++ < NA_OFI_MAX_EINTR_RETRY);
+
                 if (rc == -FI_ETIMEDOUT)
                     break;
-                else if (rc != FI_SUCCESS) {
-                    NA_LOG_ERROR("fi_wait() failed, rc: %d(%s).",
-                        rc, fi_strerror((int) -rc));
-                    ret = NA_PROTOCOL_ERROR;
-                    goto out;
-                }
+
+                NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
+                    "fi_wait() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
             }
         }
 
         /* Read from CQ */
-        ret = na_ofi_cq_read(na_class, context, NA_OFI_CQ_EVENT_NUM, cq_events,
-            src_addrs, &src_err_addr, &src_err_addrlen, &actual_count);
-        if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("Could not read events from context CQ");
-            goto out;
-        } else {
-            if (timeout) {
-                hg_time_get_current(&t2);
-                remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
-            }
-            if (actual_count == 0) {
-                ret = NA_TIMEOUT; /* Return NA_TIMEOUT if no events */
-                if (remaining <= 0)
-                    break;
-                continue;
-            }
+        ret = na_ofi_cq_read(context, NA_OFI_CQ_EVENT_NUM, cq_events, src_addrs,
+            &src_err_addr_ptr, &src_err_addrlen, &actual_count);
+        NA_CHECK_NA_ERROR(out, ret,
+            "Could not read events from context CQ");
+
+        if (timeout) {
+            hg_time_get_current(&t2);
+            remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
         }
 
+        if (actual_count == 0) {
+            ret = NA_TIMEOUT; /* Return NA_TIMEOUT if no events */
+            if (remaining <= 0)
+                break;
+            continue;
+        }
         /* Got at least one completion event */
         assert(actual_count > 0);
 
         for (i = 0; i < actual_count; i++) {
            ret = na_ofi_cq_process_event(na_class, context, &cq_events[i],
-               src_addrs[i], src_err_addr, src_err_addrlen);
-           if (ret != NA_SUCCESS) {
-               NA_LOG_ERROR("Could not process event");
-               goto out;
-           }
+               src_addrs[i], src_err_addr_ptr, src_err_addrlen);
+           NA_CHECK_NA_ERROR(out, ret, "Could not process event");
         }
+
     } while (remaining > 0 && ret != NA_SUCCESS);
 
 out:
@@ -4764,103 +4383,54 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context,
     na_op_id_t op_id)
 {
     struct na_ofi_op_id *na_ofi_op_id = (struct na_ofi_op_id *) op_id;
-    struct na_ofi_op_id *tmp = NULL, *first = NULL;
-    ssize_t rc;
+    struct fid_ep *fi_ep = NULL;
     na_return_t ret = NA_SUCCESS;
+    ssize_t rc;
 
-    if (!na_ofi_op_id_valid(na_ofi_op_id)) {
-        NA_LOG_ERROR("bad na_ofi_op_id, ignore the cancel request.");
+    /* Exit if op has already completed */
+    if (!hg_atomic_cas32(&na_ofi_op_id->status, 0, NA_OFI_OP_CANCELED))
         goto out;
-    }
-    if (hg_atomic_get32(&na_ofi_op_id->noo_completed))
-        goto out;
-    if (!hg_atomic_cas32(&na_ofi_op_id->noo_canceled, NA_FALSE, NA_TRUE)) {
-        NA_LOG_WARNING("ignore canceling for a canceled op.");
-        goto out;
-    }
-
-    hg_atomic_incr32(&na_ofi_op_id->noo_canceled);
-
-    switch (na_ofi_op_id->noo_completion_data.callback_info.type) {
-    case NA_CB_LOOKUP:
-        break;
-    case NA_CB_RECV_UNEXPECTED:
-        rc = fi_cancel(&NA_OFI_CONTEXT(context)->noc_rx->fid,
-            &na_ofi_op_id->noo_fi_ctx);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_cancel unexpected recv failed, rc: %d(%s).",
-                         rc, fi_strerror((int) -rc));
-            ret = NA_CANCEL_ERROR;
-            goto out;
-        }
-
-        tmp = first = na_ofi_msg_unexpected_op_pop(context);
-        do {
-            if (!tmp) {
-                NA_LOG_ERROR("got NULL head of unexpected op queue.");
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-            if (tmp == na_ofi_op_id) {
-                break;
-            }
-            na_ofi_msg_unexpected_op_push(context, tmp);
 
-            tmp = na_ofi_msg_unexpected_op_pop(context);
-            if (tmp == first) {
-                NA_LOG_ERROR("tmp == first");
-                ret = NA_PROTOCOL_ERROR;
-                goto out;
-            }
-        } while (tmp != na_ofi_op_id);
-
-        ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
-        break;
-    case NA_CB_RECV_EXPECTED:
-        rc = fi_cancel(&NA_OFI_CONTEXT(context)->noc_rx->fid,
-            &na_ofi_op_id->noo_fi_ctx);
-        if (rc != 0) {
-            NA_LOG_ERROR("fi_cancel expected recv failed, rc: %d(%s).",
-                         rc, fi_strerror((int) -rc));
-            ret = NA_CANCEL_ERROR;
-            goto out;
-        }
+    NA_LOG_DEBUG("Canceling operation ID %p", na_ofi_op_id);
 
-        ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
-        break;
-    case NA_CB_SEND_UNEXPECTED:
-    case NA_CB_SEND_EXPECTED:
-    case NA_CB_PUT:
-    case NA_CB_GET:
-        /* May or may not be canceled in that case */
-        rc = fi_cancel(&NA_OFI_CONTEXT(context)->noc_tx->fid,
-            &na_ofi_op_id->noo_fi_ctx);
-        if (rc != 0) {
-            NA_LOG_WARNING("fi_cancel failed, rc: %d(%s).",
-                         rc, fi_strerror((int) -rc));
-        }
-        /* fi_cancel() is not guaranteed to return proper return code for now */
-//        if (rc == 0) {
-            /* Complete only if successfully canceled */
-        ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
-//        } else
-//            ret = NA_CANCEL_ERROR;
-        break;
-    default:
-        break;
+    switch (na_ofi_op_id->completion_data.callback_info.type) {
+        case NA_CB_RECV_UNEXPECTED:
+        case NA_CB_RECV_EXPECTED:
+            fi_ep = NA_OFI_CONTEXT(context)->fi_rx;
+            break;
+        case NA_CB_SEND_UNEXPECTED:
+        case NA_CB_SEND_EXPECTED:
+        case NA_CB_PUT:
+        case NA_CB_GET:
+            fi_ep = NA_OFI_CONTEXT(context)->fi_tx;
+            break;
+        case NA_CB_LOOKUP:
+        default:
+            NA_GOTO_ERROR(out, ret, NA_INVALID_ARG,
+                "Operation type %d not supported",
+                na_ofi_op_id->completion_data.callback_info.type);
+            break;
     }
 
+    /* fi_cancel() is an asynchronous operation, either the operation
+     * will be canceled and an FI_ECANCELED event will be generated
+     * or it will show up in the regular completion queue.
+     */
+    rc = fi_cancel(&fi_ep->fid, &na_ofi_op_id->fi_ctx);
+    NA_LOG_DEBUG("fi_cancel() rc: %d(%s)", (int) rc,
+        fi_strerror((int) -rc));
+//    NA_CHECK_ERROR(rc == -FI_ENOENT, out, ret, NA_OPNOTSUPPORTED,
+//        "fi_cancel() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+
     /* Work around segfault on fi_cq_signal() in some providers */
-    if (!(na_ofi_prov_flags[NA_OFI_CLASS(na_class)->nop_domain->nod_prov_type]
+    if (!(na_ofi_prov_flags[NA_OFI_CLASS(na_class)->domain->prov_type]
         & NA_OFI_SKIP_SIGNAL)) {
         /* Signal CQ to wake up and no longer wait on FD */
-        rc = fi_cq_signal(NA_OFI_CONTEXT(context)->noc_cq);
-        if (rc != 0 && rc != -ENOSYS) {
-            NA_LOG_ERROR("fi_cq_signal (op type %d) failed, rc: %d(%s).",
-                na_ofi_op_id->noo_completion_data.callback_info.type, rc,
-                fi_strerror((int) -rc));
-            ret = NA_PROTOCOL_ERROR;
-        }
+        int rc_signal = fi_cq_signal(NA_OFI_CONTEXT(context)->fi_cq);
+        NA_CHECK_ERROR(rc_signal != 0 && rc_signal != -ENOSYS, out, ret,
+            NA_PROTOCOL_ERROR, "fi_cq_signal (op type %d) failed, rc: %d(%s)",
+            na_ofi_op_id->completion_data.callback_info.type, rc_signal,
+            fi_strerror((int) -rc_signal));
     }
 
 out:
diff --git a/src/na/na_plugin.h b/src/na/na_plugin.h
index 2db9207..05a6076 100644
--- a/src/na/na_plugin.h
+++ b/src/na/na_plugin.h
@@ -12,6 +12,7 @@
 #define NA_PLUGIN_H
 
 #include "na.h"
+#include "na_error.h"
 
 #include "mercury_atomic_queue.h"
 #include "mercury_queue.h"
@@ -27,8 +28,8 @@ typedef void (*na_plugin_cb_t)(void *arg);
 
 /* Completion data stored in completion queue */
 struct na_cb_completion_data {
-    na_cb_t callback;                   /* Pointer to function */
     struct na_cb_info callback_info;    /* Callback info struct */
+    na_cb_t callback;                   /* Pointer to function */
     na_plugin_cb_t plugin_callback;     /* Callback which will be called after
                                          * the user callback returns. */
     void *plugin_callback_args;         /* Argument to plugin_callback */
@@ -73,8 +74,7 @@ struct na_cb_completion_data {
 /**
  * Plugin ops definition
  */
-#define NA_PLUGIN_OPS(plugin_name) \
-    const struct na_class_ops na_ ##plugin_name ##_class_ops_g
+#define NA_PLUGIN_OPS(plugin_name) na_ ##plugin_name ##_class_ops_g
 
 /*********************/
 /* Public Prototypes */
@@ -94,7 +94,7 @@ extern "C" {
  *
  * \return NA_SUCCESS or corresponding NA error code (failure is not an option)
  */
-NA_EXPORT na_return_t
+NA_PRIVATE na_return_t
 na_cb_completion_add(
         na_context_t                 *context,
         struct na_cb_completion_data *na_cb_completion_data
@@ -103,20 +103,21 @@ na_cb_completion_add(
 /*********************/
 /* Public Variables */
 /*********************/
+
 #ifdef NA_HAS_SM
-NA_EXPORT NA_PLUGIN_OPS(sm);
+extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(sm);
 #endif
 #ifdef NA_HAS_BMI
-NA_EXPORT NA_PLUGIN_OPS(bmi);
+extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(bmi);
 #endif
 #ifdef NA_HAS_MPI
-NA_EXPORT NA_PLUGIN_OPS(mpi);
+extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(mpi);
 #endif
 #ifdef NA_HAS_CCI
-NA_EXPORT NA_PLUGIN_OPS(cci);
+extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(cci);
 #endif
 #ifdef NA_HAS_OFI
-NA_EXPORT NA_PLUGIN_OPS(ofi);
+extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(ofi);
 #endif
 
 #ifdef __cplusplus
diff --git a/src/na/na_sm.c b/src/na/na_sm.c
index 58e2a19..38463ea 100644
--- a/src/na/na_sm.c
+++ b/src/na/na_sm.c
@@ -26,6 +26,7 @@
 #ifdef _WIN32
 #include <process.h>
 #else
+#include <pwd.h>
 #include <ftw.h>
 #include <unistd.h>
 #include <sys/types.h>
@@ -46,6 +47,12 @@
 /* Local Macros */
 /****************/
 
+/* Error compat */
+#define NA_INVALID_PARAM    NA_INVALID_ARG
+#define NA_SIZE_ERROR       NA_MSGSIZE
+#define NA_NOMEM_ERROR      NA_NOMEM
+#define NA_PERMISSION_ERROR NA_PERMISSION
+
 /* Plugin constants */
 #define NA_SM_MAX_FILENAME      64
 #define NA_SM_NUM_BUFS          64
@@ -77,35 +84,34 @@
 #define NA_SM_MSGHDR_INITIALIZER {NULL, 0, NULL, 0, NULL, 0, 0}
 
 /* Default filenames/paths */
-#define NA_SM_SOCK_PATH NA_SM_TMP_DIRECTORY "/" NA_SM_SHM_PREFIX
 #define NA_SM_SHM_PATH "/dev/shm"
 
-#define NA_SM_GEN_SHM_NAME(filename, na_sm_addr)        \
-    do {                                                \
-        sprintf(filename, "%s-%d-%u", NA_SM_SHM_PREFIX, \
-            na_sm_addr->pid, na_sm_addr->id);           \
+#define NA_SM_GEN_SHM_NAME(filename, username, na_sm_addr)      \
+    do {                                                        \
+        sprintf(filename, "%s_%s-%d-%u", NA_SM_SHM_PREFIX,      \
+            username, na_sm_addr->pid, na_sm_addr->id);         \
     } while (0)
 
-#define NA_SM_GEN_SOCK_PATH(pathname, na_sm_addr)               \
-    do {                                                        \
-        sprintf(pathname, "%s/%s/%d/%u", NA_SM_TMP_DIRECTORY,   \
-            NA_SM_SHM_PREFIX, na_sm_addr->pid, na_sm_addr->id); \
+#define NA_SM_GEN_SOCK_PATH(pathname, username, na_sm_addr)                 \
+    do {                                                                    \
+        sprintf(pathname, "%s/%s_%s/%d/%u", NA_SM_TMP_DIRECTORY,            \
+            NA_SM_SHM_PREFIX, username, na_sm_addr->pid, na_sm_addr->id);   \
     } while (0)
 
 #define NA_SM_SEND_NAME "s" /* used for pair_name */
 #define NA_SM_RECV_NAME "r" /* used for pair_name */
-#define NA_SM_GEN_RING_NAME(filename, pair_name, na_sm_addr)            \
-    do {                                                                \
-        sprintf(filename, "%s-%d-%u-%u-" pair_name, NA_SM_SHM_PREFIX,   \
-            na_sm_addr->pid, na_sm_addr->id, na_sm_addr->conn_id);      \
+#define NA_SM_GEN_RING_NAME(filename, pair_name, username, na_sm_addr)      \
+    do {                                                                    \
+        sprintf(filename, "%s_%s-%d-%u-%u-" pair_name, NA_SM_SHM_PREFIX,    \
+            username, na_sm_addr->pid, na_sm_addr->id, na_sm_addr->conn_id);\
     } while (0)
 
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
-#define NA_SM_GEN_FIFO_NAME(filename, pair_name, na_sm_addr)            \
+#define NA_SM_GEN_FIFO_NAME(filename, pair_name, username, na_sm_addr)  \
     do {                                                                \
-        sprintf(filename, "%s/%s/%d/%u/fifo-%u-" pair_name,             \
-            NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX, na_sm_addr->pid,     \
-            na_sm_addr->id, na_sm_addr->conn_id);                       \
+        sprintf(filename, "%s/%s_%s/%d/%u/fifo-%u-" pair_name,          \
+            NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX, username,            \
+            na_sm_addr->pid, na_sm_addr->id, na_sm_addr->conn_id);      \
     } while (0)
 #endif
 
@@ -252,6 +258,7 @@ struct na_sm_op_id {
 
 /* Private data */
 struct na_sm_class {
+    char *username;
     struct na_sm_addr *self_addr;
     hg_poll_set_t *poll_set;
     HG_QUEUE_HEAD(na_sm_addr) accepted_addr_queue;
@@ -275,6 +282,13 @@ struct na_sm_class {
 /* Local Prototypes */
 /********************/
 
+/**
+ * utility function: wrapper around getlogin().
+ */
+static char *
+getlogin_safe(void);
+
+
 /**
  * Open shared buf.
  */
@@ -881,7 +895,7 @@ na_sm_cancel(
 /* Local Variables */
 /*******************/
 
-NA_PLUGIN_OPS(sm) = {
+const struct na_class_ops NA_PLUGIN_OPS(sm) = {
     "na",                                   /* name */
     na_sm_check_protocol,                   /* check_protocol */
     na_sm_initialize,                       /* initialize */
@@ -892,7 +906,9 @@ NA_PLUGIN_OPS(sm) = {
     na_sm_op_create,                        /* op_create */
     na_sm_op_destroy,                       /* op_destroy */
     na_sm_addr_lookup,                      /* addr_lookup */
+    NULL,                                   /* addr_lookup2 */
     na_sm_addr_free,                        /* addr_free */
+    NULL,                                   /* addr_set_remove */
     na_sm_addr_self,                        /* addr_self */
     na_sm_addr_dup,                         /* addr_dup */
     na_sm_addr_is_self,                     /* addr_is_self */
@@ -964,6 +980,21 @@ na_sm_print_addr(struct na_sm_addr *na_sm_addr)
 }
 */
 
+/* Wrapper to get login information and return a dummy string if the glibc call
+ * fails for some reason.  Allows graceful handling of directory name
+ * generation.
+ */
+static char *
+getlogin_safe(void)
+{
+    struct passwd *passwd;
+
+    /* statically allocated */
+    passwd = getpwuid(getuid());
+
+    return passwd ? passwd->pw_name : "unknown";
+}
+
 /*---------------------------------------------------------------------------*/
 static void *
 na_sm_open_shared_buf(const char *name, size_t buf_size, na_bool_t create)
@@ -1141,12 +1172,16 @@ static int
 na_sm_cleanup_shm(const char *fpath, const struct stat NA_UNUSED *sb,
     int NA_UNUSED typeflag, struct FTW NA_UNUSED *ftwbuf)
 {
-    const char *prefix = NA_SM_SHM_PATH "/" NA_SM_SHM_PREFIX;
+    const char *prefix = NA_SM_SHM_PATH "/" NA_SM_SHM_PREFIX "_";
     int ret = 0;
 
     if (strncmp(fpath, prefix, strlen(prefix)) == 0) {
         const char *file = fpath + strlen(NA_SM_SHM_PATH "/");
-        ret = hg_mem_shm_unmap(file, NULL, 0);
+        char *username = getlogin_safe();
+
+        if (strncmp(file + strlen(NA_SM_SHM_PREFIX "_"),
+            username, strlen(username)) == 0)
+            ret = hg_mem_shm_unmap(file, NULL, 0);
     }
 
     return ret;
@@ -1354,7 +1389,7 @@ na_sm_setup_shm(na_class_t *na_class, struct na_sm_addr *na_sm_addr)
     na_return_t ret = NA_SUCCESS;
 
     /* Create SHM buffer */
-    NA_SM_GEN_SHM_NAME(filename, na_sm_addr);
+    NA_SM_GEN_SHM_NAME(filename, NA_SM_CLASS(na_class)->username, na_sm_addr);
     na_sm_copy_buf = (struct na_sm_copy_buf *) na_sm_open_shared_buf(
         filename, sizeof(struct na_sm_copy_buf), NA_TRUE);
     if (!na_sm_copy_buf) {
@@ -1367,7 +1402,7 @@ na_sm_setup_shm(na_class_t *na_class, struct na_sm_addr *na_sm_addr)
     na_sm_addr->na_sm_copy_buf = na_sm_copy_buf;
 
     /* Create SHM sock */
-    NA_SM_GEN_SOCK_PATH(pathname, na_sm_addr);
+    NA_SM_GEN_SOCK_PATH(pathname, NA_SM_CLASS(na_class)->username, na_sm_addr);
     ret = na_sm_create_sock(pathname, NA_TRUE, &listen_sock);
     if (ret != NA_SUCCESS) {
         NA_LOG_ERROR("Could not create sock");
@@ -1930,7 +1965,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     /* Set up ring buffer pair (send/recv) for connection IDs */
     na_sm_addr->conn_id = NA_SM_CLASS(na_class)->self_addr->conn_id;
     NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(filename,
         NA_SM_RING_BUF_SIZE, NA_TRUE);
     if (!na_sm_ring_buf) {
@@ -1943,7 +1978,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
     na_sm_addr->na_sm_send_ring_buf = na_sm_ring_buf;
 
     NA_SM_GEN_RING_NAME(filename, NA_SM_RECV_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(filename,
         NA_SM_RING_BUF_SIZE, NA_TRUE);
     if (!na_sm_ring_buf) {
@@ -1970,7 +2005,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
      * ancillary data
      */
     NA_SM_GEN_FIFO_NAME(filename, NA_SM_RECV_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     local_notify = na_sm_event_create(filename);
     if (local_notify == -1) {
         NA_LOG_ERROR("na_sm_event_create() failed");
@@ -1995,7 +2030,7 @@ na_sm_progress_accept(na_class_t *na_class, struct na_sm_addr *poll_addr,
      * ancillary data
      */
     NA_SM_GEN_FIFO_NAME(filename, NA_SM_SEND_NAME,
-        NA_SM_CLASS(na_class)->self_addr);
+        NA_SM_CLASS(na_class)->username, NA_SM_CLASS(na_class)->self_addr);
     remote_notify = na_sm_event_create(filename);
     if (remote_notify == -1) {
         NA_LOG_ERROR("na_sm_event_create() failed");
@@ -2114,7 +2149,8 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
 
             /* Open remote ring buf pair (send and recv names correspond to
              * remote ring buffer pair) */
-            NA_SM_GEN_RING_NAME(filename, NA_SM_RECV_NAME, poll_addr);
+            NA_SM_GEN_RING_NAME(filename, NA_SM_RECV_NAME,
+                NA_SM_CLASS(na_class)->username, poll_addr);
             na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(
                 filename, NA_SM_RING_BUF_SIZE, NA_FALSE);
             if (!na_sm_ring_buf) {
@@ -2124,7 +2160,8 @@ na_sm_progress_sock(na_class_t *na_class, struct na_sm_addr *poll_addr,
             }
             poll_addr->na_sm_send_ring_buf = na_sm_ring_buf;
 
-            NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME, poll_addr);
+            NA_SM_GEN_RING_NAME(filename, NA_SM_SEND_NAME,
+                NA_SM_CLASS(na_class)->username, poll_addr);
             na_sm_ring_buf = (struct na_sm_ring_buf *) na_sm_open_shared_buf(
                 filename, NA_SM_RING_BUF_SIZE, NA_FALSE);
             if (!na_sm_ring_buf) {
@@ -2454,6 +2491,7 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     static hg_atomic_int32_t id = HG_ATOMIC_VAR_INIT(0);
     struct na_sm_addr *na_sm_addr = NULL;
     pid_t pid;
+    char *username = NULL;
     hg_poll_set_t *poll_set;
     na_bool_t no_wait = NA_FALSE;
     int local_notify;
@@ -2471,6 +2509,14 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     /* Get PID */
     pid = getpid();
 
+    /* Get username */
+    username = getlogin_safe();
+    if (!username) {
+        NA_LOG_ERROR("Could not query login name");
+        ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
+
     /* Initialize errno */
     errno = 0;
 
@@ -2484,6 +2530,14 @@ na_sm_initialize(na_class_t *na_class, const struct na_info NA_UNUSED *na_info,
     memset(na_class->plugin_class, 0, sizeof(struct na_sm_class));
     NA_SM_CLASS(na_class)->no_wait = no_wait;
 
+    /* Copy username */
+    NA_SM_CLASS(na_class)->username = strdup(username);
+    if (!NA_SM_CLASS(na_class)->username) {
+        NA_LOG_ERROR("Could not dup username");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
+
     /* Create poll set to wait for events */
     poll_set = hg_poll_create();
     if (!poll_set) {
@@ -2623,6 +2677,7 @@ na_sm_finalize(na_class_t *na_class)
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->expected_op_queue_lock);
     hg_thread_spin_destroy(&NA_SM_CLASS(na_class)->copy_buf_lock);
 
+    free(NA_SM_CLASS(na_class)->username);
     free(na_class->plugin_class);
 
 done:
@@ -2633,11 +2688,16 @@ done:
 static void
 na_sm_cleanup(void)
 {
+    char pathname[NA_SM_MAX_FILENAME] = {'\0'};
+    char *username = getlogin_safe();
     int ret;
 
+    sprintf(pathname, "%s/%s_%s", NA_SM_TMP_DIRECTORY,
+        NA_SM_SHM_PREFIX, username);
+
     /* We need to remove all files first before being able to remove the
      * directories */
-    ret = nftw(NA_SM_SOCK_PATH, na_sm_cleanup_file, NA_SM_CLEANUP_NFDS,
+    ret = nftw(pathname, na_sm_cleanup_file, NA_SM_CLEANUP_NFDS,
         FTW_PHYS | FTW_DEPTH);
     if (ret != 0 && errno != ENOENT) {
         NA_LOG_WARNING("nftw() failed (%s)", strerror(errno));
@@ -2757,7 +2817,7 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
     sscanf(short_name, "%d/%u", &na_sm_addr->pid, &na_sm_addr->id);
 
     /* Open shared copy buf */
-    NA_SM_GEN_SHM_NAME(filename, na_sm_addr);
+    NA_SM_GEN_SHM_NAME(filename, NA_SM_CLASS(na_class)->username, na_sm_addr);
     na_sm_copy_buf = (struct na_sm_copy_buf *) na_sm_open_shared_buf(
         filename, sizeof(struct na_sm_copy_buf), NA_FALSE);
     if (!na_sm_copy_buf) {
@@ -2768,7 +2828,7 @@ na_sm_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_sm_addr->na_sm_copy_buf = na_sm_copy_buf;
 
     /* Open SHM sock */
-    NA_SM_GEN_SOCK_PATH(pathname, na_sm_addr);
+    NA_SM_GEN_SOCK_PATH(pathname, NA_SM_CLASS(na_class)->username, na_sm_addr);
     ret = na_sm_create_sock(pathname, NA_FALSE, &conn_sock);
     if (ret != NA_SUCCESS) {
         NA_LOG_ERROR("Could not create sock");
@@ -2881,25 +2941,29 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
 
         if (na_sm_addr->accepted) { /* Created by accept */
             /* Get file names from ring bufs / events to delete files */
-            sprintf(na_sm_send_ring_buf_name, "%s-%d-%d-%d-%s",
-                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->self_addr->pid,
+            sprintf(na_sm_send_ring_buf_name, "%s_%s-%d-%d-%d-" NA_SM_SEND_NAME,
+                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->username,
+                NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
-                na_sm_addr->conn_id, NA_SM_SEND_NAME);
-            sprintf(na_sm_recv_ring_buf_name, "%s-%d-%d-%d-%s",
-                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->self_addr->pid,
+                na_sm_addr->conn_id);
+            sprintf(na_sm_recv_ring_buf_name, "%s_%s-%d-%d-%d-" NA_SM_RECV_NAME,
+                NA_SM_SHM_PREFIX, NA_SM_CLASS(na_class)->username,
+                NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
-                na_sm_addr->conn_id, NA_SM_RECV_NAME);
+                na_sm_addr->conn_id);
             send_ring_buf_name = na_sm_send_ring_buf_name;
             recv_ring_buf_name = na_sm_recv_ring_buf_name;
 
 #ifndef HG_UTIL_HAS_SYSEVENTFD_H
-            sprintf(na_sm_local_event_name, "%s/%s/%d/%u/fifo-%u-%s",
+            sprintf(na_sm_local_event_name, "%s/%s_%s/%d/%u/fifo-%u-%s",
                 NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX,
+                NA_SM_CLASS(na_class)->username,
                 NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
                 na_sm_addr->conn_id, NA_SM_RECV_NAME);
-            sprintf(na_sm_remote_event_name, "%s/%s/%d/%u/fifo-%u-%s",
+            sprintf(na_sm_remote_event_name, "%s/%s_%s/%d/%u/fifo-%u-%s",
                 NA_SM_TMP_DIRECTORY, NA_SM_SHM_PREFIX,
+                NA_SM_CLASS(na_class)->username,
                 NA_SM_CLASS(na_class)->self_addr->pid,
                 NA_SM_CLASS(na_class)->self_addr->id,
                 na_sm_addr->conn_id, NA_SM_SEND_NAME);
@@ -2946,9 +3010,11 @@ na_sm_addr_free(na_class_t *na_class, na_addr_t addr)
                 goto done;
             }
 
-            NA_SM_GEN_SHM_NAME(na_sm_copy_buf_name, na_sm_addr);
+            NA_SM_GEN_SHM_NAME(na_sm_copy_buf_name,
+                NA_SM_CLASS(na_class)->username, na_sm_addr);
             copy_buf_name = na_sm_copy_buf_name;
-            NA_SM_GEN_SOCK_PATH(na_sock_name, na_sm_addr);
+            NA_SM_GEN_SOCK_PATH(na_sock_name,
+                NA_SM_CLASS(na_class)->username, na_sm_addr);
             pathname = na_sock_name;
         }
     }
diff --git a/src/na/na_types.h b/src/na/na_types.h
index fd18929..1f32ee2 100644
--- a/src/na/na_types.h
+++ b/src/na/na_types.h
@@ -37,9 +37,9 @@ typedef enum na_progress_mode {
 
 /* Init info */
 struct na_init_info {
+    const char *auth_key;               /* Authorization key */
     na_progress_mode_t progress_mode;   /* Progress mode */
     na_uint8_t max_contexts;            /* Max contexts */
-    const char *auth_key;               /* Authorization key */
 };
 
 /* Segment */
@@ -48,21 +48,34 @@ struct na_segment {
     na_size_t size;     /* Size of the segment in bytes */
 };
 
-/* Error return codes:
- * Functions return 0 for success or NA_XXX_ERROR for failure */
-typedef enum na_return {
-    NA_SUCCESS,             /*!< operation succeeded */
-    NA_TIMEOUT,             /*!< reached timeout */
-    NA_INVALID_PARAM,       /*!< invalid parameter */
-    NA_SIZE_ERROR,          /*!< message size error */
-    NA_ALIGNMENT_ERROR,     /*!< alignment error */
-    NA_PERMISSION_ERROR,    /*!< read/write permission error */
-    NA_NOMEM_ERROR,         /*!< no memory error */
-    NA_PROTOCOL_ERROR,      /*!< unknown error reported from the protocol layer */
-    NA_CANCELED,            /*!< operation was canceled */
-    NA_CANCEL_ERROR,        /*!< operation could not be canceled */
-    NA_ADDRINUSE_ERROR      /*!< address already in use */
-} na_return_t;
+/* Return codes:
+ * Functions return 0 for success or corresponding return code */
+#define NA_RETURN_VALUES                                                    \
+    X(NA_SUCCESS)           /*!< operation succeeded */                     \
+    X(NA_PERMISSION)        /*!< operation not permitted */                 \
+    X(NA_NOENTRY)           /*!< no such file or directory */               \
+    X(NA_INTERRUPT)         /*!< operation interrupted */                   \
+    X(NA_AGAIN)             /*!< operation must be retried */               \
+    X(NA_NOMEM)             /*!< out of memory */                           \
+    X(NA_ACCESS)            /*!< permission denied */                       \
+    X(NA_FAULT)             /*!< bad address */                             \
+    X(NA_BUSY)              /*!< device or resource busy */                 \
+    X(NA_NODEV)             /*!< no such device */                          \
+    X(NA_INVALID_ARG)       /*!< invalid argument */                        \
+    X(NA_PROTOCOL_ERROR)    /*!< protocol error */                          \
+    X(NA_OVERFLOW)          /*!< value too large */                         \
+    X(NA_MSGSIZE)           /*!< message size too long */                   \
+    X(NA_PROTONOSUPPORT)    /*!< protocol not supported */                  \
+    X(NA_OPNOTSUPPORTED)    /*!< operation not supported on endpoint */     \
+    X(NA_ADDRINUSE)         /*!< address already in use */                  \
+    X(NA_ADDRNOTAVAIL)      /*!< cannot assign requested address */         \
+    X(NA_TIMEOUT)           /*!< operation reached timeout */               \
+    X(NA_CANCELED)          /*!< operation canceled */                      \
+    X(NA_RETURN_MAX)
+
+#define X(a) a,
+typedef enum na_return { NA_RETURN_VALUES } na_return_t;
+#undef X
 
 /* Callback operation type */
 typedef enum na_cb_type {
@@ -88,13 +101,13 @@ struct na_cb_info_recv_unexpected {
 
 /* Callback info struct */
 struct na_cb_info {
-    void *arg;          /* User data */
-    na_return_t ret;    /* Return value */
-    na_cb_type_t type;  /* Callback type */
     union {             /* Union of callback info structures */
         struct na_cb_info_lookup lookup;
         struct na_cb_info_recv_unexpected recv_unexpected;
     } info;
+    void *arg;          /* User data */
+    na_cb_type_t type;  /* Callback type */
+    na_return_t ret;    /* Return value */
 };
 
 /* Callback type */
diff --git a/src/proc_extra/mercury_proc_string.h b/src/proc_extra/mercury_proc_string.h
index 918dce6..e1bc9ab 100644
--- a/src/proc_extra/mercury_proc_string.h
+++ b/src/proc_extra/mercury_proc_string.h
@@ -16,8 +16,8 @@
 
 #include <string.h>
 
-typedef const char * hg_const_string_t;
-typedef char * hg_string_t;
+typedef const char *hg_const_string_t;
+typedef char *hg_string_t;
 
 #ifdef __cplusplus
 extern "C" {
@@ -45,35 +45,29 @@ static HG_INLINE hg_return_t
 hg_proc_hg_const_string_t(hg_proc_t proc, void *data)
 {
     hg_string_object_t string;
-    hg_const_string_t *strdata = (hg_const_string_t*)data;
+    hg_const_string_t *strdata = (hg_const_string_t *) data;
     hg_return_t ret = HG_SUCCESS;
 
     switch (hg_proc_get_op(proc)) {
         case HG_ENCODE:
             hg_string_object_init_const_char(&string, *strdata, 0);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             hg_string_object_free(&string);
             break;
         case HG_DECODE:
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             *strdata = hg_string_object_swap(&string, 0);
             hg_string_object_free(&string);
             break;
         case HG_FREE:
             hg_string_object_init_const_char(&string, *strdata, 1);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             break;
         default:
             break;
@@ -95,35 +89,29 @@ static HG_INLINE hg_return_t
 hg_proc_hg_string_t(hg_proc_t proc, void *data)
 {
     hg_string_object_t string;
-    hg_string_t *strdata = (hg_string_t*)data;
+    hg_string_t *strdata = (hg_string_t *) data;
     hg_return_t ret = HG_SUCCESS;
 
     switch (hg_proc_get_op(proc)) {
         case HG_ENCODE:
             hg_string_object_init_char(&string, *strdata, 0);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             hg_string_object_free(&string);
             break;
         case HG_DECODE:
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             *strdata = hg_string_object_swap(&string, 0);
             hg_string_object_free(&string);
             break;
         case HG_FREE:
             hg_string_object_init_char(&string, *strdata, 1);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             break;
         default:
             break;
@@ -146,67 +134,61 @@ hg_proc_hg_string_object_t(hg_proc_t proc, void *string)
 {
     hg_uint64_t string_len = 0;
     hg_return_t ret = HG_SUCCESS;
-    hg_string_object_t *strobj = (hg_string_object_t*)string;
+    hg_string_object_t *strobj = (hg_string_object_t *) string;
 
     switch (hg_proc_get_op(proc)) {
         case HG_ENCODE:
             string_len = (strobj->data) ? strlen(strobj->data) + 1 : 0;
             ret = hg_proc_uint64_t(proc, &string_len);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             if (string_len) {
                 ret = hg_proc_raw(proc, strobj->data, string_len);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                if (ret != HG_SUCCESS)
                     goto done;
-                }
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_const);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_const);
+                if (ret != HG_SUCCESS)
                     goto done;
-                }
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_owned);
-                if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_owned);
+                if (ret != HG_SUCCESS)
                     goto done;
-                }
             }
             break;
         case HG_DECODE:
             ret = hg_proc_uint64_t(proc, &string_len);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Proc error");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             if (string_len) {
-                strobj->data = (char*) malloc(string_len);
+                strobj->data = (char *) malloc(string_len);
+                if (strobj->data == NULL) {
+                    ret = HG_NOMEM;
+                    goto done;
+                }
                 ret = hg_proc_raw(proc, strobj->data, string_len);
                 if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                    free(strobj->data);
+                    strobj->data = NULL;
                     goto done;
                 }
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_const);
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_const);
                 if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                    free(strobj->data);
+                    strobj->data = NULL;
                     goto done;
                 }
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_owned);
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_owned);
                 if (ret != HG_SUCCESS) {
-                    HG_LOG_ERROR("Proc error");
+                    free(strobj->data);
+                    strobj->data = NULL;
                     goto done;
                 }
-            } else {
+            } else
                 strobj->data = NULL;
-            }
             break;
         case HG_FREE:
             ret = hg_string_object_free(strobj);
-            if (ret != HG_SUCCESS) {
-                HG_LOG_ERROR("Could not free string object");
+            if (ret != HG_SUCCESS)
                 goto done;
-            }
             break;
         default:
             break;
diff --git a/src/proc_extra/mercury_string_object.c b/src/proc_extra/mercury_string_object.c
index 76863c2..b7c7832 100644
--- a/src/proc_extra/mercury_string_object.c
+++ b/src/proc_extra/mercury_string_object.c
@@ -9,6 +9,7 @@
  */
 
 #include "mercury_string_object.h"
+#include "mercury_error.h"
 
 #include <string.h>
 #include <stdlib.h>
@@ -55,7 +56,7 @@ hg_string_object_init_const_char(hg_string_object_t *string, const char *s,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    string->data = (char*) s;
+    string->data = (char *) s;
     string->is_owned = is_owned;
     string->is_const = 1;
 
@@ -87,9 +88,12 @@ hg_string_object_dup(hg_string_object_t string, hg_string_object_t *new_string)
     hg_return_t ret = HG_SUCCESS;
 
     new_string->data = strdup(string.data);
+    HG_CHECK_ERROR(new_string->data == NULL, done, ret, HG_NOMEM,
+        "Could not dup string data");
     new_string->is_owned = 1;
     new_string->is_const = 0;
 
+done:
     return ret;
 }
 
diff --git a/src/proc_extra/mercury_string_object.h b/src/proc_extra/mercury_string_object.h
index ab5ae01..7d29e26 100644
--- a/src/proc_extra/mercury_string_object.h
+++ b/src/proc_extra/mercury_string_object.h
@@ -30,7 +30,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_string_object_init(hg_string_object_t *string);
 
 /**
@@ -42,8 +42,9 @@ hg_string_object_init(hg_string_object_t *string);
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
-hg_string_object_init_char(hg_string_object_t *string, char *s, hg_bool_t is_owned);
+HG_PUBLIC hg_return_t
+hg_string_object_init_char(hg_string_object_t *string, char *s,
+    hg_bool_t is_owned);
 
 /**
  * Initialize a string object from the const string pointed to by s.
@@ -54,8 +55,9 @@ hg_string_object_init_char(hg_string_object_t *string, char *s, hg_bool_t is_own
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
-hg_string_object_init_const_char(hg_string_object_t *string, const char *s, hg_bool_t is_owned);
+HG_PUBLIC hg_return_t
+hg_string_object_init_const_char(hg_string_object_t *string, const char *s,
+    hg_bool_t is_owned);
 
 /**
  * Free a string object.
@@ -64,7 +66,7 @@ hg_string_object_init_const_char(hg_string_object_t *string, const char *s, hg_b
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_string_object_free(hg_string_object_t *string);
 
 /**
@@ -75,7 +77,7 @@ hg_string_object_free(hg_string_object_t *string);
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_EXPORT hg_return_t
+HG_PUBLIC hg_return_t
 hg_string_object_dup(hg_string_object_t string, hg_string_object_t *new_string);
 
 /**
@@ -85,7 +87,7 @@ hg_string_object_dup(hg_string_object_t string, hg_string_object_t *new_string);
  *
  * \return Pointer to string contained by string before the swap
  */
-HG_EXPORT char *
+HG_PUBLIC char *
 hg_string_object_swap(hg_string_object_t *string, char *s);
 
 #ifdef __cplusplus
diff --git a/src/util/mercury_log.c b/src/util/mercury_log.c
index 7e18319..e17e973 100644
--- a/src/util/mercury_log.c
+++ b/src/util/mercury_log.c
@@ -57,7 +57,7 @@ hg_log_set_stream_error(FILE *stream)
 
 /*---------------------------------------------------------------------------*/
 void
-hg_log_write(hg_log_type_t log_type, const char *module, const char *file,
+hg_log_write(unsigned int log_type, const char *module, const char *file,
     unsigned int line, const char *func, const char *format, ...)
 {
     char buf[HG_UTIL_LOG_MAX_BUF];
diff --git a/src/util/mercury_log.h b/src/util/mercury_log.h
index bec44c3..d6eb11e 100644
--- a/src/util/mercury_log.h
+++ b/src/util/mercury_log.h
@@ -15,11 +15,10 @@
 
 #include <stdio.h>
 
-typedef enum {
-    HG_LOG_TYPE_DEBUG,
-    HG_LOG_TYPE_WARNING,
-    HG_LOG_TYPE_ERROR
-} hg_log_type_t;
+#define HG_LOG_TYPE_NONE    0
+#define HG_LOG_TYPE_DEBUG   0x01
+#define HG_LOG_TYPE_WARNING 0x02
+#define HG_LOG_TYPE_ERROR   0x04
 
 /* For compatibility */
 #if defined(__STDC_VERSION__) &&  (__STDC_VERSION__ < 199901L)
@@ -92,7 +91,7 @@ hg_log_set_stream_error(FILE *stream);
  * \param format [IN]           string format
  */
 HG_UTIL_EXPORT void
-hg_log_write(hg_log_type_t log_type, const char *module, const char *file,
+hg_log_write(unsigned int log_type, const char *module, const char *file,
     unsigned int line, const char *func, const char *format, ...);
 
 #ifdef __cplusplus
diff --git a/src/util/mercury_thread.h b/src/util/mercury_thread.h
index 596c7e3..a90855c 100644
--- a/src/util/mercury_thread.h
+++ b/src/util/mercury_thread.h
@@ -108,6 +108,22 @@ hg_thread_cancel(hg_thread_t thread);
 HG_UTIL_EXPORT int
 hg_thread_yield(void);
 
+/**
+ * Obtain handle of the calling thread.
+ *
+ * \return
+ */
+static HG_UTIL_INLINE hg_thread_t
+hg_thread_self(void);
+
+/**
+ * Compare thread IDs.
+ *
+ * \return Non-zero if equal, zero if not equal
+ */
+static HG_UTIL_INLINE int
+hg_thread_equal(hg_thread_t t1, hg_thread_t t2);
+
 /**
  * Create a thread-specific data key visible to all threads in the process.
  *
@@ -172,6 +188,28 @@ hg_thread_getaffinity(hg_thread_t thread, hg_cpu_set_t *cpu_mask);
 HG_UTIL_EXPORT int
 hg_thread_setaffinity(hg_thread_t thread, const hg_cpu_set_t *cpu_mask);
 
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE hg_thread_t
+hg_thread_self(void)
+{
+#ifdef _WIN32
+    return GetCurrentThread();
+#else
+    return pthread_self();
+#endif
+}
+
+/*---------------------------------------------------------------------------*/
+static HG_UTIL_INLINE int
+hg_thread_equal(hg_thread_t t1, hg_thread_t t2)
+{
+#ifdef _WIN32
+    return GetThreadId(t1) == GetThreadId(t2);
+#else
+    return pthread_equal(t1, t2);
+#endif
+}
+
 /*---------------------------------------------------------------------------*/
 static HG_UTIL_INLINE void *
 hg_thread_getspecific(hg_thread_key_t key)
