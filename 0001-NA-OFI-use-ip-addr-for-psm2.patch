diff --git a/Testing/CMakeLists.txt b/Testing/CMakeLists.txt
index 4147f47..7e50aa8 100644
--- a/Testing/CMakeLists.txt
+++ b/Testing/CMakeLists.txt
@@ -75,6 +75,9 @@ if(NA_USE_OFI)
   set(NA_OFI_TESTING_PROTOCOL "sockets;tcp" CACHE STRING "Protocol(s) used for testing (e.g., sockets;psm2;verbs).")
   mark_as_advanced(NA_OFI_TESTING_PROTOCOL)
 
+  set(NA_TESTING_HOSTNAME "eth0" CACHE STRING "hostname used for testing (e.g., 192.168.1.100).")
+  mark_as_advanced(NA_TESTING_HOSTNAME)
+
   option(NA_OFI_TESTING_USE_CRAY_DRC
     "Use Cray DRC to allow multi-job communication." OFF)
   mark_as_advanced(NA_OFI_TESTING_USE_CRAY_DRC)
@@ -143,7 +146,7 @@ function(build_mercury_test test_name)
   endif()
 endfunction()
 
-macro(add_mercury_test_comm test_name comm protocol busy)
+macro(add_mercury_test_comm test_name comm protocol hostname busy)
   # Set full test name
   set(full_test_name ${test_name})
   set(opt_names ${comm} ${protocol})
@@ -155,7 +158,7 @@ macro(add_mercury_test_comm test_name comm protocol busy)
   endif()
 
   # Set test arguments
-  set(test_args --comm ${comm} --protocol ${protocol})
+  set(test_args --comm ${comm} --protocol ${protocol} --hostname ${hostname})
   if(${busy})
     set(test_args ${test_args} --busy)
   endif()
@@ -213,8 +216,8 @@ function(add_mercury_test test_name)
   foreach(comm ${NA_PLUGINS})
     string(TOUPPER ${comm} upper_comm)
     foreach(protocol ${NA_${upper_comm}_TESTING_PROTOCOL})
-      add_mercury_test_comm(${test_name} ${comm} ${protocol} false)
-      add_mercury_test_comm(${test_name} ${comm} ${protocol} true)
+      add_mercury_test_comm(${test_name} ${comm} ${protocol} ${NA_TESTING_HOSTNAME} false)
+      add_mercury_test_comm(${test_name} ${comm} ${protocol} ${NA_TESTING_HOSTNAME} true)
     endforeach()
   endforeach()
 endfunction()
@@ -267,14 +270,18 @@ build_mercury_test(server)
 set(MERCURY_tests
   rpc
   bulk
+  overflow
 )
-
-# Benchmarks
+if(NOT WIN32)
+  set(MERCURY_tests ${MERCURY_tests} posix)
+endif()
+#build_mercury_test(nested)
+build_mercury_test(cancel)
+build_mercury_test(perf)
 build_mercury_test(rpc_lat)
 build_mercury_test(write_bw)
 build_mercury_test(read_bw)
-
-# Cray DRC test
+#build_mercury_test(init)
 if(HG_TESTING_HAS_CRAY_DRC)
   build_mercury_test(drc_auth)
 endif()
diff --git a/Testing/mercury_rpc_cb.c b/Testing/mercury_rpc_cb.c
index 45bdbf9..5279c7f 100644
--- a/Testing/mercury_rpc_cb.c
+++ b/Testing/mercury_rpc_cb.c
@@ -410,7 +410,7 @@ hg_test_bulk_transfer_cb(const struct hg_cb_info *hg_cb_info)
         /* Fill output structure */
         out_struct.ret = 0;
     } else if (hg_cb_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Error in callback");
+        HG_LOG_ERROR("Error in callback");
         ret = HG_PROTOCOL_ERROR;
         goto done;
     }
@@ -480,7 +480,7 @@ hg_test_bulk_bind_transfer_cb(const struct hg_cb_info *hg_cb_info)
         /* Fill output structure */
         out_struct.ret = 0;
     } else if (hg_cb_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Error in callback");
+        HG_LOG_ERROR("Error in callback");
         ret = HG_PROTOCOL_ERROR;
         goto done;
     }
diff --git a/Testing/mercury_test.c b/Testing/mercury_test.c
index 69b4734..0cd4be3 100644
--- a/Testing/mercury_test.c
+++ b/Testing/mercury_test.c
@@ -61,11 +61,6 @@ hg_test_register(hg_class_t *hg_class);
 /* Local Variables */
 /*******************/
 
-/* Default error log mask */
-#ifdef HG_HAS_VERBOSE_ERROR
-unsigned int HG_TEST_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
-#endif
-
 extern int na_test_opt_ind_g; /* token pointer */
 extern const char *na_test_opt_arg_g; /* flag argument (or value) */
 extern const char *na_test_short_opt_g;
@@ -163,12 +158,15 @@ hg_test_parse_options(int argc, char *argv[], struct hg_test_info *hg_test_info)
 static hg_return_t
 hg_test_handle_create_cb(hg_handle_t handle, void *arg)
 {
-    struct hg_thread_work *hg_thread_work;
+    struct hg_thread_work *hg_thread_work =
+        malloc(sizeof(struct hg_thread_work));
     hg_return_t ret = HG_SUCCESS;
 
-    hg_thread_work = malloc(sizeof(struct hg_thread_work));
-    HG_TEST_CHECK_ERROR(hg_thread_work == NULL, done, ret, HG_NOMEM_ERROR,
-        "Could not allocate hg_thread_work");
+    if (!hg_thread_work) {
+        HG_LOG_ERROR("Could not allocate hg_thread_work");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
 
     (void) arg;
     HG_Set_data(handle, hg_thread_work, free);
@@ -183,33 +181,42 @@ static hg_return_t
 hg_test_finalize_rpc(struct hg_test_info *hg_test_info, hg_uint8_t target_id)
 {
     hg_request_t *request_object = NULL;
-    hg_handle_t handle = HG_HANDLE_NULL;
+    hg_handle_t handle;
     hg_return_t ret = HG_SUCCESS;
 
     request_object = hg_request_create(hg_test_info->request_class);
 
     ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
         hg_test_finalize_id_g, &handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not create HG handle");
+        goto done;
+    }
 
     /* Set target ID */
     ret = HG_Set_target_id(handle, target_id);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not set HG handle target ID");
+        goto done;
+    }
 
     /* Forward call to target addr */
     ret = HG_Forward(handle, hg_test_finalize_rpc_cb, request_object, NULL);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not forward finalize call");
+        goto done;
+    }
 
     hg_request_wait(request_object, HG_MAX_IDLE_TIME, NULL);
 
-done:
+    /* Complete */
     ret = HG_Destroy(handle);
-    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
 
+done:
     hg_request_destroy(request_object);
 
     return ret;
@@ -241,14 +248,18 @@ hg_test_finalize_cb(hg_handle_t handle)
 
     /* Free handle and send response back */
     ret = HG_Respond(handle, NULL, NULL, NULL);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Respond() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not respond");
+        goto done;
+    }
 
-done:
     ret = HG_Destroy(handle);
-    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
 
+done:
     return ret;
 }
 
@@ -325,15 +336,6 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     struct hg_init_info hg_init_info;
     struct hg_test_context_info *hg_test_context_info;
     hg_return_t ret = HG_SUCCESS;
-    na_return_t na_ret;
-#ifdef HG_HAS_VERBOSE_ERROR
-    const char *log_level = NULL;
-
-    /* Set log level */
-    log_level = getenv("HG_TEST_LOG_LEVEL");
-    if (log_level && (strcmp(log_level, "debug") == 0))
-        HG_TEST_LOG_MASK |= HG_LOG_TYPE_DEBUG;
-#endif
 
     /* Get HG test options */
     hg_test_parse_options(argc, argv, hg_test_info);
@@ -343,9 +345,10 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         char hg_test_drc_key[NA_TEST_MAX_ADDR_NAME] = { '\0' };
 
         ret = hg_test_drc_acquire(argc, argv, hg_test_info);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "hg_test_drc_acquire() failed (%s)",
-            HG_Error_to_string(ret));
-
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not acquire DRC auth key");
+            goto done;
+        }
         sprintf(hg_test_drc_key, "%u", hg_test_info->cookie);
         hg_test_info->na_test_info.key = strdup(hg_test_drc_key);
 #endif
@@ -353,9 +356,11 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
     /* Initialize NA test layer */
     hg_test_info->na_test_info.extern_init = NA_TRUE;
-    na_ret = NA_Test_init(argc, argv, &hg_test_info->na_test_info);
-    HG_TEST_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-        "NA_Test_init() failed (%s)",  NA_Error_to_string(na_ret));
+    if (NA_Test_init(argc, argv, &hg_test_info->na_test_info) != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not initialize NA test layer");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
 
     memset(&hg_init_info, 0, sizeof(struct hg_init_info));
 
@@ -385,22 +390,28 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     /* Init HG with init options */
     hg_test_info->hg_class = HG_Init_opt(NULL,
         hg_test_info->na_test_info.listen, &hg_init_info);
-    HG_TEST_CHECK_ERROR(hg_test_info->hg_class == NULL, done, ret, HG_FAULT,
-        "HG_Init_opt() failed (%s)");
+    if (!hg_test_info->hg_class) {
+        HG_LOG_ERROR("Could not initialize HG");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
     HG_CLASS_DEFAULT = hg_test_info->hg_class;
 
     /* Attach test info to class */
     ret = HG_Class_set_data(hg_test_info->hg_class, hg_test_info, NULL);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Class_set_data() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not set HG class data");
+        goto done;
+    }
 
 #ifdef MERCURY_TESTING_HAS_THREAD_POOL
     /* Attach handle created */
     ret = HG_Class_set_handle_create_callback(hg_test_info->hg_class,
         hg_test_handle_create_cb, hg_test_info->hg_class);
-    HG_TEST_CHECK_HG_ERROR(done, ret,
-        "HG_Class_set_handle_create_callback() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not set HG handle create callback");
+        goto done;
+    }
 #endif
 
     /* Set header */
@@ -412,21 +423,26 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     /* For convenience */
     ret = HG_Hl_init_opt(NULL, hg_test_info->na_test_info.listen,
         &hg_init_info);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_init_opt() failed (%s)",
-        HG_Error_to_string(ret));
-
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not initialize HG HL");
+        goto done;
+    }
     hg_test_info->context = HG_CONTEXT_DEFAULT;
     hg_test_info->request_class = HG_REQUEST_CLASS_DEFAULT;
 
     /* Attach context info to context */
     hg_test_context_info = malloc(sizeof(struct hg_test_context_info));
-    HG_TEST_CHECK_ERROR(hg_test_context_info == NULL, done, ret, HG_NOMEM_ERROR,
-        "Could not allocate HG test context info");
-
+    if (!hg_test_context_info) {
+        HG_LOG_ERROR("Could not allocate HG test context info");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     hg_atomic_set32(&hg_test_context_info->finalizing, 0);
     ret = HG_Context_set_data(hg_test_info->context, hg_test_context_info, free);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_set_data() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not set context data");
+        goto done;
+    }
 
     /* Register routines */
     hg_test_register(hg_test_info->hg_class);
@@ -458,13 +474,16 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         ret = HG_Bulk_create(hg_test_info->hg_class, 1, NULL,
             (hg_size_t *) &bulk_size, HG_BULK_READWRITE,
             &hg_test_info->bulk_handle);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
-            HG_Error_to_string(ret));
-
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not create bulk handle");
+            goto done;
+        }
         ret = HG_Bulk_access(hg_test_info->bulk_handle, 0, bulk_size,
             HG_BULK_READWRITE, 1, (void **) &buf_ptr, NULL, NULL);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_access() failed (%s)",
-            HG_Error_to_string(ret));
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not access bulk handle");
+            goto done;
+        }
         for (i = 0; i < bulk_size; i++)
             buf_ptr[i] = (char) i;
     }
@@ -482,42 +501,57 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
             hg_test_info->secondary_contexts = malloc(
                 secondary_contexts_count * sizeof(hg_context_t *));
-            HG_TEST_CHECK_ERROR(hg_test_info->secondary_contexts == NULL, done,
-                ret, HG_NOMEM_ERROR, "Could not allocate secondary contexts");
+            if (!hg_test_info->secondary_contexts) {
+                HG_LOG_ERROR("Could not allocate secondary contexts");
+                ret = HG_NOMEM_ERROR;
+                goto done;
+            }
             for (i = 0; i < secondary_contexts_count; i++) {
                 hg_uint8_t context_id = (hg_uint8_t) (i + 1);
                 hg_test_info->secondary_contexts[i] =
                     HG_Context_create_id(hg_test_info->hg_class, context_id);
-                HG_TEST_CHECK_ERROR(hg_test_info->secondary_contexts[i] == NULL,
-                    done, ret, HG_FAULT, "HG_Context_create_id() failed");
+                if (!hg_test_info->secondary_contexts[i]) {
+                    HG_LOG_ERROR("Could not create HG context for id: %u", i);
+                    ret = HG_NOMEM_ERROR;
+                    goto done;
+                }
 
                 /* Attach context info to context */
-                hg_test_context_info = malloc(
-                    sizeof(struct hg_test_context_info));
-                HG_TEST_CHECK_ERROR(hg_test_context_info == NULL, done, ret,
-                    HG_NOMEM_ERROR, "Could not allocate HG test context info");
-
+                hg_test_context_info = malloc(sizeof(struct hg_test_context_info));
+                if (!hg_test_context_info) {
+                    HG_LOG_ERROR("Could not allocate context info");
+                    ret = HG_NOMEM_ERROR;
+                    goto done;
+                }
                 hg_atomic_set32(&hg_test_context_info->finalizing, 0);
                 ret = HG_Context_set_data(hg_test_info->secondary_contexts[i],
                     hg_test_context_info, free);
-                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_set_data() failed"
-                    " (%s)", HG_Error_to_string(ret));
+                if (ret != HG_SUCCESS) {
+                    HG_LOG_ERROR("Could not set HG context data");
+                    goto done;
+                }
             }
         }
 
         /* TODO only rank 0 */
         ret = HG_Addr_self(hg_test_info->hg_class, &self_addr);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_self() failed (%s)",
-            HG_Error_to_string(ret));
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not get HG self addr");
+            goto done;
+        }
 
         ret = HG_Addr_to_string(hg_test_info->hg_class, addr_string,
             &addr_string_len, self_addr);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_to_string() failed (%s)",
-            HG_Error_to_string(ret));
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not convert addr to string");
+            goto done;
+        }
 
         ret = HG_Addr_free(hg_test_info->hg_class, self_addr);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_free() failed (%s)",
-            HG_Error_to_string(ret));
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not free addr");
+            goto done;
+        }
 
         na_test_set_config(addr_string);
 
@@ -532,8 +566,10 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
     } else if (hg_test_info->na_test_info.self_send) {
         /* Self addr is target */
         ret = HG_Addr_self(hg_test_info->hg_class, &hg_test_info->target_addr);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_self() failed (%s)",
-            HG_Error_to_string(ret));
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not get HG self addr");
+            goto done;
+        }
     } else {
         char test_addr_name[NA_TEST_MAX_ADDR_NAME] = { '\0' };
 
@@ -552,8 +588,6 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
             &hg_test_info->na_test_info);
 
         hg_test_info->na_test_info.target_name = strdup(test_addr_name);
-        HG_TEST_CHECK_ERROR(hg_test_info->na_test_info.target_name == NULL,
-            done, ret, HG_NOMEM_ERROR, "Could not dup test_addr_name");
         printf("# Target name read: %s\n",
             hg_test_info->na_test_info.target_name);
 
@@ -561,8 +595,11 @@ HG_Test_init(int argc, char *argv[], struct hg_test_info *hg_test_info)
         ret = HG_Hl_addr_lookup_wait(hg_test_info->context,
             hg_test_info->request_class, hg_test_info->na_test_info.target_name,
             &hg_test_info->target_addr, HG_MAX_IDLE_TIME);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_addr_lookup_wait() failed (%s)",
-            HG_Error_to_string(ret));
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not lookup addr for target %s",
+                hg_test_info->na_test_info.target_name);
+            goto done;
+        }
     }
 
 done:
@@ -590,8 +627,10 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
 
         /* Free addr id */
         ret = HG_Addr_free(hg_test_info->hg_class, hg_test_info->target_addr);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_free() failed (%s)",
-            HG_Error_to_string(ret));
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not free addr");
+            goto done;
+        }
     }
 
     NA_Test_barrier(&hg_test_info->na_test_info);
@@ -599,16 +638,11 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
     if (hg_test_info->na_test_info.listen
         || hg_test_info->na_test_info.self_send) {
 #ifdef MERCURY_TESTING_HAS_THREAD_POOL
-        /* Give some time before shutting down */
-        sleep(1);
-
         hg_thread_pool_destroy(hg_test_info->thread_pool);
         hg_thread_mutex_destroy(&hg_test_info->bulk_handle_mutex);
 #endif
         /* Destroy bulk handle */
-        ret = HG_Bulk_free(hg_test_info->bulk_handle);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
-            HG_Error_to_string(ret));
+        HG_Bulk_free(hg_test_info->bulk_handle);
 
         /* Destroy secondary contexts */
         if (hg_test_info->secondary_contexts) {
@@ -618,8 +652,10 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
 
             for (i = 0; i < secondary_contexts_count; i++) {
                 ret = HG_Context_destroy(hg_test_info->secondary_contexts[i]);
-                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Context_destroy() failed"
-                    " (%s)", HG_Error_to_string(ret));
+                if (ret != HG_SUCCESS) {
+                    HG_LOG_ERROR("Could not destroy HG context for id: %u", i);
+                    goto done;
+                }
             }
             free(hg_test_info->secondary_contexts);
         }
@@ -627,19 +663,22 @@ HG_Test_finalize(struct hg_test_info *hg_test_info)
 
     /* Finalize interface */
     ret = HG_Hl_finalize();
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_finalize() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not finalize HG Hl");
+        goto done;
+    }
 
     /* Finalize NA test interface */
     na_ret = NA_Test_finalize(&hg_test_info->na_test_info);
-    HG_TEST_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-        "NA_Test_finalize() failed (%s)", NA_Error_to_string(na_ret));
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not finalize NA test interface");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
 
     if (hg_test_info->auth) {
 #ifdef HG_TESTING_HAS_CRAY_DRC
-        ret = hg_test_drc_release(hg_test_info);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "hg_test_drc_release() failed (%s)",
-            HG_Error_to_string(ret));
+        hg_test_drc_release(hg_test_info);
 #endif
     }
 
diff --git a/Testing/mercury_test.h b/Testing/mercury_test.h
index a7cff08..e74fffe 100644
--- a/Testing/mercury_test.h
+++ b/Testing/mercury_test.h
@@ -12,7 +12,6 @@
 #define MERCURY_TEST_H
 
 #include "na_test.h"
-
 #include "mercury.h"
 #include "mercury_request.h"
 #ifdef MERCURY_TESTING_HAS_THREAD_POOL
@@ -67,106 +66,35 @@ struct hg_test_context_info {
 /* Public Macros */
 /*****************/
 
-/* Number of threads */
-#define MERCURY_TESTING_NUM_THREADS_DEFAULT 8
-
 /* Default error macro */
 #ifdef HG_HAS_VERBOSE_ERROR
-# include <mercury_log.h>
-# define HG_TEST_LOG_MASK hg_test_log_mask
-/* Log mask will be initialized in init routine */
-extern unsigned int HG_TEST_LOG_MASK;
-# define HG_TEST_LOG_MODULE_NAME "HG Test"
-# define HG_TEST_LOG_ERROR(...) do {                                \
-    if (HG_TEST_LOG_MASK & HG_LOG_TYPE_ERROR)                       \
-        HG_LOG_WRITE_ERROR(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__);   \
-} while (0)
-# define HG_TEST_LOG_DEBUG(...) do {                                \
-    if (HG_TEST_LOG_MASK & HG_LOG_TYPE_DEBUG)                       \
-        HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__);   \
-} while (0)
-# define HG_TEST_LOG_WARNING(...) do {                              \
-    if (HG_TEST_LOG_MASK & HG_LOG_TYPE_WARNING)                     \
-        HG_LOG_WRITE_WARNING(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__); \
-} while (0)
-#else
-# define HG_TEST_LOG_ERROR(...)     (void)0
-# define HG_TEST_LOG_DEBUG(...)     (void)0
-# define HG_TEST_LOG_WARNING(...)   (void)0
-#endif
-
-/* Branch predictor hints */
-#ifndef _WIN32
-# define likely(x)       __builtin_expect(!!(x), 1)
-# define unlikely(x)     __builtin_expect(!!(x), 0)
+  #include <mercury_log.h>
+  #define HG_TEST_LOG_MODULE_NAME "HG Test"
+  #define HG_TEST_LOG_ERROR(...)                                \
+      HG_LOG_WRITE_ERROR(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
+  #define HG_TEST_LOG_WARNING(...)                              \
+      HG_LOG_WRITE_WARNING(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
 #else
-# define likely(x)       (x)
-# define unlikely(x)     (x)
+  #define HG_TEST_LOG_ERROR(...) (void)0
+  #define HG_TEST_LOG_WARNING(...) (void)0
 #endif
 
-/* Error macros */
-#define HG_TEST_GOTO_DONE(label, ret, ret_val) do {             \
-    ret = ret_val;                                              \
-    goto label;                                                 \
-} while (0)
-
-#define HG_TEST_GOTO_ERROR(label, ret, err_val, ...) do {       \
-    HG_LOG_ERROR(__VA_ARGS__);                                  \
-    ret = err_val;                                              \
-    goto label;                                                 \
-} while (0)
-
-/* Check for hg_ret value and goto label */
-#define HG_TEST_CHECK_HG_ERROR(label, hg_ret, ...) do {         \
-    if (unlikely(hg_ret != HG_SUCCESS)) {                       \
-        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
-        goto label;                                             \
-    }                                                           \
+#define HG_TEST(x) do {         \
+    printf("Testing %-62s", x); \
+    fflush(stdout);             \
 } while (0)
 
-/* Check for cond, set ret to err_val and goto label */
-#define HG_TEST_CHECK_ERROR(cond, label, ret, err_val, ...) do {\
-    if (unlikely(cond)) {                                       \
-        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
-        ret = err_val;                                          \
-        goto label;                                             \
-    }                                                           \
+#define HG_PASSED() do {        \
+    puts(" PASSED");            \
+    fflush(stdout);             \
 } while (0)
 
-#define HG_TEST_CHECK_ERROR_NORET(cond, label, ...) do {        \
-    if (unlikely(cond)) {                                       \
-        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
-        goto label;                                             \
-    }                                                           \
+#define HG_FAILED() do {        \
+    puts("*FAILED*");           \
+    fflush(stdout);             \
 } while (0)
 
-#define HG_TEST_CHECK_ERROR_DONE(cond, ...) do {                \
-    if (unlikely(cond)) {                                       \
-        HG_TEST_LOG_ERROR(__VA_ARGS__);                         \
-    }                                                           \
-} while (0)
-
-/* Check for cond and print warning */
-#define HG_TEST_CHECK_WARNING(cond, ...) do {                   \
-    if (unlikely(cond)) {                                       \
-        HG_TEST_LOG_WARNING(__VA_ARGS__);                       \
-    }                                                           \
-} while (0)
-
-#define HG_TEST(x) do {                                         \
-    printf("Testing %-62s", x);                                 \
-    fflush(stdout);                                             \
-} while (0)
-
-#define HG_PASSED() do {                                        \
-    puts(" PASSED");                                            \
-    fflush(stdout);                                             \
-} while (0)
-
-#define HG_FAILED() do {                                        \
-    puts("*FAILED*");                                           \
-    fflush(stdout);                                             \
-} while (0)
+#define MERCURY_TESTING_NUM_THREADS_DEFAULT 8
 
 /*********************/
 /* Public Prototypes */
diff --git a/Testing/mercury_test_drc.c b/Testing/mercury_test_drc.c
index 2fbede4..b383c1d 100644
--- a/Testing/mercury_test_drc.c
+++ b/Testing/mercury_test_drc.c
@@ -125,7 +125,7 @@ hg_proc_hg_test_drc_grant_in_t(hg_proc_t proc, void *data)
 
     ret = hg_proc_hg_uint32_t(proc, &struct_data->wlm_id);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Proc error");
+        HG_LOG_ERROR("Proc error");
         goto done;
     }
 
@@ -143,13 +143,13 @@ hg_proc_hg_test_drc_grant_out_t(hg_proc_t proc, void *data)
 #ifdef HG_TEST_DRC_USE_TOKEN
     ret = hg_proc_hg_string_t(proc, &struct_data->token);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Proc error");
+        HG_LOG_ERROR("Proc error");
         goto done;
     }
 #else
     ret = hg_proc_hg_uint32_t(proc, &struct_data->credential);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Proc error");
+        HG_LOG_ERROR("Proc error");
         goto done;
     }
 #endif
@@ -183,7 +183,7 @@ hg_test_drc_grant_cb(hg_handle_t handle)
     /* Get input buffer */
     ret = HG_Get_input(handle, &in_struct);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not get input");
+        HG_LOG_ERROR("Could not get input");
         goto done;
     }
 
@@ -202,7 +202,7 @@ drc_grant_again:
             sleep(1);
             goto drc_grant_again;
         }
-        HG_TEST_LOG_ERROR("drc_grant() to %d failed (%d, %s)", hg_test_info->wlm_id,
+        HG_LOG_ERROR("drc_grant() to %d failed (%d, %s)", hg_test_info->wlm_id,
             rc, drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -214,7 +214,7 @@ drc_grant_again:
 #ifndef HG_TEST_DRC_IGNORE
     rc = drc_get_credential_token(hg_test_info->credential, &token);
     if (rc != DRC_SUCCESS) {
-        HG_TEST_LOG_ERROR("drc_get_credential_token() failed (%d, %s)", rc,
+        HG_LOG_ERROR("drc_get_credential_token() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -234,7 +234,7 @@ drc_grant_again:
     /* Free handle and send response back */
     ret = HG_Respond(handle, NULL, NULL, &out_struct);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not respond");
+        HG_LOG_ERROR("Could not respond");
         goto done;
     }
 
@@ -264,7 +264,7 @@ drc_acquire_again:
                 sleep(1);
                 goto drc_acquire_again;
             }
-            HG_TEST_LOG_ERROR("drc_acquire() failed (%d, %s)", rc, drc_strerror(-rc));
+            HG_LOG_ERROR("drc_acquire() failed (%d, %s)", rc, drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
         }
@@ -284,7 +284,7 @@ drc_access_again:
             sleep(1);
             goto drc_access_again;
         }
-        HG_TEST_LOG_ERROR("drc_access() failed (%d, %s)", rc,
+        HG_LOG_ERROR("drc_access() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -329,7 +329,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
         hg_test_info->request_class, hg_test_info->na_test_info.target_name,
         &hg_test_info->target_addr, HG_MAX_IDLE_TIME);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not find addr for target %s",
+        HG_LOG_ERROR("Could not find addr for target %s",
             hg_test_info->na_test_info.target_name);
         goto done;
     }
@@ -341,7 +341,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
     ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
         hg_test_drc_grant_id_g, &handle);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not create handle");
+        HG_LOG_ERROR("Could not create handle");
         goto done;
     }
 
@@ -357,7 +357,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
     fflush(stdout);
     ret = HG_Forward(handle, hg_test_drc_token_request_cb, request, &in_struct);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not forward call with id=%d",
+        HG_LOG_ERROR("Could not forward call with id=%d",
             hg_test_drc_grant_id_g);
         goto done;
     }
@@ -368,7 +368,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
     /* Get output */
     ret = HG_Get_output(handle, &out_struct);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not get output");
+        HG_LOG_ERROR("Could not get output");
         goto done;
     }
 
@@ -382,7 +382,7 @@ hg_test_drc_token_request(struct hg_test_info *hg_test_info)
 #ifndef HG_TEST_DRC_IGNORE
     rc = drc_access_with_token(token, 0, &hg_test_info->credential_info);
     if (rc != DRC_SUCCESS) {/* failed to grant access to the credential */
-        HG_TEST_LOG_ERROR("drc_access_with_token() failed (%d, %s)", rc,
+        HG_LOG_ERROR("drc_access_with_token() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -403,7 +403,7 @@ drc_access_again:
             sleep(1);
             goto drc_access_again;
         }
-        HG_TEST_LOG_ERROR("drc_access() failed (%d, %s)", rc,
+        HG_LOG_ERROR("drc_access() failed (%d, %s)", rc,
             drc_strerror(-rc));
         ret = HG_PROTOCOL_ERROR;
         goto done;
@@ -423,13 +423,13 @@ drc_access_again:
     /* Clean up resources */
     ret = HG_Free_output(handle, &out_struct);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not free output");
+        HG_LOG_ERROR("Could not free output");
         goto done;
     }
 
     ret = HG_Destroy(handle);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not destroy handle");
+        HG_LOG_ERROR("Could not destroy handle");
         goto done;
     }
 
@@ -438,7 +438,7 @@ drc_access_again:
     /* Free target addr */
     ret = HG_Addr_free(hg_test_info->hg_class, hg_test_info->target_addr);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not free addr");
+        HG_LOG_ERROR("Could not free addr");
         goto done;
     }
 
@@ -454,7 +454,7 @@ hg_test_drc_token_request_cb(const struct hg_cb_info *callback_info)
     hg_return_t ret = HG_SUCCESS;
 
     if (callback_info->ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
+        HG_LOG_ERROR("Return from callback info is not HG_SUCCESS");
         goto done;
     }
 
@@ -477,7 +477,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     hg_test_drc_info.na_test_info.protocol = strdup("tcp");
     hg_test_drc_info.na_test_info.listen = hg_test_info->na_test_info.listen;
     if (NA_Test_init(argc, argv, &hg_test_drc_info.na_test_info) != NA_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not initialize NA test layer");
+        HG_LOG_ERROR("Could not initialize NA test layer");
         ret = HG_NA_ERROR;
         goto done;
     }
@@ -489,7 +489,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     ret = HG_Hl_init_opt(NULL, hg_test_drc_info.na_test_info.listen,
         &hg_test_drc_init_info);
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not initialize HG HL");
+        HG_LOG_ERROR("Could not initialize HG HL");
         goto done;
     }
     hg_test_drc_info.hg_class = HG_CLASS_DEFAULT;
@@ -510,21 +510,21 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
         ret = hg_test_drc_token_acquire(&hg_test_drc_info);
         if (ret != HG_SUCCESS) {
-            HG_TEST_LOG_ERROR("Could not acquire DRC token");
+            HG_LOG_ERROR("Could not acquire DRC token");
             goto done;
         }
 
         /* TODO only rank 0 */
         ret = HG_Addr_self(hg_test_drc_info.hg_class, &self_addr);
         if (ret != HG_SUCCESS) {
-            HG_TEST_LOG_ERROR("Could not get self addr");
+            HG_LOG_ERROR("Could not get self addr");
             goto done;
         }
 
         ret = HG_Addr_to_string(hg_test_drc_info.hg_class, addr_string,
             &addr_string_len, self_addr);
         if (ret != HG_SUCCESS) {
-            HG_TEST_LOG_ERROR("Could not convert addr to string");
+            HG_LOG_ERROR("Could not convert addr to string");
             goto done;
         }
         HG_Addr_free(hg_test_drc_info.hg_class, self_addr);
@@ -566,7 +566,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
 
         ret = hg_test_drc_token_request(&hg_test_drc_info);
         if (ret != HG_SUCCESS) {
-            HG_TEST_LOG_ERROR("Could not request DRC token");
+            HG_LOG_ERROR("Could not request DRC token");
             goto done;
         }
     }
@@ -578,7 +578,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     /* Finalize HG HL interface */
     ret = HG_Hl_finalize();
     if (ret != HG_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not finalize HG HL");
+        HG_LOG_ERROR("Could not finalize HG HL");
         goto done;
     }
 
@@ -587,7 +587,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
     hg_test_drc_info.na_test_info.mpi_no_finalize = NA_TRUE;
 #endif
     if (NA_Test_finalize(&hg_test_drc_info.na_test_info) != NA_SUCCESS) {
-        HG_TEST_LOG_ERROR("Could not finalize NA test interface");
+        HG_LOG_ERROR("Could not finalize NA test interface");
         ret = HG_NA_ERROR;
         goto done;
     }
@@ -596,7 +596,7 @@ hg_test_drc_acquire(int argc, char *argv[], struct hg_test_info *hg_test_info)
         hg_test_drc_info.credential = hg_test_info->credential;
         ret = hg_test_drc_token_acquire(&hg_test_drc_info);
         if (ret != HG_SUCCESS) {
-            HG_TEST_LOG_ERROR("Could not acquire DRC token");
+            HG_LOG_ERROR("Could not acquire DRC token");
             goto done;
         }
     }
@@ -633,7 +633,7 @@ hg_test_drc_release(struct hg_test_info *hg_test_info)
     if (hg_test_info->credential_info) {
         rc = drc_release_local(&hg_test_info->credential_info);
         if (rc != DRC_SUCCESS) { /* failed to release credential info */
-            HG_TEST_LOG_ERROR("Could not release credential info (%d, %s)", rc,
+            HG_LOG_ERROR("Could not release credential info (%d, %s)", rc,
                 drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
@@ -645,7 +645,7 @@ hg_test_drc_release(struct hg_test_info *hg_test_info)
         rc = drc_revoke(hg_test_info->credential, hg_test_info->wlm_id,
             DRC_FLAGS_TARGET_WLM);
         if (rc != DRC_SUCCESS) { /* failed to release credential info */
-            HG_TEST_LOG_ERROR("Could not revoke access for %d (%d, %s)",
+            HG_LOG_ERROR("Could not revoke access for %d (%d, %s)",
                 hg_test_info->wlm_id, rc, drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
@@ -656,7 +656,7 @@ hg_test_drc_release(struct hg_test_info *hg_test_info)
         printf("# Releasing credential %u\n", hg_test_info->credential);
         rc = drc_release(hg_test_info->credential, 0);
         if (rc != DRC_SUCCESS) { /* failed to release credential */
-            HG_TEST_LOG_ERROR("Could not release credential (%d, %s)", rc,
+            HG_LOG_ERROR("Could not release credential (%d, %s)", rc,
                 drc_strerror(-rc));
             ret = HG_PROTOCOL_ERROR;
             goto done;
diff --git a/Testing/na/na_test.c b/Testing/na/na_test.c
index 2d55055..eb6de10 100644
--- a/Testing/na/na_test.c
+++ b/Testing/na/na_test.c
@@ -71,11 +71,6 @@ extern const char *na_test_opt_arg_g; /* flag argument (or value) */
 extern const char *na_test_short_opt_g;
 extern const struct na_test_opt na_test_opt_g[];
 
-/* Default error log mask */
-#ifdef NA_HAS_VERBOSE_ERROR
-unsigned int NA_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
-#endif
-
 /*---------------------------------------------------------------------------*/
 void
 na_test_usage(const char *execname)
@@ -271,7 +266,7 @@ na_test_gen_config(struct na_test_info *na_test_info)
     info_string = (char *) malloc(sizeof(char) * NA_TEST_MAX_ADDR_NAME);
     if (!info_string) {
         NA_LOG_ERROR("Could not allocate info string");
-        ret = NA_NOMEM;
+        ret = NA_NOMEM_ERROR;
         goto done;
     }
     memset(info_string, '\0', NA_TEST_MAX_ADDR_NAME);
@@ -305,10 +300,18 @@ na_test_gen_config(struct na_test_info *na_test_info)
             /* special-case SM (pid:id) */
             sprintf(info_string_ptr, "%d/%d", (int) getpid(), port_incr);
         }
-    } else if ((strcmp("tcp", na_test_info->protocol) == 0)
+    } else if (strcmp("psm2", na_test_info->protocol) == 0) {
+        if (!na_test_info->listen) {
+            sprintf(info_string_ptr, "%s:%d", na_test_info->hostname,
+                    33333);
+        } else {
+            sprintf(info_string_ptr, "%s:%d", na_test_info->hostname,
+                    22222);
+        }
+
+    } else if((strcmp("tcp", na_test_info->protocol) == 0)
         || (strcmp("verbs;ofi_rxm", na_test_info->protocol) == 0)
         || (strcmp("verbs", na_test_info->protocol) == 0)
-        || (strcmp("psm2", na_test_info->protocol) == 0)
         || (strcmp("sockets", na_test_info->protocol) == 0)) {
         if (!na_test_info->hostname) {
             /* Nothing */
@@ -328,7 +331,7 @@ na_test_gen_config(struct na_test_info *na_test_info)
             base_port + port_incr);
     } else {
         NA_LOG_ERROR("Unknown protocol: %s", na_test_info->protocol);
-        ret = NA_INVALID_ARG;
+        ret = NA_INVALID_PARAM;
         goto done;
     }
 
@@ -486,6 +489,27 @@ NA_Test_init(int argc, char *argv[], struct na_test_info *na_test_info)
         }
     }
 
+    {
+        char addr_string[NA_TEST_MAX_ADDR_NAME];
+        na_size_t addr_string_len = NA_TEST_MAX_ADDR_NAME;
+        na_addr_t self_addr;
+        na_return_t nret;
+
+        /* TODO only rank 0 */
+        nret = NA_Addr_self(na_test_info->na_class, &self_addr);
+        if (nret != NA_SUCCESS) {
+            NA_LOG_ERROR("Could not get self addr");
+        }
+
+        nret = NA_Addr_to_string(na_test_info->na_class, addr_string,
+                &addr_string_len, self_addr);
+        if (nret != NA_SUCCESS) {
+            NA_LOG_ERROR("Could not convert addr to string");
+        }
+        NA_LOG_DEBUG("self URI: %s\n", addr_string);
+        NA_Addr_free(na_test_info->na_class, self_addr);
+    }
+
 done:
     if (ret != NA_SUCCESS)
         NA_Test_finalize(na_test_info);
diff --git a/Testing/na/test_lat_client.c b/Testing/na/test_lat_client.c
index 7ef42b1..ff80698 100644
--- a/Testing/na/test_lat_client.c
+++ b/Testing/na/test_lat_client.c
@@ -134,7 +134,7 @@ na_test_target_lookup(struct na_test_lat_info *na_test_lat_info)
         na_test_target_lookup_cb, &request_args,
         na_test_lat_info->na_test_info.target_name, &op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("Could not lookup address (%s)", NA_Error_to_string(ret));
+        NA_LOG_ERROR("Could not lookup address");
         goto done;
     }
 
@@ -221,21 +221,16 @@ na_test_measure_latency(struct na_test_lat_info *na_test_lat_info,
             recv_buf, buf_size, recv_buf_data, na_test_lat_info->target_addr, 0,
             0, &recv_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_recv_expected() failed (%s)", NA_Error_to_string(ret));
+            NA_LOG_ERROR("NA_Msg_recv_expected() failed");
             goto done;
         }
 
-again:
         /* Post send */
         ret = NA_Msg_send_unexpected(na_test_lat_info->na_class,
             na_test_lat_info->context, NULL, NULL, send_buf, buf_size,
             send_buf_data, na_test_lat_info->target_addr, 0, 0, &send_op_id);
-        if (ret == NA_AGAIN) {
-            hg_request_wait(recv_request, 0, NULL);
-            goto again;
-        }
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_send_unexpected() failed (%s)", NA_Error_to_string(ret));
+            NA_LOG_ERROR("NA_Msg_send_unexpected() failed");
             goto done;
         }
 
@@ -257,7 +252,7 @@ again:
             recv_buf, buf_size, recv_buf_data, na_test_lat_info->target_addr, 0,
             1, &recv_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_recv_expected() failed (%s)", NA_Error_to_string(ret));
+            NA_LOG_ERROR("NA_Msg_recv_expected() failed");
             goto done;
         }
 
@@ -267,7 +262,7 @@ again:
             send_buf_data, na_test_lat_info->target_addr, 0, 1,
             &send_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_send_unexpected() failed (%s)", NA_Error_to_string(ret));
+            NA_LOG_ERROR("NA_Msg_send_unexpected() failed");
             goto done;
         }
 
@@ -360,7 +355,7 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
         recv_buf, buf_size, recv_buf_data, na_test_lat_info->target_addr, 0,
         NA_TEST_TAG_DONE, &recv_op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("NA_Msg_recv_expected() failed (%s)", NA_Error_to_string(ret));
+        NA_LOG_ERROR("NA_Msg_recv_expected() failed");
         goto done;
     }
 
@@ -370,7 +365,7 @@ na_test_send_finalize(struct na_test_lat_info *na_test_lat_info)
         send_buf_data, na_test_lat_info->target_addr, 0, NA_TEST_TAG_DONE,
         &send_op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("NA_Msg_send_unexpected() failed (%s)", NA_Error_to_string(ret));
+        NA_LOG_ERROR("NA_Msg_send_unexpected() failed");
         goto done;
     }
 
diff --git a/Testing/na/test_lat_server.c b/Testing/na/test_lat_server.c
index cd52b2e..ea48512 100644
--- a/Testing/na/test_lat_server.c
+++ b/Testing/na/test_lat_server.c
@@ -142,7 +142,7 @@ na_test_recv_unexpected_cb(const struct na_cb_info *na_cb_info)
         na_cb_info->info.recv_unexpected.tag,
         &na_test_source_recv_arg->send_op_id);
     if (ret != NA_SUCCESS) {
-        NA_LOG_ERROR("NA_Msg_send_expected() failed (%s)", NA_Error_to_string(ret));
+        NA_LOG_ERROR("NA_Msg_send_expected() failed");
     }
 
     NA_Addr_free(na_test_lat_info->na_class,
@@ -210,7 +210,7 @@ na_test_loop_latency(struct na_test_lat_info *na_test_lat_info)
             &na_test_source_recv_arg, recv_buf, unexpected_size,
             recv_buf_data, &recv_op_id);
         if (ret != NA_SUCCESS) {
-            NA_LOG_ERROR("NA_Msg_recv_unexpected() failed (%s)", NA_Error_to_string(ret));
+            NA_LOG_ERROR("NA_Msg_recv_unexpected() failed");
             goto done;
         }
 
diff --git a/Testing/script/travis_build.sh b/Testing/script/travis_build.sh
index 61217bc..0955e7d 100755
--- a/Testing/script/travis_build.sh
+++ b/Testing/script/travis_build.sh
@@ -1,11 +1,11 @@
 #!/bin/bash
 
 BMI_VERSION=master
-CMAKE_VERSION_MAJOR=3.16
-CMAKE_VERSION_MINOR=1
-MPI_VERSION=3.3.2
+CMAKE_VERSION_MAJOR=3.15
+CMAKE_VERSION_MINOR=5
+MPI_VERSION=3.3.1
 CCI_VERSION=2.1
-OFI_VERSION=1.9.0
+OFI_VERSION=1.9.0rc2
 PREFIX=$HOME/install
 
 set -e
diff --git a/Testing/test_bulk.c b/Testing/test_bulk.c
index 541bae3..cfb31f2 100644
--- a/Testing/test_bulk.c
+++ b/Testing/test_bulk.c
@@ -13,38 +13,29 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-/****************/
-/* Local Macros */
-/****************/
+extern hg_id_t hg_test_bulk_write_id_g;
+extern hg_id_t hg_test_bulk_bind_write_id_g;
 
 #define BUFSIZE (MERCURY_TESTING_BUFFER_SIZE * 1024 * 1024)
 
-/************************************/
-/* Local Type and Struct Definition */
-/************************************/
-
 struct forward_cb_args {
     hg_request_t *request;
     size_t expected_bytes;
     hg_return_t ret;
 };
 
-/********************/
-/* Local Prototypes */
-/********************/
-
-static hg_return_t
-hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info);
-
-
-/*******************/
-/* Local Variables */
-/*******************/
-
-extern hg_id_t hg_test_bulk_write_id_g;
-extern hg_id_t hg_test_bulk_bind_write_id_g;
+//#define HG_TEST_DEBUG
+#ifdef HG_TEST_DEBUG
+#define HG_TEST_LOG_DEBUG(...)                                \
+    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
+#else
+#define HG_TEST_LOG_DEBUG(...) (void)0
+#endif
 
 /*---------------------------------------------------------------------------*/
+/**
+ * HG_Forward callback
+ */
 static hg_return_t
 hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -54,24 +45,32 @@ hg_test_bulk_forward_cb(const struct hg_cb_info *callback_info)
     bulk_write_out_t bulk_write_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
-        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
+    if (callback_info->ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
+        goto done;
+    }
 
     /* Get output */
     ret = HG_Get_output(handle, &bulk_write_out_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not get output");
+        goto done;
+    }
 
     /* Get output parameters */
     bulk_write_ret = bulk_write_out_struct.ret;
-    HG_TEST_CHECK_ERROR(bulk_write_ret != args->expected_bytes, done,
-        args->ret, HG_MSGSIZE, "Returned: %zu bytes, was expecting %zu",
-        bulk_write_ret, args->expected_bytes);
+    if (bulk_write_ret != args->expected_bytes) {
+        HG_TEST_LOG_ERROR("Returned: %zu bytes, was expecting %zu",
+            bulk_write_ret, args->expected_bytes);
+        args->ret = HG_SIZE_ERROR;
+    }
 
     /* Free request */
     ret = HG_Free_output(handle, &bulk_write_out_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not free output");
+        goto done;
+    }
 
 done:
     hg_request_complete(args->request);
@@ -88,24 +87,32 @@ hg_test_bulk_bind_forward_cb(const struct hg_cb_info *callback_info)
     bulk_bind_write_out_t bulk_write_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
-        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
+    if (callback_info->ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
+        goto done;
+    }
 
     /* Get output */
     ret = HG_Get_output(handle, &bulk_write_out_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not get output");
+        goto done;
+    }
 
     /* Get output parameters */
     bulk_write_ret = bulk_write_out_struct.ret;
-    HG_TEST_CHECK_ERROR(bulk_write_ret != args->expected_bytes, done,
-        args->ret, HG_MSGSIZE, "Returned: %zu bytes, was expecting %zu",
-        bulk_write_ret, args->expected_bytes);
+    if (bulk_write_ret != args->expected_bytes) {
+        HG_TEST_LOG_ERROR("Returned: %zu bytes, was expecting %zu",
+            bulk_write_ret, args->expected_bytes);
+        args->ret = HG_SIZE_ERROR;
+    }
 
     /* Free request */
     ret = HG_Free_output(handle, &bulk_write_out_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not free output");
+        goto done;
+    }
 
 done:
     hg_request_complete(args->request);
@@ -133,14 +140,14 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
     hg_cb_t forward_cb = hg_test_bulk_forward_cb;
     size_t i;
 
-    HG_TEST_CHECK_ERROR(origin_offset + transfer_size > bulk_size, done, ret,
-        HG_OVERFLOW, "Exceeding bulk size");
+    if (origin_offset + transfer_size > bulk_size) {
+        HG_LOG_ERROR("Exceeding bulk size");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
 
     /* Prepare bulk_buf */
     bulk_buf = malloc(bulk_size);
-    HG_TEST_CHECK_ERROR(bulk_buf == NULL, done, ret, HG_NOMEM_ERROR,
-         "Could not allocate bulk_buf");
-
     for (i = 0; i < bulk_size; i++)
         bulk_buf[i] = (char) i;
     buf_ptrs[0] = bulk_buf;
@@ -153,8 +160,10 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
     /* Register memory */
     ret = HG_Bulk_create(hg_class, 2, buf_ptrs, buf_sizes, HG_BULK_READ_ONLY,
         &bulk_handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create bulk handle");
+        goto done;
+    }
 
     if (bind_addr) {
         /* Bind local context to bulk, it is only necessary if this bulk handle
@@ -162,16 +171,19 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
          * should also work for normal case. Add here just to test the
          * functionality. */
         ret = HG_Bulk_bind(bulk_handle, context);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_bind() failed (%s)",
-            HG_Error_to_string(ret));
-
+        if (ret != HG_SUCCESS) {
+            HG_TEST_LOG_ERROR("Could not bind context to bulk handle");
+            goto done;
+        }
         rpc_id = hg_test_bulk_bind_write_id_g;
         forward_cb = hg_test_bulk_bind_forward_cb;
     }
 
     ret = HG_Create(context, target_addr, rpc_id, &handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create handle");
+        goto done;
+    }
 
     /* Fill input structure */
     bulk_write_in_struct.fildes = 0;
@@ -190,20 +202,26 @@ hg_test_bulk_contig(hg_class_t *hg_class, hg_context_t *context,
     forward_cb_args.ret = HG_SUCCESS;
     ret = HG_Forward(handle, forward_cb, &forward_cb_args,
         &bulk_write_in_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not forward call");
+        goto done;
+    }
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy bulk handle");
+        goto done;
+    }
 
     /* Complete */
     ret = HG_Destroy(handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
 
     hg_request_destroy(request);
 
@@ -235,26 +253,20 @@ hg_test_bulk_seg(hg_class_t *hg_class, hg_context_t *context,
     hg_size_t bulk_size = BUFSIZE;
     size_t i;
 
-    HG_TEST_CHECK_ERROR(origin_offset + transfer_size > bulk_size, done, ret,
-        HG_OVERFLOW, "Exceeding bulk size");
+    if (origin_offset + transfer_size > bulk_size) {
+        HG_LOG_ERROR("Exceeding bulk size");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
 
     /* Prepare bulk_buf */
     buf_ptrs = (void **) malloc(origin_segment_count * sizeof(void *));
-    HG_TEST_CHECK_ERROR(buf_ptrs == NULL, done, ret, HG_NOMEM_ERROR,
-         "Could not allocate buf_ptrs");
-
     buf_sizes = (hg_size_t *) malloc(origin_segment_count * sizeof(hg_size_t));
-    HG_TEST_CHECK_ERROR(buf_sizes == NULL, done, ret, HG_NOMEM_ERROR,
-         "Could not allocate buf_sizes");
-
     for (i = 0; i < origin_segment_count; i++) {
         hg_size_t j;
 
         buf_sizes[i] = bulk_size / origin_segment_count;
         buf_ptrs[i] = malloc(buf_sizes[i]);
-        HG_TEST_CHECK_ERROR(buf_ptrs == NULL, done, ret, HG_NOMEM_ERROR,
-             "Could not allocate bulk_buf");
-
         for (j = 0; j < buf_sizes[i]; j++) {
             ((char **) buf_ptrs)[i][j] = (char) (i * buf_sizes[i] + j);
         }
@@ -263,14 +275,18 @@ hg_test_bulk_seg(hg_class_t *hg_class, hg_context_t *context,
     request = hg_request_create(request_class);
 
     ret = HG_Create(context, target_addr, hg_test_bulk_write_id_g, &handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create handle");
+        goto done;
+    }
 
     /* Register memory */
     ret = HG_Bulk_create(hg_class, origin_segment_count, buf_ptrs,
         buf_sizes, HG_BULK_READ_ONLY, &bulk_handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create bulk handle");
+        goto done;
+    }
 
     /* Fill input structure */
     bulk_write_in_struct.fildes = 0;
@@ -290,20 +306,26 @@ hg_test_bulk_seg(hg_class_t *hg_class, hg_context_t *context,
     forward_cb_args.ret = HG_SUCCESS;
     ret = HG_Forward(handle, hg_test_bulk_forward_cb, &forward_cb_args,
             &bulk_write_in_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not forward call");
+        goto done;
+    }
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy bulk handle");
+        goto done;
+    }
 
     /* Complete */
     ret = HG_Destroy(handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
 
     hg_request_destroy(request);
 
@@ -338,8 +360,11 @@ hg_test_bulk_small(hg_class_t *hg_class, hg_context_t *context,
     hg_size_t bulk_size = 12;
     size_t i;
 
-    HG_TEST_CHECK_ERROR(origin_offset + transfer_size > bulk_size, done, ret,
-        HG_OVERFLOW, "Exceeding bulk size");
+    if (origin_offset + transfer_size > bulk_size) {
+        HG_LOG_ERROR("Exceeding bulk size");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
 
     /* Prepare bulk buf */
     for (i = 0; i < bulk_size; i++)
@@ -348,14 +373,18 @@ hg_test_bulk_small(hg_class_t *hg_class, hg_context_t *context,
     request = hg_request_create(request_class);
 
     ret = HG_Create(context, target_addr, hg_test_bulk_write_id_g, &handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create handle");
+        goto done;
+    }
 
     /* Register memory */
     ret = HG_Bulk_create(hg_class, 2, buf_ptrs, buf_sizes, HG_BULK_READ_ONLY,
         &bulk_handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_create() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create bulk handle");
+        goto done;
+    }
 
     /* Fill input structure */
     bulk_write_in_struct.fildes = 1;
@@ -375,20 +404,26 @@ hg_test_bulk_small(hg_class_t *hg_class, hg_context_t *context,
     forward_cb_args.ret = HG_SUCCESS;
     ret = HG_Forward(handle, hg_test_bulk_forward_cb, &forward_cb_args,
             &bulk_write_in_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not forward call");
+        goto done;
+    }
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
     /* Free memory handle */
     ret = HG_Bulk_free(bulk_handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Bulk_free() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy bulk handle");
+        goto done;
+    }
 
     /* Complete */
     ret = HG_Destroy(handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
 
     hg_request_destroy(request);
 
@@ -400,126 +435,146 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
-int
-main(int argc, char *argv[])
+int main(int argc, char *argv[])
 {
     struct hg_test_info hg_test_info = { 0 };
     hg_return_t hg_ret;
     int ret = EXIT_SUCCESS;
 
     /* Initialize the interface */
-    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "HG_Test_init() failed");
+    HG_Test_init(argc, argv, &hg_test_info);
 
     /* Simple RPC bulk test */
     HG_TEST("contiguous RPC bulk (size BUFSIZE, offsets 0, 0)");
     hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, 0, hg_test_info.target_addr, BUFSIZE, 0, 0);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "contiguous RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     HG_TEST("contiguous RPC bulk (size BUFSIZE/4, offsets BUFSIZE/2 + 1, 0)");
     hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, 0, hg_test_info.target_addr, BUFSIZE/4,
         BUFSIZE/2 + 1, 0);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "contiguous RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     HG_TEST("contiguous RPC bulk (size BUFSIZE/8, offsets BUFSIZE/2 + 1, BUFSIZE/4)");
     hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, 0, hg_test_info.target_addr, BUFSIZE/8,
         BUFSIZE/2 + 1, BUFSIZE/4);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "contiguous RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     /* small bulk test */
     HG_TEST("small segmented RPC bulk (size 8, offsets 0, 0)");
     hg_ret = hg_test_bulk_small(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 8, 0, 0);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "small segmented RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     HG_TEST("small segmented RPC bulk (size 4, offsets 8, 0)");
     hg_ret = hg_test_bulk_small(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 4, 8, 0);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "small segmented RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     HG_TEST("small segmented RPC bulk (size 8, offsets 4, 2)");
     hg_ret = hg_test_bulk_small(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 8, 4, 2);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "small segmented RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     HG_TEST("segmented RPC bulk (size BUFSIZE, offsets 0, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE, 0, 0, 16);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "segmented RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     HG_TEST("segmented RPC bulk (size BUFSIZE/4, offsets BUFSIZE/2 + 1, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/4,
         BUFSIZE/2 + 1, 0, 16);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "segmented RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     HG_TEST("segmented RPC bulk (size BUFSIZE/8, offsets BUFSIZE/2 + 1, BUFSIZE/4)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/8,
         BUFSIZE/2 + 1, BUFSIZE/4, 16);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "segmented RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     HG_TEST("over-segmented RPC bulk (size BUFSIZE, offsets 0, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE, 0, 0,
         1024);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "over-segmented RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     HG_TEST("over-segmented RPC bulk (size BUFSIZE/4, offsets BUFSIZE/2 + 1, 0)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/4,
         BUFSIZE/2 + 1, 0, 1024);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "over-segmented RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     HG_TEST("over-segmented RPC bulk (size BUFSIZE/8, offsets BUFSIZE/2 + 1, BUFSIZE/4)");
     hg_ret = hg_test_bulk_seg(hg_test_info.hg_class, hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, BUFSIZE/8,
         BUFSIZE/2 + 1, BUFSIZE/4, 1024);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "over-segmented RPC bulk failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     if (strcmp(HG_Class_get_name(hg_test_info.hg_class), "ofi") == 0) {
         HG_TEST("bind contiguous RPC bulk (size BUFSIZE, offsets 0, 0)");
         hg_ret = hg_test_bulk_contig(hg_test_info.hg_class, hg_test_info.context,
             hg_test_info.request_class, 1, hg_test_info.target_addr, BUFSIZE, 0, 0);
-        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-            "bind contiguous RPC bulk failed");
+        if (hg_ret != HG_SUCCESS) {
+            ret = EXIT_FAILURE;
+            goto done;
+        }
         HG_PASSED();
     }
 
 done:
     if (ret != EXIT_SUCCESS)
         HG_FAILED();
-
-    hg_ret = HG_Test_finalize(&hg_test_info);
-    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
-
+    HG_Test_finalize(&hg_test_info);
     return ret;
 }
diff --git a/Testing/test_bulk.h b/Testing/test_bulk.h
index ecafb96..02eecaf 100644
--- a/Testing/test_bulk.h
+++ b/Testing/test_bulk.h
@@ -45,24 +45,34 @@ hg_proc_bulk_write_in_t(hg_proc_t proc, void *data)
     bulk_write_in_t *struct_data = (bulk_write_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fildes);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_hg_size_t(proc, &struct_data->transfer_size);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_hg_size_t(proc, &struct_data->origin_offset);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_hg_size_t(proc, &struct_data->target_offset);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -80,8 +90,10 @@ hg_proc_bulk_write_out_t(hg_proc_t proc, void *data)
     bulk_write_out_t *struct_data = (bulk_write_out_t *) data;
 
     ret = hg_proc_hg_size_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -100,12 +112,16 @@ hg_proc_bulk_bind_write_out_t(hg_proc_t proc, void *data)
     bulk_bind_write_out_t *struct_data = (bulk_bind_write_out_t *) data;
 
     ret = hg_proc_hg_size_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
diff --git a/Testing/test_bulk_seg.c b/Testing/test_bulk_seg.c
new file mode 100644
index 0000000..c025d3f
--- /dev/null
+++ b/Testing/test_bulk_seg.c
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#include "mercury_test.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+extern hg_id_t hg_test_bulk_seg_write_id_g;
+
+static hg_return_t
+hg_test_bulk_seg_forward_cb(const struct hg_cb_info *callback_info)
+{
+    hg_handle_t handle = callback_info->info.forward.handle;
+    hg_request_t *request = (hg_request_t *) callback_info->arg;
+    size_t bulk_write_ret = 0;
+    bulk_write_out_t bulk_write_out_struct;
+    hg_return_t ret = HG_SUCCESS;
+
+    /* Get output */
+    ret = HG_Get_output(handle, &bulk_write_out_struct);
+    if (ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not get output\n");
+        goto done;
+    }
+
+    /* Get output parameters */
+    bulk_write_ret = bulk_write_out_struct.ret;
+    printf("bulk_write returned: %zu\n", bulk_write_ret);
+
+    /* Free request */
+    ret = HG_Free_output(handle, &bulk_write_out_struct);
+    if (ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not free output\n");
+        goto done;
+    }
+
+    hg_request_complete(request);
+
+done:
+    return ret;
+}
+
+/*****************************************************************************/
+int main(int argc, char *argv[])
+{
+    struct hg_test_info hg_test_info = { 0 };
+    hg_request_t *request = NULL;
+    hg_handle_t handle;
+
+    bulk_write_in_t bulk_write_in_struct;
+
+    int fildes = 12345;
+    void **bulk_buf;
+    size_t *bulk_sizes;
+    size_t bulk_size = 1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE / sizeof(int);
+    size_t bulk_size_x = 16;
+    size_t bulk_size_y = 0;
+    size_t *bulk_size_y_var = NULL;
+    hg_bulk_t bulk_handle = HG_BULK_NULL;
+
+    hg_return_t hg_ret;
+    size_t i, j;
+
+    /* Initialize the interface */
+    HG_Test_init(argc, argv, &hg_test_info);
+
+    request = hg_request_create(hg_test_info.request_class);
+
+    hg_ret = HG_Create(hg_test_info.context, hg_test_info.target_addr,
+        hg_test_bulk_seg_write_id_g, &handle);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not start call\n");
+        return EXIT_FAILURE;
+    }
+
+    /* This will create a list of variable size segments */
+//    if (hg_test_info.variable) {
+//        printf("Using variable size segments!\n");
+//        /* bulk_size_x >= 2 */
+//        /* 524288 + 262144 + 131072 + 65536 + 32768 + 16384 + 8192 + 8192 */
+//        bulk_size_x = 8;
+//        bulk_size_y_var = (size_t*) malloc(bulk_size_x * sizeof(size_t));
+//        bulk_size_y_var[0] = bulk_size / 2;
+//        for (i = 1; i < bulk_size_x - 1; i++) {
+//            bulk_size_y_var[i] = bulk_size_y_var[i-1] / 2;
+//        }
+//        bulk_size_y_var[bulk_size_x - 1] = bulk_size_y_var[bulk_size_x - 2];
+//    }
+//    /* This will use an extra encoding buffer */
+//    else if (hg_test_info.extra) {
+//        printf("Using large number of segments!\n");
+//        bulk_size_x = 1024;
+//        bulk_size_y = bulk_size / bulk_size_x;
+//    }
+//    else {
+        /* This will create a list of fixed size segments */
+        bulk_size_y = bulk_size / bulk_size_x;
+//    }
+
+    /* Prepare bulk_buf */
+    bulk_buf = (void **) malloc(bulk_size_x * sizeof(void *));
+    bulk_sizes = (size_t *) malloc(bulk_size_x * sizeof(size_t));
+    if (bulk_size_y_var) {
+        int val = 0;
+        for (i = 0; i < bulk_size_x; i++) {
+            bulk_sizes[i] = bulk_size_y_var[i] * sizeof(int);
+            bulk_buf[i] = malloc(bulk_sizes[i]);
+            for (j = 0; j < bulk_size_y_var[i]; j++) {
+                ((int **) (bulk_buf))[i][j] = val;
+                val++;
+            }
+        }
+    } else {
+        for (i = 0; i < bulk_size_x; i++) {
+            bulk_sizes[i] = bulk_size_y * sizeof(int);
+            bulk_buf[i] = malloc(bulk_sizes[i]);
+            for (j = 0; j < bulk_size_y; j++) {
+                ((int **) (bulk_buf))[i][j] = (int) (i * bulk_size_y + j);
+            }
+        }
+    }
+
+    /* Register memory */
+    hg_ret = HG_Bulk_create(hg_test_info.hg_class, (hg_uint32_t) bulk_size_x,
+        bulk_buf, (hg_size_t *) bulk_sizes, HG_BULK_READ_ONLY, &bulk_handle);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not create bulk data handle\n");
+        return EXIT_FAILURE;
+    }
+
+    free(bulk_sizes);
+    bulk_sizes = NULL;
+    if (bulk_size_y_var) free(bulk_size_y_var);
+    bulk_size_y_var = NULL;
+
+    /* Fill input structure */
+    bulk_write_in_struct.fildes = fildes;
+    bulk_write_in_struct.bulk_handle = bulk_handle;
+
+    /* Forward call to remote addr and get a new request */
+    printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_seg_write_id_g);
+    hg_ret = HG_Forward(handle, hg_test_bulk_seg_forward_cb, request,
+            &bulk_write_in_struct);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not forward call\n");
+        return EXIT_FAILURE;
+    }
+
+    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+    /* Free memory handle */
+    hg_ret = HG_Bulk_free(bulk_handle);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not free bulk data handle\n");
+        return EXIT_FAILURE;
+    }
+
+    /* Complete */
+    hg_ret = HG_Destroy(handle);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not complete\n");
+        return EXIT_FAILURE;
+    }
+
+    hg_request_destroy(request);
+
+    HG_Test_finalize(&hg_test_info);
+
+    /* Free bulk_buf */
+    for (i = 0; i < bulk_size_x; i++) {
+        free(bulk_buf[i]);
+        bulk_buf[i] = NULL;
+    }
+    free(bulk_buf);
+    bulk_buf = NULL;
+
+    return EXIT_SUCCESS;
+}
diff --git a/Testing/test_cancel.c b/Testing/test_cancel.c
new file mode 100644
index 0000000..5e1b834
--- /dev/null
+++ b/Testing/test_cancel.c
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#include "mercury_test.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+extern hg_id_t hg_test_cancel_rpc_id_g;
+
+//#define HG_TEST_DEBUG
+#ifdef HG_TEST_DEBUG
+#define HG_TEST_LOG_DEBUG(...)                                \
+    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
+#else
+#define HG_TEST_LOG_DEBUG(...) (void)0
+#endif
+
+/*---------------------------------------------------------------------------*/
+/**
+ * HG_Forward callback
+ */
+static hg_return_t
+hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
+{
+    hg_request_t *request = (hg_request_t *) callback_info->arg;
+    hg_return_t ret = HG_SUCCESS;
+
+    if (callback_info->ret != HG_CANCELED) {
+        HG_TEST_LOG_DEBUG("Error: HG_Forward() was not canceled: %d",
+            callback_info->ret);
+    } else {
+        HG_TEST_LOG_DEBUG("HG_Forward() was successfully canceled");
+    }
+
+    hg_request_complete(request);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
+{
+    hg_request_t *request = NULL;
+    hg_handle_t handle;
+    hg_return_t ret = HG_SUCCESS;
+
+    request = hg_request_create(request_class);
+
+    /* Create RPC request */
+    ret = HG_Create(context, addr, rpc_id, &handle);
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create handle");
+        goto done;
+    }
+
+    /* Forward call to remote addr and get a new request */
+    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
+    ret = HG_Forward(handle, callback, request, NULL);
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not forward call");
+        goto done;
+    }
+
+    /* Cancel request */
+    ret = HG_Cancel(handle);
+    if (ret != HG_SUCCESS && ret != HG_CANCEL_ERROR) {
+        HG_TEST_LOG_ERROR("Could not cancel call");
+        goto done;
+    }
+
+    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+    /* Complete */
+    ret = HG_Destroy(handle);
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
+
+done:
+    hg_request_destroy(request);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+int
+main(int argc, char *argv[])
+{
+    struct hg_test_info hg_test_info = { 0 };
+    hg_return_t hg_ret;
+    int ret = EXIT_SUCCESS;
+
+    /* Initialize the interface */
+    HG_Test_init(argc, argv, &hg_test_info);
+
+    /* Skip for OFI/tcp for now (cancelation of unexpected send is not
+     * guaranteed by underlying provider) */
+    if (!(strcmp(HG_Class_get_name(hg_test_info.hg_class), "ofi"))
+        && !strcmp(hg_test_info.na_test_info.protocol, "tcp"))
+        goto done;
+
+    /* Cancel RPC test */
+    HG_TEST("cancel RPC");
+    hg_ret = hg_test_cancel_rpc(hg_test_info.context,
+        hg_test_info.request_class, hg_test_info.target_addr,
+        hg_test_cancel_rpc_id_g, hg_test_rpc_forward_cb);
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    HG_PASSED();
+
+done:
+    if (ret != EXIT_SUCCESS)
+        HG_FAILED();
+    HG_Test_finalize(&hg_test_info);
+    return ret;
+}
diff --git a/Testing/test_multiple.c b/Testing/test_multiple.c
new file mode 100644
index 0000000..6c80d21
--- /dev/null
+++ b/Testing/test_multiple.c
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#include "mercury_test.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+extern hg_id_t hg_test_rpc_open_id_g;
+extern hg_id_t hg_test_bulk_write_id_g;
+
+/******************************************************************************/
+int main(int argc, char *argv[])
+{
+    hg_addr_t addr;
+
+    rpc_open_in_t  rpc_open_in_struct;
+    rpc_open_out_t rpc_open_out_struct;
+    hg_request_t rpc_open_request;
+
+    bulk_write_in_t bulk_write_in_struct;
+    bulk_write_out_t bulk_write_out_struct;
+    hg_request_t bulk_write_request;
+
+    hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
+    rpc_handle_t rpc_open_handle;
+    int rpc_open_ret = 0;
+    int rpc_open_event_id = 0;
+
+    int fildes = 12345;
+    int *bulk_buf = NULL;
+    size_t bulk_size = 1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE / sizeof(int);
+    hg_bulk_t bulk_handle = HG_BULK_NULL;
+    size_t bulk_write_ret = 0;
+
+    hg_status_t rpc_open_status;
+    hg_status_t bulk_write_status;
+    hg_return_t hg_ret;
+    size_t i;
+
+    /* Prepare bulk_buf */
+    bulk_buf = (int*) malloc(sizeof(int) * bulk_size);
+    for (i = 0; i < bulk_size; i++) {
+        bulk_buf[i] = i;
+    }
+
+    /* Initialize the interface (for convenience, shipper_test_client_init
+     * initializes the network interface with the selected plugin)
+     */
+    HG_Test_client_init(argc, argv, &addr, NULL);
+
+    /* Register memory */
+    hg_ret = HG_Bulk_handle_create(bulk_buf, sizeof(int) * bulk_size, HG_BULK_READ_ONLY,
+            &bulk_handle);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not create bulk data handle\n");
+        return EXIT_FAILURE;
+    }
+
+    /* Fill input structure */
+    rpc_open_handle.cookie = 12345;
+    rpc_open_in_struct.path = rpc_open_path;
+    rpc_open_in_struct.handle = rpc_open_handle;
+    bulk_write_in_struct.fildes = fildes;
+    bulk_write_in_struct.bulk_handle = bulk_handle;
+
+    /* Forward call to remote addr and get a new request */
+    printf("Forwarding rpc_open, op id: %u...\n", hg_test_rpc_open_id_g);
+    hg_ret = HG_Forward(addr, hg_test_rpc_open_id_g, &rpc_open_in_struct,
+            &rpc_open_out_struct, &rpc_open_request);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not forward call\n");
+        return EXIT_FAILURE;
+    }
+    printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_write_id_g);
+    hg_ret = HG_Forward(addr, hg_test_bulk_write_id_g,
+            &bulk_write_in_struct, &bulk_write_out_struct, &bulk_write_request);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not forward call\n");
+        return EXIT_FAILURE;
+    }
+
+    /* Wait for call to be executed and return value to be sent back
+     * (Request is freed when the call completes)
+     */
+    hg_ret = HG_Wait(rpc_open_request, HG_MAX_IDLE_TIME, &rpc_open_status);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Error during wait\n");
+        return EXIT_FAILURE;
+    }
+    if (!rpc_open_status) {
+        fprintf(stderr, "Operation did not complete\n");
+        return EXIT_FAILURE;
+    } else {
+        printf("Call completed\n");
+    }
+    hg_ret = HG_Wait(bulk_write_request, HG_MAX_IDLE_TIME, &bulk_write_status);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Error during wait\n");
+        return EXIT_FAILURE;
+    }
+    if (!bulk_write_status) {
+        fprintf(stderr, "Operation did not complete\n");
+        return EXIT_FAILURE;
+    } else {
+        printf("Call completed\n");
+    }
+
+    /* Get output parameters */
+    rpc_open_ret = rpc_open_out_struct.ret;
+    rpc_open_event_id = rpc_open_out_struct.event_id;
+    printf("rpc_open returned: %d with event_id: %d\n", rpc_open_ret, rpc_open_event_id);
+    bulk_write_ret = bulk_write_out_struct.ret;
+    printf("bulk_write returned: %lu\n", bulk_write_ret);
+
+    /* Free request */
+    hg_ret = HG_Request_free(rpc_open_request);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not free request\n");
+        return EXIT_FAILURE;
+    }
+    hg_ret = HG_Request_free(bulk_write_request);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not free request\n");
+        return EXIT_FAILURE;
+    }
+
+    /* Free memory handle */
+    hg_ret = HG_Bulk_handle_free(bulk_handle);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not free bulk data handle\n");
+        return EXIT_FAILURE;
+    }
+
+    /* Free bulk data */
+    free(bulk_buf);
+
+    HG_Test_finalize();
+
+    return EXIT_SUCCESS;
+}
diff --git a/Testing/test_multiple.h b/Testing/test_multiple.h
new file mode 100644
index 0000000..b497125
--- /dev/null
+++ b/Testing/test_multiple.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#ifndef TEST_MULTIPLE_H
+#define TEST_MULTIPLE_H
+
+#include "test_rpc.h"
+#include "test_bulk.h"
+
+#endif /* TEST_MULTIPLE_H */
diff --git a/Testing/test_overflow.c b/Testing/test_overflow.c
new file mode 100644
index 0000000..49499a6
--- /dev/null
+++ b/Testing/test_overflow.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#include "mercury_test.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+extern hg_id_t hg_test_overflow_id_g;
+
+//#define HG_TEST_DEBUG
+#ifdef HG_TEST_DEBUG
+#define HG_TEST_LOG_DEBUG(...)                                \
+    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
+#else
+#define HG_TEST_LOG_DEBUG(...) (void)0
+#endif
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
+{
+    hg_handle_t handle = callback_info->info.forward.handle;
+    hg_request_t *request = (hg_request_t *) callback_info->arg;
+    overflow_out_t out_struct;
+    hg_string_t string;
+    size_t string_len;
+    hg_return_t ret = HG_SUCCESS;
+
+    if (callback_info->ret != HG_SUCCESS) {
+        HG_TEST_LOG_WARNING("Return from callback info is not HG_SUCCESS");
+        goto done;
+    }
+
+    /* Get output */
+    ret = HG_Get_output(handle, &out_struct);
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not get output");
+        goto done;
+    }
+
+    /* Get output parameters */
+    string = out_struct.string;
+    string_len = out_struct.string_len;
+    HG_TEST_LOG_DEBUG("Returned string (length %zu): %s", string_len, string);
+    (void) string;
+    (void) string_len;
+
+    /* Free request */
+    ret = HG_Free_output(handle, &out_struct);
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not free output");
+        goto done;
+    }
+
+done:
+    hg_request_complete(request);
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static hg_return_t
+hg_test_overflow(hg_context_t *context, hg_request_class_t *request_class,
+    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
+{
+    hg_request_t *request = NULL;
+    hg_handle_t handle;
+    hg_return_t hg_ret = HG_SUCCESS;
+
+    request = hg_request_create(request_class);
+
+    /* Create RPC request */
+    hg_ret = HG_Create(context, addr, rpc_id, &handle);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create handle");
+        goto done;
+    }
+
+    /* Forward call to remote addr and get a new request */
+    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
+    hg_ret = HG_Forward(handle, callback, request, NULL);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not forward call");
+        goto done;
+    }
+
+    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
+
+    /* Complete */
+    hg_ret = HG_Destroy(handle);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
+
+done:
+    hg_request_destroy(request);
+    return hg_ret;
+}
+
+/*---------------------------------------------------------------------------*/
+int
+main(int argc, char *argv[])
+{
+    struct hg_test_info hg_test_info = { 0 };
+    hg_return_t hg_ret;
+    int ret = EXIT_SUCCESS;
+
+    /* Initialize the interface */
+    HG_Test_init(argc, argv, &hg_test_info);
+
+    /* Overflow RPC test */
+    HG_TEST("overflow RPC");
+    hg_ret = hg_test_overflow(hg_test_info.context, hg_test_info.request_class,
+        hg_test_info.target_addr, hg_test_overflow_id_g,
+        hg_test_rpc_forward_cb);
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
+    HG_PASSED();
+
+done:
+    if (ret != EXIT_SUCCESS)
+        HG_FAILED();
+    HG_Test_finalize(&hg_test_info);
+    return ret;
+}
diff --git a/Testing/test_overflow.h b/Testing/test_overflow.h
index b85a72c..7fad03a 100644
--- a/Testing/test_overflow.h
+++ b/Testing/test_overflow.h
@@ -32,12 +32,16 @@ hg_proc_overflow_out_t(hg_proc_t proc, void *data)
     overflow_out_t *struct_data = (overflow_out_t *) data;
 
     ret = hg_proc_hg_string_t(proc, &struct_data->string);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_hg_uint64_t(proc, &struct_data->string_len);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
diff --git a/Testing/test_pipeline.c b/Testing/test_pipeline.c
new file mode 100644
index 0000000..9f540a0
--- /dev/null
+++ b/Testing/test_pipeline.c
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2013-2019 Argonne National Laboratory, Department of Energy,
+ *                    UChicago Argonne, LLC and The HDF Group.
+ * All rights reserved.
+ *
+ * The full copyright notice, including terms governing use, modification,
+ * and redistribution, is contained in the COPYING file that can be
+ * found at the root of the source code distribution tree.
+ */
+
+#include "mercury_test.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+extern hg_id_t hg_test_pipeline_write_id_g;
+
+/*****************************************************************************/
+int main(int argc, char *argv[])
+{
+    hg_addr_t addr;
+
+    bulk_write_in_t bulk_write_in_struct;
+    bulk_write_out_t bulk_write_out_struct;
+    hg_request_t bulk_write_request;
+
+    int fildes = 12345;
+    int *bulk_buf;
+    void *buf_ptr[1];
+    size_t count = (1024 * 1024 * MERCURY_TESTING_BUFFER_SIZE) / sizeof(int);
+    size_t bulk_size = count * sizeof(int);
+    hg_bulk_t bulk_handle = HG_BULK_NULL;
+    size_t bulk_write_ret = 0;
+
+    hg_status_t bla_open_status;
+    hg_return_t hg_ret;
+    size_t i;
+
+    /* Initialize the interface (for convenience, shipper_test_client_init
+     * initializes the network interface with the selected plugin)
+     */
+    HG_Test_client_init(argc, argv, &addr, NULL);
+
+    /* Prepare bulk_buf */
+    bulk_buf = (int*) malloc(bulk_size);
+    for (i = 0; i < count; i++) {
+        bulk_buf[i] = (int) i;
+    }
+    *buf_ptr = bulk_buf;
+
+    /* Register memory */
+    hg_ret = HG_Bulk_handle_create(1, buf_ptr, &bulk_size,
+            HG_BULK_READ_ONLY, &bulk_handle);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not create bulk data handle\n");
+        return EXIT_FAILURE;
+    }
+
+    /* Fill input structure */
+    bulk_write_in_struct.fildes = fildes;
+    bulk_write_in_struct.bulk_handle = bulk_handle;
+
+    /* Forward call to remote addr and get a new request */
+    /* printf("Forwarding bulk_write, op id: %u...\n", hg_test_bulk_write_id_g); */
+    hg_ret = HG_Forward(addr, hg_test_pipeline_write_id_g,
+            &bulk_write_in_struct, &bulk_write_out_struct, &bulk_write_request);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not forward call\n");
+        return EXIT_FAILURE;
+    }
+
+    /* Wait for call to be executed and return value to be sent back
+     * (Request is freed when the call completes)
+     */
+    hg_ret = HG_Wait(bulk_write_request, HG_MAX_IDLE_TIME, &bla_open_status);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Error during wait\n");
+        return EXIT_FAILURE;
+    }
+    if (!bla_open_status) {
+        fprintf(stderr, "Operation did not complete\n");
+        return EXIT_FAILURE;
+    } else {
+        /* printf("Call completed\n"); */
+    }
+
+    /* Get output parameters */
+    bulk_write_ret = bulk_write_out_struct.ret;
+    if (bulk_write_ret != bulk_size) {
+        fprintf(stderr, "Data not correctly processed\n");
+    }
+
+    /* Free request */
+    hg_ret = HG_Request_free(bulk_write_request);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not free request\n");
+        return EXIT_FAILURE;
+    }
+
+    /* Free memory handle */
+    hg_ret = HG_Bulk_handle_free(bulk_handle);
+    if (hg_ret != HG_SUCCESS) {
+        fprintf(stderr, "Could not free bulk data handle\n");
+        return EXIT_FAILURE;
+    }
+
+    /* Free bulk_buf */
+    free(bulk_buf);
+    bulk_buf = NULL;
+
+    HG_Test_finalize();
+
+    return EXIT_SUCCESS;
+}
diff --git a/Testing/test_posix.h b/Testing/test_posix.h
index 9e88136..770f946 100644
--- a/Testing/test_posix.h
+++ b/Testing/test_posix.h
@@ -66,16 +66,22 @@ hg_proc_open_in_t(hg_proc_t proc, void *data)
     open_in_t *struct_data = (open_in_t *) data;
 
     ret = hg_proc_hg_const_string_t(proc, &struct_data->path);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_int32_t(proc, &struct_data->flags);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_uint32_t(proc, &struct_data->mode);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -93,8 +99,10 @@ hg_proc_open_out_t(hg_proc_t proc, void *data)
     open_out_t *struct_data = (open_out_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -112,8 +120,10 @@ hg_proc_close_in_t(hg_proc_t proc, void *data)
     close_in_t *struct_data = (close_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fd);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -131,8 +141,10 @@ hg_proc_close_out_t(hg_proc_t proc, void *data)
     close_out_t *struct_data = (close_out_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -151,12 +163,16 @@ hg_proc_write_in_t(hg_proc_t proc, void *data)
     write_in_t *struct_data = (write_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fd);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -174,8 +190,10 @@ hg_proc_write_out_t(hg_proc_t proc, void *data)
     write_out_t *struct_data = (write_out_t *) data;
 
     ret = hg_proc_int64_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -194,12 +212,16 @@ hg_proc_read_in_t(hg_proc_t proc, void *data)
     read_in_t *struct_data = (read_in_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->fd);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_hg_bulk_t(proc, &struct_data->bulk_handle);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -217,8 +239,10 @@ hg_proc_read_out_t(hg_proc_t proc, void *data)
     read_out_t *struct_data = (read_out_t *) data;
 
     ret = hg_proc_int64_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
diff --git a/Testing/test_rpc.c b/Testing/test_rpc.c
index 2146b0e..789ca88 100644
--- a/Testing/test_rpc.c
+++ b/Testing/test_rpc.c
@@ -14,67 +14,28 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-/****************/
-/* Local Macros */
-/****************/
+extern hg_id_t hg_test_rpc_open_id_g;
+extern hg_id_t hg_test_rpc_open_id_no_resp_g;
 
 #define NINFLIGHT 32
 
-/************************************/
-/* Local Type and Struct Definition */
-/************************************/
-
 struct forward_cb_args {
     hg_request_t *request;
     rpc_handle_t *rpc_handle;
 };
 
-/********************/
-/* Local Prototypes */
-/********************/
-
-static hg_return_t
-hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info);
-static hg_return_t
-hg_test_rpc_forward_no_resp_cb(const struct hg_cb_info *callback_info);
-static hg_return_t
-hg_test_rpc_forward_reset_cb(const struct hg_cb_info *callback_info);
-static hg_return_t
-hg_test_rpc_forward_overflow_cb(const struct hg_cb_info *callback_info);
-
-static hg_return_t
-hg_test_rpc(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
-static hg_return_t
-hg_test_rpc_lookup(hg_context_t *context, hg_request_class_t *request_class,
-    const char *target_name, hg_id_t rpc_id, hg_cb_t callback);
-static hg_return_t
-hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
-static hg_return_t
-hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
-static hg_return_t
-hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_uint8_t target_id, hg_id_t rpc_id, hg_cb_t callback);
-static hg_return_t
-hg_test_overflow(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
-static hg_return_t
-hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback);
-
-
-/*******************/
-/* Local Variables */
-/*******************/
-
-extern hg_id_t hg_test_rpc_open_id_g;
-extern hg_id_t hg_test_rpc_open_id_no_resp_g;
-extern hg_id_t hg_test_overflow_id_g;
-extern hg_id_t hg_test_cancel_rpc_id_g;
+//#define HG_TEST_DEBUG
+#ifdef HG_TEST_DEBUG
+#define HG_TEST_LOG_DEBUG(...)                                \
+    HG_LOG_WRITE_DEBUG(HG_TEST_LOG_MODULE_NAME, __VA_ARGS__)
+#else
+#define HG_TEST_LOG_DEBUG(...) (void)0
+#endif
 
 /*---------------------------------------------------------------------------*/
+/**
+ * HG_Forward callback
+ */
 static hg_return_t
 hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
 {
@@ -85,16 +46,17 @@ hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
     rpc_open_out_t rpc_open_out_struct;
     hg_return_t ret = HG_SUCCESS;
 
-    if (callback_info->ret == HG_NOENTRY)
+    if (callback_info->ret != HG_SUCCESS) {
+        HG_TEST_LOG_DEBUG("Return from callback info is not HG_SUCCESS");
         goto done;
-
-    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
-        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
+    }
 
     /* Get output */
     ret = HG_Get_output(handle, &rpc_open_out_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not get output");
+        goto done;
+    }
 
     /* Get output parameters */
     rpc_open_ret = rpc_open_out_struct.ret;
@@ -102,13 +64,17 @@ hg_test_rpc_forward_cb(const struct hg_cb_info *callback_info)
     HG_TEST_LOG_DEBUG("rpc_open returned: %d with event_id: %d", rpc_open_ret,
         rpc_open_event_id);
     (void)rpc_open_ret;
-    HG_TEST_CHECK_ERROR(rpc_open_event_id != (int) args->rpc_handle->cookie,
-        done, ret, HG_FAULT, "Cookie did not match RPC response");
+    if (rpc_open_event_id != (int) args->rpc_handle->cookie) {
+        HG_TEST_LOG_ERROR("Cookie did not match RPC response");
+        goto done;
+    }
 
     /* Free request */
     ret = HG_Free_output(handle, &rpc_open_out_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not free output");
+        goto done;
+    }
 
 done:
     hg_request_complete(args->request);
@@ -116,14 +82,19 @@ done:
 }
 
 /*---------------------------------------------------------------------------*/
+/**
+ * HG_Forward callback (no response)
+ */
 static hg_return_t
 hg_test_rpc_forward_no_resp_cb(const struct hg_cb_info *callback_info)
 {
     struct forward_cb_args *args = (struct forward_cb_args *) callback_info->arg;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
-        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
+    if (callback_info->ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
+        goto done;
+    }
 
 done:
     hg_request_complete(args->request);
@@ -137,91 +108,44 @@ hg_test_rpc_forward_reset_cb(const struct hg_cb_info *callback_info)
     struct forward_cb_args *args = (struct forward_cb_args *) callback_info->arg;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
-        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
+    if (callback_info->ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Return from callback info is not HG_SUCCESS");
+        goto done;
+    }
 
     ret = HG_Reset(callback_info->info.forward.handle, HG_ADDR_NULL, 0);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Reset() failed (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not reset handle");
+        goto done;
+    }
 
 done:
     hg_request_complete(args->request);
     return ret;
 }
 
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_rpc_forward_overflow_cb(const struct hg_cb_info *callback_info)
-{
-    hg_handle_t handle = callback_info->info.forward.handle;
-    hg_request_t *request = (hg_request_t *) callback_info->arg;
-    overflow_out_t out_struct;
-    hg_string_t string;
-    size_t string_len;
-    hg_return_t ret = HG_SUCCESS;
-
-    HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
-        "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
-
-    /* Get output */
-    ret = HG_Get_output(handle, &out_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Get_output() failed (%s)",
-        HG_Error_to_string(ret));
-
-    /* Get output parameters */
-    string = out_struct.string;
-    string_len = out_struct.string_len;
-    HG_TEST_LOG_DEBUG("Returned string (length %zu): %s", string_len, string);
-
-    /* Free request */
-    ret = HG_Free_output(handle, &out_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Free_output() failed (%s)",
-        HG_Error_to_string(ret));
-
-done:
-    hg_request_complete(request);
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_rpc_forward_cancel_cb(const struct hg_cb_info *callback_info)
-{
-    hg_request_t *request = (hg_request_t *) callback_info->arg;
-    hg_return_t ret = HG_SUCCESS;
-
-    if (callback_info->ret == HG_CANCELED)
-        HG_TEST_LOG_DEBUG("HG_Forward() was successfully canceled");
-    else
-        HG_TEST_CHECK_ERROR_NORET(callback_info->ret != HG_SUCCESS, done,
-            "Error in HG callback (%s)", HG_Error_to_string(callback_info->ret));
-
-done:
-    hg_request_complete(request);
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 static hg_return_t
 hg_test_rpc(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
-    hg_handle_t handle = HG_HANDLE_NULL;
-    hg_return_t ret = HG_SUCCESS;
+    hg_handle_t handle;
+    hg_return_t hg_ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
     hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
-    rpc_open_in_t rpc_open_in_struct;
+    rpc_open_in_t  rpc_open_in_struct;
 
     request = hg_request_create(request_class);
 
     /* Create RPC request */
-    ret = HG_Create(context, addr, rpc_id, &handle);
-    if (ret == HG_NOENTRY)
+    hg_ret = HG_Create(context, addr, rpc_id, &handle);
+    if (hg_ret != HG_SUCCESS) {
+        if (hg_ret != HG_NO_MATCH)
+            HG_TEST_LOG_ERROR("Could not create handle");
         goto done;
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
+    }
 
     /* Fill input structure */
     rpc_open_handle.cookie = 100;
@@ -232,26 +156,25 @@ hg_test_rpc(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args.request = request;
     forward_cb_args.rpc_handle = &rpc_open_handle;
-again:
-    ret = HG_Forward(handle, callback, &forward_cb_args,
+    hg_ret = HG_Forward(handle, callback, &forward_cb_args,
         &rpc_open_in_struct);
-    if (ret == HG_AGAIN) {
-        hg_request_wait(request, 0, NULL);
-        goto again;
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not forward call");
+        goto done;
     }
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
-done:
-    ret = HG_Destroy(handle);
-    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
+    /* Complete */
+    hg_ret = HG_Destroy(handle);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
 
+done:
     hg_request_destroy(request);
-
-    return ret;
+    return hg_ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -260,12 +183,12 @@ hg_test_rpc_lookup(hg_context_t *context, hg_request_class_t *request_class,
     const char *target_name, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
-    hg_handle_t handle = HG_HANDLE_NULL;
-    hg_return_t ret = HG_SUCCESS;
+    hg_handle_t handle;
+    hg_return_t hg_ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
     hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
-    rpc_open_in_t rpc_open_in_struct;
+    rpc_open_in_t  rpc_open_in_struct;
     hg_addr_t target_addr = HG_ADDR_NULL;
     int i;
 
@@ -273,15 +196,18 @@ hg_test_rpc_lookup(hg_context_t *context, hg_request_class_t *request_class,
         request = hg_request_create(request_class);
 
         /* Look up target addr using target name info */
-        ret = HG_Hl_addr_lookup_wait(context, request_class, target_name,
+        hg_ret = HG_Hl_addr_lookup_wait(context, request_class, target_name,
             &target_addr, HG_MAX_IDLE_TIME);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Hl_addr_lookup_wait() failed (%s)",
-            HG_Error_to_string(ret));
+        if (hg_ret != HG_SUCCESS)
+            goto done;
 
         /* Create RPC request */
-        ret = HG_Create(context, target_addr, rpc_id, &handle);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-            HG_Error_to_string(ret));
+        hg_ret = HG_Create(context, target_addr, rpc_id, &handle);
+        if (hg_ret != HG_SUCCESS) {
+            if (hg_ret != HG_NO_MATCH)
+                HG_TEST_LOG_ERROR("Could not create handle");
+            goto done;
+        }
 
         /* Fill input structure */
         rpc_open_handle.cookie = 100;
@@ -292,35 +218,32 @@ hg_test_rpc_lookup(hg_context_t *context, hg_request_class_t *request_class,
         HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
         forward_cb_args.request = request;
         forward_cb_args.rpc_handle = &rpc_open_handle;
-        ret = HG_Forward(handle, callback, &forward_cb_args,
+        hg_ret = HG_Forward(handle, callback, &forward_cb_args,
             &rpc_open_in_struct);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-            HG_Error_to_string(ret));
+        if (hg_ret != HG_SUCCESS) {
+            HG_TEST_LOG_ERROR("Could not forward call");
+            goto done;
+        }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
         /* Complete */
-        ret = HG_Destroy(handle);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
-            HG_Error_to_string(ret));
+        hg_ret = HG_Destroy(handle);
+        if (hg_ret != HG_SUCCESS) {
+            HG_TEST_LOG_ERROR("Could not destroy handle");
+            goto done;
+        }
 
-        ret = HG_Addr_set_remove(context->hg_class, target_addr);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_set_remove() failed (%s)",
-            HG_Error_to_string(ret));
-
-        ret = HG_Addr_free(context->hg_class, target_addr);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Addr_free() failed (%s)",
-            HG_Error_to_string(ret));
+        HG_Addr_set_remove(context->hg_class, target_addr);
+        HG_Addr_free(context->hg_class, target_addr);
         target_addr = HG_ADDR_NULL;
-
         hg_request_destroy(request);
         request = NULL;
     }
 
 done:
     hg_request_destroy(request);
-
-    return ret;
+    return hg_ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -329,24 +252,28 @@ hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
-    hg_handle_t handle = HG_HANDLE_NULL;
-    hg_return_t ret = HG_SUCCESS;
+    hg_handle_t handle;
+    hg_return_t hg_ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
     hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
-    rpc_open_in_t rpc_open_in_struct;
+    rpc_open_in_t  rpc_open_in_struct;
 
     request = hg_request_create(request_class);
 
     /* Create request with invalid RPC id */
-    ret = HG_Create(context, HG_ADDR_NULL, 0, &handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
+    hg_ret = HG_Create(context, HG_ADDR_NULL, 0, &handle);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create handle");
+        goto done;
+    }
 
     /* Reset with valid addr and ID */
-    ret = HG_Reset(handle, addr, rpc_id);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Reset() failed (%s)",
-        HG_Error_to_string(ret));
+    hg_ret = HG_Reset(handle, addr, rpc_id);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not reset handle");
+        goto done;
+    }
 
     /* Fill input structure */
     rpc_open_handle.cookie = 100;
@@ -357,21 +284,26 @@ hg_test_rpc_reset(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args.request = request;
     forward_cb_args.rpc_handle = &rpc_open_handle;
-    ret = HG_Forward(handle, callback, &forward_cb_args,
+    hg_ret = HG_Forward(handle, callback, &forward_cb_args,
         &rpc_open_in_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not forward call");
+        goto done;
+    }
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
-done:
-    ret = HG_Destroy(handle);
-    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
+    /* Complete */
+    hg_ret = HG_Destroy(handle);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
 
     hg_request_destroy(request);
 
-    return ret;
+done:
+    return hg_ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -380,8 +312,8 @@ hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
     hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
 {
     hg_request_t *request = NULL;
-    hg_handle_t handle = HG_HANDLE_NULL;
-    hg_return_t ret = HG_SUCCESS;
+    hg_handle_t handle;
+    hg_return_t hg_ret = HG_SUCCESS;
     struct forward_cb_args forward_cb_args;
     hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle;
@@ -390,13 +322,13 @@ hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
     request = hg_request_create(request_class);
 
     /* Create request with invalid RPC id */
-    ret = HG_Create(context, addr, rpc_id, &handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
+    hg_ret = HG_Create(context, addr, rpc_id, &handle);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create handle");
+        goto done;
+    }
 
-    ret = HG_Set_target_id(handle, 0);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
-        HG_Error_to_string(ret));
+    HG_Set_target_id(handle, 0);
 
     /* Fill input structure */
     rpc_open_handle.cookie = 100;
@@ -407,21 +339,26 @@ hg_test_rpc_mask(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args.request = request;
     forward_cb_args.rpc_handle = &rpc_open_handle;
-    ret = HG_Forward(handle, callback, &forward_cb_args,
+    hg_ret = HG_Forward(handle, callback, &forward_cb_args,
         &rpc_open_in_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not forward call");
+        goto done;
+    }
 
     hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
 
-done:
-    ret = HG_Destroy(handle);
-    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
+    /* Complete */
+    hg_ret = HG_Destroy(handle);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
 
     hg_request_destroy(request);
 
-    return ret;
+done:
+    return hg_ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -432,8 +369,8 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     hg_request_t *request1 = NULL, *request2 = NULL;
     hg_handle_t handle1, handle2;
     struct forward_cb_args forward_cb_args1, forward_cb_args2;
-    hg_return_t ret = HG_SUCCESS;
-    rpc_open_in_t rpc_open_in_struct;
+    hg_return_t hg_ret = HG_SUCCESS;
+    rpc_open_in_t  rpc_open_in_struct;
     hg_const_string_t rpc_open_path = MERCURY_TESTING_TEMP_DIRECTORY "/test.h5";
     rpc_handle_t rpc_open_handle1, rpc_open_handle2;
     /* Used for multiple in-flight RPCs */
@@ -446,13 +383,16 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     /* Create request 1 */
     request1 = hg_request_create(request_class);
 
-    ret = HG_Create(context, addr, rpc_id, &handle1);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
-
-    ret = HG_Set_target_id(handle1, target_id);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
-        HG_Error_to_string(ret));
+    hg_ret = HG_Create(context, addr, rpc_id, &handle1);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create handle");
+        goto done;
+    }
+    hg_ret = HG_Set_target_id(handle1, target_id);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not set target ID to handle");
+        goto done;
+    }
 
     /* Fill input structure */
     rpc_open_handle1.cookie = 1;
@@ -463,20 +403,26 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args1.request = request1;
     forward_cb_args1.rpc_handle = &rpc_open_handle1;
-    ret = HG_Forward(handle1, callback, &forward_cb_args1, &rpc_open_in_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
+    hg_ret = HG_Forward(handle1, callback, &forward_cb_args1,
+        &rpc_open_in_struct);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create handle");
+        goto done;
+    }
 
     /* Create request 2 */
     request2 = hg_request_create(request_class);
 
-    ret = HG_Create(context, addr, rpc_id, &handle2);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
-
-    ret = HG_Set_target_id(handle2, target_id);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
-        HG_Error_to_string(ret));
+    hg_ret = HG_Create(context, addr, rpc_id, &handle2);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not create handle");
+        goto done;
+    }
+    hg_ret = HG_Set_target_id(handle2, target_id);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not set target ID to handle");
+        goto done;
+    }
 
     /* Fill input structure */
     rpc_open_handle2.cookie = 2;
@@ -487,21 +433,27 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
     HG_TEST_LOG_DEBUG("Forwarding rpc_open, op id: %u...", rpc_id);
     forward_cb_args2.request = request2;
     forward_cb_args2.rpc_handle = &rpc_open_handle2;
-    ret = HG_Forward(handle2, callback, &forward_cb_args2, &rpc_open_in_struct);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
+    hg_ret = HG_Forward(handle2, callback, &forward_cb_args2,
+        &rpc_open_in_struct);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not forward call");
+        goto done;
+    }
 
     hg_request_wait(request2, HG_MAX_IDLE_TIME, NULL);
     hg_request_wait(request1, HG_MAX_IDLE_TIME, NULL);
 
     /* Complete */
-    ret = HG_Destroy(handle1);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
-
-    ret = HG_Destroy(handle2);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
+    hg_ret = HG_Destroy(handle1);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
+    hg_ret = HG_Destroy(handle2);
+    if (hg_ret != HG_SUCCESS) {
+        HG_TEST_LOG_ERROR("Could not destroy handle");
+        goto done;
+    }
 
     hg_request_destroy(request1);
     hg_request_destroy(request2);
@@ -511,115 +463,46 @@ hg_test_rpc_multiple(hg_context_t *context, hg_request_class_t *request_class,
      */
     HG_TEST_LOG_DEBUG("Creating %u requests...", NINFLIGHT);
     for (i = 0; i < NINFLIGHT; i++) {
-        request_m[i] = hg_request_create(request_class);
-        ret = HG_Create(context, addr, rpc_id, handle_m + i);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-            HG_Error_to_string(ret));
-
-        ret = HG_Set_target_id(handle_m[i], target_id);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
-            HG_Error_to_string(ret));
-
-        rpc_open_handle_m[i].cookie = i;
-        rpc_open_in_struct.path = rpc_open_path;
-        rpc_open_in_struct.handle = rpc_open_handle_m[i];
-        HG_TEST_LOG_DEBUG(" %d Forwarding rpc_open, op id: %u...", i, rpc_id);
-        forward_cb_args_m[i].request = request_m[i];
-        forward_cb_args_m[i].rpc_handle = &rpc_open_handle_m[i];
-        ret = HG_Forward(handle_m[i], callback, &forward_cb_args_m[i],
-            &rpc_open_in_struct);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-            HG_Error_to_string(ret));
+	    request_m[i] = hg_request_create(request_class);
+	    hg_ret = HG_Create(context, addr, rpc_id, handle_m + i );
+	    if (hg_ret != HG_SUCCESS) {
+	        HG_TEST_LOG_ERROR("Could not create handle");
+		    goto done;
+	    }
+	    hg_ret = HG_Set_target_id(handle_m[i], target_id);
+	    if (hg_ret != HG_SUCCESS) {
+	        HG_TEST_LOG_ERROR("Could not set target ID to handle");
+	        goto done;
+	    }
+	    rpc_open_handle_m[i].cookie = i;
+	    rpc_open_in_struct.path = rpc_open_path;
+	    rpc_open_in_struct.handle = rpc_open_handle_m[i];
+	    HG_TEST_LOG_DEBUG(" %d Forwarding rpc_open, op id: %u...", i, rpc_id);
+	    forward_cb_args_m[i].request = request_m[i];
+	    forward_cb_args_m[i].rpc_handle = &rpc_open_handle_m[i];
+	    hg_ret = HG_Forward(handle_m[i], callback, &forward_cb_args_m[i],
+	        &rpc_open_in_struct);
+	    if (hg_ret != HG_SUCCESS) {
+	        HG_TEST_LOG_ERROR("Could not forward call");
+		    goto done;
+	    }
     }
 
     /* Complete */
     for (i = 0; i < NINFLIGHT; i++) {
-        hg_request_wait(request_m[i], HG_MAX_IDLE_TIME, NULL);
+	    hg_request_wait(request_m[i], HG_MAX_IDLE_TIME, NULL);
 
-        ret = HG_Destroy(handle_m[i]);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
-            HG_Error_to_string(ret));
-
-        hg_request_destroy(request_m[i]);
+	    hg_ret = HG_Destroy(handle_m[i]);
+	    if (hg_ret != HG_SUCCESS) {
+	        HG_TEST_LOG_ERROR("Could not destroy handle");
+		    goto done;
+	    }
+	    hg_request_destroy(request_m[i]);
     }
     HG_TEST_LOG_DEBUG("Done");
 
 done:
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_overflow(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
-{
-    hg_request_t *request = NULL;
-    hg_handle_t handle = HG_HANDLE_NULL;
-    hg_return_t ret = HG_SUCCESS;
-
-    request = hg_request_create(request_class);
-
-    /* Create RPC request */
-    ret = HG_Create(context, addr, rpc_id, &handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
-
-    /* Forward call to remote addr and get a new request */
-    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
-    ret = HG_Forward(handle, callback, request, NULL);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
-
-    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
-
-done:
-    ret = HG_Destroy(handle);
-    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
-
-    hg_request_destroy(request);
-
-    return ret;
-}
-
-/*---------------------------------------------------------------------------*/
-static hg_return_t
-hg_test_cancel_rpc(hg_context_t *context, hg_request_class_t *request_class,
-    hg_addr_t addr, hg_id_t rpc_id, hg_cb_t callback)
-{
-    hg_request_t *request = NULL;
-    hg_handle_t handle = HG_HANDLE_NULL;
-    hg_return_t ret = HG_SUCCESS;
-
-    request = hg_request_create(request_class);
-
-    /* Create RPC request */
-    ret = HG_Create(context, addr, rpc_id, &handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-        HG_Error_to_string(ret));
-
-    /* Forward call to remote addr and get a new request */
-    HG_TEST_LOG_DEBUG("Forwarding RPC, op id: %u...", rpc_id);
-    ret = HG_Forward(handle, callback, request, NULL);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-        HG_Error_to_string(ret));
-
-    /* Cancel request before making progress, this ensures that the RPC has not
-     * completed yet. */
-    ret = HG_Cancel(handle);
-    HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Cancel() failed (%s)",
-        HG_Error_to_string(ret));
-
-    hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
-
-done:
-    ret = HG_Destroy(handle);
-    HG_TEST_CHECK_ERROR_DONE(ret != HG_SUCCESS, "HG_Destroy() failed (%s)",
-        HG_Error_to_string(ret));
-
-    hg_request_destroy(request);
-
-    return ret;
+    return hg_ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -632,39 +515,41 @@ main(int argc, char *argv[])
     int ret = EXIT_SUCCESS;
 
     /* Initialize the interface */
-    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "HG_Test_init() failed");
+    HG_Test_init(argc, argv, &hg_test_info);
 
     /* Simple RPC test */
     HG_TEST("simple RPC");
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_cb);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "simple RPC test failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     /* RPC test with lookup/free */
     if (!hg_test_info.na_test_info.self_send &&
         strcmp(HG_Class_get_name(hg_test_info.hg_class), "mpi")) {
+        HG_TEST("lookup RPC");
         HG_Addr_free(hg_test_info.hg_class, hg_test_info.target_addr);
         hg_test_info.target_addr = HG_ADDR_NULL;
-
-        HG_TEST("lookup RPC");
-        hg_ret = hg_test_rpc_lookup(hg_test_info.context,
-            hg_test_info.request_class, hg_test_info.na_test_info.target_name,
-            hg_test_rpc_open_id_g, hg_test_rpc_forward_cb);
-        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-            "lookup test failed");
-        HG_PASSED();
-
+        hg_ret = hg_test_rpc_lookup(hg_test_info.context, hg_test_info.request_class,
+            hg_test_info.na_test_info.target_name, hg_test_rpc_open_id_g,
+            hg_test_rpc_forward_cb);
+        if (hg_ret != HG_SUCCESS) {
+            ret = EXIT_FAILURE;
+            goto done;
+        }
         /* Look up target addr using target name info */
         hg_ret = HG_Hl_addr_lookup_wait(hg_test_info.context,
             hg_test_info.request_class, hg_test_info.na_test_info.target_name,
             &hg_test_info.target_addr, HG_MAX_IDLE_TIME);
-        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-            "HG_Hl_addr_lookup_wait() failed (%s)", HG_Error_to_string(hg_ret));
+        if (ret != HG_SUCCESS) {
+            ret = EXIT_FAILURE;
+            goto done;
+        }
+        HG_PASSED();
     }
 
     /* RPC reset test */
@@ -672,8 +557,10 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc_reset(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_cb);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "reset RPC test failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     /* RPC test with tag mask */
@@ -681,8 +568,10 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc_mask(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_cb);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "tagged RPC test failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     /* RPC test with no response */
@@ -690,37 +579,37 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_no_resp_g,
         hg_test_rpc_forward_no_resp_cb);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "no response RPC test failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     /* RPC test with unregistered ID */
-    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "unreg_id", void, void,
-        NULL);
-    HG_TEST_CHECK_ERROR(inv_id == 0, done, ret, EXIT_FAILURE,
-        "HG_Register() failed");
-    hg_ret = HG_Deregister(hg_test_info.hg_class, inv_id);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "HG_Deregister() failed (%s)", HG_Error_to_string(hg_ret));
-
     HG_TEST("unregistered RPC");
+    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "unreg_id", void, void, NULL);
+    hg_ret = HG_Deregister(hg_test_info.hg_class, inv_id);
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, inv_id, hg_test_rpc_forward_cb);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "unregistered RPC test failed");
+    if (hg_ret == HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     /* RPC test with invalid ID (not registered on server) */
-    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "inv_id", void, void,
-        NULL);
-    HG_TEST_CHECK_ERROR(inv_id == 0, done, ret, EXIT_FAILURE,
-        "HG_Register() failed");
-
     HG_TEST("invalid RPC");
+    inv_id = MERCURY_REGISTER(hg_test_info.hg_class, "inv_id", void, void, NULL);
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, inv_id, hg_test_rpc_forward_cb);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "invalid RPC test failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     /* RPC test with reset */
@@ -728,8 +617,10 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc(hg_test_info.context, hg_test_info.request_class,
         hg_test_info.target_addr, hg_test_rpc_open_id_g,
         hg_test_rpc_forward_reset_cb);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "reset RPC test failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     /* RPC test with multiple handle in flight */
@@ -737,8 +628,10 @@ main(int argc, char *argv[])
     hg_ret = hg_test_rpc_multiple(hg_test_info.context,
         hg_test_info.request_class, hg_test_info.target_addr, 0,
         hg_test_rpc_open_id_g, hg_test_rpc_forward_cb);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "concurrent RPC test failed");
+    if (hg_ret != HG_SUCCESS) {
+        ret = EXIT_FAILURE;
+        goto done;
+    }
     HG_PASSED();
 
     /* RPC test with multiple handle to multiple target contexts */
@@ -746,43 +639,22 @@ main(int argc, char *argv[])
         hg_uint8_t i, context_count =
             hg_test_info.na_test_info.max_contexts;
 
-        HG_TEST("multi context target RPCs");
+        HG_TEST("multi-target RPCs");
         for (i = 0; i < context_count; i++) {
             hg_ret = hg_test_rpc_multiple(hg_test_info.context,
                 hg_test_info.request_class, hg_test_info.target_addr, i,
                 hg_test_rpc_open_id_g, hg_test_rpc_forward_cb);
-            HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-                "multi context target RPC test failed");
+            if (hg_ret != HG_SUCCESS) {
+                ret = EXIT_FAILURE;
+                goto done;
+            }
         }
         HG_PASSED();
     }
 
-    /* Overflow RPC test */
-    HG_TEST("overflow RPC");
-    hg_ret = hg_test_overflow(hg_test_info.context, hg_test_info.request_class,
-        hg_test_info.target_addr, hg_test_overflow_id_g,
-        hg_test_rpc_forward_overflow_cb);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "overflow RPC test failed");
-    HG_PASSED();
-
-    /* Cancel RPC test (self cancelation is not supported) */
-    if (!hg_test_info.na_test_info.self_send) {
-        HG_TEST("cancel RPC");
-        hg_ret = hg_test_cancel_rpc(hg_test_info.context,
-            hg_test_info.request_class, hg_test_info.target_addr,
-            hg_test_cancel_rpc_id_g, hg_test_rpc_forward_cancel_cb);
-        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-            "cancel RPC test failed");
-        HG_PASSED();
-    }
-
 done:
     if (ret != EXIT_SUCCESS)
         HG_FAILED();
-
-    hg_ret = HG_Test_finalize(&hg_test_info);
-    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
-
+    HG_Test_finalize(&hg_test_info);
     return ret;
 }
diff --git a/Testing/test_rpc.h b/Testing/test_rpc.h
index 6f14eaa..fddc856 100644
--- a/Testing/test_rpc.h
+++ b/Testing/test_rpc.h
@@ -50,8 +50,10 @@ hg_proc_rpc_handle_t(hg_proc_t proc, void *data)
     rpc_handle_t *struct_data = (rpc_handle_t *) data;
 
     ret = hg_proc_uint64_t(proc, &struct_data->cookie);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -70,12 +72,16 @@ hg_proc_rpc_open_in_t(hg_proc_t proc, void *data)
     rpc_open_in_t *struct_data = (rpc_open_in_t *) data;
 
     ret = hg_proc_hg_const_string_t(proc, &struct_data->path);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_rpc_handle_t(proc, &struct_data->handle);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -94,12 +100,16 @@ hg_proc_rpc_open_out_t(hg_proc_t proc, void *data)
     rpc_open_out_t *struct_data = (rpc_open_out_t *) data;
 
     ret = hg_proc_int32_t(proc, &struct_data->ret);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     ret = hg_proc_int32_t(proc, &struct_data->event_id);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     return ret;
 }
@@ -113,8 +123,10 @@ hg_proc_perf_rpc_lat_in_t(hg_proc_t proc, void *data)
     hg_return_t ret = HG_SUCCESS;
 
     ret = hg_proc_hg_uint32_t(proc, &struct_data->buf_size);
-    if (ret != HG_SUCCESS)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Proc error");
         return ret;
+    }
 
     if (struct_data->buf_size) {
         switch (hg_proc_get_op(proc)) {
@@ -123,14 +135,17 @@ hg_proc_perf_rpc_lat_in_t(hg_proc_t proc, void *data)
                 HG_FALLTHROUGH();
             case HG_ENCODE:
                 ret = hg_proc_raw(proc, struct_data->buf, struct_data->buf_size);
-                if (ret != HG_SUCCESS)
+                if (ret != HG_SUCCESS) {
+                    HG_LOG_ERROR("Proc error");
                     return ret;
+                }
                 break;
             case HG_FREE:
                 free(struct_data->buf);
                 break;
             default:
-                ret = HG_INVALID_ARG;
+                HG_LOG_ERROR("Proc error");
+                ret = HG_PROTOCOL_ERROR;
                 return ret;
         }
 
diff --git a/Testing/test_rpc_lat.c b/Testing/test_rpc_lat.c
index 2ddc1bc..a31c3c2 100644
--- a/Testing/test_rpc_lat.c
+++ b/Testing/test_rpc_lat.c
@@ -79,17 +79,12 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
     /* Prepare bulk_buf */
     if (nbytes) {
         bulk_buf = malloc(nbytes);
-        HG_TEST_CHECK_ERROR(bulk_buf == NULL, done, ret, HG_NOMEM_ERROR,
-            "Could not allocate bulk buf");
         for (i = 0; i < nbytes; i++)
             bulk_buf[i] = (char) i;
     }
 
     /* Create handles */
     handles = malloc(nhandles * sizeof(hg_handle_t));
-    HG_TEST_CHECK_ERROR(handles == NULL, done, ret, HG_NOMEM_ERROR,
-        "Could not allocate handles");
-
     for (i = 0; i < nhandles; i++) {
         /* Use NULL RPC ID to skip proc encoding if total_size = 0 */
         hg_id_t rpc_id = total_size ? hg_test_perf_rpc_lat_id_g :
@@ -97,8 +92,10 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
 
         ret = HG_Create(hg_test_info->context, hg_test_info->target_addr,
             rpc_id, &handles[i]);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Create() failed (%s)",
-            HG_Error_to_string(ret));
+        if (ret != HG_SUCCESS) {
+            fprintf(stderr, "Could not start call\n");
+            goto done;
+        }
     }
 
     request = hg_request_create(hg_test_info->request_class);
@@ -117,8 +114,10 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
         for (j = 0; j < nhandles; j++) {
             ret = HG_Forward(handles[j], hg_test_perf_forward_cb,
                 &args, &in_struct);
-            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-                HG_Error_to_string(ret));
+            if (ret != HG_SUCCESS) {
+                fprintf(stderr, "Could not forward call\n");
+                goto done;
+            }
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -137,17 +136,16 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
 
         for (j = 0; j < nhandles; j++) {
             /* Assign handles to multiple targets */
-            if (hg_test_info->na_test_info.max_contexts > 1) {
-                ret = HG_Set_target_id(handles[j],
+            if (hg_test_info->na_test_info.max_contexts > 1)
+                HG_Set_target_id(handles[j],
                     (hg_uint8_t) (avg_iter % hg_test_info->na_test_info.max_contexts));
-                HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Set_target_id() failed (%s)",
-                    HG_Error_to_string(ret));
-            }
 
             ret = HG_Forward(handles[j], hg_test_perf_forward_cb, &args,
 			     &in_struct);
-            HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Forward() failed (%s)",
-                HG_Error_to_string(ret));
+            if (ret != HG_SUCCESS) {
+                fprintf(stderr, "Could not forward call\n");
+                goto done;
+            }
         }
 
         hg_request_wait(request, HG_MAX_IDLE_TIME, NULL);
@@ -180,8 +178,10 @@ measure_rpc_latency(struct hg_test_info *hg_test_info, size_t total_size,
     hg_request_destroy(request);
     for (i = 0; i < nhandles; i++) {
         ret = HG_Destroy(handles[i]);
-        HG_TEST_CHECK_HG_ERROR(done, ret, "HG_Destroy() failed (%s)",
-            HG_Error_to_string(ret));
+        if (ret != HG_SUCCESS) {
+            fprintf(stderr, "Could not complete\n");
+            goto done;
+        }
     }
 
 done:
@@ -197,12 +197,8 @@ main(int argc, char *argv[])
     struct hg_test_info hg_test_info = { 0 };
     unsigned int nhandles;
     size_t size;
-    hg_return_t hg_ret;
-    int ret = EXIT_SUCCESS;
 
-    hg_ret = HG_Test_init(argc, argv, &hg_test_info);
-    HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-        "HG_Test_init() failed");
+    HG_Test_init(argc, argv, &hg_test_info);
 
     for (nhandles = 1; nhandles <= MAX_HANDLES; nhandles *= 2) {
         if (hg_test_info.na_test_info.mpi_comm_rank == 0) {
@@ -219,23 +215,16 @@ main(int argc, char *argv[])
         }
 
         /* NULL RPC */
-        hg_ret = measure_rpc_latency(&hg_test_info, 0, nhandles);
-        HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-            "measure_rpc_latency() failed");
+        measure_rpc_latency(&hg_test_info, 0, nhandles);
 
         /* RPC with different sizes */
-        for (size = sizeof(hg_uint32_t); size <= MAX_MSG_SIZE; size *= 2) {
-            hg_ret = measure_rpc_latency(&hg_test_info, size, nhandles);
-            HG_TEST_CHECK_ERROR(hg_ret != HG_SUCCESS, done, ret, EXIT_FAILURE,
-                "measure_rpc_latency() failed");
-        }
+        for (size = sizeof(hg_uint32_t); size <= MAX_MSG_SIZE; size *= 2)
+            measure_rpc_latency(&hg_test_info, size, nhandles);
 
         fprintf(stdout, "\n");
     }
 
-done:
-    hg_ret = HG_Test_finalize(&hg_test_info);
-    HG_TEST_CHECK_ERROR_DONE(hg_ret != HG_SUCCESS, "HG_Test_finalize() failed");
+    HG_Test_finalize(&hg_test_info);
 
-    return ret;
+    return EXIT_SUCCESS;
 }
diff --git a/Testing/test_server.c b/Testing/test_server.c
index 8023c04..bee0c8e 100644
--- a/Testing/test_server.c
+++ b/Testing/test_server.c
@@ -127,7 +127,7 @@ main(int argc, char *argv[])
     }
 #else
     if (hg_test_info.secondary_contexts)
-        HG_TEST_LOG_WARNING("Secondary contexts only supported with thread pool");
+        HG_LOG_WARNING("Secondary contexts only supported with thread pool");
 
     do {
         unsigned int actual_count = 0;
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index f258f24..55e1b8f 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -243,6 +243,7 @@ set(MERCURY_HEADERS
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core_header.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_core_types.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mercury_error.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_header.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_macros.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mercury_proc_bulk.h
diff --git a/src/mercury.c b/src/mercury.c
index fcf0a42..d45c9d0 100644
--- a/src/mercury.c
+++ b/src/mercury.c
@@ -12,7 +12,6 @@
 #include "mercury_bulk.h"
 #include "mercury_proc.h"
 #include "mercury_proc_bulk.h"
-#include "mercury_error.h"
 
 #include "mercury_hash_string.h"
 #include "mercury_mem.h"
@@ -20,7 +19,6 @@
 
 #include <stdlib.h>
 #include <string.h>
-#include <assert.h>
 
 /****************/
 /* Local Macros */
@@ -28,6 +26,10 @@
 
 #define HG_POST_LIMIT_DEFAULT 256
 
+/* Convert value to string */
+#define HG_ERROR_STRING_MACRO(def, value, string) \
+  if (value == def) string = #def
+
 #define HG_CONTEXT_CLASS(context) \
     ((struct hg_private_class *)(context->hg_class))
 
@@ -38,9 +40,11 @@
 /* HG class */
 struct hg_private_class {
     struct hg_class hg_class;       /* Must remain as first field */
+    hg_thread_spin_t register_lock; /* Register lock */
+
+    /* Callbacks */
     hg_return_t (*handle_create)(hg_handle_t, void *);  /* handle_create */
     void *handle_create_arg;                            /* handle_create arg */
-    hg_thread_spin_t register_lock; /* Register lock */
 };
 
 /* Info for function map */
@@ -48,28 +52,28 @@ struct hg_proc_info {
     hg_rpc_cb_t rpc_cb;             /* RPC callback */
     hg_proc_cb_t in_proc_cb;        /* Input proc callback */
     hg_proc_cb_t out_proc_cb;       /* Output proc callback */
+    hg_bool_t no_response;          /* RPC response not expected */
     void *data;                     /* User data */
     void (*free_callback)(void *);  /* User data free callback */
-    hg_bool_t no_response;          /* RPC response not expected */
 };
 
 /* HG handle */
 struct hg_private_handle {
     struct hg_handle handle;        /* Must remain as first field */
-    struct hg_header hg_header;     /* Header for input/output */
     hg_cb_t forward_cb;             /* Forward callback */
-    hg_cb_t respond_cb;             /* Respond callback */
-    hg_return_t (*extra_bulk_transfer_cb)(hg_core_handle_t); /* Bulk transfer callback */
     void *forward_arg;              /* Forward callback args */
+    hg_cb_t respond_cb;             /* Respond callback */
     void *respond_arg;              /* Respond callback args */
-    void *in_extra_buf;             /* Extra input buffer */
-    void *out_extra_buf;            /* Extra output buffer */
+    struct hg_header hg_header;     /* Header for input/output */
     hg_proc_t in_proc;              /* Proc for input */
     hg_proc_t out_proc;             /* Proc for output */
-    hg_bulk_t in_extra_bulk;        /* Extra input bulk handle */
-    hg_bulk_t out_extra_bulk;       /* Extra output bulk handle */
+    void *in_extra_buf;             /* Extra input buffer */
     hg_size_t in_extra_buf_size;    /* Extra input buffer size */
+    hg_bulk_t in_extra_bulk;        /* Extra input bulk handle */
+    void *out_extra_buf;            /* Extra output buffer */
     hg_size_t out_extra_buf_size;   /* Extra output buffer size */
+    hg_bulk_t out_extra_bulk;       /* Extra output bulk handle */
+    hg_return_t (*extra_bulk_transfer_cb)(hg_core_handle_t); /* Bulk transfer callback */
 };
 
 /* HG op id */
@@ -79,13 +83,13 @@ struct hg_op_info_lookup {
 };
 
 struct hg_op_id {
-    union {
-        struct hg_op_info_lookup lookup;
-    } info;
     struct hg_context *context;     /* Context */
+    hg_cb_type_t type;              /* Callback type */
     hg_cb_t callback;               /* Callback */
     void *arg;                      /* Callback arguments */
-    hg_cb_type_t type;              /* Callback type */
+    union {
+        struct hg_op_info_lookup lookup;
+    } info;
 };
 
 /********************/
@@ -240,16 +244,6 @@ hg_core_respond_cb(
 /* Local Variables */
 /*******************/
 
-/* Return code string table */
-#define X(a) #a,
-static const char *const hg_return_name[] = { HG_RETURN_VALUES };
-#undef X
-
-/* Default error log mask */
-#ifdef HG_HAS_VERBOSE_ERROR
-unsigned int HG_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
-#endif
-
 /*---------------------------------------------------------------------------*/
 /**
  * Free function for value in function map.
@@ -274,27 +268,28 @@ hg_handle_create(struct hg_private_class *hg_class)
     /* Create private data to wrap callbacks etc */
     hg_handle = (struct hg_private_handle *) malloc(
         sizeof(struct hg_private_handle));
-    HG_CHECK_ERROR_NORET(hg_handle == NULL, error,
-        "Could not allocate handle private data");
-
+    if (!hg_handle) {
+        HG_LOG_ERROR("Could not allocate private data");
+        goto done;
+    }
     memset(hg_handle, 0, sizeof(struct hg_private_handle));
     hg_handle->handle.info.hg_class = (hg_class_t *) hg_class;
     hg_header_init(&hg_handle->hg_header, HG_UNDEF);
 
     /* CRC32 is enough for small size buffers */
-    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32,
-        &hg_handle->in_proc);
-    HG_CHECK_HG_ERROR(error, ret, "Cannot create HG proc");
-
-    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32,
-        &hg_handle->out_proc);
-    HG_CHECK_HG_ERROR(error, ret, "Cannot create HG proc");
+    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32, &hg_handle->in_proc);
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Cannot create HG proc");
+        goto done;
+    }
+    ret = hg_proc_create((hg_class_t *) hg_class, HG_CRC32, &hg_handle->out_proc);
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Cannot create HG proc");
+        goto done;
+    }
 
+done:
     return hg_handle;
-
-error:
-    hg_handle_free(hg_handle);
-    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -303,9 +298,6 @@ hg_handle_free(void *arg)
 {
     struct hg_private_handle *hg_handle = (struct hg_private_handle *) arg;
 
-    if (!hg_handle)
-        return;
-
     if (hg_handle->handle.data_free_callback)
         hg_handle->handle.data_free_callback(hg_handle->handle.data);
     if (hg_handle->in_proc != HG_PROC_NULL)
@@ -325,9 +317,11 @@ hg_handle_create_cb(hg_core_handle_t core_handle, void *arg)
     hg_return_t ret = HG_SUCCESS;
 
     hg_handle = hg_handle_create(HG_CONTEXT_CLASS(hg_context));
-    HG_CHECK_ERROR(hg_handle == NULL, error, ret, HG_NOMEM,
-        "Could not create HG handle");
-
+    if (!hg_handle) {
+        HG_LOG_ERROR("Could not create HG handle");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     hg_handle->handle.core_handle = core_handle;
     hg_handle->handle.info.context = hg_context;
 
@@ -338,13 +332,13 @@ hg_handle_create_cb(hg_core_handle_t core_handle, void *arg)
         ret = HG_CONTEXT_CLASS(hg_context)->handle_create(
             (hg_handle_t) hg_handle,
             HG_CONTEXT_CLASS(hg_context)->handle_create_arg);
-        HG_CHECK_HG_ERROR(error, ret, "Error in handle create callback");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Error in handle create callback");
+            goto done;
+        }
     }
 
-    return ret;
-
-error:
-    hg_handle_free(hg_handle);
+done:
     return ret;
 }
 
@@ -359,8 +353,11 @@ hg_more_data_cb(hg_core_handle_t core_handle, hg_op_t op,
 
     /* Retrieve private data */
     hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
-    HG_CHECK_ERROR(hg_handle == NULL, done, ret, HG_FAULT,
-        "Could not get private data");
+    if (!hg_handle) {
+        HG_LOG_ERROR("Could not get private data");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     switch (op) {
         case HG_INPUT:
@@ -370,18 +367,25 @@ hg_more_data_cb(hg_core_handle_t core_handle, hg_op_t op,
             extra_buf = hg_handle->out_extra_buf;
             break;
         default:
-            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
+            HG_LOG_ERROR("Invalid HG op");
+            ret = HG_INVALID_PARAM;
+            goto done;
     }
 
     if (extra_buf) {
         /* We were forwarding to ourself and the extra buf is already set */
         ret = done_cb(core_handle);
-        HG_CHECK_HG_ERROR(done, ret,
-            "Could not execute more data done callback");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not execute more data done callback");
+            goto done;
+        }
     } else {
         /* We need to do a bulk transfer to get the extra data */
         ret = hg_get_extra_payload(hg_handle, op, done_cb);
-        HG_CHECK_HG_ERROR(done, ret, "Could not get extra payload");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not get extra payload");
+            goto done;
+        }
     }
 
 done:
@@ -396,10 +400,14 @@ hg_more_data_free_cb(hg_core_handle_t core_handle)
 
     /* Retrieve private data */
     hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
-    if (!hg_handle)
-        return;
+    if (!hg_handle) {
+        goto done;
+    }
 
     hg_free_extra_payload(hg_handle);
+
+done:
+    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -417,17 +425,16 @@ hg_core_rpc_cb(hg_core_handle_t core_handle)
     hg_handle->handle.info.context_id = hg_core_info->context_id;
     hg_handle->handle.info.id = hg_core_info->id;
 
-    HG_CHECK_ERROR(hg_proc_info->rpc_cb == NULL, error, ret, HG_INVALID_ARG,
-        "No RPC callback registered");
-
+    if (!hg_proc_info->rpc_cb) {
+        HG_LOG_ERROR("No RPC callback registered");
+        /* Need to decrement refcount on handle */
+        HG_Core_destroy(core_handle);
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
     ret = hg_proc_info->rpc_cb((hg_handle_t) hg_handle);
 
-    return ret;
-
-error:
-    /* Need to decrement refcount on handle */
-    HG_Core_destroy(core_handle);
-
+done:
     return ret;
 }
 
@@ -447,7 +454,6 @@ hg_core_addr_lookup_cb(const struct hg_core_cb_info *callback_info)
         hg_op_id->callback(&hg_cb_info);
 
     free(hg_op_id);
-
     return ret;
 }
 
@@ -478,19 +484,21 @@ hg_get_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.input.hash;
 #endif
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf,
-                &buf_size);
-            HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer");
-
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not get input buffer");
+                goto done;
+            }
             extra_buf = hg_handle->in_extra_buf;
             extra_buf_size = hg_handle->in_extra_buf_size;
             break;
         case HG_OUTPUT:
             /* Cannot respond if no_response flag set */
-            HG_CHECK_ERROR(hg_proc_info->no_response, done, ret,
-                HG_OPNOTSUPPORTED,
-                "No output was produced on that RPC (no response)");
-
+            if (hg_proc_info->no_response) {
+                HG_LOG_ERROR("No output was produced on that RPC (no response)");
+                ret = HG_PROTOCOL_ERROR;
+                goto done;
+            }
             /* Use custom header offset */
             header_offset += hg_handle->handle.info.hg_class->out_offset;
             /* Set output proc */
@@ -500,25 +508,34 @@ hg_get_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.output.hash;
 #endif
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf,
-                &buf_size);
-            HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer");
-
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not get output buffer");
+                goto done;
+            }
             extra_buf = hg_handle->out_extra_buf;
             extra_buf_size = hg_handle->out_extra_buf_size;
             break;
         default:
-            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
+            HG_LOG_ERROR("Invalid HG op");
+            ret = HG_INVALID_PARAM;
+            goto done;
+    }
+    if (!proc_cb) {
+        HG_LOG_ERROR("No proc set, proc must be set in HG_Register()");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
     }
-    HG_CHECK_ERROR(proc_cb == NULL, done, ret, HG_FAULT,
-        "No proc set, proc must be set in HG_Register()");
 
     /* Reset header */
     hg_header_reset(hg_header, op);
 
     /* Get header */
     ret = hg_header_proc(HG_DECODE, buf, buf_size, hg_header);
-    HG_CHECK_HG_ERROR(done, ret, "Could not process header");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not process header");
+        goto done;
+    }
 
     /* If the payload did not fit into the core buffer and we have an extra
      * buffer set, use that buffer directly */
@@ -533,21 +550,33 @@ hg_get_struct(struct hg_private_handle *hg_handle,
 
     /* Reset proc */
     ret = hg_proc_reset(proc, buf, buf_size, HG_DECODE);
-    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not reset proc");
+        goto done;
+    }
 
     /* Decode parameters */
     ret = proc_cb(proc, struct_ptr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not decode parameters");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not decode parameters");
+        goto done;
+    }
 
     /* Flush proc */
     ret = hg_proc_flush(proc);
-    HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Error in proc flush");
+        goto done;
+    }
 
 #ifdef HG_HAS_CHECKSUMS
     /* Compare checksum with header hash */
     ret = hg_proc_checksum_verify(proc, &hg_header_hash->payload,
         sizeof(hg_header_hash->payload));
-    HG_CHECK_HG_ERROR(done, ret, "Error in proc checksum verify");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Error in proc checksum verify");
+        goto done;
+    }
 #endif
 
     /* Increment ref count on handle so that it remains valid until free_struct
@@ -587,20 +616,22 @@ hg_set_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.input.hash;
 #endif
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf,
-                &buf_size);
-            HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer");
-
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not get input buffer");
+                goto done;
+            }
             extra_buf = &hg_handle->in_extra_buf;
             extra_buf_size = &hg_handle->in_extra_buf_size;
             extra_bulk = &hg_handle->in_extra_bulk;
             break;
         case HG_OUTPUT:
             /* Cannot respond if no_response flag set */
-            HG_CHECK_ERROR(hg_proc_info->no_response, done, ret,
-                HG_OPNOTSUPPORTED,
-                "No output was produced on that RPC (no response)");
-
+            if (hg_proc_info->no_response) {
+                HG_LOG_ERROR("No output was produced on that RPC (no response)");
+                ret = HG_PROTOCOL_ERROR;
+                goto done;
+            }
             /* Use custom header offset */
             header_offset += hg_handle->handle.info.hg_class->out_offset;
             /* Set output proc */
@@ -610,16 +641,19 @@ hg_set_struct(struct hg_private_handle *hg_handle,
             hg_header_hash = &hg_header->msg.output.hash;
 #endif
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf,
-                &buf_size);
-            HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer");
-
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not get output buffer");
+                goto done;
+            }
             extra_buf = &hg_handle->out_extra_buf;
             extra_buf_size = &hg_handle->out_extra_buf_size;
             extra_bulk = &hg_handle->out_extra_bulk;
             break;
         default:
-            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
+            HG_LOG_ERROR("Invalid HG op");
+            ret = HG_INVALID_PARAM;
+            goto done;
     }
     if (!proc_cb || !struct_ptr) {
         /* Silently skip */
@@ -636,21 +670,33 @@ hg_set_struct(struct hg_private_handle *hg_handle,
 
     /* Reset proc */
     ret = hg_proc_reset(proc, buf, buf_size, HG_ENCODE);
-    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not reset proc");
+        goto done;
+    }
 
     /* Encode parameters */
     ret = proc_cb(proc, struct_ptr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not encode parameters");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not encode parameters");
+        goto done;
+    }
 
     /* Flush proc */
     ret = hg_proc_flush(proc);
-    HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Error in proc flush");
+        goto done;
+    }
 
 #ifdef HG_HAS_CHECKSUMS
     /* Set checksum in header */
     ret = hg_proc_checksum_get(proc, &hg_header_hash->payload,
         sizeof(hg_header_hash->payload));
-    HG_CHECK_HG_ERROR(done, ret, "Error in getting proc checksum");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Error in getting proc checksum");
+        goto done;
+    }
 #endif
 
     /* The proc object may have allocated an extra buffer at this point.
@@ -663,8 +709,9 @@ hg_set_struct(struct hg_private_handle *hg_handle,
         /* Potentially free previous payload if handle was not reset */
         hg_free_extra_payload(hg_handle);
 #ifdef HG_HAS_XDR
-        HG_GOTO_ERROR(done, HG_PROTOCOL_ERROR,
-            "Extra encoding using XDR is not yet supported");
+        HG_LOG_ERROR("Extra encoding using XDR is not yet supported");
+        ret = HG_SIZE_ERROR;
+        goto done;
 #endif
         /* Create a bulk descriptor only of the size that is used */
         *extra_buf = hg_proc_get_extra_buf(proc);
@@ -676,23 +723,38 @@ hg_set_struct(struct hg_private_handle *hg_handle,
         /* Create bulk descriptor */
         ret = HG_Bulk_create(hg_handle->handle.info.hg_class, 1, extra_buf,
             extra_buf_size, HG_BULK_READ_ONLY, extra_bulk);
-        HG_CHECK_HG_ERROR(done, ret, "Could not create bulk data handle");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not create bulk data handle");
+            goto done;
+        }
 
         /* Reset proc */
         ret = hg_proc_reset(proc, buf, buf_size, HG_ENCODE);
-        HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not reset proc");
+            goto done;
+        }
 
         /* Encode extra_bulk_handle, we can do that safely here because
          * the user payload has been copied so we don't have to worry
          * about overwriting the user's data */
         ret = hg_proc_hg_bulk_t(proc, extra_bulk);
-        HG_CHECK_HG_ERROR(done, ret, "Could not process extra bulk handle");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not process extra bulk handle");
+            goto done;
+        }
 
         ret = hg_proc_flush(proc);
-        HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Error in proc flush");
+            goto done;
+        }
 
-        HG_CHECK_ERROR(hg_proc_get_extra_buf(proc), done, ret,
-            HG_OVERFLOW, "Extra bulk handle could not fit into buffer");
+        if (hg_proc_get_extra_buf(proc)) {
+            HG_LOG_ERROR("Extra bulk handle could not fit into buffer");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
 
         *more_data = HG_TRUE;
     }
@@ -701,7 +763,10 @@ hg_set_struct(struct hg_private_handle *hg_handle,
     buf = (char *) buf - header_offset;
     buf_size += header_offset;
     ret = hg_header_proc(HG_ENCODE, buf, buf_size, hg_header);
-    HG_CHECK_HG_ERROR(done, ret, "Could not process header");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not process header");
+        goto done;
+    }
 
     /* Only send the actual size of the data, not the entire buffer */
     *payload_size = hg_proc_get_size_used(proc) + header_offset;
@@ -731,22 +796,36 @@ hg_free_struct(struct hg_private_handle *hg_handle,
             proc_cb = hg_proc_info->out_proc_cb;
             break;
         default:
-            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
+            HG_LOG_ERROR("Invalid HG op");
+            ret = HG_INVALID_PARAM;
+            goto done;
+    }
+    if (!proc_cb) {
+        HG_LOG_ERROR("No proc set, proc must be set in HG_Register()");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
     }
-    HG_CHECK_ERROR(proc_cb == NULL, done, ret, HG_FAULT,
-        "No proc set, proc must be set in HG_Register()");
 
     /* Reset proc */
     ret = hg_proc_reset(proc, NULL, 0, HG_FREE);
-    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not reset proc");
+        goto done;
+    }
 
     /* Free memory allocated during decode operation */
     ret = proc_cb(proc, struct_ptr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not free allocated parameters");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not free allocated parameters");
+        goto done;
+    }
 
     /* Decrement ref count or free */
     ret = HG_Core_destroy(hg_handle->handle.core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not decrement handle ref count");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not decrement handle ref count");
+        goto done;
+    }
 
 done:
     return ret;
@@ -775,10 +854,11 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
             /* Set input proc */
             proc = hg_handle->in_proc;
             /* Get core input buffer */
-            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf,
-                &buf_size);
-            HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer");
-
+            ret = HG_Core_get_input(hg_handle->handle.core_handle, &buf, &buf_size);
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not get input buffer");
+                goto done;
+            }
             extra_buf = &hg_handle->in_extra_buf;
             extra_buf_size = &hg_handle->in_extra_buf_size;
             extra_bulk = &hg_handle->in_extra_bulk;
@@ -789,16 +869,19 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
             /* Set output proc */
             proc = hg_handle->out_proc;
             /* Get core output buffer */
-            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf,
-                &buf_size);
-            HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer");
-
+            ret = HG_Core_get_output(hg_handle->handle.core_handle, &buf, &buf_size);
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not get output buffer");
+                goto done;
+            }
             extra_buf = &hg_handle->out_extra_buf;
             extra_buf_size = &hg_handle->out_extra_buf_size;
             extra_bulk = &hg_handle->out_extra_bulk;
             break;
         default:
-            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid HG op");
+            HG_LOG_ERROR("Invalid HG op");
+            ret = HG_INVALID_PARAM;
+            goto done;
     }
 
     /* Include our own header offset */
@@ -806,24 +889,39 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
     buf_size -= header_offset;
 
     ret = hg_proc_reset(proc, buf, buf_size, HG_DECODE);
-    HG_CHECK_HG_ERROR(done, ret, "Could not reset proc");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not reset proc");
+        goto done;
+    }
 
     /* Decode extra bulk handle */
     ret = hg_proc_hg_bulk_t(proc, extra_bulk);
-    HG_CHECK_HG_ERROR(done, ret, "Could not process extra bulk handle");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not process extra bulk handle");
+        goto done;
+    }
 
     ret = hg_proc_flush(proc);
-    HG_CHECK_HG_ERROR(done, ret, "Error in proc flush");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Error in proc flush");
+        goto done;
+    }
 
     /* Create a new local handle to read the data */
     *extra_buf_size = HG_Bulk_get_size(*extra_bulk);
     *extra_buf = hg_mem_aligned_alloc(page_size, *extra_buf_size);
-    HG_CHECK_ERROR(*extra_buf == NULL, done, ret, HG_NOMEM,
-        "Could not allocate extra payload buffer");
+    if (!*extra_buf) {
+        HG_LOG_ERROR("Could not allocate extra payload buffer");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
 
     ret = HG_Bulk_create(hg_handle->handle.info.hg_class, 1, extra_buf,
         extra_buf_size, HG_BULK_READWRITE, &local_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not create HG bulk handle");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not create HG bulk handle");
+        goto done;
+    }
 
     /* Read bulk data here and wait for the data to be here  */
     hg_handle->extra_bulk_transfer_cb = done_cb;
@@ -832,7 +930,10 @@ hg_get_extra_payload(struct hg_private_handle *hg_handle, hg_op_t op,
         (hg_addr_t) hg_core_info->addr, hg_core_info->context_id,
         *extra_bulk, 0, local_handle, 0, *extra_buf_size,
         HG_OP_ID_IGNORE /* TODO not used for now */);
-    HG_CHECK_HG_ERROR(done, ret, "Could not transfer bulk data");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not transfer bulk data");
+        goto done;
+    }
 
 done:
     HG_Bulk_free(local_handle);
@@ -852,7 +953,10 @@ hg_get_extra_payload_cb(const struct hg_cb_info *callback_info)
     hg_return_t ret = HG_SUCCESS;
 
     ret = hg_handle->extra_bulk_transfer_cb(hg_handle->handle.core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not execute bulk transfer callback");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not execute bulk transfer callback");
+        goto done;
+    }
 
 done:
     return ret;
@@ -943,7 +1047,21 @@ HG_Version_get(unsigned int *major, unsigned int *minor, unsigned int *patch)
 const char *
 HG_Error_to_string(hg_return_t errnum)
 {
-    return hg_return_name[errnum];
+    const char *hg_error_string = "UNDEFINED/UNRECOGNIZED NA ERROR";
+
+    HG_ERROR_STRING_MACRO(HG_SUCCESS, errnum, hg_error_string);
+    HG_ERROR_STRING_MACRO(HG_NA_ERROR, errnum, hg_error_string);
+    HG_ERROR_STRING_MACRO(HG_TIMEOUT, errnum, hg_error_string);
+    HG_ERROR_STRING_MACRO(HG_INVALID_PARAM, errnum, hg_error_string);
+    HG_ERROR_STRING_MACRO(HG_SIZE_ERROR, errnum, hg_error_string);
+    HG_ERROR_STRING_MACRO(HG_NOMEM_ERROR, errnum, hg_error_string);
+    HG_ERROR_STRING_MACRO(HG_PROTOCOL_ERROR, errnum, hg_error_string);
+    HG_ERROR_STRING_MACRO(HG_NO_MATCH, errnum, hg_error_string);
+    HG_ERROR_STRING_MACRO(HG_CHECKSUM_ERROR, errnum, hg_error_string);
+    HG_ERROR_STRING_MACRO(HG_CANCELED, errnum, hg_error_string);
+    HG_ERROR_STRING_MACRO(HG_OTHER_ERROR, errnum, hg_error_string);
+
+    return hg_error_string;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -959,42 +1077,34 @@ HG_Init_opt(const char *na_info_string, hg_bool_t na_listen,
     const struct hg_init_info *hg_init_info)
 {
     struct hg_private_class *hg_class = NULL;
-#ifdef HG_HAS_VERBOSE_ERROR
-    const char *log_level = NULL;
-
-    /* Set log level */
-    log_level = getenv("HG_LOG_LEVEL");
-    if (log_level && (strcmp(log_level, "debug") == 0))
-        HG_LOG_MASK |= HG_LOG_TYPE_DEBUG;
-#endif
-
-    /* Make sure error return codes match */
-    assert(HG_CANCELED == (hg_return_t) NA_CANCELED);
+    hg_return_t ret = HG_SUCCESS;
 
     hg_class = malloc(sizeof(struct hg_private_class));
-    HG_CHECK_ERROR_NORET(hg_class == NULL, error,
-        "Could not allocate HG class");
-
+    if (!hg_class) {
+        HG_LOG_ERROR("Could not allocate HG class");
+        goto done;
+    }
     memset(hg_class, 0, sizeof(struct hg_private_class));
     hg_thread_spin_init(&hg_class->register_lock);
 
     hg_class->hg_class.core_class = HG_Core_init_opt(na_info_string, na_listen,
         hg_init_info);
-    HG_CHECK_ERROR_NORET(hg_class->hg_class.core_class == NULL, error,
-        "Could not create HG core class");
+    if (!hg_class->hg_class.core_class) {
+        HG_LOG_ERROR("Could not create HG core class");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Set more data callback */
     HG_Core_set_more_data_callback(hg_class->hg_class.core_class,
         hg_more_data_cb, hg_more_data_free_cb);
 
-    return (hg_class_t *) hg_class;
-
-error:
-    if (hg_class) {
-        hg_thread_spin_destroy(&hg_class->register_lock);
+done:
+    if (ret != HG_SUCCESS) {
         free(hg_class);
+        hg_class = NULL;
     }
-    return NULL;
+    return (hg_class_t *) hg_class;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1006,8 +1116,10 @@ HG_Finalize(hg_class_t *hg_class)
     hg_return_t ret = HG_SUCCESS;
 
     ret = HG_Core_finalize(private_class->hg_class.core_class);
-    HG_CHECK_HG_ERROR(done, ret, "Could not finalize HG core class");
-
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not finalize HG core class");
+        goto done;
+    }
     hg_thread_spin_destroy(&private_class->register_lock);
     free(private_class);
 
@@ -1031,8 +1143,11 @@ HG_Class_set_handle_create_callback(hg_class_t *hg_class,
         (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     private_class->handle_create = callback;
     private_class->handle_create_arg = arg;
@@ -1059,19 +1174,26 @@ HG_Context_create_id(hg_class_t *hg_class, hg_uint8_t id)
 #else
     unsigned int request_count = HG_POST_LIMIT_DEFAULT;
 #endif
+    hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR_NORET(hg_class == NULL, error, "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        goto done;
+    }
 
     hg_context = malloc(sizeof(struct hg_context));
-    HG_CHECK_ERROR_NORET(hg_context == NULL, error,
-        "Could not allocate HG context");
-
+    if (!hg_context) {
+        HG_LOG_ERROR("Could not allocate HG context");
+        goto done;
+    }
     memset(hg_context, 0, sizeof(struct hg_context));
     hg_context->hg_class = hg_class;
     hg_context->core_context = HG_Core_context_create_id(
         hg_class->core_class, id);
-    HG_CHECK_ERROR_NORET(hg_context->core_context == NULL, error,
-        "Could not create context for ID %u", id);
+    if (!hg_context->core_context) {
+        HG_LOG_ERROR("Could not create context for ID %u", id);
+        goto done;
+    }
 
     /* Set handle create callback */
     HG_Core_context_set_handle_create_callback(hg_context->core_context,
@@ -1079,24 +1201,16 @@ HG_Context_create_id(hg_class_t *hg_class, hg_uint8_t id)
 
     /* If we are listening, start posting requests */
     if (HG_Core_class_is_listening(hg_class->core_class)) {
-        hg_return_t ret = HG_Core_context_post(hg_context->core_context,
-            request_count, HG_TRUE);
-        HG_CHECK_HG_ERROR(error, ret, "Could not post context requests (%s)",
-            HG_Error_to_string(ret));
+        ret = HG_Core_context_post(hg_context->core_context, request_count,
+            HG_TRUE);
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not post context requests");
+            goto done;
+        }
     }
 
+done:
     return hg_context;
-
-error:
-    if (hg_context) {
-        if (hg_context->core_context) {
-            hg_return_t ret = HG_Core_context_destroy(hg_context->core_context);
-            HG_CHECK_ERROR_DONE(ret != HG_SUCCESS,
-                "Could not destroy HG core context");
-        }
-        free(hg_context);
-    }
-    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1105,13 +1219,17 @@ HG_Context_destroy(hg_context_t *context)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG context");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Core_context_destroy(context->core_context);
-    HG_CHECK_HG_ERROR(done, ret, "Could not destroy HG core context (%s)",
-        HG_Error_to_string(ret));
-
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not destroy HG core context");
+        goto done;
+    }
     free(context);
 
 done:
@@ -1124,18 +1242,26 @@ HG_Register_name(hg_class_t *hg_class, const char *func_name,
     hg_proc_cb_t in_proc_cb, hg_proc_cb_t out_proc_cb, hg_rpc_cb_t rpc_cb)
 {
     hg_id_t id = 0;
-    hg_return_t ret;
+    hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR_NORET(hg_class == NULL, done, "NULL HG class");
-    HG_CHECK_ERROR_NORET(func_name == NULL, done, "NULL string");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        goto done;
+    }
+    if (!func_name) {
+        HG_LOG_ERROR("NULL string");
+        goto done;
+    }
 
     /* Generate an ID from the function name */
     id = hg_hash_string(func_name);
 
     /* Register RPC */
     ret = HG_Register(hg_class, id, in_proc_cb, out_proc_cb, rpc_cb);
-    HG_CHECK_HG_ERROR(done, ret, "Could not register RPC ID (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not register RPC id");
+        goto done;
+    }
 
 done:
     return id;
@@ -1151,23 +1277,31 @@ HG_Registered_name(hg_class_t *hg_class, const char *func_name, hg_id_t *id,
     hg_id_t rpc_id = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
-    HG_CHECK_ERROR(func_name == NULL, done, ret, HG_INVALID_ARG, "NULL string");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!func_name) {
+        HG_LOG_ERROR("NULL string");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    hg_thread_spin_lock(&private_class->register_lock);
 
     /* Generate an ID from the function name */
     rpc_id = hg_hash_string(func_name);
 
-    hg_thread_spin_lock(&private_class->register_lock);
-
     ret = HG_Core_registered(private_class->hg_class.core_class, rpc_id, flag);
-    HG_CHECK_HG_ERROR(unlock, ret, "Could not check for registered RPC ID (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not check for registered RPC id");
+        hg_thread_spin_unlock(&private_class->register_lock);
+        goto done;
+    }
 
-    if (id)
-        *id = rpc_id;
+    if (id) *id = rpc_id;
 
-unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1182,59 +1316,67 @@ HG_Register(hg_class_t *hg_class, hg_id_t id, hg_proc_cb_t in_proc_cb,
     struct hg_private_class *private_class =
         (struct hg_private_class *) hg_class;
     struct hg_proc_info *hg_proc_info = NULL;
-    hg_bool_t registered = HG_FALSE;
+    hg_bool_t registered;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Check if already registered */
     ret = HG_Core_registered(hg_class->core_class, id, &registered);
-    HG_CHECK_HG_ERROR(error, ret, "Could not check for registered RPC ID (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not check for registered RPC id");
+        goto done;
+    }
 
     /* Register RPC (register only RPC callback if already registered) */
     ret = HG_Core_register(hg_class->core_class, id, hg_core_rpc_cb);
-    HG_CHECK_HG_ERROR(error, ret, "Could not register RPC ID (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not register RPC id");
+        goto done;
+    }
 
     if (!registered) {
         hg_proc_info =
             (struct hg_proc_info *) malloc(sizeof(struct hg_proc_info));
-        HG_CHECK_ERROR(hg_proc_info == NULL, error, ret, HG_NOMEM,
-            "Could not allocate proc info");
+        if (!hg_proc_info) {
+            HG_LOG_ERROR("Could not allocate proc info");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
         memset(hg_proc_info, 0, sizeof(struct hg_proc_info));
 
         /* Attach proc info to RPC ID */
         ret = HG_Core_register_data(hg_class->core_class, id, hg_proc_info,
             hg_proc_info_free);
-        HG_CHECK_HG_ERROR(error, ret, "Could not set proc info (%s)",
-            HG_Error_to_string(ret));
-        registered = HG_TRUE;
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not set proc info");
+            goto done;
+        }
     } else {
         /* Retrieve proc function from function map */
         hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
             hg_class->core_class, id);
-        HG_CHECK_ERROR(hg_proc_info == NULL, error, ret, HG_FAULT,
-            "Could not get registered data");
+        if (!hg_proc_info) {
+            HG_LOG_ERROR("Could not get registered data");
+            goto done;
+        }
     }
     hg_proc_info->rpc_cb = rpc_cb;
     hg_proc_info->in_proc_cb = in_proc_cb;
     hg_proc_info->out_proc_cb = out_proc_cb;
 
-    hg_thread_spin_unlock(&private_class->register_lock);
-
 done:
-    return ret;
-
-error:
-    if (registered)
-        HG_Core_deregister(hg_class->core_class, id);
-    else
+    if (ret != HG_SUCCESS) {
         free(hg_proc_info);
-    hg_thread_spin_unlock(&private_class->register_lock);
+    }
+    if (hg_class)
+        hg_thread_spin_unlock(&private_class->register_lock);
     return ret;
 }
 
@@ -1246,14 +1388,15 @@ HG_Deregister(hg_class_t *hg_class, hg_id_t id)
         (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->register_lock);
     ret = HG_Core_deregister(hg_class->core_class, id);
     hg_thread_spin_unlock(&private_class->register_lock);
-    HG_CHECK_HG_ERROR(done, ret, "Could not deregister RPC ID (%s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1267,14 +1410,15 @@ HG_Registered(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag)
         (struct hg_private_class *) hg_class;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->register_lock);
     ret = HG_Core_registered(hg_class->core_class, id, flag);
     hg_thread_spin_unlock(&private_class->register_lock);
-    HG_CHECK_HG_ERROR(done, ret, "Could not check for registered RPC ID (s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1290,29 +1434,31 @@ HG_Registered_proc_cb(hg_class_t *hg_class, hg_id_t id, hg_bool_t *flag,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     ret = HG_Core_registered(hg_class->core_class, id, flag);
-    HG_CHECK_HG_ERROR(unlock, ret, "Could not check for registered RPC ID (%s)",
-        HG_Error_to_string(ret));
-
-    if(*flag) {
+    if(ret == HG_SUCCESS && *flag) {
         /* if RPC is registered, retrieve pointers */
         hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
             hg_class->core_class, id);
-        HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_FAULT,
-            "Could not get registered data");
-
+        if (!hg_proc_info) {
+            HG_LOG_ERROR("Could not get registered data");
+            ret = HG_NO_MATCH;
+            hg_thread_spin_unlock(&private_class->register_lock);
+            goto done;
+        }
         if (in_proc_cb)
             *in_proc_cb = hg_proc_info->in_proc_cb;
         if (out_proc_cb)
             *out_proc_cb = hg_proc_info->out_proc_cb;
     }
 
-unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1329,21 +1475,27 @@ HG_Register_data(hg_class_t *hg_class, hg_id_t id, void *data,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_NOENTRY,
-        "Could not get registered data");
+    if (!hg_proc_info) {
+        HG_LOG_ERROR("Could not get registered data");
+        ret = HG_NO_MATCH;
+        hg_thread_spin_unlock(&private_class->register_lock);
+        goto done;
+    }
 
     hg_proc_info->data = data;
     hg_proc_info->free_callback = free_callback;
 
-unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1359,19 +1511,24 @@ HG_Registered_data(hg_class_t *hg_class, hg_id_t id)
     struct hg_proc_info *hg_proc_info = NULL;
     void *data = NULL;
 
-    HG_CHECK_ERROR_NORET(hg_class == NULL, done, "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    HG_CHECK_ERROR_NORET(hg_proc_info == NULL, unlock,
-        "Could not get registered data");
+    if (!hg_proc_info) {
+        HG_LOG_ERROR("Could not get registered data");
+        hg_thread_spin_unlock(&private_class->register_lock);
+        goto done;
+    }
 
     data = hg_proc_info->data;
 
-unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1388,20 +1545,26 @@ HG_Registered_disable_response(hg_class_t *hg_class, hg_id_t id,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_NOENTRY,
-        "Could not get registered data");
+    if (!hg_proc_info) {
+        HG_LOG_ERROR("Could not get registered data");
+        ret = HG_NO_MATCH;
+        hg_thread_spin_unlock(&private_class->register_lock);
+        goto done;
+    }
 
     hg_proc_info->no_response = disable;
 
-unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1418,22 +1581,31 @@ HG_Registered_disabled_response(hg_class_t *hg_class, hg_id_t id,
     struct hg_proc_info *hg_proc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
-    HG_CHECK_ERROR(disabled == NULL, done, ret, HG_INVALID_ARG,
-        "NULL pointer to disabled flag");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!disabled) {
+        HG_LOG_ERROR("NULL pointer to disabled flag");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->register_lock);
 
     /* Retrieve proc function from function map */
     hg_proc_info = (struct hg_proc_info *) HG_Core_registered_data(
         hg_class->core_class, id);
-    HG_CHECK_ERROR(hg_proc_info == NULL, unlock, ret, HG_NOENTRY,
-        "Could not get registered data");
+    if (!hg_proc_info) {
+        HG_LOG_ERROR("Could not get registered data");
+        ret = HG_NO_MATCH;
+        hg_thread_spin_unlock(&private_class->register_lock);
+        goto done;
+    }
 
     *disabled = hg_proc_info->no_response;
 
-unlock:
     hg_thread_spin_unlock(&private_class->register_lock);
 
 done:
@@ -1448,14 +1620,19 @@ HG_Addr_lookup(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_op_id *hg_op_id = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, error, ret, HG_INVALID_ARG,
-        "NULL HG context");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Allocate op_id */
     hg_op_id = (struct hg_op_id *) malloc(sizeof(struct hg_op_id));
-    HG_CHECK_ERROR(hg_op_id == NULL, error, ret, HG_NOMEM,
-        "Could not allocate HG operation ID");
-
+    if (!hg_op_id) {
+        HG_LOG_ERROR("Could not allocate HG operation ID");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     hg_op_id->context = context;
     hg_op_id->type = HG_CB_LOOKUP;
     hg_op_id->callback = callback;
@@ -1464,18 +1641,12 @@ HG_Addr_lookup(hg_context_t *context, hg_cb_t callback, void *arg,
 
     ret = HG_Core_addr_lookup(context->core_context, hg_core_addr_lookup_cb,
         hg_op_id, name, &hg_op_id->info.lookup.core_op_id);
-    HG_CHECK_HG_ERROR(error, ret, "Could not lookup %s (%s)", name,
-        HG_Error_to_string(ret));
 
     /* Assign op_id */
     if (op_id && op_id != HG_OP_ID_IGNORE)
         *op_id = (hg_op_id_t) hg_op_id;
 
-    return ret;
-
-error:
-    free(hg_op_id);
-
+done:
     return ret;
 }
 
@@ -1485,12 +1656,13 @@ HG_Addr_free(hg_class_t *hg_class, hg_addr_t addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Core_addr_free(hg_class->core_class, (hg_core_addr_t) addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not free addr (%s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1502,12 +1674,13 @@ HG_Addr_set_remove(hg_class_t *hg_class, hg_addr_t addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Core_addr_set_remove(hg_class->core_class, (hg_core_addr_t) addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not set addr to be removed (%s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1519,12 +1692,13 @@ HG_Addr_self(hg_class_t *hg_class, hg_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Core_addr_self(hg_class->core_class, (hg_core_addr_t *) addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not retrieve self addr (%s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1536,13 +1710,14 @@ HG_Addr_dup(hg_class_t *hg_class, hg_addr_t addr, hg_addr_t *new_addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Core_addr_dup(hg_class->core_class, (hg_core_addr_t) addr,
         (hg_core_addr_t *) new_addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not dup addr (%s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1555,13 +1730,14 @@ HG_Addr_to_string(hg_class_t *hg_class, char *buf, hg_size_t *buf_size,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Core_addr_to_string(hg_class->core_class, buf, buf_size,
         (hg_core_addr_t) addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not convert addr to string (%s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1576,16 +1752,20 @@ HG_Create(hg_context_t *context, hg_addr_t addr, hg_id_t id,
     hg_core_handle_t core_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG context");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Create HG core handle (calls handle_create_cb) */
     ret = HG_Core_create(context->core_context, (hg_core_addr_t) addr, id,
         &core_handle);
-    if (ret == HG_NOENTRY)
-        goto done; /* silence error if invalid ID is used */
-    HG_CHECK_HG_ERROR(done, ret, "Cannot create HG handle with ID %lu (%s)", id,
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        if (ret != HG_NO_MATCH) /* silence error if invalid ID is used */
+            HG_LOG_ERROR("Cannot create HG handle with ID %lu", id);
+        goto done;
+    }
 
     /* Get data and HG info */
     hg_handle = (struct hg_private_handle *) HG_Core_get_data(core_handle);
@@ -1604,12 +1784,13 @@ HG_Destroy(hg_handle_t handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    if (handle == HG_HANDLE_NULL)
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
         goto done;
+    }
 
     ret = HG_Core_destroy(handle->core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not set handle to be destroyed (%s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1623,13 +1804,18 @@ HG_Reset(hg_handle_t handle, hg_addr_t addr, hg_id_t id)
         (struct hg_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Call core reset */
     ret = HG_Core_reset(handle->core_handle, (hg_core_addr_t) addr, id);
-    HG_CHECK_HG_ERROR(done, ret, "Could not reset core HG handle (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not reset core HG handle");
+        goto done;
+    }
 
     /* Set info */
     private_handle->handle.info.addr = addr;
@@ -1647,22 +1833,33 @@ HG_Get_input(hg_handle_t handle, void *in_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
-    HG_CHECK_ERROR(in_struct == NULL, done, ret, HG_INVALID_ARG,
-        "NULL pointer to input struct");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!in_struct) {
+        HG_LOG_ERROR("NULL pointer to input struct");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
-        "Could not get proc info");
+    if (!hg_proc_info) {
+        HG_LOG_ERROR("Could not get proc info");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Get input struct */
     ret = hg_get_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_INPUT, in_struct);
-    HG_CHECK_HG_ERROR(done, ret, "Could not get input (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not get input");
+        goto done;
+    }
 
 done:
     return ret;
@@ -1675,22 +1872,33 @@ HG_Free_input(hg_handle_t handle, void *in_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
-    HG_CHECK_ERROR(in_struct == NULL, done, ret, HG_INVALID_ARG,
-        "NULL pointer to input struct");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!in_struct) {
+        HG_LOG_ERROR("NULL pointer to input struct");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
-        "Could not get proc info");
+    if (!hg_proc_info) {
+        HG_LOG_ERROR("Could not get proc info");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Free input struct */
     ret = hg_free_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_INPUT, in_struct);
-    HG_CHECK_HG_ERROR(done, ret, "Could not free input (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not free input");
+        goto done;
+    }
 
 done:
     return ret;
@@ -1703,22 +1911,33 @@ HG_Get_output(hg_handle_t handle, void *out_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
-    HG_CHECK_ERROR(out_struct == NULL, done, ret, HG_INVALID_ARG,
-        "NULL pointer to output struct");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!out_struct) {
+        HG_LOG_ERROR("NULL pointer to output struct");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
-        "Could not get proc info");
+    if (!hg_proc_info) {
+        HG_LOG_ERROR("Could not get proc info");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Get output struct */
     ret = hg_get_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_OUTPUT, out_struct);
-    HG_CHECK_HG_ERROR(done, ret, "Could not get output (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not get output");
+        goto done;
+    }
 
 done:
     return ret;
@@ -1731,22 +1950,33 @@ HG_Free_output(hg_handle_t handle, void *out_struct)
     const struct hg_proc_info *hg_proc_info;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
-    HG_CHECK_ERROR(out_struct == NULL, done, ret, HG_INVALID_ARG,
-        "NULL pointer to output struct");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!out_struct) {
+        HG_LOG_ERROR("NULL pointer to output struct");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
-        "Could not get proc info");
+    if (!hg_proc_info) {
+        HG_LOG_ERROR("Could not get proc info");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Free output struct */
     ret = hg_free_struct((struct hg_private_handle *) handle, hg_proc_info,
         HG_OUTPUT, out_struct);
-    HG_CHECK_HG_ERROR(done, ret, "Could not free output (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not free output");
+        goto done;
+    }
 
 done:
     return ret;
@@ -1759,10 +1989,16 @@ HG_Get_input_buf(hg_handle_t handle, void **in_buf, hg_size_t *in_buf_size)
     hg_size_t buf_size, header_offset = hg_header_get_size(HG_INPUT);
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
-    HG_CHECK_ERROR(in_buf == NULL, done, ret, HG_INVALID_ARG,
-        "NULL input buffer pointer");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!in_buf) {
+        HG_LOG_ERROR("NULL pointer");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Get core input buffer */
     /* Note: any extra header information will be transmitted with the
@@ -1770,8 +2006,10 @@ HG_Get_input_buf(hg_handle_t handle, void **in_buf, hg_size_t *in_buf_size)
      * limit.
      */
     ret = HG_Core_get_input(handle->core_handle, in_buf, &buf_size);
-    HG_CHECK_HG_ERROR(done, ret, "Could not get input buffer (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not get input buffer");
+        goto done;
+    }
 
     *in_buf = (char *) *in_buf + header_offset;
     if (in_buf_size)
@@ -1788,10 +2026,16 @@ HG_Get_output_buf(hg_handle_t handle, void **out_buf, hg_size_t *out_buf_size)
     hg_size_t buf_size, header_offset = hg_header_get_size(HG_OUTPUT);
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
-    HG_CHECK_ERROR(out_buf == NULL, done, ret, HG_INVALID_ARG,
-        "NULL output buffer pointer");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!out_buf) {
+        HG_LOG_ERROR("NULL pointer");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Get core output buffer */
     /* Note: any extra header information will be transmitted with the
@@ -1799,8 +2043,10 @@ HG_Get_output_buf(hg_handle_t handle, void **out_buf, hg_size_t *out_buf_size)
      * size limit.
      */
     ret = HG_Core_get_output(handle->core_handle, out_buf, &buf_size);
-    HG_CHECK_HG_ERROR(done, ret, "Could not get output buffer (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not get output buffer");
+        goto done;
+    }
 
     *out_buf = (char *) *out_buf + header_offset;
     if (out_buf_size)
@@ -1819,10 +2065,16 @@ HG_Get_input_extra_buf(hg_handle_t handle, void **in_buf,
         (struct hg_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
-    HG_CHECK_ERROR(in_buf == NULL, done, ret, HG_INVALID_ARG,
-        "NULL input buffer pointer");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!in_buf) {
+        HG_LOG_ERROR("NULL pointer");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* No offset if extra buffer since only the user payload is copied */
     *in_buf = private_handle->in_extra_buf;
@@ -1842,10 +2094,16 @@ HG_Get_output_extra_buf(hg_handle_t handle, void **out_buf,
         (struct hg_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
-    HG_CHECK_ERROR(out_buf == NULL, done, ret, HG_INVALID_ARG,
-        "NULL output buffer pointer");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!out_buf) {
+        HG_LOG_ERROR("NULL pointer");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* No offset if extra buffer since only the user payload is copied */
     *out_buf = private_handle->out_extra_buf;
@@ -1862,14 +2120,17 @@ HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
 {
     struct hg_private_handle *private_handle =
         (struct hg_private_handle *) handle;
-    const struct hg_proc_info *hg_proc_info = NULL;
-    hg_size_t payload_size = 0;
+    const struct hg_proc_info *hg_proc_info;
+    hg_size_t payload_size;
     hg_bool_t more_data = HG_FALSE;
     hg_uint8_t flags = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Set callback data */
     private_handle->forward_cb = callback;
@@ -1878,14 +2139,19 @@ HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
-        "Could not get proc info");
+    if (!hg_proc_info) {
+        HG_LOG_ERROR("Could not get proc info");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Set input struct */
     ret = hg_set_struct(private_handle, hg_proc_info, HG_INPUT, in_struct,
         &payload_size, &more_data);
-    HG_CHECK_HG_ERROR(done, ret, "Could not set input (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not set input");
+        goto done;
+    }
 
     /* Set more data flag on handle so that handle_more_callback is triggered */
     if (more_data)
@@ -1898,10 +2164,10 @@ HG_Forward(hg_handle_t handle, hg_cb_t callback, void *arg, void *in_struct)
     /* Send request */
     ret = HG_Core_forward(handle->core_handle, hg_core_forward_cb, handle,
         flags, payload_size);
-    if (ret == HG_AGAIN)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not forward call");
         goto done;
-    HG_CHECK_HG_ERROR(done, ret, "Could not forward call (%s)",
-        HG_Error_to_string(ret));
+    }
 
 done:
     return ret;
@@ -1919,8 +2185,11 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     hg_uint8_t flags = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Set callback data */
     private_handle->respond_cb = callback;
@@ -1929,14 +2198,19 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     /* Retrieve RPC data */
     hg_proc_info = (const struct hg_proc_info *) HG_Core_get_rpc_data(
         handle->core_handle);
-    HG_CHECK_ERROR(hg_proc_info == NULL, done, ret, HG_FAULT,
-        "Could not get proc info");
+    if (!hg_proc_info) {
+        HG_LOG_ERROR("Could not get proc info");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Set output struct */
     ret = hg_set_struct(private_handle, hg_proc_info, HG_OUTPUT, out_struct,
         &payload_size, &more_data);
-    HG_CHECK_HG_ERROR(done, ret, "Could not set output (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not set output");
+        goto done;
+    }
 
     /* Set more data flag on handle so that handle_more_callback is triggered */
     if (more_data)
@@ -1945,8 +2219,10 @@ HG_Respond(hg_handle_t handle, hg_cb_t callback, void *arg, void *out_struct)
     /* Send response back */
     ret = HG_Core_respond(handle->core_handle, hg_core_respond_cb, handle,
         flags, payload_size);
-    HG_CHECK_HG_ERROR(done, ret, "Could not respond (%s)",
-        HG_Error_to_string(ret));
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not respond");
+        goto done;
+    }
 
 done:
     return ret;
@@ -1958,13 +2234,13 @@ HG_Progress(hg_context_t *context, unsigned int timeout)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG context");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Core_progress(context->core_context, timeout);
-    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
-        "Could not make progress on context (%s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1977,14 +2253,14 @@ HG_Trigger(hg_context_t *context, unsigned int timeout, unsigned int max_count,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG context");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Core_trigger(context->core_context, timeout, max_count,
         actual_count);
-    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
-        "Could not trigger operations from context (%s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
@@ -1996,12 +2272,13 @@ HG_Cancel(hg_handle_t handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG handle");
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Core_cancel(handle->core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle (%s)",
-        HG_Error_to_string(ret));
 
 done:
     return ret;
diff --git a/src/mercury.h b/src/mercury.h
index 91e4778..397ed22 100644
--- a/src/mercury.h
+++ b/src/mercury.h
@@ -13,6 +13,7 @@
 
 #include "mercury_types.h"
 #include "mercury_header.h"
+#include "mercury_error.h"
 
 #include "mercury_core.h"
 
@@ -45,7 +46,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Version_get(
         unsigned int *major,
         unsigned int *minor,
@@ -59,7 +60,7 @@ HG_Version_get(
  *
  * \return String
  */
-HG_PUBLIC const char *
+HG_EXPORT const char *
 HG_Error_to_string(
         hg_return_t errnum
         );
@@ -75,7 +76,7 @@ HG_Error_to_string(
  *
  * \return Pointer to HG class or NULL in case of failure
  */
-HG_PUBLIC hg_class_t *
+HG_EXPORT hg_class_t *
 HG_Init(
         const char *na_info_string,
         hg_bool_t na_listen
@@ -94,7 +95,7 @@ HG_Init(
  *
  * \return Pointer to HG class or NULL in case of failure
  */
-HG_PUBLIC hg_class_t *
+HG_EXPORT hg_class_t *
 HG_Init_opt(
         const char *na_info_string,
         hg_bool_t na_listen,
@@ -108,7 +109,7 @@ HG_Init_opt(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Finalize(
         hg_class_t *hg_class
         );
@@ -119,7 +120,7 @@ HG_Finalize(
  * to HG_Finalize(), this routine gives a chance to programs that terminate
  * abnormally to easily clean up those resources.
  */
-HG_PUBLIC void
+HG_EXPORT void
 HG_Cleanup(
         void
         );
@@ -263,7 +264,7 @@ HG_Class_get_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Class_set_handle_create_callback(
         hg_class_t *hg_class,
         hg_return_t (*callback)(hg_handle_t, void *),
@@ -282,7 +283,7 @@ HG_Class_set_handle_create_callback(
  *
  * \return Pointer to HG context or NULL in case of failure
  */
-HG_PUBLIC hg_context_t *
+HG_EXPORT hg_context_t *
 HG_Context_create(
         hg_class_t *hg_class
         );
@@ -303,7 +304,7 @@ HG_Context_create(
  *
  * \return Pointer to HG context or NULL in case of failure
  */
-HG_PUBLIC hg_context_t *
+HG_EXPORT hg_context_t *
 HG_Context_create_id(
         hg_class_t *hg_class,
         hg_uint8_t id
@@ -316,7 +317,7 @@ HG_Context_create_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Context_destroy(
         hg_context_t *context
         );
@@ -388,7 +389,7 @@ HG_Context_get_data(
  *
  * \return unique ID associated to the registered function
  */
-HG_PUBLIC hg_id_t
+HG_EXPORT hg_id_t
 HG_Register_name(
         hg_class_t *hg_class,
         const char *func_name,
@@ -408,7 +409,7 @@ HG_Register_name(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Registered_name(
         hg_class_t *hg_class,
         const char *func_name,
@@ -429,7 +430,7 @@ HG_Registered_name(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Register(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -448,7 +449,7 @@ HG_Register(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Deregister(
         hg_class_t *hg_class,
         hg_id_t id
@@ -463,7 +464,7 @@ HG_Deregister(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Registered(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -482,7 +483,7 @@ HG_Registered(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Registered_proc_cb(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -503,7 +504,7 @@ HG_Registered_proc_cb(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Register_data(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -520,7 +521,7 @@ HG_Register_data(
  *
  * \return Pointer to data or NULL
  */
-HG_PUBLIC void *
+HG_EXPORT void *
 HG_Registered_data(
         hg_class_t *hg_class,
         hg_id_t id
@@ -540,7 +541,7 @@ HG_Registered_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Registered_disable_response(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -558,7 +559,7 @@ HG_Registered_disable_response(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Registered_disabled_response(
         hg_class_t *hg_class,
         hg_id_t id,
@@ -578,7 +579,7 @@ HG_Registered_disabled_response(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Addr_lookup(
         hg_context_t *context,
         hg_cb_t       callback,
@@ -595,7 +596,7 @@ HG_Addr_lookup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Addr_free(
         hg_class_t *hg_class,
         hg_addr_t   addr
@@ -612,7 +613,7 @@ HG_Addr_free(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Addr_set_remove(
         hg_class_t *hg_class,
         hg_addr_t   addr
@@ -626,7 +627,7 @@ HG_Addr_set_remove(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Addr_self(
         hg_class_t *hg_class,
         hg_addr_t  *addr
@@ -643,7 +644,7 @@ HG_Addr_self(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Addr_dup(
         hg_class_t *hg_class,
         hg_addr_t   addr,
@@ -664,7 +665,7 @@ HG_Addr_dup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Addr_to_string(
         hg_class_t *hg_class,
         char       *buf,
@@ -685,7 +686,7 @@ HG_Addr_to_string(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Create(
         hg_context_t *context,
         hg_addr_t addr,
@@ -701,7 +702,7 @@ HG_Create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Destroy(
         hg_handle_t handle
         );
@@ -718,7 +719,7 @@ HG_Destroy(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Reset(
         hg_handle_t handle,
         hg_addr_t addr,
@@ -805,7 +806,7 @@ HG_Get_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Get_input(
         hg_handle_t handle,
         void *in_struct
@@ -821,7 +822,7 @@ HG_Get_input(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Free_input(
         hg_handle_t handle,
         void *in_struct
@@ -841,7 +842,7 @@ HG_Free_input(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Get_output(
         hg_handle_t handle,
         void *out_struct
@@ -857,7 +858,7 @@ HG_Get_output(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Free_output(
         hg_handle_t handle,
         void *out_struct
@@ -882,7 +883,7 @@ HG_Free_output(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Get_input_buf(
         hg_handle_t handle,
         void **in_buf,
@@ -908,7 +909,7 @@ HG_Get_input_buf(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Get_output_buf(
         hg_handle_t handle,
         void **out_buf,
@@ -930,7 +931,7 @@ HG_Get_output_buf(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Get_input_extra_buf(
         hg_handle_t handle,
         void **in_buf,
@@ -952,7 +953,7 @@ HG_Get_input_extra_buf(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Get_output_extra_buf(
         hg_handle_t handle,
         void **out_buf,
@@ -993,7 +994,7 @@ HG_Set_target_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Forward(
         hg_handle_t handle,
         hg_cb_t callback,
@@ -1019,7 +1020,7 @@ HG_Forward(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Respond(
         hg_handle_t handle,
         hg_cb_t callback,
@@ -1039,7 +1040,7 @@ HG_Respond(
  *
  * \return HG_SUCCESS if any completion has occurred / HG error code otherwise
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Progress(
         hg_context_t *context,
         unsigned int timeout
@@ -1057,7 +1058,7 @@ HG_Progress(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Trigger(
         hg_context_t *context,
         unsigned int timeout,
@@ -1072,7 +1073,7 @@ HG_Trigger(
  *
  * \return HG_SUCCESS or HG_CANCEL_ERROR or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Cancel(
         hg_handle_t handle
         );
@@ -1096,8 +1097,8 @@ struct hg_context {
 
 /* HG handle */
 struct hg_handle {
-    struct hg_info info;                /* HG info */
     hg_core_handle_t core_handle;       /* Core handle */
+    struct hg_info info;                /* HG info */
     void *data;                         /* User data */
     void (*data_free_callback)(void *); /* User data free callback */
 };
@@ -1106,6 +1107,12 @@ struct hg_handle {
 static HG_INLINE const char *
 HG_Class_get_name(const hg_class_t *hg_class)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return NULL;
+    }
+#endif
     return HG_Core_class_get_name(hg_class->core_class);
 }
 
@@ -1113,6 +1120,12 @@ HG_Class_get_name(const hg_class_t *hg_class)
 static HG_INLINE const char *
 HG_Class_get_protocol(const hg_class_t *hg_class)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return NULL;
+    }
+#endif
     return HG_Core_class_get_protocol(hg_class->core_class);
 }
 
@@ -1120,6 +1133,12 @@ HG_Class_get_protocol(const hg_class_t *hg_class)
 static HG_INLINE hg_bool_t
 HG_Class_is_listening(const hg_class_t *hg_class)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return HG_FALSE;
+    }
+#endif
     return HG_Core_class_is_listening(hg_class->core_class);
 }
 
@@ -1127,8 +1146,15 @@ HG_Class_is_listening(const hg_class_t *hg_class)
 static HG_INLINE hg_size_t
 HG_Class_get_input_eager_size(const hg_class_t *hg_class)
 {
-    hg_size_t core = HG_Core_class_get_input_eager_size(hg_class->core_class),
-        header = hg_header_get_size(HG_INPUT);
+    hg_size_t core, header;
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return 0;
+    }
+#endif
+    core = HG_Core_class_get_input_eager_size(hg_class->core_class);
+    header = hg_header_get_size(HG_INPUT);
 
     return (core > header) ? core - header : 0;
 }
@@ -1137,8 +1163,15 @@ HG_Class_get_input_eager_size(const hg_class_t *hg_class)
 static HG_INLINE hg_size_t
 HG_Class_get_output_eager_size(const hg_class_t *hg_class)
 {
-    hg_size_t core = HG_Core_class_get_output_eager_size(hg_class->core_class),
-        header = hg_header_get_size(HG_OUTPUT);
+    hg_size_t core, header;
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return 0;
+    }
+#endif
+    core = HG_Core_class_get_output_eager_size(hg_class->core_class);
+    header = hg_header_get_size(HG_OUTPUT);
 
     return (core > header) ? core - header : 0;
 }
@@ -1147,9 +1180,15 @@ HG_Class_get_output_eager_size(const hg_class_t *hg_class)
 static HG_INLINE hg_return_t
 HG_Class_set_input_offset(hg_class_t *hg_class, hg_size_t offset)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return HG_INVALID_PARAM;
+    }
+#endif
     /* Extra input header must not be larger than eager size */
     if (offset > HG_Class_get_input_eager_size(hg_class))
-        return HG_INVALID_ARG;
+        return HG_INVALID_PARAM;
 
     hg_class->in_offset = offset;
 
@@ -1160,9 +1199,15 @@ HG_Class_set_input_offset(hg_class_t *hg_class, hg_size_t offset)
 static HG_INLINE hg_return_t
 HG_Class_set_output_offset(hg_class_t *hg_class, hg_size_t offset)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return HG_INVALID_PARAM;
+    }
+#endif
     /* Extra output header must not be larger than eager size */
     if (offset > HG_Class_get_output_eager_size(hg_class))
-        return HG_INVALID_ARG;
+        return HG_INVALID_PARAM;
 
     hg_class->out_offset = offset;
 
@@ -1174,6 +1219,12 @@ static HG_INLINE hg_return_t
 HG_Class_set_data(hg_class_t *hg_class, void *data,
     void (*free_callback)(void *))
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return HG_INVALID_PARAM;
+    }
+#endif
     return HG_Core_class_set_data(hg_class->core_class, data, free_callback);
 }
 
@@ -1181,6 +1232,12 @@ HG_Class_set_data(hg_class_t *hg_class, void *data,
 static HG_INLINE void *
 HG_Class_get_data(const hg_class_t *hg_class)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        return NULL;
+    }
+#endif
     return HG_Core_class_get_data(hg_class->core_class);
 }
 
@@ -1188,6 +1245,12 @@ HG_Class_get_data(const hg_class_t *hg_class)
 static HG_INLINE hg_class_t *
 HG_Context_get_class(const hg_context_t *context)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        return NULL;
+    }
+#endif
     return context->hg_class;
 }
 
@@ -1195,6 +1258,12 @@ HG_Context_get_class(const hg_context_t *context)
 static HG_INLINE hg_uint8_t
 HG_Context_get_id(const hg_context_t *context)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        return 0;
+    }
+#endif
     return HG_Core_context_get_id(context->core_context);
 }
 
@@ -1203,6 +1272,12 @@ static HG_INLINE hg_return_t
 HG_Context_set_data(hg_context_t *context, void *data,
     void (*free_callback)(void *))
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        return HG_INVALID_PARAM;
+    }
+#endif
     return HG_Core_context_set_data(context->core_context, data, free_callback);
 }
 
@@ -1210,6 +1285,12 @@ HG_Context_set_data(hg_context_t *context, void *data,
 static HG_INLINE void *
 HG_Context_get_data(const hg_context_t *context)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG context");
+        return NULL;
+    }
+#endif
     return HG_Core_context_get_data(context->core_context);
 }
 
@@ -1217,6 +1298,12 @@ HG_Context_get_data(const hg_context_t *context)
 static HG_INLINE hg_return_t
 HG_Ref_incr(hg_handle_t handle)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
     return HG_Core_ref_incr(handle->core_handle);
 }
 
@@ -1224,6 +1311,12 @@ HG_Ref_incr(hg_handle_t handle)
 static HG_INLINE hg_int32_t
 HG_Ref_get(hg_handle_t handle)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return -1;
+    }
+#endif
     return HG_Core_ref_get(handle->core_handle);
 }
 
@@ -1231,6 +1324,12 @@ HG_Ref_get(hg_handle_t handle)
 static HG_INLINE const struct hg_info *
 HG_Get_info(hg_handle_t handle)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return NULL;
+    }
+#endif
     return &handle->info;
 }
 
@@ -1238,6 +1337,12 @@ HG_Get_info(hg_handle_t handle)
 static HG_INLINE hg_return_t
 HG_Set_data(hg_handle_t handle, void *data, void (*free_callback)(void *))
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
     handle->data = data;
     handle->data_free_callback = free_callback;
 
@@ -1248,6 +1353,12 @@ HG_Set_data(hg_handle_t handle, void *data, void (*free_callback)(void *))
 static HG_INLINE void *
 HG_Get_data(hg_handle_t handle)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return NULL;
+    }
+#endif
     return handle->data;
 }
 
@@ -1255,6 +1366,12 @@ HG_Get_data(hg_handle_t handle)
 static HG_INLINE hg_return_t
 HG_Set_target_id(hg_handle_t handle, hg_uint8_t id)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
     handle->info.context_id = id;
 
     return HG_Core_set_target_id(handle->core_handle, id);
diff --git a/src/mercury_bulk.c b/src/mercury_bulk.c
index 22afddd..6ce331d 100644
--- a/src/mercury_bulk.c
+++ b/src/mercury_bulk.c
@@ -13,6 +13,8 @@
 #include "mercury_private.h"
 #include "mercury_error.h"
 
+#include "na.h"
+
 #include "mercury_atomic.h"
 
 #include <stdlib.h>
@@ -24,16 +26,13 @@
 #define HG_BULK_MIN(a, b) \
     (a < b) ? a : b
 
-/* Number of retries when receiving NA_AGAIN error */
-#define HG_BULK_MAX_AGAIN_RETRY     (10)
-
 /* Remove warnings when plugin does not use callback arguments */
 #if defined(__cplusplus)
-# define HG_BULK_UNUSED
+    #define HG_BULK_UNUSED
 #elif defined(__GNUC__) && (__GNUC__ >= 4)
-# define HG_BULK_UNUSED __attribute__((unused))
+    #define HG_BULK_UNUSED __attribute__((unused))
 #else
-# define HG_BULK_UNUSED
+    #define HG_BULK_UNUSED
 #endif
 
 /************************************/
@@ -52,10 +51,6 @@ struct hg_context {
 
 /* HG Bulk op id */
 struct hg_bulk_op_id {
-    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
-    struct hg_bulk *hg_bulk_origin;       /* Origin handle */
-    struct hg_bulk *hg_bulk_local;        /* Local handle */
-    na_op_id_t *na_op_ids ;               /* NA operations IDs */
     hg_context_t *context;                /* Context */
     na_class_t *na_class;                 /* NA class */
     na_context_t *na_context;             /* NA context */
@@ -63,10 +58,14 @@ struct hg_bulk_op_id {
     void *arg;                            /* Callback arguments */
     hg_atomic_int32_t completed;          /* Operation completed TODO needed ? */
     hg_atomic_int32_t canceled;           /* Operation canceled */
-    hg_atomic_int32_t op_completed_count; /* Number of operations completed */
     unsigned int op_count;                /* Number of ongoing operations */
+    hg_atomic_int32_t op_completed_count; /* Number of operations completed */
     hg_bulk_op_t op;                      /* Operation type */
+    struct hg_bulk *hg_bulk_origin;       /* Origin handle */
+    struct hg_bulk *hg_bulk_local;        /* Local handle */
+    na_op_id_t *na_op_ids ;               /* NA operations IDs */
     hg_bool_t is_self;                    /* Is self operation */
+    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
 };
 
 /* Segment used to transfer data and map to NA layer */
@@ -100,23 +99,23 @@ struct hg_bulk {
 #ifdef HG_HAS_SM_ROUTING
     na_class_t *na_sm_class;             /* NA SM class */
 #endif
+    hg_uint8_t context_id;               /* Context ID (valid if bound to handle) */
     hg_core_addr_t addr;                 /* Addr (valid if bound to handle) */
+    hg_size_t total_size;                /* Total size of data abstracted */
+    hg_uint32_t segment_count;           /* Number of segments */
     struct hg_bulk_segment *segments;    /* Array of segments */
     na_mem_handle_t *na_mem_handles;     /* Array of NA memory handles */
 #ifdef HG_HAS_SM_ROUTING
     na_mem_handle_t *na_sm_mem_handles;  /* Array of NA SM memory handles */
 #endif
-    void *serialize_ptr;                 /* Cached serialization buffer */
-    hg_size_t total_size;                /* Total size of data abstracted */
-    hg_size_t serialize_size;            /* Cached serialization size */
-    hg_uint32_t segment_count;           /* Number of segments */
     hg_uint32_t na_mem_handle_count;     /* Number of handles */
-    hg_atomic_int32_t ref_count;         /* Reference count */
     hg_bool_t segment_published;         /* NA memory handles published */
     hg_bool_t segment_alloc;             /* Allocated memory to mirror data */
-    hg_bool_t eager_mode;                /* Eager transfer */
     hg_uint8_t flags;                    /* Permission flags */
-    hg_uint8_t context_id;               /* Context ID (valid if bound to handle) */
+    hg_bool_t eager_mode;                /* Eager transfer */
+    void *serialize_ptr;                 /* Cached serialization buffer */
+    hg_size_t serialize_size;            /* Cached serialization size */
+    hg_atomic_int32_t ref_count;         /* Reference count */
 };
 
 /********************/
@@ -255,26 +254,9 @@ hg_bulk_na_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_offset_t remote_offset, na_size_t data_size, na_addr_t remote_addr,
     na_uint8_t remote_id, na_op_id_t *op_id)
 {
-    na_return_t na_ret;
-    int retry_cnt = 0;
-
-    /* Post RMA put */
-    do {
-        na_ret = NA_Put(na_class, context, callback, arg, local_mem_handle,
+    return NA_Put(na_class, context, callback, arg, local_mem_handle,
             local_offset, remote_mem_handle, remote_offset, data_size,
             remote_addr, remote_id, op_id);
-        if (na_ret != NA_AGAIN || retry_cnt++ > HG_BULK_MAX_AGAIN_RETRY)
-            break;
-
-        /* Attempt to make progress on NA with timeout of 0 */
-        na_ret = NA_Progress(na_class, context, 0);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done,
-            na_ret, na_ret, "Could not make progress on NA (%s)",
-            NA_Error_to_string(na_ret));
-    } while (1);
-
-done:
-    return na_ret;
 }
 
 /**
@@ -288,26 +270,9 @@ hg_bulk_na_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_offset_t remote_offset, na_size_t data_size, na_addr_t remote_addr,
     na_uint8_t remote_id, na_op_id_t *op_id)
 {
-    na_return_t na_ret;
-    int retry_cnt = 0;
-
-    /* Post RMA get */
-    do {
-        na_ret = NA_Get(na_class, context, callback, arg, local_mem_handle,
+    return NA_Get(na_class, context, callback, arg, local_mem_handle,
             local_offset, remote_mem_handle, remote_offset, data_size,
             remote_addr, remote_id, op_id);
-        if (na_ret != NA_AGAIN || retry_cnt++ > HG_BULK_MAX_AGAIN_RETRY)
-            break;
-
-        /* Attempt to make progress on NA with timeout of 0 */
-        na_ret = NA_Progress(na_class, context, 0);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done,
-            na_ret, na_ret, "Could not make progress on NA (%s)",
-            NA_Error_to_string(na_ret));
-    } while (1);
-
-done:
-    return na_ret;
 }
 
 /**
@@ -363,8 +328,11 @@ hg_bulk_serialize_memcpy(char **dest, ssize_t *dest_left, const void *src,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR((*dest_left -= (ssize_t) n) < 0, done, ret, HG_OVERFLOW,
-        "Serialize buffer size too small");
+    if ((*dest_left -= (ssize_t) n) < 0) {
+        HG_LOG_ERROR("Buffer size too small");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
     memcpy(*dest, src, n);
     *dest += n;
 
@@ -381,8 +349,11 @@ hg_bulk_deserialize_memcpy(const char **src, ssize_t *src_left, void *dest,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR((*src_left -= (ssize_t) n) < 0, done, ret, HG_OVERFLOW,
-        "Deserialize buffer size too small");
+    if ((*src_left -= (ssize_t) n) < 0) {
+        HG_LOG_ERROR("Buffer size too small");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
     memcpy(dest, *src, n);
     *src += n;
 
@@ -412,9 +383,11 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
     unsigned int i;
 
     hg_bulk = (struct hg_bulk *) malloc(sizeof(struct hg_bulk));
-    HG_CHECK_ERROR(hg_bulk == NULL, error, ret, HG_NOMEM,
-        "Could not allocate handle");
-
+    if (!hg_bulk) {
+        HG_LOG_ERROR("Could not allocate handle");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     memset(hg_bulk, 0, sizeof(struct hg_bulk));
     hg_bulk->hg_class = hg_class;
     hg_bulk->na_class = na_class;
@@ -430,9 +403,11 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
     /* Allocate segments */
     hg_bulk->segments = (struct hg_bulk_segment *) malloc(
         hg_bulk->segment_count * sizeof(struct hg_bulk_segment));
-    HG_CHECK_ERROR(hg_bulk->segments == NULL, error, ret, HG_NOMEM,
-        "Could not allocate segment array");
-
+    if (!hg_bulk->segments) {
+        HG_LOG_ERROR("Could not allocate segment array");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     memset(hg_bulk->segments, 0,
            hg_bulk->segment_count * sizeof(struct hg_bulk_segment));
 
@@ -447,23 +422,31 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
             /* Use calloc to avoid uninitialized memory used for transfer */
             hg_bulk->segments[i].address = (hg_ptr_t) calloc(
                 hg_bulk->segments[i].size, sizeof(char));
-            HG_CHECK_ERROR(hg_bulk->segments[i].address == (hg_ptr_t ) 0, error,
-                ret, HG_NOMEM, "Could not allocate segment");
+            if (!hg_bulk->segments[i].address) {
+                HG_LOG_ERROR("Could not allocate segment");
+                ret = HG_NOMEM_ERROR;
+                goto done;
+            }
         }
     }
 
     /* Allocate NA memory handles */
     hg_bulk->na_mem_handles = (na_mem_handle_t *) malloc(
         hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-    HG_CHECK_ERROR(hg_bulk->na_mem_handles == NULL, error, ret, HG_NOMEM,
-        "Could not allocate mem handle array");
-
+    if (!hg_bulk->na_mem_handles) {
+        HG_LOG_ERROR("Could not allocate mem handle array");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
 #ifdef HG_HAS_SM_ROUTING
     if (na_sm_class) {
         hg_bulk->na_sm_mem_handles = (na_mem_handle_t *) malloc(
             hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-        HG_CHECK_ERROR(hg_bulk->na_sm_mem_handles == NULL, error, ret,
-            HG_NOMEM, "Could not allocate SM mem handle array");
+        if (!hg_bulk->na_sm_mem_handles) {
+            HG_LOG_ERROR("Could not allocate SM mem handle array");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
     }
 #endif
     for (i = 0; i < hg_bulk->na_mem_handle_count; i++) {
@@ -486,67 +469,69 @@ hg_bulk_create(struct hg_class *hg_class, hg_uint32_t count,
             na_size_t na_segment_count = (na_size_t) hg_bulk->segment_count;
             na_ret = NA_Mem_handle_create_segments(na_class, na_segments,
                 na_segment_count, flags, &hg_bulk->na_mem_handles[i]);
-            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
-                (hg_return_t ) na_ret,
-                "NA_Mem_handle_create_segments() failed (%s)",
-                NA_Error_to_string(na_ret));
-
+            if (na_ret != NA_SUCCESS) {
+                HG_LOG_ERROR("NA_Mem_handle_create_segments failed");
+                ret = HG_NA_ERROR;
+                goto done;
+            }
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles) {
                 na_ret = NA_Mem_handle_create_segments(na_sm_class, na_segments,
                     na_segment_count, flags, &hg_bulk->na_sm_mem_handles[i]);
-                HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
-                    (hg_return_t) na_ret,
-                    "NA_Mem_handle_create_segments() for SM failed (%s)",
-                    NA_Error_to_string(na_ret));
+                if (na_ret != NA_SUCCESS) {
+                    HG_LOG_ERROR("NA_Mem_handle_create_segments for SM failed");
+                    ret = HG_NA_ERROR;
+                    goto done;
+                }
             }
 #endif
         } else {
             na_ret = NA_Mem_handle_create(na_class,
                 (void *) hg_bulk->segments[i].address,
                 hg_bulk->segments[i].size, flags, &hg_bulk->na_mem_handles[i]);
-            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
-                (hg_return_t) na_ret,
-                "NA_Mem_handle_create() failed (%s)",
-                NA_Error_to_string(na_ret));
-
+            if (na_ret != NA_SUCCESS) {
+                HG_LOG_ERROR("NA_Mem_handle_create failed");
+                ret = HG_NA_ERROR;
+                goto done;
+            }
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles) {
                 na_ret = NA_Mem_handle_create(na_sm_class,
                     (void *) hg_bulk->segments[i].address,
-                    hg_bulk->segments[i].size, flags,
-                    &hg_bulk->na_sm_mem_handles[i]);
-                HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
-                    (hg_return_t) na_ret,
-                    "NA_Mem_handle_create() for SM failed (%s)",
-                    NA_Error_to_string(na_ret));
+                    hg_bulk->segments[i].size, flags, &hg_bulk->na_sm_mem_handles[i]);
+                if (na_ret != NA_SUCCESS) {
+                    HG_LOG_ERROR("NA_Mem_handle_create for SM failed");
+                    ret = HG_NA_ERROR;
+                    goto done;
+                }
             }
 #endif
         }
-
         /* Register segment */
         na_ret = NA_Mem_register(na_class, hg_bulk->na_mem_handles[i]);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-            "NA_Mem_register() failed (%s)", NA_Error_to_string(na_ret));
-
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("NA_Mem_register failed");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
 #ifdef HG_HAS_SM_ROUTING
         if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-            na_ret = NA_Mem_register(na_sm_class,
-                hg_bulk->na_sm_mem_handles[i]);
-            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
-                (hg_return_t) na_ret,
-                "NA_Mem_register() failed (%s)", NA_Error_to_string(na_ret));
+            na_ret = NA_Mem_register(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
+            if (na_ret != NA_SUCCESS) {
+                HG_LOG_ERROR("NA_Mem_register failed");
+                ret = HG_NA_ERROR;
+                goto done;
+            }
         }
 #endif
     }
 
     *hg_bulk_ptr = hg_bulk;
 
-    return ret;
-
-error:
-    hg_bulk_free(hg_bulk);
-
+done:
+    if (ret != HG_SUCCESS) {
+        hg_bulk_free(hg_bulk);
+    }
     return ret;
 }
 
@@ -557,12 +542,12 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
     hg_return_t ret = HG_SUCCESS;
     unsigned int i;
 
-    if (!hg_bulk)
-        goto done;
+    if (!hg_bulk) goto done;
 
-    /* Cannot free yet */
-    if (hg_atomic_decr32(&hg_bulk->ref_count))
+    if (hg_atomic_decr32(&hg_bulk->ref_count)) {
+        /* Cannot free yet */
         goto done;
+    }
 
     if (hg_bulk->na_mem_handles) {
         na_class_t *na_class = hg_bulk->na_class;
@@ -579,18 +564,15 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
                     continue;
 
                 na_ret = NA_Mem_unpublish(na_class, hg_bulk->na_mem_handles[i]);
-                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                    (hg_return_t) na_ret,
-                    "NA_Mem_unpublish() failed (%s)");
-
+                if (na_ret != NA_SUCCESS) {
+                    HG_LOG_ERROR("NA_Mem_unpublish failed");
+                }
 #ifdef HG_HAS_SM_ROUTING
                 if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-                    na_ret = NA_Mem_unpublish(na_sm_class,
-                        hg_bulk->na_sm_mem_handles[i]);
-                    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                        (hg_return_t) na_ret,
-                        "NA_Mem_unpublish() for SM failed (%s)",
-                        NA_Error_to_string(na_ret));
+                    na_ret = NA_Mem_unpublish(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
+                    if (na_ret != NA_SUCCESS) {
+                        HG_LOG_ERROR("NA_Mem_unpublish for SM failed");
+                    }
                 }
 #endif
             }
@@ -604,33 +586,26 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
                 continue;
 
             na_ret = NA_Mem_deregister(na_class, hg_bulk->na_mem_handles[i]);
-            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                (hg_return_t) na_ret,
-                "NA_Mem_deregister() failed (%s)", NA_Error_to_string(na_ret));
+            if (na_ret != NA_SUCCESS) {
+                HG_LOG_ERROR("NA_Mem_deregister failed");
+            }
 
             na_ret = NA_Mem_handle_free(na_class, hg_bulk->na_mem_handles[i]);
-            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                (hg_return_t) na_ret,
-                "NA_Mem_handle_free() failed (%s)", NA_Error_to_string(na_ret));
-
+            if (na_ret != NA_SUCCESS) {
+                HG_LOG_ERROR("NA_Mem_handle_free failed");
+            }
             hg_bulk->na_mem_handles[i] = NA_MEM_HANDLE_NULL;
 
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-                na_ret = NA_Mem_deregister(na_sm_class,
-                    hg_bulk->na_sm_mem_handles[i]);
-                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                    (hg_return_t) na_ret,
-                    "NA_Mem_deregister() for SM failed (%s)",
-                    NA_Error_to_string(na_ret));
-
-                na_ret = NA_Mem_handle_free(na_sm_class,
-                    hg_bulk->na_sm_mem_handles[i]);
-                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                    (hg_return_t) na_ret,
-                    "NA_Mem_handle_free() for SM failed (%s)",
-                    NA_Error_to_string(na_ret));
-
+                na_ret = NA_Mem_deregister(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
+                if (na_ret != NA_SUCCESS) {
+                    HG_LOG_ERROR("NA_Mem_deregister for SM failed");
+                }
+                na_ret = NA_Mem_handle_free(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
+                if (na_ret != NA_SUCCESS) {
+                    HG_LOG_ERROR("NA_Mem_handle_free for SM failed");
+                }
                 hg_bulk->na_sm_mem_handles[i] = NA_MEM_HANDLE_NULL;
             }
 #endif
@@ -651,8 +626,7 @@ hg_bulk_free(struct hg_bulk *hg_bulk)
     free(hg_bulk->segments);
 
     /* Free addr if any was attached to handle */
-    ret = HG_Core_addr_free(hg_bulk->hg_class->core_class, hg_bulk->addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk addr");
+    HG_Core_addr_free(hg_bulk->hg_class->core_class, hg_bulk->addr);
 
     free(hg_bulk);
 
@@ -728,8 +702,7 @@ hg_bulk_access(struct hg_bulk *hg_bulk, hg_size_t offset, hg_size_t size,
         count++;
     }
 
-    if (actual_count)
-        *actual_count = count;
+    if (actual_count) *actual_count = count;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -738,14 +711,18 @@ hg_bulk_transfer_cb(const struct na_cb_info *callback_info)
 {
     struct hg_bulk_op_id *hg_bulk_op_id =
         (struct hg_bulk_op_id *) callback_info->arg;
+    na_return_t na_ret = NA_SUCCESS;
     int ret = 0;
 
-    /* If canceled, mark handle as canceled */
-    if (callback_info->ret == NA_CANCELED)
+    if (callback_info->ret == NA_CANCELED) {
+        /* If canceled, mark handle as canceled */
         hg_atomic_cas32(&hg_bulk_op_id->canceled, 0, 1);
-    else
-        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
-            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
+    } else if (callback_info->ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Error in NA callback: %s",
+            NA_Error_to_string(callback_info->ret));
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* When all NA transfers that correspond to bulk operation complete
      * add HG user callback to completion queue
@@ -757,6 +734,7 @@ hg_bulk_transfer_cb(const struct na_cb_info *callback_info)
     }
 
 done:
+    (void) na_ret;
     return ret;
 }
 
@@ -822,11 +800,11 @@ hg_bulk_transfer_pieces(na_bulk_op_t na_bulk_op, na_addr_t origin_addr, na_uint8
                 hg_bulk_origin->segments[origin_segment_index].address,
                 origin_segment_offset, transfer_size, origin_addr, origin_id,
                 &hg_bulk_op_id->na_op_ids[count]);
-            if (na_ret == NA_AGAIN)
-                HG_GOTO_DONE(done, ret, HG_AGAIN);
-            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                (hg_return_t ) na_ret, "Could not transfer data (%s)",
-                NA_Error_to_string(na_ret));
+            if (na_ret != NA_SUCCESS) {
+                HG_LOG_ERROR("Could not transfer data");
+                ret = HG_NA_ERROR;
+                break;
+            }
         }
         count++;
 
@@ -857,7 +835,6 @@ hg_bulk_transfer_pieces(na_bulk_op_t na_bulk_op, na_addr_t origin_addr, na_uint8
         }
     }
 
-done:
     /* Set number of NA operations issued */
     if (na_op_count)
         *na_op_count = count;
@@ -908,15 +885,19 @@ hg_bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
                 scatter_gather = HG_FALSE;
             break;
         default:
-            HG_GOTO_ERROR(error, ret, HG_INVALID_ARG, "Unknown bulk operation");
+            HG_LOG_ERROR("Unknown bulk operation");
+            ret = HG_INVALID_PARAM;
+            goto done;
     }
 
     /* Allocate op_id */
     hg_bulk_op_id = (struct hg_bulk_op_id *) malloc(
         sizeof(struct hg_bulk_op_id));
-    HG_CHECK_ERROR(hg_bulk_op_id == NULL, error, ret, HG_NOMEM,
-        "Could not allocate HG Bulk operation ID");
-
+    if (!hg_bulk_op_id) {
+        HG_LOG_ERROR("Could not allocate HG Bulk operation ID");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     hg_bulk_op_id->context = context;
 #ifdef HG_HAS_SM_ROUTING
     if (na_sm_class == na_origin_addr_class) {
@@ -956,45 +937,44 @@ hg_bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
 
     /* Figure out number of NA operations required */
     if (!scatter_gather) {
-        ret = hg_bulk_transfer_pieces(NULL, NA_ADDR_NULL, origin_id, use_sm,
-            hg_bulk_origin, origin_segment_start_index,
-            origin_segment_start_offset, hg_bulk_local,
-            local_segment_start_index, local_segment_start_offset, size,
-            HG_FALSE, NULL, &hg_bulk_op_id->op_count);
-        HG_CHECK_HG_ERROR(error, ret, "Could not get bulk op count");
-        HG_CHECK_ERROR(hg_bulk_op_id->op_count == 0, error, ret,
-            HG_INVALID_ARG, "Could not get bulk op_count");
+        hg_bulk_transfer_pieces(NULL, NA_ADDR_NULL, origin_id, use_sm, hg_bulk_origin,
+            origin_segment_start_index, origin_segment_start_offset,
+            hg_bulk_local, local_segment_start_index,
+            local_segment_start_offset, size, HG_FALSE, NULL,
+            &hg_bulk_op_id->op_count);
+        if (!hg_bulk_op_id->op_count) {
+            HG_LOG_ERROR("Could not get bulk op_count");
+            ret = HG_INVALID_PARAM;
+            goto done;
+        }
     }
 
     /* Allocate memory for NA operation IDs */
-    hg_bulk_op_id->na_op_ids = malloc(
-        sizeof(na_op_id_t) * hg_bulk_op_id->op_count);
-    HG_CHECK_ERROR(hg_bulk_op_id->na_op_ids == NULL, error, ret, HG_NOMEM,
-        "Could not allocate memory for op_ids");
-
-    for (i = 0; i < hg_bulk_op_id->op_count; i++) {
+    hg_bulk_op_id->na_op_ids = malloc(sizeof(na_op_id_t) * hg_bulk_op_id->op_count);
+    if (!hg_bulk_op_id->na_op_ids) {
+        HG_LOG_ERROR("Could not allocate memory for op_ids");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
+    for (i = 0; i < hg_bulk_op_id->op_count; i++)
         hg_bulk_op_id->na_op_ids[i] = NA_Op_create(hg_bulk_op_id->na_class);
-        HG_CHECK_ERROR(hg_bulk_op_id->na_op_ids[i] == NA_OP_ID_NULL, error, ret,
-            HG_NA_ERROR, "Could not create NA op ID");
-    }
 
     /* Do actual transfer */
     ret = hg_bulk_transfer_pieces(na_bulk_op, na_origin_addr, origin_id, use_sm,
         hg_bulk_origin, origin_segment_start_index, origin_segment_start_offset,
         hg_bulk_local, local_segment_start_index, local_segment_start_offset,
         size, scatter_gather, hg_bulk_op_id, NULL);
-    if (ret == HG_AGAIN)
-       goto error;
-    HG_CHECK_HG_ERROR(error, ret, "Could not transfer data pieces");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not transfer data pieces");
+        goto done;
+    }
 
     /* Assign op_id */
     if (op_id && op_id != HG_OP_ID_IGNORE)
         *op_id = (hg_op_id_t) hg_bulk_op_id;
 
-    return ret;
-
-error:
-    if (hg_bulk_op_id) {
+done:
+    if (ret != HG_SUCCESS && hg_bulk_op_id) {
         free(hg_bulk_op_id->na_op_ids);
         free(hg_bulk_op_id);
     }
@@ -1015,7 +995,10 @@ hg_bulk_complete(struct hg_bulk_op_id *hg_bulk_op_id)
         /* In the case of eager bulk transfer, directly trigger the operation
          * to avoid potential deadlocks */
         ret = hg_bulk_trigger_entry(hg_bulk_op_id);
-        HG_CHECK_HG_ERROR(done, ret, "Could not trigger completion entry");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not trigger completion entry");
+            goto done;
+        }
     } else {
         struct hg_completion_entry *hg_completion_entry =
             &hg_bulk_op_id->hg_completion_entry;
@@ -1025,8 +1008,10 @@ hg_bulk_complete(struct hg_bulk_op_id *hg_bulk_op_id)
 
         ret = hg_core_completion_add(context->core_context, hg_completion_entry,
             hg_bulk_op_id->is_self);
-        HG_CHECK_HG_ERROR(done, ret,
-            "Could not add HG completion entry to completion queue");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not add HG completion entry to completion queue");
+            goto done;
+        }
     }
 
 done:
@@ -1060,18 +1045,19 @@ hg_bulk_trigger_entry(struct hg_bulk_op_id *hg_bulk_op_id)
 
     /* Decrement ref_count */
     ret = hg_bulk_free(hg_bulk_op_id->hg_bulk_origin);
-    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk handle");
-
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not free bulk handle");
+        goto done;
+    }
     ret = hg_bulk_free(hg_bulk_op_id->hg_bulk_local);
-    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk handle");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not free bulk handle");
+        goto done;
+    }
 
     /* Free op */
-    for (i = 0; i < hg_bulk_op_id->op_count; i++) {
-        na_return_t na_ret = NA_Op_destroy(hg_bulk_op_id->na_class,
-            hg_bulk_op_id->na_op_ids[i]);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not destroy NA op ID (%s)", NA_Error_to_string(na_ret));
-    }
+    for (i = 0; i < hg_bulk_op_id->op_count; i++)
+        NA_Op_destroy(hg_bulk_op_id->na_class, hg_bulk_op_id->na_op_ids[i]);
     free(hg_bulk_op_id->na_op_ids);
     free(hg_bulk_op_id);
 
@@ -1087,29 +1073,49 @@ HG_Bulk_create(hg_class_t *hg_class, hg_uint32_t count, void **buf_ptrs,
     struct hg_bulk *hg_bulk = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG class");
-    HG_CHECK_ERROR(count == 0, done, ret, HG_INVALID_ARG,
-        "Invalid number of segments");
-    HG_CHECK_ERROR(buf_sizes == NULL, done, ret, HG_INVALID_ARG,
-        "NULL segment size pointer");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (!count) {
+        HG_LOG_ERROR("Invalid number of segments");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (!buf_sizes) {
+        HG_LOG_ERROR("NULL segment pointer");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     switch (flags) {
         case HG_BULK_READWRITE:
+            break;
         case HG_BULK_READ_ONLY:
+            break;
         case HG_BULK_WRITE_ONLY:
             break;
         default:
-            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG,
-                "Unrecognized handle flag");
+            HG_LOG_ERROR("Unrecognized handle flag");
+            ret = HG_INVALID_PARAM;
+            goto done;
     }
 
     ret = hg_bulk_create(hg_class, count, buf_ptrs, buf_sizes, flags, &hg_bulk);
-    HG_CHECK_HG_ERROR(done, ret, "Could not create bulk handle");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not create bulk handle");
+        goto done;
+    }
 
     *handle = (hg_bulk_t) hg_bulk;
 
 done:
+    if (ret != HG_SUCCESS) {
+        hg_bulk_free(hg_bulk);
+    }
     return ret;
 }
 
@@ -1120,11 +1126,9 @@ HG_Bulk_free(hg_bulk_t handle)
     hg_return_t ret = HG_SUCCESS;
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    if (!hg_bulk)
-        goto done;
+    if (!hg_bulk) goto done;
 
     ret = hg_bulk_free(hg_bulk);
-    HG_CHECK_HG_ERROR(done, ret, "Could not free bulk handle");
 
 done:
     return ret;
@@ -1137,8 +1141,11 @@ HG_Bulk_ref_incr(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
-        "NULL memory handle passed");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL memory handle passed");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Increment ref count */
     hg_atomic_incr32(&hg_bulk->ref_count);
@@ -1155,16 +1162,30 @@ HG_Bulk_bind(hg_bulk_t handle, hg_context_t *context)
     struct hg_context *hg_context = context;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
-        "NULL memory handle passed");
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG context");
-    HG_CHECK_ERROR(hg_bulk->addr != HG_CORE_ADDR_NULL, done, ret,
-        HG_INVALID_ARG, "Handle is already bound to existing address");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL memory handle passed");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (!context) {
+        HG_LOG_ERROR("NULL HG bulk context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (hg_bulk->addr != HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("Handle is already bound to existing address");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Retrieve self address */
     ret = HG_Core_addr_self(hg_bulk->hg_class->core_class, &hg_bulk->addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not get self address");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not get self address");
+        goto done;
+    }
 
     /* Add context ID */
     hg_bulk->context_id = HG_Core_context_get_id(hg_context->core_context);
@@ -1180,7 +1201,10 @@ HG_Bulk_get_addr(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_core_addr_t ret = HG_CORE_ADDR_NULL;
 
-    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL memory handle passed");
+        goto done;
+    }
 
     ret = hg_bulk->addr;
 
@@ -1195,7 +1219,10 @@ HG_Bulk_get_context_id(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_uint8_t ret = 0;
 
-    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL memory handle passed");
+        goto done;
+    }
 
     ret = hg_bulk->context_id;
 
@@ -1210,18 +1237,24 @@ HG_Bulk_access(hg_bulk_t handle, hg_size_t offset, hg_size_t size,
     hg_size_t *buf_sizes, hg_uint32_t *actual_count)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
+    hg_uint32_t count = 0;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
-        "NULL memory handle passed");
-
-    if (!size || !max_count)
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL memory handle passed");
+        ret = HG_INVALID_PARAM;
         goto done;
+    }
+
+    if (!size || !max_count) goto done;
 
     hg_bulk_access(hg_bulk, offset, size, flags, max_count, buf_ptrs,
-        buf_sizes, actual_count);
+        buf_sizes, &count);
 
 done:
+    if (ret == HG_SUCCESS) {
+        if (actual_count) *actual_count = count;
+    }
     return ret;
 }
 
@@ -1232,7 +1265,10 @@ HG_Bulk_get_size(hg_bulk_t handle)
     hg_size_t ret = 0;
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL bulk handle");
+        goto done;
+    }
 
     ret = hg_bulk->total_size;
 
@@ -1247,7 +1283,10 @@ HG_Bulk_get_segment_count(hg_bulk_t handle)
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
     hg_uint32_t ret = 0;
 
-    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL bulk handle passed");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL bulk handle");
+        goto done;
+    }
 
     ret = hg_bulk->segment_count;
 
@@ -1263,7 +1302,10 @@ HG_Bulk_get_serialize_size(hg_bulk_t handle, hg_bool_t request_eager)
     hg_size_t ret = 0;
     hg_uint32_t i;
 
-    HG_CHECK_ERROR_NORET(hg_bulk == NULL, done, "NULL memory handle passed");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL bulk handle");
+        goto done;
+    }
 
     /* Permission flags */
     ret = sizeof(hg_bulk->flags);
@@ -1287,15 +1329,17 @@ HG_Bulk_get_serialize_size(hg_bulk_t handle, hg_bool_t request_eager)
     for (i = 0; i < hg_bulk->na_mem_handle_count; i++) {
         na_size_t serialize_size = 0;
 
-        if (hg_bulk->na_mem_handles[i])
+        if (hg_bulk->na_mem_handles[i]) {
             serialize_size = NA_Mem_handle_get_serialize_size(
                 hg_bulk->na_class, hg_bulk->na_mem_handles[i]);
+        }
         ret += sizeof(serialize_size) + serialize_size;
 #ifdef HG_HAS_SM_ROUTING
         if (hg_bulk->na_sm_mem_handles) {
-            if (hg_bulk->na_sm_mem_handles[i])
+            if (hg_bulk->na_sm_mem_handles[i]) {
                 serialize_size = NA_Mem_handle_get_serialize_size(
                     hg_bulk->na_sm_class, hg_bulk->na_sm_mem_handles[i]);
+            }
             ret += sizeof(serialize_size) + serialize_size;
         }
 #endif
@@ -1328,8 +1372,11 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
 #endif
     hg_uint32_t i;
 
-    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
-        "NULL memory handle passed");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL memory handle passed");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Get NA class */
     na_class = hg_bulk->na_class;
@@ -1344,18 +1391,19 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
                 continue;
 
             na_ret = NA_Mem_publish(na_class, hg_bulk->na_mem_handles[i]);
-            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                (hg_return_t ) na_ret, "NA_Mem_publish() failed (%s)",
-                NA_Error_to_string(na_ret));
-
+            if (na_ret != NA_SUCCESS) {
+                HG_LOG_ERROR("NA_Mem_publish failed");
+                ret = HG_NA_ERROR;
+                goto done;
+            }
 #ifdef HG_HAS_SM_ROUTING
             if (hg_bulk->na_sm_mem_handles && hg_bulk->na_sm_mem_handles[i]) {
-                na_ret = NA_Mem_publish(na_sm_class,
-                    hg_bulk->na_sm_mem_handles[i]);
-                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                    (hg_return_t ) na_ret,
-                    "NA_Mem_publish() for SM failed (%s)",
-                    NA_Error_to_string(na_ret));
+                na_ret = NA_Mem_publish(na_sm_class, hg_bulk->na_sm_mem_handles[i]);
+                if (na_ret != NA_SUCCESS) {
+                    HG_LOG_ERROR("NA_Mem_publish for SM failed");
+                    ret = HG_NA_ERROR;
+                    goto done;
+                }
             }
 #endif
         }
@@ -1365,13 +1413,19 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
     /* Add the permission flags */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->flags, sizeof(hg_bulk->flags));
-    HG_CHECK_HG_ERROR(done, ret, "Could not encode permission flags");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not encode permission flags");
+        goto done;
+    }
 
     /* Address information is bound */
     bind_addr = (hg_bool_t) (hg_bulk->addr != HG_CORE_ADDR_NULL);
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &bind_addr, sizeof(bind_addr));
-    HG_CHECK_HG_ERROR(done, ret, "Could not encode bind address boolean");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not encode bind address boolean");
+        goto done;
+    }
 
     /* Add the address information and context ID */
     if (hg_bulk->addr != HG_CORE_ADDR_NULL) {
@@ -1380,62 +1434,85 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
 
         ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
             &serialize_size, sizeof(serialize_size));
-        HG_CHECK_HG_ERROR(done, ret, "Could not encode serialize size");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not encode serialize size");
+            goto done;
+        }
 
         na_ret = NA_Addr_serialize(na_class, buf_ptr, (na_size_t) buf_size_left,
             HG_Core_addr_get_na(hg_bulk->addr));
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not serialize address (%s)", NA_Error_to_string(na_ret));
-
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not serialize address");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
         buf_ptr += serialize_size;
         buf_size_left -= (ssize_t) serialize_size;
 
         ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->context_id, sizeof(hg_bulk->context_id));
-        HG_CHECK_HG_ERROR(done, ret, "Could not encode context ID");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not encode context ID");
+            goto done;
+        }
     }
 
     /* Add the total size of the segments */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->total_size, sizeof(hg_bulk->total_size));
-    HG_CHECK_HG_ERROR(done, ret, "Could not encode total size");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not encode total size");
+        goto done;
+    }
 
     /* Add the number of segments */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->segment_count, sizeof(hg_bulk->segment_count));
-    HG_CHECK_HG_ERROR(done, ret, "Could not encode segment count");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not encode segment count");
+        goto done;
+    }
 
     /* Add the array of segments */
     for (i = 0; i < hg_bulk->segment_count; i++) {
         ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->segments[i], sizeof(hg_bulk->segments[i]));
-        HG_CHECK_HG_ERROR(done, ret, "Could not encode segment");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not encode segment");
+            goto done;
+        }
     }
 
     /* Add the number of NA memory handles */
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->na_mem_handle_count, sizeof(hg_bulk->na_mem_handle_count));
-    HG_CHECK_HG_ERROR(done, ret, "Could not encode NA memory handle count");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not encode NA memory handle count");
+        goto done;
+    }
 
     /* Add the NA memory handles */
     for (i = 0; i < hg_bulk->na_mem_handle_count; i++) {
         na_size_t serialize_size = 0;
 
-        if (hg_bulk->na_mem_handles[i])
+        if (hg_bulk->na_mem_handles[i]) {
             serialize_size = NA_Mem_handle_get_serialize_size(
                 na_class, hg_bulk->na_mem_handles[i]);
-
-        ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
-            &serialize_size, sizeof(serialize_size));
-        HG_CHECK_HG_ERROR(done, ret, "Could not encode serialize size");
-
+        }
+        ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left, &serialize_size,
+            sizeof(serialize_size));
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not encode serialize size");
+            goto done;
+        }
         if (hg_bulk->na_mem_handles[i]) {
             na_ret = NA_Mem_handle_serialize(na_class, buf_ptr,
                 (na_size_t) buf_size_left, hg_bulk->na_mem_handles[i]);
-            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                (hg_return_t ) na_ret, "Could not serialize memory handle (%s)",
-                NA_Error_to_string(na_ret));
-
+            if (na_ret != NA_SUCCESS) {
+                HG_LOG_ERROR("Could not serialize memory handle");
+                ret = HG_NA_ERROR;
+                goto done;
+            }
             buf_ptr += serialize_size;
             buf_size_left -= (ssize_t) serialize_size;
         }
@@ -1449,16 +1526,18 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
                 serialize_size = 0;
             ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
                 &serialize_size, sizeof(serialize_size));
-            HG_CHECK_HG_ERROR(done, ret, "Could not encode serialize size");
-
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not encode serialize size");
+                goto done;
+            }
             if (hg_bulk->na_sm_mem_handles[i]) {
                 na_ret = NA_Mem_handle_serialize(na_sm_class, buf_ptr,
                     (na_size_t) buf_size_left, hg_bulk->na_sm_mem_handles[i]);
-                HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                    (hg_return_t ) na_ret,
-                    "Could not serialize SM memory handle (%s)",
-                    NA_Error_to_string(na_ret));
-
+                if (na_ret != NA_SUCCESS) {
+                    HG_LOG_ERROR("Could not serialize SM memory handle");
+                    ret = HG_NA_ERROR;
+                    goto done;
+                }
                 buf_ptr += serialize_size;
                 buf_size_left -= (ssize_t) serialize_size;
             }
@@ -1470,7 +1549,10 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
     eager_mode = (request_eager && (hg_bulk->flags == HG_BULK_READ_ONLY));
     ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left, &eager_mode,
         sizeof(eager_mode));
-    HG_CHECK_HG_ERROR(done, ret, "Could not encode eager_mode bool");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not encode eager_mode bool");
+        goto done;
+    }
 
     /* Add the serialized data */
     if (eager_mode) {
@@ -1481,12 +1563,15 @@ HG_Bulk_serialize(void *buf, hg_size_t buf_size, hg_bool_t request_eager,
             ret = hg_bulk_serialize_memcpy(&buf_ptr, &buf_size_left,
                 (const void *) hg_bulk->segments[i].address,
                 hg_bulk->segments[i].size);
-            HG_CHECK_HG_ERROR(done, ret, "Could not encode segment data");
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not encode segment data");
+                goto done;
+            }
         }
     }
 
-    HG_CHECK_WARNING(buf_size_left > 0, "Buf size left greater than 0, %zd",
-        buf_size_left);
+    if (buf_size_left)
+        HG_LOG_WARNING("Buf size left greater than 0, %zd", buf_size_left);
 
 done:
     return ret;
@@ -1505,13 +1590,18 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
     hg_bool_t bind_addr;
     hg_uint32_t i;
 
-    HG_CHECK_ERROR(handle == NULL, error, ret, HG_INVALID_ARG,
-        "NULL memory handle passed");
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to memory handle passed");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_bulk = (struct hg_bulk *) malloc(sizeof(struct hg_bulk));
-    HG_CHECK_ERROR(hg_bulk == NULL, error, ret, HG_NOMEM,
-        "Could not allocate handle");
-
+    if (!hg_bulk) {
+        HG_LOG_ERROR("Could not allocate handle");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     memset(hg_bulk, 0, sizeof(struct hg_bulk));
     hg_bulk->hg_class = hg_class;
     hg_bulk->na_class = HG_Core_class_get_na(hg_class->core_class);
@@ -1523,12 +1613,18 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
     /* Get the permission flags */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->flags, sizeof(hg_bulk->flags));
-    HG_CHECK_HG_ERROR(error, ret, "Could not decode permission flags");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not decode permission flags");
+        goto done;
+    }
 
     /* Address information is bound */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &bind_addr, sizeof(bind_addr));
-    HG_CHECK_HG_ERROR(error, ret, "Could not decode bind address boolean");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not decode bind address boolean");
+        goto done;
+    }
 
     /* Get the address information and context ID */
     if (bind_addr) {
@@ -1537,67 +1633,96 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
 
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &serialize_size, sizeof(serialize_size));
-        HG_CHECK_HG_ERROR(error, ret, "Could not decode serialize size");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not decode serialize size");
+            goto done;
+        }
 
         na_ret = NA_Addr_deserialize(hg_bulk->na_class, &na_addr, buf_ptr,
             (na_size_t) buf_size_left);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-            "Could not deserialize address (%s)", NA_Error_to_string(na_ret));
-
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not deserialize address");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
         buf_ptr += serialize_size;
         buf_size_left -= (ssize_t) serialize_size;
 
-        ret = HG_Core_addr_create(hg_bulk->hg_class->core_class,
-            &hg_bulk->addr);
-        HG_CHECK_HG_ERROR(error, ret, "Could not create core addr");
-
+        ret = HG_Core_addr_create(hg_bulk->hg_class->core_class, &hg_bulk->addr);
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not create core addr");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
         HG_Core_addr_set_na(hg_bulk->addr, na_addr);
 
         /* Decode context ID */
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->context_id, sizeof(hg_bulk->context_id));
-        HG_CHECK_HG_ERROR(error, ret, "Could not decode context ID");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not decode context ID");
+            goto done;
+        }
     }
 
     /* Get the total size of the segments */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->total_size, sizeof(hg_bulk->total_size));
-    HG_CHECK_HG_ERROR(error, ret, "Could not decode total size");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not decode total size");
+        goto done;
+    }
 
     /* Get the number of segments */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->segment_count, sizeof(hg_bulk->segment_count));
-    HG_CHECK_HG_ERROR(error, ret, "Could not decode segment count");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not decode segment count");
+        goto done;
+    }
 
     /* Get the array of segments */
     hg_bulk->segments = (struct hg_bulk_segment *) malloc(
             hg_bulk->segment_count * sizeof(struct hg_bulk_segment));
-    HG_CHECK_ERROR(hg_bulk->segments == NULL, error, ret, HG_NOMEM,
-        "Could not allocate segment array");
-
+    if (!hg_bulk->segments) {
+        HG_LOG_ERROR("Could not allocate segment array");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     for (i = 0; i < hg_bulk->segment_count; i++) {
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &hg_bulk->segments[i], sizeof(hg_bulk->segments[i]));
-        HG_CHECK_HG_ERROR(error, ret, "Could not decode segment");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not decode segment");
+            goto done;
+        }
     }
 
     /* Get the number of NA memory handles */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->na_mem_handle_count, sizeof(hg_bulk->na_mem_handle_count));
-    HG_CHECK_HG_ERROR(error, ret, "Could not decode NA memory handle count");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not decode NA memory handle count");
+        goto done;
+    }
 
     /* Get the NA memory handles */
     hg_bulk->na_mem_handles = (na_mem_handle_t *) malloc(
             hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-    HG_CHECK_ERROR(hg_bulk->na_mem_handles == NULL, error, ret, HG_NOMEM,
-        "Could not allocate NA memory handle array");
-
+    if (!hg_bulk->na_mem_handles) {
+        HG_LOG_ERROR("Could not allocate NA memory handle array");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
 #ifdef HG_HAS_SM_ROUTING
     if (hg_bulk->na_sm_class) {
         hg_bulk->na_sm_mem_handles = (na_mem_handle_t *) malloc(
                 hg_bulk->na_mem_handle_count * sizeof(na_mem_handle_t));
-        HG_CHECK_ERROR(hg_bulk->na_sm_mem_handles == NULL, error, ret,
-            HG_NOMEM, "Could not allocate NA SM memory handle array");
+        if (!hg_bulk->na_sm_mem_handles) {
+            HG_LOG_ERROR("Could not allocate NA SM memory handle array");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
     }
 #endif
 
@@ -1606,39 +1731,47 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
 
         ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
             &serialize_size, sizeof(serialize_size));
-        HG_CHECK_HG_ERROR(error, ret, "Could not decode serialize size");
-
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not decode serialize size");
+            goto done;
+        }
         if (serialize_size) {
             na_ret = NA_Mem_handle_deserialize(hg_bulk->na_class,
                 &hg_bulk->na_mem_handles[i], buf_ptr,
                 (na_size_t) buf_size_left);
-            HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
-                (hg_return_t ) na_ret, "Could not deserialize memory handle");
-
+            if (na_ret != NA_SUCCESS) {
+                HG_LOG_ERROR("Could not deserialize memory handle");
+                ret = HG_NA_ERROR;
+                goto done;
+            }
             buf_ptr += serialize_size;
             buf_size_left -= (ssize_t) serialize_size;
-        } else
+        } else {
             hg_bulk->na_mem_handles[i] = NA_MEM_HANDLE_NULL;
+        }
 
 #ifdef HG_HAS_SM_ROUTING
         if (hg_bulk->na_sm_mem_handles) {
             ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
                 &serialize_size, sizeof(serialize_size));
-            HG_CHECK_HG_ERROR(error, ret, "Could not decode serialize size");
-
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not decode serialize size");
+                goto done;
+            }
             if (serialize_size) {
                 na_ret = NA_Mem_handle_deserialize(hg_bulk->na_sm_class,
                     &hg_bulk->na_sm_mem_handles[i], buf_ptr,
                     (na_size_t) buf_size_left);
-                HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret,
-                    (hg_return_t ) na_ret,
-                    "Could not deserialize SM memory handle (%s)",
-                    NA_Error_to_string(na_ret));
-
+                if (na_ret != NA_SUCCESS) {
+                    HG_LOG_ERROR("Could not deserialize SM memory handle");
+                    ret = HG_NA_ERROR;
+                    goto done;
+                }
                 buf_ptr += serialize_size;
                 buf_size_left -= (ssize_t) serialize_size;
-            } else
+            } else {
                 hg_bulk->na_sm_mem_handles[i] = NA_MEM_HANDLE_NULL;
+            }
         }
 #endif
     }
@@ -1646,7 +1779,10 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
     /* Get whether data is serialized or not */
     ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
         &hg_bulk->eager_mode, sizeof(hg_bulk->eager_mode));
-    HG_CHECK_HG_ERROR(error, ret, "Could not decode eager_mode bool");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not decode eager_mode bool");
+        goto done;
+    }
 
     /* Get the serialized data */
     if (hg_bulk->eager_mode) {
@@ -1658,26 +1794,30 @@ HG_Bulk_deserialize(hg_class_t *hg_class, hg_bulk_t *handle, const void *buf,
             /* Use calloc to avoid uninitialized memory used for transfer */
             hg_bulk->segments[i].address = (hg_ptr_t) calloc(
                 hg_bulk->segments[i].size, sizeof(char));
-            HG_CHECK_ERROR(hg_bulk->segments[i].address == 0, error, ret,
-                HG_NOMEM, "Could not allocate segment");
-
+            if (!hg_bulk->segments[i].address) {
+                HG_LOG_ERROR("Could not allocate segment");
+                ret = HG_NOMEM_ERROR;
+                goto done;
+            }
             ret = hg_bulk_deserialize_memcpy(&buf_ptr, &buf_size_left,
                 (void *) hg_bulk->segments[i].address,
                 hg_bulk->segments[i].size);
-            HG_CHECK_HG_ERROR(error, ret, "Could not decode segment data");
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not decode segment data");
+                goto done;
+            }
         }
     }
 
-    HG_CHECK_WARNING(buf_size_left > 0, "Buf size left greater than 0, %zd",
-        buf_size_left);
+    if (buf_size_left)
+        HG_LOG_WARNING("Buf size left greater than 0, %zd", buf_size_left);
 
     *handle = (hg_bulk_t) hg_bulk;
 
-    return ret;
-
-error:
-    hg_bulk_free(hg_bulk);
-
+done:
+    if (ret != HG_SUCCESS) {
+        hg_bulk_free(hg_bulk);
+    }
     return ret;
 }
 
@@ -1687,12 +1827,12 @@ HG_Bulk_get_serialize_cached_ptr(hg_bulk_t handle)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    HG_CHECK_ERROR_NORET(hg_bulk == NULL, error, "NULL memory handle passed");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL bulk handle");
+        return NULL;
+    }
 
     return hg_bulk->serialize_ptr;
-
-error:
-    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1701,12 +1841,12 @@ HG_Bulk_get_serialize_cached_size(hg_bulk_t handle)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
 
-    HG_CHECK_ERROR_NORET(hg_bulk == NULL, error, "NULL memory handle passed");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL bulk handle");
+        return 0;
+    }
 
     return hg_bulk->serialize_size;
-
-error:
-    return 0;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1715,16 +1855,16 @@ HG_Bulk_set_serialize_cached_ptr(hg_bulk_t handle, void *buf,
     na_size_t buf_size)
 {
     struct hg_bulk *hg_bulk = (struct hg_bulk *) handle;
-    hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_bulk == NULL, done, ret, HG_INVALID_ARG,
-        "NULL memory handle passed");
+    if (!hg_bulk) {
+        HG_LOG_ERROR("NULL bulk handle");
+        return HG_INVALID_PARAM;
+    }
 
     hg_bulk->serialize_ptr = buf;
     hg_bulk->serialize_size = buf_size;
 
-done:
-    return ret;
+    return HG_SUCCESS;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1737,11 +1877,18 @@ HG_Bulk_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_bulk *hg_bulk_origin = (struct hg_bulk *) origin_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_bulk_origin == NULL, done, ret, HG_INVALID_ARG,
-        "NULL origin handle passed");
-    HG_CHECK_ERROR(hg_bulk_origin->addr != HG_CORE_ADDR_NULL
-        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr, done, ret,
-        HG_INVALID_ARG, "Mismatched address information from origin handle");
+    if (!hg_bulk_origin) {
+        HG_LOG_ERROR("NULL origin handle passed");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (hg_bulk_origin->addr != HG_CORE_ADDR_NULL
+        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr) {
+        HG_LOG_ERROR("Mismatched address information passed with origin handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Bulk_transfer_id(context, callback, arg, op, origin_addr, 0,
         origin_handle, origin_offset, local_handle, local_offset, size, op_id);
@@ -1760,11 +1907,18 @@ HG_Bulk_bind_transfer(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_bulk *hg_bulk_origin = (struct hg_bulk *) origin_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_bulk_origin == NULL, done, ret, HG_INVALID_ARG,
-        "NULL origin handle passed");
-    HG_CHECK_ERROR(hg_bulk_origin->addr == HG_CORE_ADDR_NULL, done, ret,
-        HG_INVALID_ARG, "No address information found on bulk handle, "
-        "HG_Bulk_bind() must be called on bulk handle");
+    if (!hg_bulk_origin) {
+        HG_LOG_ERROR("NULL origin handle passed");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (hg_bulk_origin->addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("No address information found on bulk handle, "
+            "HG_Bulk_bind() must be called on bulk handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = HG_Bulk_transfer_id(context, callback, arg, op,
         (hg_addr_t) hg_bulk_origin->addr, hg_bulk_origin->context_id,
@@ -1785,48 +1939,84 @@ HG_Bulk_transfer_id(hg_context_t *context, hg_cb_t callback, void *arg,
     struct hg_bulk *hg_bulk_local = (struct hg_bulk *) local_handle;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG context");
-    HG_CHECK_ERROR(hg_bulk_origin == NULL || hg_bulk_local == NULL, done, ret,
-        HG_INVALID_ARG, "NULL memory handle passed");
-    HG_CHECK_ERROR(hg_bulk_origin->addr != HG_CORE_ADDR_NULL
-        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr, done, ret,
-        HG_INVALID_ARG, "Mismatched address information from origin handle");
-    HG_CHECK_ERROR(hg_bulk_origin->addr != HG_CORE_ADDR_NULL
-        && hg_bulk_origin->context_id != origin_id, done, ret, HG_INVALID_ARG,
-        "Mismatched context ID information from origin handle");
-    HG_CHECK_ERROR(size == 0, done, ret, HG_INVALID_ARG,
-        "Transfer size must be non-zero");
-    HG_CHECK_ERROR(size > hg_bulk_origin->total_size, done, ret, HG_INVALID_ARG,
-        "Exceeding size of memory exposed by origin handle");
-    HG_CHECK_ERROR(size > hg_bulk_local->total_size, done, ret, HG_INVALID_ARG,
-        "Exceeding size of memory exposed by local handle");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG bulk context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (!hg_bulk_origin || !hg_bulk_local) {
+        HG_LOG_ERROR("NULL memory handle passed");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (hg_bulk_origin->addr != HG_CORE_ADDR_NULL
+        && hg_bulk_origin->addr != (hg_core_addr_t) origin_addr) {
+        HG_LOG_ERROR("Mismatched address information passed with origin handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (hg_bulk_origin->addr != HG_CORE_ADDR_NULL
+        && hg_bulk_origin->context_id != origin_id) {
+        HG_LOG_ERROR("Mismatched context ID information passed with origin handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (!size) {
+        HG_LOG_ERROR("Transfer size must be non-zero");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
+
+    if (size > hg_bulk_origin->total_size) {
+        HG_LOG_ERROR("Exceeding size of memory exposed by origin handle");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
+
+    if (size > hg_bulk_local->total_size) {
+        HG_LOG_ERROR("Exceeding size of memory exposed by local handle");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
 
     switch (op) {
         case HG_BULK_PUSH:
-            HG_CHECK_ERROR(!(hg_bulk_origin->flags & HG_BULK_WRITE_ONLY)
-                || !(hg_bulk_local->flags & HG_BULK_READ_ONLY), done, ret,
-                HG_PERMISSION, "Invalid permission flags for PUSH operation "
-                "(origin=%d, local=%d)", hg_bulk_origin->flags,
-                hg_bulk_local->flags);
+            if (!(hg_bulk_origin->flags & HG_BULK_WRITE_ONLY)
+                || !(hg_bulk_local->flags & HG_BULK_READ_ONLY)) {
+                HG_LOG_ERROR("Invalid permission flags for PUSH operation "
+                    "(origin=%d, local=%d)", hg_bulk_origin->flags,
+                    hg_bulk_local->flags);
+                ret = HG_INVALID_PARAM;
+                goto done;
+            }
             break;
         case HG_BULK_PULL:
-            HG_CHECK_ERROR(!(hg_bulk_origin->flags & HG_BULK_READ_ONLY)
-                || !(hg_bulk_local->flags & HG_BULK_WRITE_ONLY), done, ret,
-                HG_PERMISSION, "Invalid permission flags for PULL operation "
-                "(origin=%d, local=%d)", hg_bulk_origin->flags,
-                hg_bulk_local->flags);
+            if (!(hg_bulk_origin->flags & HG_BULK_READ_ONLY)
+                || !(hg_bulk_local->flags & HG_BULK_WRITE_ONLY)) {
+                HG_LOG_ERROR("Invalid permission flags for PULL operation "
+                    "(origin=%d, local=%d)", hg_bulk_origin->flags,
+                    hg_bulk_local->flags);
+                ret = HG_INVALID_PARAM;
+                goto done;
+            }
             break;
         default:
-            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Unknown bulk operation");
+            HG_LOG_ERROR("Unknown bulk operation");
+            ret = HG_INVALID_PARAM;
+            goto done;
     }
 
     ret = hg_bulk_transfer(context, callback, arg, op, origin_addr, origin_id,
         hg_bulk_origin, origin_offset, hg_bulk_local, local_offset, size,
         op_id);
-    if (ret == HG_AGAIN)
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not transfer data");
         goto done;
-    HG_CHECK_HG_ERROR(done, ret, "Could not start transfer of bulk data");
+    }
 
 done:
     return ret;
@@ -1839,19 +2029,27 @@ HG_Bulk_cancel(hg_op_id_t op_id)
     struct hg_bulk_op_id *hg_bulk_op_id = (struct hg_bulk_op_id *) op_id;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_bulk_op_id == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG bulk operation ID");
+    if (!hg_bulk_op_id) {
+        HG_LOG_ERROR("NULL HG bulk operation ID");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     if (HG_UTIL_TRUE != hg_atomic_cas32(&hg_bulk_op_id->completed, 1, 0)) {
         unsigned int i = 0;
 
         /* Cancel all NA operations issued */
         for (i = 0; i < hg_bulk_op_id->op_count; i++) {
-            na_return_t na_ret = NA_Cancel(hg_bulk_op_id->na_class,
+            na_return_t na_ret;
+
+            /* Cancel NA operation */
+            na_ret = NA_Cancel(hg_bulk_op_id->na_class,
                 hg_bulk_op_id->na_context, hg_bulk_op_id->na_op_ids[i]);
-            HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret,
-                (hg_return_t ) na_ret, "Could not cancel NA op ID (%s)",
-                NA_Error_to_string(na_ret));
+            if (na_ret != NA_SUCCESS) {
+                HG_LOG_ERROR("Could not cancel op id");
+                ret = HG_NA_ERROR;
+                goto done;
+            }
         }
     }
 
diff --git a/src/mercury_bulk.h b/src/mercury_bulk.h
index 338f24d..9b60d8b 100644
--- a/src/mercury_bulk.h
+++ b/src/mercury_bulk.h
@@ -54,7 +54,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_create(
         hg_class_t *hg_class,
         hg_uint32_t count,
@@ -71,7 +71,7 @@ HG_Bulk_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_free(
         hg_bulk_t handle
         );
@@ -83,7 +83,7 @@ HG_Bulk_free(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_ref_incr(
         hg_bulk_t handle
         );
@@ -112,7 +112,7 @@ HG_Bulk_ref_incr(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_bind(
         hg_bulk_t handle,
         hg_context_t *context
@@ -126,7 +126,7 @@ HG_Bulk_bind(
  *
  * \return abstract HG address or HG_ADDR_NULL in case of error
 */
-HG_PUBLIC hg_addr_t
+HG_EXPORT hg_addr_t
 HG_Bulk_get_addr(
        hg_bulk_t handle
        );
@@ -139,7 +139,7 @@ HG_Bulk_get_addr(
  *
  * \return valid context ID or 0 by default
 */
-HG_PUBLIC hg_uint8_t
+HG_EXPORT hg_uint8_t
 HG_Bulk_get_context_id(
        hg_bulk_t handle
        );
@@ -163,7 +163,7 @@ HG_Bulk_get_context_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_access(
         hg_bulk_t handle,
         hg_size_t offset,
@@ -182,7 +182,7 @@ HG_Bulk_access(
  *
  * \return Non-negative value
  */
-HG_PUBLIC hg_size_t
+HG_EXPORT hg_size_t
 HG_Bulk_get_size(
         hg_bulk_t handle
         );
@@ -194,7 +194,7 @@ HG_Bulk_get_size(
  *
  * \return Non-negative value
  */
-HG_PUBLIC hg_uint32_t
+HG_EXPORT hg_uint32_t
 HG_Bulk_get_segment_count(
         hg_bulk_t handle
         );
@@ -209,7 +209,7 @@ HG_Bulk_get_segment_count(
  *
  * \return Non-negative value
  */
-HG_PUBLIC hg_size_t
+HG_EXPORT hg_size_t
 HG_Bulk_get_serialize_size(
         hg_bulk_t handle,
         hg_bool_t request_eager
@@ -228,7 +228,7 @@ HG_Bulk_get_serialize_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_serialize(
         void *buf,
         hg_size_t buf_size,
@@ -246,7 +246,7 @@ HG_Bulk_serialize(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_deserialize(
         hg_class_t *hg_class,
         hg_bulk_t *handle,
@@ -261,7 +261,7 @@ HG_Bulk_deserialize(
  *
  * \return Pointer to buffer or NULL in case of error
  */
-HG_PUBLIC void *
+HG_EXPORT void *
 HG_Bulk_get_serialize_cached_ptr(
         hg_bulk_t handle
         );
@@ -273,7 +273,7 @@ HG_Bulk_get_serialize_cached_ptr(
  *
  * \return Non-negative value or 0 in case of error
  */
-HG_PUBLIC hg_size_t
+HG_EXPORT hg_size_t
 HG_Bulk_get_serialize_cached_size(
         hg_bulk_t handle
         );
@@ -287,7 +287,7 @@ HG_Bulk_get_serialize_cached_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_set_serialize_cached_ptr(
         hg_bulk_t handle,
         void *buf,
@@ -315,7 +315,7 @@ HG_Bulk_set_serialize_cached_ptr(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_transfer(
         hg_context_t *context,
         hg_cb_t callback,
@@ -350,7 +350,7 @@ HG_Bulk_transfer(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_bind_transfer(
         hg_context_t *context,
         hg_cb_t callback,
@@ -387,7 +387,7 @@ HG_Bulk_bind_transfer(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_transfer_id(
         hg_context_t *context,
         hg_cb_t callback,
@@ -410,7 +410,7 @@ HG_Bulk_transfer_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Bulk_cancel(
         hg_op_id_t op_id
         );
diff --git a/src/mercury_config.h.in b/src/mercury_config.h.in
index 3812057..fe0e00f 100644
--- a/src/mercury_config.h.in
+++ b/src/mercury_config.h.in
@@ -89,20 +89,19 @@ typedef hg_uint8_t   hg_bool_t;
 #endif
 
 /* Environment variable names (to be removed) */
+#define HG_NA_PLUGIN "MERCURY_NA_PLUGIN"
 #define HG_PORT_NAME "MERCURY_PORT_NAME"
 
 /* Shared libraries */
 #cmakedefine HG_BUILD_SHARED_LIBS
 #ifdef HG_BUILD_SHARED_LIBS
 # ifdef mercury_EXPORTS
-#  define HG_PUBLIC HG_ABI_EXPORT
+#  define HG_EXPORT HG_ABI_EXPORT
 # else
-#  define HG_PUBLIC HG_ABI_IMPORT
+#  define HG_EXPORT HG_ABI_IMPORT
 # endif
-# define HG_PRIVATE HG_ABI_HIDDEN
 #else
-# define HG_PUBLIC
-# define HG_PRIVATE
+# define HG_EXPORT
 #endif
 
 /* Build Options */
diff --git a/src/mercury_core.c b/src/mercury_core.c
index f1e45f9..053a7c0 100644
--- a/src/mercury_core.c
+++ b/src/mercury_core.c
@@ -25,7 +25,6 @@
 #include "mercury_thread_pool.h"
 #include "mercury_thread_spin.h"
 #include "mercury_time.h"
-#include "mercury_error.h"
 
 #ifdef HG_HAS_SM_ROUTING
 #include <uuid/uuid.h>
@@ -38,9 +37,11 @@
 /* Local Macros */
 /****************/
 
+#define HG_CORE_MAX_SELF_THREADS    4
+#define HG_CORE_MASK_NBITS          8
 #define HG_CORE_ATOMIC_QUEUE_SIZE   1024
 #define HG_CORE_PENDING_INCR        256
-#define HG_CORE_CLEANUP_TIMEOUT     1000
+#define HG_CORE_PROCESSING_TIMEOUT  1000
 #define HG_CORE_MAX_TRIGGER_COUNT   1
 #ifdef HG_HAS_SM_ROUTING
 # define HG_CORE_UUID_MAX_LEN       36
@@ -50,9 +51,6 @@
 # define HG_CORE_MIN(a, b)          (a < b) ? a : b /* Min macro */
 #endif
 
-/* Number of retries when receiving NA_AGAIN error */
-#define HG_CORE_MAX_AGAIN_RETRY         (10)
-
 /* Remove warnings when routine does not use arguments */
 #if defined(__cplusplus)
 # define HG_UNUSED
@@ -95,47 +93,51 @@ struct hg_core_private_class {
     uuid_t na_sm_uuid;                  /* UUID for local identification */
 #endif
     hg_hash_table_t *func_map;          /* Function map */
-    hg_return_t (*more_data_acquire)(hg_core_handle_t, hg_op_t,
-        hg_return_t (*done_callback)(hg_core_handle_t)); /* more_data_acquire */
-    void (*more_data_release)(hg_core_handle_t);         /* more_data_release */
-    na_tag_t request_max_tag;           /* Max value for tag */
-    hg_atomic_int32_t n_contexts;       /* Atomic used for number of contexts */
-    hg_atomic_int32_t n_addrs;          /* Atomic used for number of addrs */
+    hg_thread_spin_t func_map_lock;     /* Function map mutex */
     hg_atomic_int32_t request_tag;      /* Atomic used for tag generation */
-    hg_thread_spin_t func_map_lock;     /* Function map lock */
-    na_progress_mode_t progress_mode;   /* NA progress mode */
+    na_tag_t request_max_tag;           /* Max value for tag */
     hg_bool_t na_ext_init;              /* NA externally initialized */
+    na_progress_mode_t progress_mode;   /* NA progress mode */
 #ifdef HG_HAS_COLLECT_STATS
     hg_bool_t stats;                    /* (Debug) Print stats at exit */
 #endif
+    hg_atomic_int32_t n_contexts;       /* Atomic used for number of contexts */
+    hg_atomic_int32_t n_addrs;          /* Atomic used for number of addrs */
+
+    /* Callbacks */
+    hg_return_t (*more_data_acquire)(hg_core_handle_t, hg_op_t,
+        hg_return_t (*done_callback)(hg_core_handle_t)); /* more_data_acquire */
+    void (*more_data_release)(hg_core_handle_t); /* more_data_release */
 };
 
 /* HG context */
 struct hg_core_private_context {
     struct hg_core_context core_context;        /* Must remain as first field */
-    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
-    hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
-    HG_QUEUE_HEAD(hg_completion_entry) backfill_queue;  /* Backfill completion queue */
-    struct hg_atomic_queue *completion_queue;           /* Default completion queue */
-    HG_LIST_HEAD(hg_core_private_handle) created_list;  /* List of handles for that context */
-    HG_LIST_HEAD(hg_core_private_handle) pending_list;  /* List of pending handles */
-#ifdef HG_HAS_SM_ROUTING
-    HG_LIST_HEAD(hg_core_private_handle) sm_pending_list;   /* List of SM pending handles */
-#endif
-    hg_return_t (*handle_create)(hg_core_handle_t, void *); /* handle_create */
-    void *handle_create_arg;                    /* handle_create arg */
     struct hg_poll_set *poll_set;               /* Context poll set */
+    /* Pointer to function used for making progress */
     hg_return_t (*progress)(struct hg_core_private_context *context,
-        unsigned int timeout);                  /* Progress function */
+        unsigned int timeout);
+    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
+    HG_QUEUE_HEAD(hg_completion_entry) backfill_queue; /* Backfill completion queue */
     hg_atomic_int32_t backfill_queue_count;     /* Backfill queue count */
+    hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
+    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
     hg_atomic_int32_t trigger_waiting;          /* Waiting in trigger */
-    hg_atomic_int32_t n_handles;                /* Atomic used for number of handles */
-    hg_thread_spin_t created_list_lock;         /* Handle list lock */
+    HG_LIST_HEAD(hg_core_private_handle) pending_list;  /* List of pending handles */
     hg_thread_spin_t pending_list_lock;         /* Pending list lock */
+#ifdef HG_HAS_SM_ROUTING
+    HG_LIST_HEAD(hg_core_private_handle) sm_pending_list; /* List of SM pending handles */
+    hg_thread_spin_t sm_pending_list_lock;      /* SM pending list lock */
+#endif
+    HG_LIST_HEAD(hg_core_private_handle) created_list;  /* List of handles for that context */
+    hg_thread_spin_t created_list_lock;         /* Handle list lock */
 #ifdef HG_HAS_SELF_FORWARD
     int completion_queue_notify;                /* Self notification */
 #endif
+    hg_return_t (*handle_create)(hg_core_handle_t, void *); /* handle_create */
+    void *handle_create_arg;                    /* handle_create arg */
     hg_bool_t finalizing;                       /* Prevent reposts */
+    hg_atomic_int32_t n_handles;                /* Atomic used for number of handles */
 };
 
 #ifdef HG_HAS_SELF_FORWARD
@@ -154,8 +156,8 @@ struct hg_core_private_addr {
 #ifdef HG_HAS_SM_ROUTING
     uuid_t na_sm_uuid;                  /* NA SM UUID */
 #endif
-    hg_atomic_int32_t ref_count;        /* Reference count */
     hg_bool_t is_mine;                  /* Created internally or not */
+    hg_atomic_int32_t ref_count;        /* Reference count */
 };
 
 /* HG core op type */
@@ -173,59 +175,71 @@ typedef enum {
 /* HG core handle */
 struct hg_core_private_handle {
     struct hg_core_handle core_handle;  /* Must remain as first field */
-    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
-    HG_LIST_ENTRY(hg_core_private_handle) created;  /* Created list entry */
-    HG_LIST_ENTRY(hg_core_private_handle) pending;  /* Pending list entry */
-    struct hg_core_header in_header;    /* Input header */
-    struct hg_core_header out_header;   /* Output header */
     na_class_t *na_class;               /* NA class */
     na_context_t *na_context;           /* NA context */
     hg_core_cb_t request_callback;      /* Request callback */
     void *request_arg;                  /* Request callback arguments */
     hg_core_cb_t response_callback;     /* Response callback */
     void *response_arg;                 /* Response callback arguments */
-    hg_return_t (*forward)(struct hg_core_private_handle *hg_core_handle);    /* forward */
-    hg_return_t (*respond)(struct hg_core_private_handle *hg_core_handle);    /* respond */
-    hg_return_t (*no_respond)(struct hg_core_private_handle *hg_core_handle); /* no_respond */
-    void *ack_buf;                      /* Ack buf for more data */
+    hg_core_op_type_t op_type;          /* Core operation type */
+    na_tag_t tag;                       /* Tag used for request and response */
+    hg_uint8_t cookie;                  /* Cookie */
+    hg_return_t ret;                    /* Return code associated to handle */
+    HG_LIST_ENTRY(hg_core_private_handle) created;  /* Created list entry */
+    HG_LIST_ENTRY(hg_core_private_handle) pending;  /* Pending list entry */
+    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
+    hg_bool_t repost;                   /* Repost handle on completion (listen) */
+    hg_bool_t is_self;                  /* Self processed */
+    hg_atomic_int32_t in_use;           /* Is in use */
+    hg_bool_t no_response;              /* Require response or not */
+
     void *in_buf_plugin_data;           /* Input buffer NA plugin data */
+    na_size_t in_buf_used;              /* Amount of input buffer used */
     void *out_buf_plugin_data;          /* Output buffer NA plugin data */
+    na_size_t out_buf_used;             /* Amount of output buffer used */
+    void *ack_buf;                      /* Ack buf for more data */
     void *ack_buf_plugin_data;          /* Ack plugin data */
+
     na_op_id_t na_send_op_id;           /* Operation ID for send */
     na_op_id_t na_recv_op_id;           /* Operation ID for recv */
     na_op_id_t na_ack_op_id;            /* Operation ID for ack */
-    na_size_t in_buf_used;              /* Amount of input buffer used */
-    na_size_t out_buf_used;             /* Amount of output buffer used */
-    na_tag_t tag;                       /* Tag used for request and response */
-    hg_atomic_int32_t na_op_completed_count; /* Number of NA operations completed */
-    hg_atomic_int32_t in_use;           /* Is in use */
-    hg_atomic_int32_t ref_count;        /* Reference count */
-    hg_atomic_int32_t posted;           /* Handle has been posted */
-    hg_atomic_int32_t canceling;        /* Handle is being canceled */
     unsigned int na_op_count;           /* Number of ongoing operations */
-    hg_core_op_type_t op_type;          /* Core operation type */
-    hg_return_t ret;                    /* Return code associated to handle */
-    hg_uint8_t cookie;                  /* Cookie */
-    hg_bool_t repost;                   /* Repost handle on completion (listen) */
-    hg_bool_t is_self;                  /* Self processed */
-    hg_bool_t no_response;              /* Require response or not */
+    hg_atomic_int32_t na_op_completed_count;    /* Number of NA operations completed */
+    hg_bool_t na_op_id_mine;            /* Operation ID created by HG */
+
+    struct hg_core_header in_header;    /* Input header */
+    struct hg_core_header out_header;   /* Output header */
+
+    hg_atomic_int32_t ref_count;        /* Reference count */
+
+    /* Callbacks */
+    hg_return_t (*forward)(
+        struct hg_core_private_handle *hg_core_handle
+        ); /* forward */
+    hg_return_t (*respond)(
+        struct hg_core_private_handle *hg_core_handle
+        ); /* respond */
+    hg_return_t (*no_respond)(
+        struct hg_core_private_handle *hg_core_handle
+        ); /* no_respond */
 };
 
 /* HG op id */
 struct hg_core_op_info_lookup {
-    struct hg_core_private_addr *hg_core_addr;  /* Address */
-    na_op_id_t na_lookup_op_id;                 /* Operation ID for lookup */
+    struct hg_core_private_addr *hg_core_addr; /* Address */
+    na_op_id_t na_lookup_op_id;         /* Operation ID for lookup */
 };
 
 struct hg_core_op_id {
-    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
+    struct hg_core_private_context *context; /* Context */
+    hg_cb_type_t type;                  /* Callback type */
+    hg_core_cb_t callback;              /* Callback */
+    void *arg;                          /* Callback arguments */
+    hg_atomic_int32_t completed;        /* Operation completed TODO needed ? */
     union {
         struct hg_core_op_info_lookup lookup;
     } info;
-    struct hg_core_private_context *context;        /* Context */
-    hg_core_cb_t callback;                          /* Callback */
-    void *arg;                                      /* Callback arguments */
-    hg_cb_type_t type;                              /* Callback type */
+    struct hg_completion_entry hg_completion_entry; /* Entry in completion queue */
 };
 
 /********************/
@@ -303,11 +317,21 @@ hg_core_pending_list_cancel(
         struct hg_core_private_context *context
         );
 
+#ifdef HG_HAS_SM_ROUTING
 /**
- * Wail until handle lists are empty.
+ * Cancel entries from pending list.
  */
 static hg_return_t
-hg_core_context_lists_wait(
+hg_core_sm_pending_list_cancel(
+        struct hg_core_private_context *context
+        );
+#endif
+
+/**
+ * Wail until handle list is empty.
+ */
+static hg_return_t
+hg_core_created_list_wait(
         struct hg_core_private_context *context
         );
 
@@ -617,6 +641,7 @@ hg_core_process(
 static HG_INLINE hg_return_t
 hg_core_complete_na(
         struct hg_core_private_handle *hg_core_handle,
+        na_op_id_t *op_id,
         hg_bool_t *completed
         );
 
@@ -821,8 +846,11 @@ hg_core_get_sm_uuid(uuid_t *sm_uuid)
         uuid_generate(new_uuid);
 
         uuid_config = fopen(sm_path, "w");
-        HG_CHECK_ERROR(uuid_config == NULL, done, ret, HG_NOENTRY,
-            "Could not open %s for write", sm_path);
+        if (!uuid_config) {
+            HG_LOG_ERROR("Could not open %s for write", sm_path);
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
         uuid_unparse(new_uuid, uuid_str);
         fprintf(uuid_config, "%s\n", uuid_str);
     } else {
@@ -856,8 +884,7 @@ hg_core_int_hash(void *vlocation)
 static void
 hg_core_func_map_value_free(hg_hash_table_value_t value)
 {
-    struct hg_core_rpc_info *hg_core_rpc_info =
-        (struct hg_core_rpc_info *) value;
+    struct hg_core_rpc_info *hg_core_rpc_info = (struct hg_core_rpc_info *) value;
 
     if (hg_core_rpc_info->free_callback)
         hg_core_rpc_info->free_callback(hg_core_rpc_info->data);
@@ -894,11 +921,17 @@ hg_core_proc_header_request(struct hg_core_handle *hg_core_handle,
     /* Proc request header */
     ret = hg_core_header_request_proc(op, header_buf, header_buf_size,
         hg_core_header);
-    HG_CHECK_HG_ERROR(done, ret, "Could not process request header");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not process request header");
+        goto done;
+    }
 
     if (op == HG_DECODE) {
         ret = hg_core_header_request_verify(hg_core_header);
-        HG_CHECK_HG_ERROR(done, ret, "Could not verify request header");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not verify request header");
+            goto done;
+        }
     }
 
 done:
@@ -919,11 +952,17 @@ hg_core_proc_header_response(struct hg_core_handle *hg_core_handle,
     /* Proc response header */
     ret = hg_core_header_response_proc(op, header_buf, header_buf_size,
         hg_core_header);
-    HG_CHECK_HG_ERROR(done, ret, "Could not process response header");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not process response header");
+        goto done;
+    }
 
     if (op == HG_DECODE) {
         ret = hg_core_header_response_verify(hg_core_header);
-        HG_CHECK_HG_ERROR(done, ret, "Could not verify response header");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not verify response header");
+            goto done;
+        }
     }
 
 done:
@@ -934,55 +973,75 @@ done:
 static hg_return_t
 hg_core_pending_list_cancel(struct hg_core_private_context *context)
 {
-    struct hg_core_private_handle *hg_core_handle;
     hg_return_t ret = HG_SUCCESS;
 
     hg_thread_spin_lock(&context->pending_list_lock);
 
-    HG_QUEUE_FOREACH(hg_core_handle, &context->pending_list, pending) {
-        /* Prevent reposts */
-        hg_core_handle->repost = HG_FALSE;
-
-        /* Cancel handle */
-        ret = hg_core_cancel(hg_core_handle);
-        HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle");
-    }
+    while (!HG_LIST_IS_EMPTY(&context->pending_list)) {
+        struct hg_core_private_handle *hg_core_handle =
+            HG_LIST_FIRST(&context->pending_list);
+        HG_LIST_REMOVE(hg_core_handle, pending);
 
-#ifdef HG_HAS_SM_ROUTING
-    HG_QUEUE_FOREACH(hg_core_handle, &context->sm_pending_list, pending) {
         /* Prevent reposts */
         hg_core_handle->repost = HG_FALSE;
 
         /* Cancel handle */
         ret = hg_core_cancel(hg_core_handle);
-        HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not cancel handle");
+            break;
+        }
     }
-#endif
 
-done:
     hg_thread_spin_unlock(&context->pending_list_lock);
+
+    return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+#ifdef HG_HAS_SM_ROUTING
+static hg_return_t
+hg_core_sm_pending_list_cancel(struct hg_core_private_context *context)
+{
+    hg_return_t ret = HG_SUCCESS;
+
+    hg_thread_spin_lock(&context->sm_pending_list_lock);
+
+    while (!HG_LIST_IS_EMPTY(&context->sm_pending_list)) {
+        struct hg_core_private_handle *hg_core_handle =
+            HG_LIST_FIRST(&context->sm_pending_list);
+        HG_LIST_REMOVE(hg_core_handle, pending);
+
+        /* Prevent reposts */
+        hg_core_handle->repost = HG_FALSE;
+
+        /* Cancel handle */
+        ret = hg_core_cancel(hg_core_handle);
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not cancel SM handle");
+            break;
+        }
+    }
+
+    hg_thread_spin_unlock(&context->sm_pending_list_lock);
+
     return ret;
 }
+#endif
 
 /*---------------------------------------------------------------------------*/
 static hg_return_t
-hg_core_context_lists_wait(struct hg_core_private_context *context)
+hg_core_created_list_wait(struct hg_core_private_context *context)
 {
     hg_util_bool_t created_list_empty = HG_UTIL_FALSE;
-    hg_util_bool_t pending_list_empty = HG_UTIL_FALSE;
-#ifdef HG_HAS_SM_ROUTING
-    hg_util_bool_t sm_pending_list_empty = HG_UTIL_FALSE;
-#else
-    hg_util_bool_t sm_pending_list_empty = HG_UTIL_TRUE;
-#endif
     /* Convert timeout in ms into seconds */
-    double remaining = HG_CORE_CLEANUP_TIMEOUT / 1000.0;
+    double remaining = HG_CORE_PROCESSING_TIMEOUT / 1000.0;
     hg_return_t ret = HG_SUCCESS;
 
-    do {
+    while (remaining > 0) {
         unsigned int actual_count = 0;
         hg_time_t t1, t2;
-        hg_return_t trigger_ret, progress_ret;
+        hg_return_t trigger_ret;
 
         hg_time_get_current(&t1);
 
@@ -990,35 +1049,22 @@ hg_core_context_lists_wait(struct hg_core_private_context *context)
         do {
             trigger_ret = hg_core_trigger(context, 0, 1, &actual_count);
         } while ((trigger_ret == HG_SUCCESS) && actual_count);
-        HG_CHECK_ERROR(trigger_ret != HG_SUCCESS && trigger_ret != HG_TIMEOUT,
-            done, ret, trigger_ret, "Could not trigger entry");
 
         hg_thread_spin_lock(&context->created_list_lock);
         created_list_empty = HG_LIST_IS_EMPTY(&context->created_list);
         hg_thread_spin_unlock(&context->created_list_lock);
 
-        hg_thread_spin_lock(&context->pending_list_lock);
-        pending_list_empty = HG_LIST_IS_EMPTY(&context->pending_list);
-#ifdef HG_HAS_SM_ROUTING
-        sm_pending_list_empty = HG_LIST_IS_EMPTY(&context->sm_pending_list);
-#endif
-        hg_thread_spin_unlock(&context->pending_list_lock);
-
-        if (created_list_empty && pending_list_empty && sm_pending_list_empty)
+        if (created_list_empty)
             break;
 
-        progress_ret = context->progress(context,
-            (unsigned int) (remaining * 1000.0));
-        HG_CHECK_ERROR(progress_ret != HG_SUCCESS && progress_ret != HG_TIMEOUT,
-            done, ret, progress_ret, "Could not make progress");
+        ret = context->progress(context, (unsigned int) (remaining * 1000.0));
+        if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
+            HG_LOG_ERROR("Could not make progress");
+            goto done;
+        }
         hg_time_get_current(&t2);
         remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
-        if (remaining < 0)
-            remaining = 0;
-    } while (remaining > 0 || !pending_list_empty || !sm_pending_list_empty);
-
-    HG_LOG_DEBUG("Remaining %lf, Context list status: %d, %d, %d", remaining,
-        created_list_empty, pending_list_empty, sm_pending_list_empty);
+    }
 
 done:
     return ret;
@@ -1040,8 +1086,11 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     /* Create new HG class */
     hg_core_class = (struct hg_core_private_class *) malloc(
         sizeof(struct hg_core_private_class));
-    HG_CHECK_ERROR(hg_core_class == NULL, error, ret, HG_NOMEM,
-        "Could not allocate HG class");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("Could not allocate HG class");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     memset(hg_core_class, 0, sizeof(struct hg_core_private_class));
 
     /* Parse options */
@@ -1055,16 +1104,19 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
 #ifdef HG_HAS_SM_ROUTING
         auto_sm = hg_init_info->auto_sm;
 #else
-        HG_CHECK_WARNING(hg_init_info->auto_sm,
-            "Auto SM requested but not enabled, "
-            "please turn ON MERCURY_USE_SM_ROUTING in CMake options");
+        if (hg_init_info->auto_sm) {
+            HG_LOG_WARNING("Auto SM requested but not enabled, "
+                "please turn ON MERCURY_USE_SM_ROUTING in CMake options");
+        }
 #endif
 #ifdef HG_HAS_COLLECT_STATS
         hg_core_class->stats = hg_init_info->stats;
         if (hg_core_class->stats && !hg_core_print_stats_registered_g) {
-            int rc = atexit(hg_core_print_stats);
-            HG_CHECK_ERROR(rc != 0, error, ret, HG_PROTOCOL_ERROR,
-                "Could not register hg_core_print_stats");
+            if (atexit(hg_core_print_stats) != 0) {
+                HG_LOG_ERROR("Could not register hg_core_print_stats");
+                ret = HG_PROTOCOL_ERROR;
+                goto done;
+            }
             hg_core_print_stats_registered_g = HG_TRUE;
         }
 #endif
@@ -1074,44 +1126,62 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     if (!hg_core_class->na_ext_init) {
         hg_core_class->core_class.na_class = NA_Initialize_opt(
             na_info_string, na_listen, &hg_init_info->na_init_info);
-        HG_CHECK_ERROR(hg_core_class->core_class.na_class == NULL, error, ret,
-            HG_NA_ERROR, "Could not initialize NA class");
+        if (!hg_core_class->core_class.na_class) {
+            HG_LOG_ERROR("Could not initialize NA class");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
     }
 
 #ifdef HG_HAS_SM_ROUTING
     /* Initialize SM plugin */
     if (auto_sm) {
-        HG_CHECK_ERROR(strcmp(NA_Get_class_name(
-            hg_core_class->core_class.na_class), "na") == 0, error, ret,
-            HG_PROTONOSUPPORT, "Cannot use auto SM mode if initialized "
-                "NA class is already using SM");
+        if (strcmp(NA_Get_class_name(hg_core_class->core_class.na_class),
+            "na") == 0) {
+            HG_LOG_ERROR("Cannot use auto SM mode if initialized NA class is "
+                "already using SM");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
 
         /* Initialize NA SM first so that tmp directories are created */
         hg_core_class->core_class.na_sm_class = NA_Initialize_opt("na+sm",
             na_listen, &hg_init_info->na_init_info);
-        HG_CHECK_ERROR(hg_core_class->core_class.na_sm_class == NULL, error,
-            ret, HG_NA_ERROR, "Could not initialize NA SM class");
+        if (!hg_core_class->core_class.na_sm_class) {
+            HG_LOG_ERROR("Could not initialize NA SM class");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
 
         /* Get SM UUID */
         ret = hg_core_get_sm_uuid(&hg_core_class->na_sm_uuid);
-        HG_CHECK_HG_ERROR(error, ret, "Could not get SM UUID");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not get SM UUID");
+            goto done;
+        }
     }
 #endif
 
     /* Compute max request tag */
     na_max_tag = NA_Msg_get_max_tag(hg_core_class->core_class.na_class);
-    HG_CHECK_ERROR(na_max_tag == 0, error, ret, HG_NA_ERROR,
-        "NA Max tag is not defined");
+    if (!na_max_tag) {
+        HG_LOG_ERROR("NA Max tag is not defined");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
     hg_core_class->request_max_tag = na_max_tag;
 
 #ifdef HG_HAS_SM_ROUTING
     if (auto_sm) {
         na_sm_max_tag = NA_Msg_get_max_tag(
             hg_core_class->core_class.na_sm_class);
-        HG_CHECK_ERROR(na_sm_max_tag == 0, error, ret, HG_NA_ERROR,
-            "NA Max tag is not defined");
-        hg_core_class->request_max_tag = HG_CORE_MIN(
-            hg_core_class->request_max_tag, na_sm_max_tag);
+        if (!na_max_tag) {
+            HG_LOG_ERROR("NA Max tag is not defined");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
+        hg_core_class->request_max_tag = HG_CORE_MIN(hg_core_class->request_max_tag,
+            na_sm_max_tag);
     }
 #endif
 
@@ -1125,11 +1195,12 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     hg_atomic_init32(&hg_core_class->n_addrs, 0);
 
     /* Create new function map */
-    hg_core_class->func_map = hg_hash_table_new(hg_core_int_hash,
-        hg_core_int_equal);
-    HG_CHECK_ERROR(hg_core_class->func_map == NULL, error, ret, HG_NOMEM,
-        "Could not create function map");
-
+    hg_core_class->func_map = hg_hash_table_new(hg_core_int_hash, hg_core_int_equal);
+    if (!hg_core_class->func_map) {
+        HG_LOG_ERROR("Could not create function map");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     /* Automatically free all the values with the hash map */
     hg_hash_table_register_free_functions(hg_core_class->func_map, free,
             hg_core_func_map_value_free);
@@ -1137,13 +1208,12 @@ hg_core_init(const char *na_info_string, hg_bool_t na_listen,
     /* Initialize mutex */
     hg_thread_spin_init(&hg_core_class->func_map_lock);
 
-    // TODO
-    (void)ret;
+done:
+    if (ret != HG_SUCCESS) {
+        hg_core_finalize(hg_core_class);
+        hg_core_class = NULL;
+    }
     return hg_core_class;
-
-error:
-    hg_core_finalize(hg_core_class);
-    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1152,19 +1222,24 @@ hg_core_finalize(struct hg_core_private_class *hg_core_class)
 {
     hg_util_int32_t n_addrs, n_contexts;
     hg_return_t ret = HG_SUCCESS;
-    na_return_t na_ret;
 
-    if (!hg_core_class)
-        goto done;
+    if (!hg_core_class) goto done;
 
     n_contexts = hg_atomic_get32(&hg_core_class->n_contexts);
-    HG_CHECK_ERROR(n_contexts != 0, done, ret, HG_BUSY,
-        "HG contexts must be destroyed before finalizing HG (%d remaining)",
-        n_contexts);
+    if (n_contexts != 0) {
+        HG_LOG_ERROR("HG contexts must be destroyed before finalizing HG"
+            " (%d remaining)", n_contexts);
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     n_addrs = hg_atomic_get32(&hg_core_class->n_addrs);
-    HG_CHECK_ERROR(n_addrs != 0, done, ret, HG_BUSY,
-        "HG addrs must be freed before finalizing HG (%d remaining)", n_addrs);
+    if (n_addrs != 0) {
+        HG_LOG_ERROR("HG addrs must be freed before finalizing HG"
+            " (%d remaining)", n_addrs);
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Delete function map */
     if(hg_core_class->func_map)
@@ -1181,23 +1256,27 @@ hg_core_finalize(struct hg_core_private_class *hg_core_class)
 
     if (!hg_core_class->na_ext_init) {
         /* Finalize interface */
-        na_ret = NA_Finalize(hg_core_class->core_class.na_class);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not finalize NA interface (%s)", NA_Error_to_string(na_ret));
+        if (NA_Finalize(hg_core_class->core_class.na_class) != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not finalize NA interface");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
         hg_core_class->core_class.na_class = NULL;
     }
 
 #ifdef HG_HAS_SM_ROUTING
     /* Finalize SM interface */
-    na_ret = NA_Finalize(hg_core_class->core_class.na_sm_class);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-        "Could not finalize NA SM interface (%s)", NA_Error_to_string(na_ret));
+    if (NA_Finalize(hg_core_class->core_class.na_sm_class) != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not finalize NA SM interface");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
 #endif
 
+done:
     /* Free HG class */
     free(hg_core_class);
 
-done:
     return ret;
 }
 
@@ -1210,9 +1289,10 @@ hg_core_addr_create(struct hg_core_private_class *hg_core_class,
 
     hg_core_addr = (struct hg_core_private_addr *) malloc(
         sizeof(struct hg_core_private_addr));
-    HG_CHECK_ERROR_NORET(hg_core_addr == NULL, done,
-        "Could not allocate HG addr");
-
+    if (!hg_core_addr) {
+        HG_LOG_ERROR("Could not allocate HG addr");
+        goto done;
+    }
     memset(hg_core_addr, 0, sizeof(struct hg_core_private_addr));
     hg_core_addr->core_addr.na_class = na_class;
     hg_core_addr->core_addr.na_addr = NA_ADDR_NULL;
@@ -1246,21 +1326,26 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
     hg_return_t ret = HG_SUCCESS, progress_ret;
 
     /* Allocate op_id */
-    hg_core_op_id = (struct hg_core_op_id *) malloc(
-        sizeof(struct hg_core_op_id));
-    HG_CHECK_ERROR(hg_core_op_id == NULL, error, ret, HG_NOMEM,
-        "Could not allocate HG operation ID");
-
+    hg_core_op_id = (struct hg_core_op_id *) malloc(sizeof(struct hg_core_op_id));
+    if (!hg_core_op_id) {
+        HG_LOG_ERROR("Could not allocate HG operation ID");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     hg_core_op_id->context = context;
     hg_core_op_id->type = HG_CB_LOOKUP;
     hg_core_op_id->callback = callback;
     hg_core_op_id->arg = arg;
+    hg_atomic_init32(&hg_core_op_id->completed, 0);
     hg_core_op_id->info.lookup.hg_core_addr = NULL;
 
     /* Allocate addr */
     hg_core_addr = hg_core_addr_create(HG_CORE_CONTEXT_CLASS(context), NULL);
-    HG_CHECK_ERROR(hg_core_addr == NULL, error, ret, HG_NOMEM,
-        "Could not create HG addr");
+    if (!hg_core_addr) {
+        HG_LOG_ERROR("Could not create HG addr");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     hg_core_op_id->info.lookup.hg_core_addr = hg_core_addr;
 
 #ifdef HG_HAS_SM_ROUTING
@@ -1274,9 +1359,11 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
         /* Get first part of address string with UUID */
         strtok_r(lookup_name, HG_CORE_ADDR_DELIMITER, &lookup_names);
 
-        HG_CHECK_ERROR(strstr(name, HG_CORE_PROTO_DELIMITER) == NULL, error,
-            ret, HG_PROTOCOL_ERROR, "Malformed address format");
-
+        if (!strstr(name, HG_CORE_PROTO_DELIMITER)) {
+            HG_LOG_ERROR("Malformed address format");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
         /* Get address SM UUID */
         strtok_r(lookup_name, HG_CORE_PROTO_DELIMITER, &local_id_str);
         uuid_parse(local_id_str + 2, hg_core_addr->na_sm_uuid);
@@ -1303,10 +1390,11 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
 
     /* Try to use immediate lookup */
     na_ret = NA_Addr_lookup2(na_class, name_str, &na_addr);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-        "Could not start lookup for address %s (%s)", name_str,
-        NA_Error_to_string(na_ret));
-
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not start lookup for address %s", name_str);
+        ret = HG_NA_ERROR;
+        goto done;
+    }
     if (na_addr != NA_ADDR_NULL) {
         struct na_cb_info callback_info;
         callback_info.arg = hg_core_op_id;
@@ -1322,26 +1410,32 @@ hg_core_addr_lookup(struct hg_core_private_context *context,
 
         na_ret = NA_Addr_lookup(na_class, na_context, hg_core_addr_lookup_cb,
             hg_core_op_id, name_str, &hg_core_op_id->info.lookup.na_lookup_op_id);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-            "Could not start lookup for address %s (%s)", name_str,
-            NA_Error_to_string(na_ret));
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not start lookup for address %s", name_str);
+            ret = HG_NA_ERROR;
+            goto done;
+        }
     }
 
     /* TODO to avoid blocking after lookup make progress on the HG layer with
      * timeout of 0 */
     progress_ret = context->progress(context, 0);
-    HG_CHECK_ERROR(progress_ret != HG_SUCCESS && progress_ret != HG_TIMEOUT,
-        error, ret, progress_ret, "Could not make progress");
+    if (progress_ret != HG_SUCCESS && progress_ret != HG_TIMEOUT) {
+        HG_LOG_ERROR("Could not make progress");
+        ret = progress_ret;
+        goto done;
+    }
 
     /* Assign op_id */
     if (op_id && op_id != HG_CORE_OP_ID_IGNORE)
         *op_id = (hg_core_op_id_t) hg_core_op_id;
 
-    return ret;
-
-error:
-    free(hg_core_op_id);
-    hg_core_addr_free(HG_CORE_CONTEXT_CLASS(context), hg_core_addr);
+done:
+    if (ret != HG_SUCCESS) {
+        free(hg_core_op_id);
+        if (hg_core_addr != NULL)
+            hg_core_addr_free(HG_CORE_CONTEXT_CLASS(context), hg_core_addr);
+    }
 
     return ret;
 }
@@ -1352,24 +1446,26 @@ hg_core_addr_lookup_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_op_id *hg_core_op_id =
         (struct hg_core_op_id *) callback_info->arg;
-    na_return_t na_ret = callback_info->ret;
-    hg_return_t hg_ret;
+    na_return_t na_ret = NA_SUCCESS;
     int ret = 0;
 
-    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done, "(%s)",
-        NA_Error_to_string(na_ret));
+    if (callback_info->ret != NA_SUCCESS) {
+        return ret;
+    }
 
     /* Assign addr */
     hg_core_op_id->info.lookup.hg_core_addr->core_addr.na_addr =
         callback_info->info.lookup.addr;
 
     /* Mark as completed */
-    hg_ret = hg_core_addr_lookup_complete(hg_core_op_id);
-    HG_CHECK_HG_ERROR(done, hg_ret, "Could not complete operation");
-
+    if (hg_core_addr_lookup_complete(hg_core_op_id) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        goto done;
+    }
     ret++;
 
 done:
+    (void) na_ret;
     return ret;
 }
 
@@ -1382,12 +1478,17 @@ hg_core_addr_lookup_complete(struct hg_core_op_id *hg_core_op_id)
         &hg_core_op_id->hg_completion_entry;
     hg_return_t ret = HG_SUCCESS;
 
+    /* Mark operation as completed */
+    hg_atomic_incr32(&hg_core_op_id->completed);
+
     hg_completion_entry->op_type = HG_ADDR;
     hg_completion_entry->op_id.hg_core_op_id = hg_core_op_id;
 
     ret = hg_core_completion_add(context, hg_completion_entry, HG_FALSE);
-    HG_CHECK_HG_ERROR(done, ret,
-        "Could not add HG completion entry to completion queue");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not add HG completion entry to completion queue");
+        goto done;
+    }
 
 done:
     return ret;
@@ -1401,12 +1502,12 @@ hg_core_addr_free(struct hg_core_private_class *hg_core_class,
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
-    if (!hg_core_addr)
-        goto done;
+    if (!hg_core_addr) goto done;
 
-    if (hg_atomic_decr32(&hg_core_addr->ref_count))
+    if (hg_atomic_decr32(&hg_core_addr->ref_count)) {
         /* Cannot free yet */
         goto done;
+    }
 
     /* Decrement N addrs from HG class */
     hg_atomic_decr32(&hg_core_class->n_addrs);
@@ -1416,17 +1517,22 @@ hg_core_addr_free(struct hg_core_private_class *hg_core_class,
     if (hg_core_addr->core_addr.na_sm_addr != NA_ADDR_NULL) {
         na_ret = NA_Addr_free(hg_core_class->core_class.na_sm_class,
             hg_core_addr->core_addr.na_sm_addr);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not free NA SM address (%s)", NA_Error_to_string(na_ret));
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not free NA SM address");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
     }
 #endif
 
     /* Free NA address */
     na_ret = NA_Addr_free(hg_core_addr->core_addr.na_class,
         hg_core_addr->core_addr.na_addr);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-        "Could not free NA address (%s)", NA_Error_to_string(na_ret));
-
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not free address");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
     free(hg_core_addr);
 
 done:
@@ -1444,21 +1550,30 @@ hg_core_addr_self(struct hg_core_private_class *hg_core_class,
 
     hg_core_addr = hg_core_addr_create(hg_core_class,
         hg_core_class->core_class.na_class);
-    HG_CHECK_ERROR(hg_core_addr == NULL, done, ret, HG_NOMEM,
-        "Could not create HG addr");
+    if (!hg_core_addr) {
+        HG_LOG_ERROR("Could not create HG addr");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
 
     na_ret = NA_Addr_self(hg_core_class->core_class.na_class,
         &hg_core_addr->core_addr.na_addr);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-        "Could not get self address (%s)", NA_Error_to_string(na_ret));
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not get self address");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
 
 #ifdef HG_HAS_SM_ROUTING
     if (hg_core_class->core_class.na_sm_class) {
         /* Get SM address */
         na_ret = NA_Addr_self(hg_core_class->core_class.na_sm_class,
             &hg_core_addr->core_addr.na_sm_addr);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not get self SM address (%s)", NA_Error_to_string(na_ret));
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not get self SM address");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
 
         /* Copy local UUID */
         uuid_copy(hg_core_addr->na_sm_uuid, hg_core_class->na_sm_uuid);
@@ -1490,14 +1605,18 @@ hg_core_addr_dup(struct hg_core_private_class *hg_core_class,
 
         dup = hg_core_addr_create(hg_core_class,
             hg_core_addr->core_addr.na_class);
-        HG_CHECK_ERROR(dup == NULL, done, ret, HG_NOMEM,
-            "Could not create dup HG addr");
-
+        if (!dup) {
+            HG_LOG_ERROR("Could not create HG addr");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
         na_ret = NA_Addr_dup(hg_core_addr->core_addr.na_class,
             hg_core_addr->core_addr.na_addr, &dup->core_addr.na_addr);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not duplicate address (%s)", NA_Error_to_string(na_ret));
-
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not duplicate address");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
         *hg_new_addr = dup;
     } else {
         hg_atomic_incr32(&hg_core_addr->ref_count);
@@ -1518,6 +1637,11 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
+    if (!buf_size) {
+        HG_LOG_ERROR("NULL buffer size");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
     new_buf_size = *buf_size;
 
 #ifdef HG_HAS_SM_ROUTING
@@ -1530,9 +1654,11 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
         uuid_unparse(hg_core_addr->na_sm_uuid, uuid_str);
         desc_len = snprintf(addr_str, HG_CORE_ADDR_MAX_SIZE,
             "uid://%s" HG_CORE_ADDR_DELIMITER, uuid_str);
-        HG_CHECK_ERROR(desc_len > HG_CORE_ADDR_MAX_SIZE, done, ret,
-            HG_OVERFLOW, "Exceeding max addr name");
-
+        if (desc_len > HG_CORE_ADDR_MAX_SIZE) {
+            HG_LOG_ERROR("Exceeding max addr name");
+            ret = HG_SIZE_ERROR;
+            goto done;
+        }
         if (buf_ptr) {
             strcpy(buf_ptr, addr_str);
             buf_ptr += desc_len;
@@ -1544,10 +1670,11 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
         /* Get NA SM address string */
         na_ret = NA_Addr_to_string(hg_core_class->core_class.na_sm_class,
             buf_ptr, &new_buf_size, hg_core_addr->core_addr.na_sm_addr);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not convert SM address to string (%s)",
-            NA_Error_to_string(na_ret));
-
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not convert SM address to string");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
         if (buf_ptr) {
             buf_ptr[new_buf_size - 1] = *HG_CORE_ADDR_DELIMITER;
             buf_ptr += new_buf_size;
@@ -1561,9 +1688,11 @@ hg_core_addr_to_string(struct hg_core_private_class *hg_core_class, char *buf,
     /* Get NA address string */
     na_ret = NA_Addr_to_string(hg_core_class->core_class.na_class, buf_ptr,
         &new_buf_size, hg_core_addr->core_addr.na_addr);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-        "Could not convert address to string (%s)", NA_Error_to_string(na_ret));
-
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not convert address to string");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
     *buf_size = new_buf_size + buf_size_used;
 
 done:
@@ -1579,9 +1708,10 @@ hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
 
     hg_core_handle = (struct hg_core_private_handle *) malloc(
         sizeof(struct hg_core_private_handle));
-    HG_CHECK_ERROR_NORET(hg_core_handle == NULL, error,
-        "Could not allocate handle");
-
+    if (!hg_core_handle) {
+        HG_LOG_ERROR("Could not allocate handle");
+        goto done;
+    }
     memset(hg_core_handle, 0, sizeof(struct hg_core_private_handle));
 
     hg_core_handle->op_type = HG_CORE_PROCESS; /* Default */
@@ -1604,12 +1734,6 @@ hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
     /* Handle is not in use */
     hg_atomic_init32(&hg_core_handle->in_use, HG_FALSE);
 
-    /* Handle has not been posted */
-    hg_atomic_init32(&hg_core_handle->posted, HG_FALSE);
-
-    /* Handle is not being canceled */
-    hg_atomic_init32(&hg_core_handle->canceling, HG_FALSE);
-
     /* Init in/out header */
     hg_core_header_request_init(&hg_core_handle->in_header);
     hg_core_header_response_init(&hg_core_handle->out_header);
@@ -1622,21 +1746,25 @@ hg_core_create(struct hg_core_private_context *context, hg_bool_t use_sm)
 
     /* Alloc/init NA resources */
     ret = hg_core_alloc_na(hg_core_handle, use_sm);
-    HG_CHECK_HG_ERROR(error, ret, "Could not allocate NA handle ops");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not allocate NA handle ops");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
 
+done:
+    if (ret != HG_SUCCESS) {
+        hg_core_destroy(hg_core_handle);
+        hg_core_handle = NULL;
+    }
     return hg_core_handle;
-
-error:
-    hg_core_destroy(hg_core_handle);
-    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
 static void
 hg_core_destroy(struct hg_core_private_handle *hg_core_handle)
 {
-    if (!hg_core_handle)
-        goto done;
+    if (!hg_core_handle) goto done;
 
     if (hg_atomic_decr32(&hg_core_handle->ref_count))
         goto done; /* Cannot free yet */
@@ -1681,7 +1809,6 @@ hg_core_alloc_na(struct hg_core_private_handle *hg_core_handle,
     hg_bool_t HG_UNUSED use_sm)
 {
     hg_return_t ret = HG_SUCCESS;
-    na_return_t na_ret;
 
     /* Set handle NA class/context */
     hg_core_handle->na_class =
@@ -1708,47 +1835,46 @@ hg_core_alloc_na(struct hg_core_private_handle *hg_core_handle,
     hg_core_handle->core_handle.in_buf = NA_Msg_buf_alloc(
         hg_core_handle->na_class, hg_core_handle->core_handle.in_buf_size,
         &hg_core_handle->in_buf_plugin_data);
-    HG_CHECK_ERROR(hg_core_handle->core_handle.in_buf == NULL, error, ret,
-        HG_NOMEM, "Could not allocate buffer for input");
-
-    na_ret = NA_Msg_init_unexpected(hg_core_handle->na_class,
+    if (!hg_core_handle->core_handle.in_buf) {
+        HG_LOG_ERROR("Could not allocate buffer for input");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
+    NA_Msg_init_unexpected(hg_core_handle->na_class,
         hg_core_handle->core_handle.in_buf,
         hg_core_handle->core_handle.in_buf_size);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-        "Could not initialize input buffer (%s)",
-        NA_Error_to_string(na_ret));
 
     hg_core_handle->core_handle.out_buf = NA_Msg_buf_alloc(
         hg_core_handle->na_class, hg_core_handle->core_handle.out_buf_size,
         &hg_core_handle->out_buf_plugin_data);
-    HG_CHECK_ERROR(hg_core_handle->core_handle.out_buf == NULL, error, ret,
-        HG_NOMEM, "Could not allocate buffer for output");
-
-    na_ret = NA_Msg_init_expected(hg_core_handle->na_class,
+    if (!hg_core_handle->core_handle.out_buf) {
+        HG_LOG_ERROR("Could not allocate buffer for output");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
+    NA_Msg_init_expected(hg_core_handle->na_class,
         hg_core_handle->core_handle.out_buf,
         hg_core_handle->core_handle.out_buf_size);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-        "Could not initialize output buffer (%s)",
-        NA_Error_to_string(na_ret));
 
     /* Create NA operation IDs */
     hg_core_handle->na_send_op_id = NA_Op_create(hg_core_handle->na_class);
-    HG_CHECK_ERROR(hg_core_handle->na_send_op_id == NA_OP_ID_NULL, error, ret,
-        HG_NA_ERROR, "Could not create NA op ID");
     hg_core_handle->na_recv_op_id = NA_Op_create(hg_core_handle->na_class);
-    HG_CHECK_ERROR(hg_core_handle->na_recv_op_id == NA_OP_ID_NULL, error, ret,
-        HG_NA_ERROR, "Could not create NA op ID");
     hg_core_handle->na_ack_op_id = NA_Op_create(hg_core_handle->na_class);
-    HG_CHECK_ERROR(hg_core_handle->na_ack_op_id == NA_OP_ID_NULL, error, ret,
-        HG_NA_ERROR, "Could not create NA op ID");
-
+    if (hg_core_handle->na_recv_op_id || hg_core_handle->na_send_op_id
+        || hg_core_handle->na_ack_op_id) {
+        if ((hg_core_handle->na_recv_op_id == NA_OP_ID_NULL)
+            || (hg_core_handle->na_send_op_id == NA_OP_ID_NULL)
+            || (hg_core_handle->na_ack_op_id == NA_OP_ID_NULL)) {
+            HG_LOG_ERROR("NULL operation ID");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
+        hg_core_handle->na_op_id_mine = HG_TRUE;
+    }
     hg_core_handle->na_op_count = 1; /* Default (no response) */
     hg_atomic_init32(&hg_core_handle->na_op_completed_count, 0);
 
-    return ret;
-
-error:
-    hg_core_free_na(hg_core_handle);
+done:
     return ret;
 }
 
@@ -1758,52 +1884,33 @@ hg_core_free_na(struct hg_core_private_handle *hg_core_handle)
 {
     na_return_t na_ret;
 
+    /* Free eventual ack buffer */
+    if (hg_core_handle->ack_buf) {
+        NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->ack_buf,
+            hg_core_handle->ack_buf_plugin_data);
+        hg_core_handle->ack_buf = NULL;
+    }
+
     /* Destroy NA op IDs */
-    na_ret = NA_Op_destroy(hg_core_handle->na_class,
-        hg_core_handle->na_send_op_id);
-    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
-        "Could not destroy send op ID (%s)", NA_Error_to_string(na_ret));
-    hg_core_handle->na_send_op_id = NA_OP_ID_NULL;
-
-    na_ret = NA_Op_destroy(hg_core_handle->na_class,
-        hg_core_handle->na_recv_op_id);
-    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
-        "Could not destroy recv op ID (%s)", NA_Error_to_string(na_ret));
-    hg_core_handle->na_recv_op_id = NA_OP_ID_NULL;
-
-    na_ret = NA_Op_destroy(hg_core_handle->na_class,
-        hg_core_handle->na_ack_op_id);
-    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
-        "Could not destroy ack op ID (%s)", NA_Error_to_string(na_ret));
-    hg_core_handle->na_ack_op_id = NA_OP_ID_NULL;
+    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_send_op_id);
+    if (na_ret != NA_SUCCESS)
+        HG_LOG_ERROR("Could not destroy NA op ID");
+    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_recv_op_id);
+    if (na_ret != NA_SUCCESS)
+        HG_LOG_ERROR("Could not destroy NA op ID");
+    na_ret = NA_Op_destroy(hg_core_handle->na_class, hg_core_handle->na_ack_op_id);
+    if (na_ret != NA_SUCCESS)
+        HG_LOG_ERROR("Could not destroy NA op ID");
 
     /* Free buffers */
     na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
         hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_plugin_data);
-    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
-        "Could not free input buffer (%s)", NA_Error_to_string(na_ret));
-    hg_core_handle->core_handle.in_buf = NULL;
-    hg_core_handle->in_buf_plugin_data = NULL;
-
+    if (na_ret != NA_SUCCESS)
+        HG_LOG_ERROR("Could not destroy NA input msg buffer");
     na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
-        hg_core_handle->core_handle.out_buf,
-        hg_core_handle->out_buf_plugin_data);
-    HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
-        "Could not free output buffer (%s)", NA_Error_to_string(na_ret));
-    hg_core_handle->core_handle.out_buf = NULL;
-    hg_core_handle->out_buf_plugin_data = NULL;
-
-    if (hg_core_handle->ack_buf) {
-        na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
-            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
-        HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
-            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
-        hg_core_handle->ack_buf = NULL;
-        hg_core_handle->ack_buf_plugin_data = NULL;
-    }
-
-done:
-    return;
+        hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_plugin_data);
+    if (na_ret != NA_SUCCESS)
+        HG_LOG_ERROR("Could not destroy NA output msg buffer");
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1815,11 +1922,8 @@ hg_core_reset(struct hg_core_private_handle *hg_core_handle,
     if (reset_info) {
         if (hg_core_handle->core_handle.info.addr != HG_CORE_ADDR_NULL
             && hg_core_handle->core_handle.info.addr->na_addr != NA_ADDR_NULL) {
-            na_return_t na_ret = NA_Addr_free(
-                hg_core_handle->core_handle.info.addr->na_class,
+            NA_Addr_free(hg_core_handle->core_handle.info.addr->na_class,
                 hg_core_handle->core_handle.info.addr->na_addr);
-            HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
-                "Could not free NA address (%s)", NA_Error_to_string(na_ret));
             hg_core_handle->core_handle.info.addr->na_addr = NA_ADDR_NULL;
         }
         hg_core_handle->core_handle.info.id = 0;
@@ -1844,19 +1948,14 @@ hg_core_reset(struct hg_core_private_handle *hg_core_handle,
         HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_release(
             (hg_core_handle_t) hg_core_handle);
     if (hg_core_handle->ack_buf) {
-        na_return_t na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
-            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
-        HG_CHECK_ERROR_NORET(na_ret != NA_SUCCESS, done,
-            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
+        NA_Msg_buf_free(hg_core_handle->na_class, hg_core_handle->ack_buf,
+            hg_core_handle->ack_buf_plugin_data);
         hg_core_handle->ack_buf = NULL;
         hg_core_handle->ack_buf_plugin_data = NULL;
     }
 
     hg_core_header_request_reset(&hg_core_handle->in_header);
     hg_core_header_response_reset(&hg_core_handle->out_header);
-
-done:
-    return;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -1902,9 +2001,11 @@ hg_core_set_rpc(struct hg_core_private_handle *hg_core_handle,
             (hg_hash_table_key_t) &id);
         hg_thread_spin_unlock(
             &HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map_lock);
-        if (!hg_core_rpc_info)
-            HG_GOTO_DONE(done, ret, HG_NOENTRY);
-
+        if (!hg_core_rpc_info) {
+            /* HG_LOG_ERROR("Could not find RPC ID in function map"); */
+            ret = HG_NO_MATCH;
+            goto done;
+        }
         hg_core_handle->core_handle.info.id = id;
 
         /* Cache RPC info */
@@ -1927,7 +2028,10 @@ hg_core_forward_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Post operation to self processing pool */
     ret = hg_core_process_self(hg_core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not self process handle");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not self process handle");
+        goto done;
+    }
 
 done:
     return ret;
@@ -1940,7 +2044,6 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
 {
     na_return_t na_ret;
     hg_return_t ret = HG_SUCCESS;
-    int retry_cnt = 0;
 
     /* Set operation type for trigger */
     hg_core_handle->op_type = HG_CORE_FORWARD;
@@ -1949,8 +2052,11 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
     hg_core_handle->tag = hg_core_gen_request_tag(
         HG_CORE_HANDLE_CLASS(hg_core_handle));
 
-    /* Pre-post recv (output) if response is expected */
     if (!hg_core_handle->no_response) {
+        /* Increment number of expected NA operations */
+        hg_core_handle->na_op_count++;
+
+        /* Pre-post the recv message (output) if response is expected */
         na_ret = NA_Msg_recv_expected(hg_core_handle->na_class,
             hg_core_handle->na_context, hg_core_recv_output_cb, hg_core_handle,
             hg_core_handle->core_handle.out_buf,
@@ -1959,62 +2065,35 @@ hg_core_forward_na(struct hg_core_private_handle *hg_core_handle)
             hg_core_handle->core_handle.info.addr->na_addr,
             hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
             &hg_core_handle->na_recv_op_id);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not post recv for output buffer (%s)",
-            NA_Error_to_string(na_ret));
-
-        /* Increment number of expected NA operations */
-        hg_core_handle->na_op_count++;
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not post recv for output buffer");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
     }
 
-    /* Mark handle as posted */
-    hg_atomic_set32(&hg_core_handle->posted, HG_TRUE);
-
-    /* Post send (input) */
-    do {
-        na_ret = NA_Msg_send_unexpected(hg_core_handle->na_class,
-            hg_core_handle->na_context, hg_core_send_input_cb, hg_core_handle,
-            hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_used,
-            hg_core_handle->in_buf_plugin_data,
-            hg_core_handle->core_handle.info.addr->na_addr,
-            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
-            &hg_core_handle->na_send_op_id);
-        if (na_ret != NA_AGAIN || retry_cnt++ > HG_CORE_MAX_AGAIN_RETRY)
-            break;
-
-        /* Attempt to make progress on NA with timeout of 0 */
-        na_ret = NA_Progress(hg_core_handle->na_class,
-            hg_core_handle->na_context, 0);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, cancel,
-            ret, (hg_return_t) na_ret, "Could not make progress on NA (%s)",
-            NA_Error_to_string(na_ret));
-    } while (1);
-    /* Silently return on NA_AGAIN error so that users can manually retry */
-    if (na_ret == NA_AGAIN)
-        HG_GOTO_DONE(cancel, ret, HG_AGAIN);
-
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, cancel, ret, (hg_return_t) na_ret,
-        "Could not post send for input buffer (%s)",
-        NA_Error_to_string(na_ret));
+    /* And post the send message (input) */
+    na_ret = NA_Msg_send_unexpected(hg_core_handle->na_class,
+        hg_core_handle->na_context, hg_core_send_input_cb, hg_core_handle,
+        hg_core_handle->core_handle.in_buf, hg_core_handle->in_buf_used,
+        hg_core_handle->in_buf_plugin_data,
+        hg_core_handle->core_handle.info.addr->na_addr,
+        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
+        &hg_core_handle->na_send_op_id);
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not post send for input buffer");
+        /* Cancel the above posted recv op */
+        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
+            hg_core_handle->na_recv_op_id);
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not cancel recv op id");
+        }
+        ret = HG_NA_ERROR;
+        goto done;
+    }
 
 done:
     return ret;
-
-cancel:
-    if (!hg_core_handle->no_response)
-        hg_core_handle->na_op_count--;
-
-    /* Handle is no longer posted and being canceled*/
-    hg_atomic_set32(&hg_core_handle->posted, HG_FALSE);
-    hg_atomic_set32(&hg_core_handle->canceling, HG_TRUE);
-
-    /* Cancel the above posted recv op */
-    na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-        hg_core_handle->na_recv_op_id);
-    HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
-        "Could not cancel recv op id (%s)", NA_Error_to_string(na_ret));
-
-    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2029,7 +2108,10 @@ hg_core_respond_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Complete and add to completion queue */
     ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not complete handle");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete handle");
+        goto done;
+    }
 
 done:
     return ret;
@@ -2046,7 +2128,10 @@ hg_core_no_respond_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Complete and add to completion queue */
     ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not complete handle");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete handle");
+        goto done;
+    }
 
 done:
     return ret;
@@ -2059,8 +2144,6 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
-    hg_bool_t ack_recv_posted = HG_FALSE;
-    int retry_cnt = 0;
 
     /* Increment number of expected NA operations */
     hg_core_handle->na_op_count++;
@@ -2075,15 +2158,15 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
 
         hg_core_handle->ack_buf = NA_Msg_buf_alloc(hg_core_handle->na_class,
             sizeof(hg_uint8_t), &hg_core_handle->ack_buf_plugin_data);
-        HG_CHECK_ERROR(hg_core_handle->ack_buf == NULL, error, ret,
-            HG_NA_ERROR, "Could not allocate buffer for ack");
+        if (!hg_core_handle->ack_buf) {
+            HG_LOG_ERROR("Could not allocate buffer for ack");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
+        NA_Msg_init_expected(hg_core_handle->na_class, hg_core_handle->ack_buf,
+            sizeof(hg_uint8_t));
 
-        na_ret = NA_Msg_init_expected(hg_core_handle->na_class,
-            hg_core_handle->ack_buf, sizeof(hg_uint8_t));
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-            "Could not initialize ack buffer (%s)", NA_Error_to_string(na_ret));
-
-        /* Pre-post recv (ack) if more data is expected */
+        /* Pre-post the recv message (output) if response is expected */
         na_ret = NA_Msg_recv_expected(hg_core_handle->na_class,
             hg_core_handle->na_context, hg_core_recv_ack_cb, hg_core_handle,
             hg_core_handle->ack_buf, sizeof(hg_uint8_t),
@@ -2091,55 +2174,28 @@ hg_core_respond_na(struct hg_core_private_handle *hg_core_handle)
             hg_core_handle->core_handle.info.addr->na_addr,
             hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
             &hg_core_handle->na_ack_op_id);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-            "Could not post recv for ack buffer (%s)",
-            NA_Error_to_string(na_ret));
-        ack_recv_posted = HG_TRUE;
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not post recv for ack buffer");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
     }
 
-    /* Post expected send (output) */
-    do {
-        na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
-            hg_core_handle->na_context, hg_core_send_output_cb, hg_core_handle,
-            hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_used,
-            hg_core_handle->out_buf_plugin_data,
-            hg_core_handle->core_handle.info.addr->na_addr,
-            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
-            &hg_core_handle->na_send_op_id);
-        if (na_ret != NA_AGAIN || retry_cnt++ > HG_CORE_MAX_AGAIN_RETRY)
-            break;
-
-        /* Attempt to make progress on NA with timeout of 0 */
-        na_ret = NA_Progress(hg_core_handle->na_class,
-            hg_core_handle->na_context, 0);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, error,
-            ret, (hg_return_t) na_ret, "Could not make progress on NA (%s)",
-            NA_Error_to_string(na_ret));
-    } while (1);
-    /* Expected sends should always succeed after retry */
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-        "Could not post send for output buffer (%s)",
-        NA_Error_to_string(na_ret));
-
-    return ret;
-
-error:
-    if (ack_recv_posted) {
-        /* Cancel the above posted recv ack op */
-        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
-            hg_core_handle->na_ack_op_id);
-        HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
-            "Could not cancel ack op id (%s)", NA_Error_to_string(na_ret));
-    }
-    if (hg_core_handle->ack_buf) {
-        na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
-            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
-        HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
-            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
-        hg_core_handle->ack_buf = NULL;
-        hg_core_handle->ack_buf_plugin_data = NULL;
+    /* Respond back */
+    na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
+        hg_core_handle->na_context, hg_core_send_output_cb, hg_core_handle,
+        hg_core_handle->core_handle.out_buf, hg_core_handle->out_buf_used,
+        hg_core_handle->out_buf_plugin_data,
+        hg_core_handle->core_handle.info.addr->na_addr,
+        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
+        &hg_core_handle->na_send_op_id);
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not post send for output buffer");
+        ret = HG_NA_ERROR;
+        goto done;
     }
 
+done:
     return ret;
 }
 
@@ -2153,7 +2209,10 @@ hg_core_no_respond_na(struct hg_core_private_handle *hg_core_handle)
     hg_core_handle->op_type = HG_CORE_NO_RESPOND;
 
     ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        goto done;
+    }
 
 done:
     return ret;
@@ -2165,20 +2224,27 @@ hg_core_send_input_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
+    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
-    hg_return_t ret;
 
-    /* If canceled, mark handle as canceled */
-    if (callback_info->ret == NA_CANCELED)
+    if (callback_info->ret == NA_CANCELED) {
+        /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
-    else
-        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
-            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
+    } else if (callback_info->ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Error in NA callback");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
-    ret = hg_core_complete_na(hg_core_handle, &completed);
-    HG_CHECK_HG_ERROR(done, ret, "Error in NA callback");
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_send_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Error in NA callback");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
 done:
+    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2191,77 +2257,103 @@ hg_core_recv_input_cb(const struct na_cb_info *callback_info)
     const struct na_cb_info_recv_unexpected *na_cb_info_recv_unexpected =
         &callback_info->info.recv_unexpected;
 #ifndef HG_HAS_POST_LIMIT
-    hg_bool_t pending_empty = HG_FALSE;
-    hg_bool_t use_sm = HG_FALSE;
+    hg_bool_t pending_empty = NA_FALSE;
+# ifdef HG_HAS_SM_ROUTING
+    hg_bool_t sm_pending_empty = NA_FALSE;
+# endif
 #endif
+    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
-    hg_return_t ret;
 
-    /* Remove handle from pending list */
-    hg_thread_spin_lock(
-        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
-    HG_LIST_REMOVE(hg_core_handle, pending);
-    hg_thread_spin_unlock(
-        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
-
-    /* If canceled, mark handle as canceled */
     if (callback_info->ret == NA_CANCELED) {
+        /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
         /* Only decrement refcount and exit */
         hg_core_destroy(hg_core_handle);
         goto done;
-    } else
-        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
-            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
+    } else if (callback_info->ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Error in NA callback");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Fill unexpected info */
     hg_core_handle->core_handle.info.addr->na_addr =
         na_cb_info_recv_unexpected->source;
     hg_core_handle->tag = na_cb_info_recv_unexpected->tag;
-    HG_CHECK_ERROR_NORET(na_cb_info_recv_unexpected->actual_buf_size >
-        hg_core_handle->core_handle.in_buf_size, done,
-        "Actual transfer size is too large for unexpected recv");
+    if (na_cb_info_recv_unexpected->actual_buf_size >
+    hg_core_handle->core_handle.in_buf_size) {
+        HG_LOG_ERROR("Actual transfer size is too large for unexpected recv");
+        goto done;
+    }
     hg_core_handle->in_buf_used = na_cb_info_recv_unexpected->actual_buf_size;
 
-#ifndef HG_HAS_POST_LIMIT
-    /* Check if we need more handles */
-    hg_thread_spin_lock(
-        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
-
-# ifdef HG_HAS_SM_ROUTING
-    if (hg_core_handle->na_class
-        == hg_core_handle->core_handle.info.core_class->na_sm_class) {
-        pending_empty =  HG_LIST_IS_EMPTY(
+    /* Remove handle from pending list */
+#ifdef HG_HAS_SM_ROUTING
+    if (hg_core_handle->na_class ==
+        hg_core_handle->core_handle.info.core_class->na_sm_class) {
+        hg_thread_spin_lock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
+        HG_LIST_REMOVE(hg_core_handle, pending);
+# ifndef HG_HAS_POST_LIMIT
+        sm_pending_empty = HG_LIST_IS_EMPTY(
             &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list);
-        use_sm = HG_TRUE;
-    } else
 # endif
+        hg_thread_spin_unlock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
+    } else {
+#endif
+        hg_thread_spin_lock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+        HG_LIST_REMOVE(hg_core_handle, pending);
+#ifndef HG_HAS_POST_LIMIT
         pending_empty = HG_LIST_IS_EMPTY(
             &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list);
+#endif
+        hg_thread_spin_unlock(
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+#ifdef HG_HAS_SM_ROUTING
+    }
+#endif
 
-    hg_thread_spin_unlock(
-        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
-
+#ifndef HG_HAS_POST_LIMIT
+    /* If pending list is empty, post more handles */
+    if (pending_empty
+        && hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
+        HG_CORE_PENDING_INCR, hg_core_handle->repost, HG_FALSE) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not post additional handles");
+        goto done;
+    }
+# ifdef HG_HAS_SM_ROUTING
     /* If pending list is empty, post more handles */
-    if (pending_empty) {
-        ret = hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
-            HG_CORE_PENDING_INCR, hg_core_handle->repost, use_sm);
-        HG_CHECK_HG_ERROR(done, ret, "Could not post additional handles");
+    if (sm_pending_empty
+        && hg_core_context_post(HG_CORE_HANDLE_CONTEXT(hg_core_handle),
+        HG_CORE_PENDING_INCR, hg_core_handle->repost, HG_TRUE) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not post additional SM handles");
+        goto done;
     }
+# endif
 #endif
 
     /* Set operation type for trigger */
     hg_core_handle->op_type = HG_CORE_PROCESS;
 
     /* Process input information */
-    ret = hg_core_process_input(hg_core_handle, &completed);
-    HG_CHECK_HG_ERROR(done, ret, "Could not process input");
+    if (hg_core_process_input(hg_core_handle, &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not process input");
+        goto done;
+    }
 
     /* Complete operation */
-    ret = hg_core_complete_na(hg_core_handle, &completed);
-    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_recv_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
 done:
+    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2280,7 +2372,10 @@ hg_core_process_input(struct hg_core_private_handle *hg_core_handle,
     /* Get and verify input header */
     ret = hg_core_proc_header_request(&hg_core_handle->core_handle,
         &hg_core_handle->in_header, HG_DECODE);
-    HG_CHECK_HG_ERROR(done, ret, "Could not get request header");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not get request header");
+        goto done;
+    }
 
     /* Get operation ID from header */
     hg_core_handle->core_handle.info.id =
@@ -2304,17 +2399,21 @@ hg_core_process_input(struct hg_core_private_handle *hg_core_handle,
 
     /* Must let upper layer get extra payload if HG_CORE_MORE_DATA is set */
     if (hg_core_handle->in_header.msg.request.flags & HG_CORE_MORE_DATA) {
-        HG_CHECK_ERROR(!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire,
-            done, ret, HG_OPNOTSUPPORTED,
-            "No callback defined for acquiring more data");
+        if (!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire) {
+            HG_LOG_ERROR("No callback defined for acquiring more data");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
 #ifdef HG_HAS_COLLECT_STATS
         /* Increment counter */
         hg_core_stat_incr(&hg_core_rpc_extra_count_g);
 #endif
         ret = HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire(
             (hg_core_handle_t) hg_core_handle, HG_INPUT, hg_core_complete);
-        HG_CHECK_HG_ERROR(done, ret,
-            "Error in HG core handle more data acquire callback");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Error in HG core handle more data acquire callback");
+            goto done;
+        }
         *completed = HG_FALSE;
     } else
         *completed = HG_TRUE;
@@ -2329,21 +2428,28 @@ hg_core_send_output_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
+    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
-    hg_return_t ret;
 
-    /* If canceled, mark handle as canceled */
-    if (callback_info->ret == NA_CANCELED)
+    if (callback_info->ret == NA_CANCELED) {
+        /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
-    else
-        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
-            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
+    } else if (callback_info->ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Error in NA callback");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Complete operation */
-    ret = hg_core_complete_na(hg_core_handle, &completed);
-    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_send_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
 done:
+    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2353,35 +2459,36 @@ hg_core_recv_output_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
+    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
-    hg_return_t ret;
 
-    /* If canceled, mark handle as canceled */
     if (callback_info->ret == NA_CANCELED) {
+        /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
-
-        /* Do not add handle to completion queue if it was not posted */
-        if (hg_atomic_get32(&hg_core_handle->posted))
-            goto complete;
-        else {
-            /* Cancelation has been processed */
-            hg_atomic_set32(&hg_core_handle->canceling, HG_FALSE);
-            goto done;
-        }
-    } else
-        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
-            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
+    } else if (callback_info->ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Error in NA callback");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Process output information */
-    ret = hg_core_process_output(hg_core_handle, &completed, hg_core_send_ack);
-    HG_CHECK_HG_ERROR(done, ret, "Could not process output");
+    if (hg_core_handle->ret != HG_CANCELED
+        && hg_core_process_output(hg_core_handle, &completed, hg_core_send_ack)
+            != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not process output");
+        goto done;
+    }
 
-complete:
     /* Complete operation */
-    ret = hg_core_complete_na(hg_core_handle, &completed);
-    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_recv_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
 done:
+    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2394,9 +2501,11 @@ hg_core_process_output(struct hg_core_private_handle *hg_core_handle,
     hg_return_t ret = HG_SUCCESS;
 
     /* Get and verify output header */
-    ret= hg_core_proc_header_response(&hg_core_handle->core_handle,
-        &hg_core_handle->out_header, HG_DECODE);
-    HG_CHECK_HG_ERROR(done, ret, "Could not decode header");
+    if (hg_core_proc_header_response(&hg_core_handle->core_handle,
+        &hg_core_handle->out_header, HG_DECODE) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not decode header");
+        goto done;
+    }
 
     /* Get return code from header */
     hg_core_handle->ret =
@@ -2406,14 +2515,17 @@ hg_core_process_output(struct hg_core_private_handle *hg_core_handle,
 
     /* Must let upper layer get extra payload if HG_CORE_MORE_DATA is set */
     if (hg_core_handle->out_header.msg.response.flags & HG_CORE_MORE_DATA) {
-        HG_CHECK_ERROR(!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire,
-            done, ret, HG_OPNOTSUPPORTED,
-            "No callback defined for acquiring more data");
-
+        if (!HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire) {
+            HG_LOG_ERROR("No callback defined for acquiring more data");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
         ret = HG_CORE_HANDLE_CLASS(hg_core_handle)->more_data_acquire(
             (hg_core_handle_t) hg_core_handle, HG_OUTPUT, done_callback);
-        HG_CHECK_HG_ERROR(done, ret,
-            "Error in HG core handle more data acquire callback");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Error in HG core handle more data acquire callback");
+            goto done;
+        }
         *completed = HG_FALSE;
     } else
         *completed = HG_TRUE;
@@ -2430,7 +2542,6 @@ hg_core_send_ack(hg_core_handle_t handle)
         (struct hg_core_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
-    int retry_cnt = 0;
 
     /* Increment number of expected NA operations */
     hg_core_handle->na_op_count++;
@@ -2438,48 +2549,29 @@ hg_core_send_ack(hg_core_handle_t handle)
     /* Allocate buffer for ack */
     hg_core_handle->ack_buf = NA_Msg_buf_alloc(hg_core_handle->na_class,
         sizeof(hg_uint8_t), &hg_core_handle->ack_buf_plugin_data);
-    HG_CHECK_ERROR(hg_core_handle->ack_buf == NULL, error, ret, HG_NA_ERROR,
-        "Could not allocate buffer for ack");
-
-    na_ret = NA_Msg_init_expected(hg_core_handle->na_class,
-        hg_core_handle->ack_buf, sizeof(hg_uint8_t));
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-        "Could not initialize ack buffer (%s)", NA_Error_to_string(na_ret));
-
-    /* Post expected send (ack) */
-    do {
-        na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
-            hg_core_handle->na_context, hg_core_send_ack_cb, hg_core_handle,
-            hg_core_handle->ack_buf, sizeof(hg_uint8_t),
-            hg_core_handle->ack_buf_plugin_data,
-            hg_core_handle->core_handle.info.addr->na_addr,
-            hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
-            &hg_core_handle->na_ack_op_id);
-        if (na_ret != NA_AGAIN || retry_cnt++ > HG_CORE_MAX_AGAIN_RETRY)
-            break;
-
-        /* Attempt to make progress on NA with timeout of 0 */
-        na_ret = NA_Progress(hg_core_handle->na_class,
-            hg_core_handle->na_context, 0);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, error,
-            ret, (hg_return_t) na_ret, "Could not make progress on NA (%s)",
-            NA_Error_to_string(na_ret));
-    } while (1);
-    /* Expected sends should always succeed after retry */
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-        "Could not post send for ack buffer (%s)", NA_Error_to_string(na_ret));
-
-    return ret;
+    if (!hg_core_handle->ack_buf) {
+        HG_LOG_ERROR("Could not allocate buffer for ack");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
+    NA_Msg_init_expected(hg_core_handle->na_class, hg_core_handle->ack_buf,
+        sizeof(hg_uint8_t));
 
-error:
-    if (hg_core_handle->ack_buf) {
-        na_ret = NA_Msg_buf_free(hg_core_handle->na_class,
-            hg_core_handle->ack_buf, hg_core_handle->ack_buf_plugin_data);
-        HG_CHECK_ERROR_DONE(na_ret != NA_SUCCESS,
-            "Could not free ack buffer (%s)", NA_Error_to_string(na_ret));
-        hg_core_handle->ack_buf = NULL;
-        hg_core_handle->ack_buf_plugin_data = NULL;
+    /* Pre-post the recv message (output) if response is expected */
+    na_ret = NA_Msg_send_expected(hg_core_handle->na_class,
+        hg_core_handle->na_context, hg_core_send_ack_cb, hg_core_handle,
+        hg_core_handle->ack_buf, sizeof(hg_uint8_t),
+        hg_core_handle->ack_buf_plugin_data,
+        hg_core_handle->core_handle.info.addr->na_addr,
+        hg_core_handle->core_handle.info.context_id, hg_core_handle->tag,
+        &hg_core_handle->na_ack_op_id);
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not post send for ack buffer");
+        ret = HG_NA_ERROR;
+        goto done;
     }
+
+done:
     return ret;
 }
 
@@ -2489,21 +2581,28 @@ hg_core_send_ack_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
+    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
-    hg_return_t ret;
 
-    /* If canceled, mark handle as canceled */
-    if (callback_info->ret == NA_CANCELED)
+    if (callback_info->ret == NA_CANCELED) {
+        /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
-    else
-        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
-            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
+    } else if (callback_info->ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Error in NA callback");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Complete operation */
-    ret = hg_core_complete_na(hg_core_handle, &completed);
-    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_ack_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
 done:
+    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2513,21 +2612,28 @@ hg_core_recv_ack_cb(const struct na_cb_info *callback_info)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) callback_info->arg;
+    na_return_t na_ret = NA_SUCCESS;
     hg_bool_t completed = HG_TRUE;
-    hg_return_t ret;
 
-    /* If canceled, mark handle as canceled */
-    if (callback_info->ret == NA_CANCELED)
+    if (callback_info->ret == NA_CANCELED) {
+        /* If canceled, mark handle as canceled */
         hg_core_handle->ret = HG_CANCELED;
-    else
-        HG_CHECK_ERROR_NORET(callback_info->ret != NA_SUCCESS, done,
-            "Error in NA callback (s)", NA_Error_to_string(callback_info->ret));
+    } else if (callback_info->ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Error in NA callback");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Complete operation */
-    ret = hg_core_complete_na(hg_core_handle, &completed);
-    HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
+    if (hg_core_complete_na(hg_core_handle, &hg_core_handle->na_ack_op_id,
+        &completed) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
+        na_ret = NA_PROTOCOL_ERROR;
+        goto done;
+    }
 
 done:
+    (void) na_ret; /* unused */
     return (int) completed;
 }
 
@@ -2561,12 +2667,15 @@ hg_core_self_cb(const struct hg_core_cb_info *callback_info)
 
     /* Process output */
     ret = hg_core_process_output(hg_core_handle, &completed, hg_core_complete);
-    HG_CHECK_HG_ERROR(done, ret, "Could not process output");
+    if (ret != HG_SUCCESS) {
+       HG_LOG_ERROR("Could not process output");
+       goto done;
+   }
 
     /* Mark as completed */
-    if (completed) {
-        ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-        HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
+    if (completed
+        && hg_core_complete((hg_core_handle_t) hg_core_handle) != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not complete operation");
     }
 
 done:
@@ -2585,12 +2694,18 @@ hg_core_process_self(struct hg_core_private_handle *hg_core_handle)
 
     /* Process input */
     ret = hg_core_process_input(hg_core_handle, &completed);
-    HG_CHECK_HG_ERROR(done, ret, "Could not process input");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not process input");
+        goto done;
+    }
 
     /* Mark as completed */
     if (completed) {
         ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-        HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not complete operation");
+            goto done;
+        }
     }
 
 done:
@@ -2613,12 +2728,15 @@ hg_core_process(struct hg_core_private_handle *hg_core_handle)
     hg_thread_spin_unlock(&HG_CORE_HANDLE_CLASS(hg_core_handle)->func_map_lock);
     if (!hg_core_rpc_info) {
         HG_LOG_WARNING("Could not find RPC ID in function map");
-        ret = HG_NOENTRY;
+        ret = HG_NO_MATCH;
         goto done;
     }
 
-    HG_CHECK_ERROR(hg_core_rpc_info->rpc_cb == NULL, done, ret,
-        HG_INVALID_ARG, "No RPC callback registered");
+    if (!hg_core_rpc_info->rpc_cb) {
+        HG_LOG_ERROR("No RPC callback registered");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Cache RPC info */
     hg_core_handle->core_handle.rpc_info = hg_core_rpc_info;
@@ -2629,7 +2747,10 @@ hg_core_process(struct hg_core_private_handle *hg_core_handle)
 
     /* Execute RPC callback */
     ret = hg_core_rpc_info->rpc_cb((hg_core_handle_t) hg_core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Error while executing RPC callback");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Error while executing RPC callback");
+        goto done;
+    }
 
 done:
     return ret;
@@ -2638,17 +2759,22 @@ done:
 /*---------------------------------------------------------------------------*/
 static HG_INLINE hg_return_t
 hg_core_complete_na(struct hg_core_private_handle *hg_core_handle,
-    hg_bool_t *completed)
+    na_op_id_t *op_id, hg_bool_t *completed)
 {
     hg_return_t ret = HG_SUCCESS;
 
+    /* Reset op ID value */
+    if (!hg_core_handle->na_op_id_mine)
+        *op_id = NA_OP_ID_NULL;
+
     /* Add handle to completion queue when expected operations have completed */
     if (hg_atomic_incr32(&hg_core_handle->na_op_completed_count)
         == (hg_util_int32_t) hg_core_handle->na_op_count && *completed) {
         /* Mark as completed */
-        ret = hg_core_complete((hg_core_handle_t) hg_core_handle);
-        HG_CHECK_HG_ERROR(done, ret, "Could not complete operation");
-
+        if (hg_core_complete((hg_core_handle_t) hg_core_handle) != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not complete operation");
+            goto done;
+        }
         /* Increment number of entries added to completion queue */
         *completed = HG_TRUE;
     } else
@@ -2674,8 +2800,10 @@ hg_core_complete(hg_core_handle_t handle)
 
     ret = hg_core_completion_add(context, hg_completion_entry,
         hg_core_handle->is_self);
-    HG_CHECK_HG_ERROR(done, ret,
-        "Could not add HG completion entry to completion queue");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not add HG completion entry to completion queue");
+        goto done;
+    }
 
 done:
     return ret;
@@ -2716,16 +2844,15 @@ hg_core_completion_add(struct hg_core_context *context,
 
 #ifdef HG_HAS_SELF_FORWARD
     /* TODO could prevent from self notifying if hg_poll_wait() not entered */
-    if (self_notify && private_context->completion_queue_notify) {
-        int rc = hg_event_set(private_context->completion_queue_notify);
-        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_FAULT,
-            "Could not signal completion queue");
+    if (self_notify && private_context->completion_queue_notify
+        && hg_event_set(private_context->completion_queue_notify) != HG_UTIL_SUCCESS) {
+        HG_LOG_ERROR("Could not signal completion queue");
+        ret = HG_PROTOCOL_ERROR;
     }
 #else
     (void) self_notify;
 #endif
 
-done:
     return ret;
 }
 
@@ -2743,27 +2870,32 @@ hg_core_context_post(struct hg_core_private_context *context,
         struct hg_core_private_addr *hg_core_addr = NULL;
 
         /* Create a new handle */
-        // TODO
         hg_core_handle = hg_core_create(context, use_sm);
-        HG_CHECK_ERROR(hg_core_handle == NULL, error, ret, HG_NOMEM,
-            "Could not create HG core handle");
+        if (!hg_core_handle) {
+            HG_LOG_ERROR("Could not create HG core handle");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
 
         /* Execute class callback on handle, this allows upper layers to
          * allocate private data on handle creation */
         if (context->handle_create) {
             ret = context->handle_create((hg_core_handle_t) hg_core_handle,
                 context->handle_create_arg);
-            HG_CHECK_HG_ERROR(error, ret,
-                "Error in HG core handle create callback");
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Error in HG core handle create callback");
+                goto done;
+            }
         }
 
         /* Create internal addresses */
-        // TODO
         hg_core_addr = hg_core_addr_create(HG_CORE_CONTEXT_CLASS(context),
             hg_core_handle->na_class);
-        HG_CHECK_ERROR(hg_core_addr == NULL, error, ret, HG_NOMEM,
-            "Could not create HG addr");
-
+        if (!hg_core_addr) {
+            HG_LOG_ERROR("Could not create HG addr");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
         /* To safely repost handle and prevent externally referenced address */
         hg_core_addr->is_mine = HG_TRUE;
         hg_core_handle->core_handle.info.addr = (hg_core_addr_t) hg_core_addr;
@@ -2772,13 +2904,13 @@ hg_core_context_post(struct hg_core_private_context *context,
         hg_core_handle->repost = repost;
 
         ret = hg_core_post(hg_core_handle);
-        HG_CHECK_HG_ERROR(error, ret, "Cannot post handle");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Cannot post handle");
+            goto done;
+        }
     }
 
-    return ret;
-
-error:
-    /* TODO */
+done:
     return ret;
 }
 
@@ -2796,12 +2928,12 @@ hg_core_post(struct hg_core_private_handle *hg_core_handle)
     if (hg_core_handle->na_class ==
         hg_core_handle->core_handle.info.core_class->na_sm_class) {
         hg_thread_spin_lock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
         HG_LIST_INSERT_HEAD(
             &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list,
             hg_core_handle, pending);
         hg_thread_spin_unlock(
-            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
+            &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->sm_pending_list_lock);
     } else {
 #endif
         hg_thread_spin_lock(
@@ -2821,19 +2953,13 @@ hg_core_post(struct hg_core_private_handle *hg_core_handle)
         hg_core_handle->core_handle.in_buf,
         hg_core_handle->core_handle.in_buf_size,
         hg_core_handle->in_buf_plugin_data, &hg_core_handle->na_recv_op_id);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, error, ret, (hg_return_t) na_ret,
-        "Could not post unexpected recv for input buffer (%s)",
-        NA_Error_to_string(na_ret));
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not post unexpected recv for input buffer");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
 
-    return ret;
-
-error:
-    hg_thread_spin_lock(
-        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
-    HG_LIST_REMOVE(hg_core_handle, pending);
-    hg_thread_spin_unlock(
-        &HG_CORE_HANDLE_CONTEXT(hg_core_handle)->pending_list_lock);
-    hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
+done:
     return ret;
 }
 
@@ -2855,7 +2981,10 @@ hg_core_reset_post(struct hg_core_private_handle *hg_core_handle)
 
     /* Safe to repost */
     ret = hg_core_post(hg_core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Cannot post handle");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Cannot post handle");
+        goto done;
+    }
 
 done:
     return ret;
@@ -2870,13 +2999,15 @@ hg_core_completion_queue_notify_cb(void *arg,
     struct hg_core_private_context *context =
         (struct hg_core_private_context *) arg;
     hg_util_bool_t notified = HG_UTIL_FALSE;
-    int rc = HG_UTIL_SUCCESS;
+    int ret = HG_UTIL_SUCCESS;
 
     /* TODO could prevent from self notifying if hg_poll_wait() not entered */
-    rc = hg_event_get(context->completion_queue_notify, &notified);
-    HG_CHECK_ERROR_NORET(rc != HG_UTIL_SUCCESS, done,
-        "Could not get completion notification");
-
+    if (hg_event_get(context->completion_queue_notify,
+        &notified) != HG_UTIL_SUCCESS) {
+        HG_LOG_ERROR("Could not get completion notification");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
     if (notified || !hg_atomic_queue_is_empty(context->completion_queue)
         || hg_atomic_get32(&context->backfill_queue_count)) {
         *progressed = HG_UTIL_TRUE; /* Progressed */
@@ -2886,7 +3017,7 @@ hg_core_completion_queue_notify_cb(void *arg,
     *progressed = HG_UTIL_FALSE;
 
 done:
-    return rc;
+    return ret;
 }
 #endif
 
@@ -2898,21 +3029,24 @@ hg_core_progress_na_cb(void *arg, int HG_UNUSED error,
     struct hg_core_private_context *context =
         (struct hg_core_private_context *) arg;
      unsigned int actual_count = 0;
+    na_return_t na_ret;
     unsigned int completed_count = 0;
     int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
-    int rc = HG_UTIL_SUCCESS;
-    na_return_t na_ret;
+    int ret = HG_UTIL_SUCCESS;
 
     /* Check progress on NA (no need to call try_wait here) */
     na_ret = NA_Progress(HG_CORE_CONTEXT_CLASS(context)->core_class.na_class,
         context->core_context.na_context, 0);
-    if (na_ret == NA_TIMEOUT) {
+    if (na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT) {
+        HG_LOG_ERROR("Could not make progress on NA");
+        ret = HG_UTIL_FAIL;
+        goto done;
+    }
+    if (na_ret != NA_SUCCESS) {
         /* Nothing progressed */
         *progressed = HG_UTIL_FALSE;
         goto done;
-    } else
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, rc, HG_UTIL_FAIL,
-            "Could not make progress on NA (%s)", NA_Error_to_string(na_ret));
+    }
 
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
@@ -2926,9 +3060,6 @@ hg_core_progress_na_cb(void *arg, int HG_UNUSED error,
         for (i = 0; i < actual_count; i++)
             completed_count += (unsigned int) cb_ret[i];
     } while ((na_ret == NA_SUCCESS) && actual_count);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, rc,
-        HG_UTIL_FAIL, "Could not trigger NA callback (%s)",
-        NA_Error_to_string(na_ret));
 
     /* We can't only verify that the completion queue is not empty, we need
      * to check what was added to the completion queue, as the completion queue
@@ -2943,7 +3074,7 @@ hg_core_progress_na_cb(void *arg, int HG_UNUSED error,
     *progressed = HG_UTIL_TRUE;
 
 done:
-    return rc;
+    return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2955,22 +3086,24 @@ hg_core_progress_na_sm_cb(void *arg, int HG_UNUSED error,
     struct hg_core_private_context *context =
         (struct hg_core_private_context *) arg;
     unsigned int actual_count = 0;
+    na_return_t na_ret;
     unsigned int completed_count = 0;
     int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
-    int rc = HG_UTIL_SUCCESS;
-    na_return_t na_ret;
+    int ret = HG_UTIL_SUCCESS;
 
     /* Check progress on NA SM (no need to call try_wait here) */
     na_ret = NA_Progress(HG_CORE_CONTEXT_CLASS(context)->core_class.na_sm_class,
         context->core_context.na_sm_context, 0);
-    if (na_ret == NA_TIMEOUT) {
+    if (na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT) {
+        HG_LOG_ERROR("Could not make progress on NA SM");
+        ret = HG_UTIL_FAIL;
+        goto done;
+    }
+    if (na_ret != NA_SUCCESS) {
         /* Nothing progressed */
         *progressed = HG_UTIL_FALSE;
         goto done;
-    } else
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, rc, HG_UTIL_FAIL,
-            "Could not make progress on NA SM (%s)",
-            NA_Error_to_string(na_ret));
+    }
 
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
@@ -2984,9 +3117,6 @@ hg_core_progress_na_sm_cb(void *arg, int HG_UNUSED error,
         for (i = 0; i < actual_count; i++)
             completed_count += (unsigned int)cb_ret[i];
     } while ((na_ret == NA_SUCCESS) && actual_count);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, rc,
-        HG_UTIL_FAIL, "Could not trigger NA SM callback (%s)",
-        NA_Error_to_string(na_ret));
 
     /* We can't only verify that the completion queue is not empty, we need
      * to check what was added to the completion queue, as the completion queue
@@ -3001,7 +3131,7 @@ hg_core_progress_na_sm_cb(void *arg, int HG_UNUSED error,
     *progressed = HG_UTIL_TRUE;
 
 done:
-    return rc;
+    return ret;
 }
 #endif
 
@@ -3017,8 +3147,9 @@ hg_core_progress_na(struct hg_core_private_context *context,
     if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK) {
         timeout = 0;
         remaining = 0;
-    } else
+    } else {
         remaining = timeout / 1000.0; /* Convert timeout in ms into seconds */
+    }
 
     for (;;) {
         unsigned int actual_count = 0;
@@ -3040,9 +3171,6 @@ hg_core_progress_na(struct hg_core_private_context *context,
             for (i = 0; i < actual_count; i++)
                 completed_count += (unsigned int)cb_ret[i];
         } while ((na_ret == NA_SUCCESS) && actual_count);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
-            (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
-            NA_Error_to_string(na_ret));
 
         /* We can't only verify that the completion queue is not empty, we need
          * to check what was added to the completion queue, as the completion
@@ -3078,14 +3206,16 @@ hg_core_progress_na(struct hg_core_private_context *context,
             remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
         }
 
-        /* Trigger NA callbacks and check whether we completed something */
-        if (na_ret == NA_SUCCESS)
+        if (na_ret == NA_SUCCESS) {
+            /* Trigger NA callbacks and check whether we completed something */
             continue;
-        else if (na_ret == NA_TIMEOUT)
+        } else if (na_ret == NA_TIMEOUT) {
             break;
-        else
-            HG_GOTO_ERROR(done, ret, (hg_return_t) na_ret,
-                "Could not make NA Progress (%s)", NA_Error_to_string(na_ret));
+        } else {
+            HG_LOG_ERROR("Could not make NA Progress");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
     }
 
 done:
@@ -3142,16 +3272,17 @@ hg_core_progress_poll(struct hg_core_private_context *context,
     do {
         hg_time_t t1, t2;
         hg_util_bool_t progressed;
-        int rc;
 
         if (timeout)
             hg_time_get_current(&t1);
 
         /* Will call hg_core_poll_try_wait_cb if timeout is not 0 */
-        rc = hg_poll_wait(context->poll_set, (unsigned int)(remaining * 1000.0),
-            &progressed);
-        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_PROTOCOL_ERROR,
-            "hg_poll_wait() failed");
+        if (hg_poll_wait(context->poll_set, (unsigned int)(remaining * 1000.0),
+            &progressed) != HG_UTIL_SUCCESS) {
+            HG_LOG_ERROR("hg_poll_wait() failed");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
 
         /* We progressed, return success */
         if (progressed) {
@@ -3241,42 +3372,50 @@ hg_core_trigger(struct hg_core_private_context *context, unsigned int timeout,
         }
 
         /* Completion queue should not be empty now */
-        HG_CHECK_ERROR(hg_completion_entry == NULL, done, ret,
-            HG_FAULT, "NULL completion entry");
+        if (!hg_completion_entry) {
+            HG_LOG_ERROR("NULL completion entry");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
 
         /* Trigger entry */
         switch(hg_completion_entry->op_type) {
             case HG_ADDR:
                 ret = hg_core_trigger_lookup_entry(
                     hg_completion_entry->op_id.hg_core_op_id);
-                HG_CHECK_HG_ERROR(done, ret,
-                    "Could not trigger addr completion entry");
+                if (ret != HG_SUCCESS) {
+                    HG_LOG_ERROR("Could not trigger completion entry");
+                    goto done;
+                }
                 break;
             case HG_RPC:
                 ret = hg_core_trigger_entry((struct hg_core_private_handle *)
                     hg_completion_entry->op_id.hg_core_handle);
-                HG_CHECK_HG_ERROR(done, ret,
-                    "Could not trigger RPC completion entry");
+                if (ret != HG_SUCCESS) {
+                    HG_LOG_ERROR("Could not trigger completion entry");
+                    goto done;
+                }
                 break;
             case HG_BULK:
                 ret = hg_bulk_trigger_entry(
                     hg_completion_entry->op_id.hg_bulk_op_id);
-                HG_CHECK_HG_ERROR(done, ret,
-                    "Could not trigger bulk completion entry");
+                if (ret != HG_SUCCESS) {
+                    HG_LOG_ERROR("Could not trigger completion entry");
+                    goto done;
+                }
                 break;
             default:
-                HG_GOTO_ERROR(done, ret, HG_INVALID_ARG,
-                    "Invalid type of completion entry (%d)",
-                    (int) hg_completion_entry->op_type);
+                HG_LOG_ERROR("Invalid type of completion entry");
+                ret = HG_PROTOCOL_ERROR;
+                goto done;
         }
 
         count++;
     }
 
-    if (actual_count)
+done:
+    if ((ret == HG_SUCCESS || ret == HG_TIMEOUT) && actual_count)
         *actual_count = count;
-
-done:
     return ret;
 }
 
@@ -3287,13 +3426,10 @@ hg_core_trigger_lookup_entry(struct hg_core_op_id *hg_core_op_id)
     hg_return_t ret = HG_SUCCESS;
 
     /* Free op */
-    if (hg_core_op_id->info.lookup.na_lookup_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret = NA_Op_destroy(
+    if (hg_core_op_id->info.lookup.na_lookup_op_id != NA_OP_ID_NULL)
+        NA_Op_destroy(
             hg_core_op_id->info.lookup.hg_core_addr->core_addr.na_class,
             hg_core_op_id->info.lookup.na_lookup_op_id);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not destroy addr op ID (%s)", NA_Error_to_string(na_ret));
-    }
 
     /* Execute callback */
     if (hg_core_op_id->callback) {
@@ -3308,7 +3444,6 @@ hg_core_trigger_lookup_entry(struct hg_core_op_id *hg_core_op_id)
         hg_core_op_id->callback(&hg_core_cb_info);
     }
 
-done:
     free(hg_core_op_id);
     return ret;
 }
@@ -3333,13 +3468,19 @@ hg_core_trigger_entry(struct hg_core_private_handle *hg_core_handle)
             hg_core_handle->ret = ret;
             ret = HG_Core_respond((hg_core_handle_t) hg_core_handle, NULL, NULL,
                 0, header_size);
-            HG_CHECK_HG_ERROR(done, ret, "Could not respond");
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not respond");
+                goto done;
+            }
         }
 
         /* No response callback */
         if (hg_core_handle->no_response) {
             ret = hg_core_handle->no_respond(hg_core_handle);
-            HG_CHECK_HG_ERROR(done, ret, "Could not complete handle");
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not complete handle");
+                goto done;
+            }
         }
     } else {
         hg_core_cb_t hg_cb = NULL;
@@ -3382,8 +3523,9 @@ hg_core_trigger_entry(struct hg_core_private_handle *hg_core_handle)
                 break;
             case HG_CORE_PROCESS:
             default:
-                HG_GOTO_ERROR(done, ret, HG_OPNOTSUPPORTED,
-                    "Invalid core operation type");
+                HG_LOG_ERROR("Invalid core operation type");
+                ret = HG_PROTOCOL_ERROR;
+                goto done;
         }
 
         /* Execute user callback */
@@ -3396,7 +3538,10 @@ hg_core_trigger_entry(struct hg_core_private_handle *hg_core_handle)
         && !HG_CORE_HANDLE_CONTEXT(hg_core_handle)->finalizing) {
         /* Repost handle */
         ret = hg_core_reset_post(hg_core_handle);
-        HG_CHECK_HG_ERROR(done, ret, "Cannot repost handle");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Cannot repost handle");
+            goto done;
+        }
     } else
         hg_core_destroy(hg_core_handle);
 
@@ -3410,30 +3555,54 @@ hg_core_cancel(struct hg_core_private_handle *hg_core_handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_handle->is_self, done, ret, HG_OPNOTSUPPORTED,
-        "Local cancellation is not supported");
+    if (hg_core_handle->is_self) {
+        HG_LOG_ERROR("Local cancelation is not supported");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Cancel all NA operations issued */
     if (hg_core_handle->na_recv_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret = NA_Cancel(hg_core_handle->na_class,
-            hg_core_handle->na_context, hg_core_handle->na_recv_op_id);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not cancel recv op id (%s)", NA_Error_to_string(na_ret));
+        na_return_t na_ret;
+
+        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
+            hg_core_handle->na_recv_op_id);
+        if (na_ret == NA_CANCEL_ERROR)
+            ret = HG_CANCEL_ERROR;
+        else if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not cancel recv op id");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
     }
 
     if (hg_core_handle->na_send_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret = NA_Cancel(hg_core_handle->na_class,
-            hg_core_handle->na_context, hg_core_handle->na_send_op_id);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not cancel send op id (%s)", NA_Error_to_string(na_ret));
+        na_return_t na_ret;
+
+        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
+            hg_core_handle->na_send_op_id);
+        if (na_ret == NA_CANCEL_ERROR)
+            ret = HG_CANCEL_ERROR;
+        else if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not cancel send op id");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
     }
 
+    /* TODO
     if (hg_core_handle->na_ack_op_id != NA_OP_ID_NULL) {
-        na_return_t na_ret = NA_Cancel(hg_core_handle->na_class,
-            hg_core_handle->na_context, hg_core_handle->na_ack_op_id);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not cancel ack op id (%s)", NA_Error_to_string(na_ret));
+        na_return_t na_ret;
+
+        na_ret = NA_Cancel(hg_core_handle->na_class, hg_core_handle->na_context,
+            hg_core_handle->na_ack_op_id);
+        if (na_ret != NA_SUCCESS) {
+            HG_LOG_ERROR("Could not cancel ack op id");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
     }
+    */
 
 done:
     return ret;
@@ -3452,12 +3621,19 @@ HG_Core_init_opt(const char *na_info_string, hg_bool_t na_listen,
     const struct hg_init_info *hg_init_info)
 {
     struct hg_core_private_class *hg_core_class = NULL;
+    hg_return_t ret = HG_SUCCESS;
 
     hg_core_class = hg_core_init(na_info_string, na_listen, hg_init_info);
-    HG_CHECK_ERROR_NORET(hg_core_class == NULL, done,
-        "Cannot initialize HG core layer");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("Cannot initialize HG core layer");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
 done:
+    if (ret != HG_SUCCESS) {
+        /* Nothing */
+    }
     return (hg_core_class_t *) hg_core_class;
 }
 
@@ -3465,10 +3641,13 @@ done:
 hg_return_t
 HG_Core_finalize(hg_core_class_t *hg_core_class)
 {
-    hg_return_t ret;
+    hg_return_t ret = HG_SUCCESS;
 
     ret = hg_core_finalize((struct hg_core_private_class *) hg_core_class);
-    HG_CHECK_HG_ERROR(done, ret, "Cannot finalize HG core layer");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Cannot finalize HG core layer");
+        goto done;
+    }
 
 done:
     return ret;
@@ -3492,8 +3671,11 @@ HG_Core_set_more_data_callback(struct hg_core_class *hg_core_class,
         (struct hg_core_private_class *) hg_core_class;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core class");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     private_class->more_data_acquire = more_data_acquire_callback;
     private_class->more_data_release = more_data_release_callback;
@@ -3513,26 +3695,35 @@ HG_Core_context_create(hg_core_class_t *hg_core_class)
 hg_core_context_t *
 HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
 {
+    hg_return_t ret = HG_SUCCESS;
     struct hg_core_private_context *context = NULL;
     int na_poll_fd;
 #ifdef HG_HAS_SELF_FORWARD
     int fd;
 #endif
 
-    HG_CHECK_ERROR_NORET(hg_core_class == NULL, error, "NULL HG core class");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     context = (struct hg_core_private_context *) malloc(
         sizeof(struct hg_core_private_context));
-    HG_CHECK_ERROR_NORET(context == NULL, error,
-        "Could not allocate HG context");
-
+    if (!context) {
+        HG_LOG_ERROR("Could not allocate HG context");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     memset(context, 0, sizeof(struct hg_core_private_context));
     context->core_context.core_class = hg_core_class;
     context->completion_queue =
         hg_atomic_queue_alloc(HG_CORE_ATOMIC_QUEUE_SIZE);
-    HG_CHECK_ERROR_NORET(context->completion_queue == NULL, error,
-        "Could not allocate queue");
-
+    if (!context->completion_queue) {
+        HG_LOG_ERROR("Could not allocate queue");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     HG_QUEUE_INIT(&context->backfill_queue);
     hg_atomic_init32(&context->backfill_queue_count, 0);
     HG_LIST_INIT(&context->pending_list);
@@ -3550,31 +3741,46 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
     hg_atomic_init32(&context->trigger_waiting, 0);
 
     hg_thread_spin_init(&context->pending_list_lock);
+#ifdef HG_HAS_SM_ROUTING
+    hg_thread_spin_init(&context->sm_pending_list_lock);
+#endif
     hg_thread_spin_init(&context->created_list_lock);
 
     context->core_context.na_context = NA_Context_create_id(
         hg_core_class->na_class, id);
-    HG_CHECK_ERROR_NORET(context->core_context.na_context == NULL, error,
-        "Could not create NA context");
-
+    if (!context->core_context.na_context) {
+        HG_LOG_ERROR("Could not create NA context");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
 #ifdef HG_HAS_SM_ROUTING
     if (hg_core_class->na_sm_class) {
         context->core_context.na_sm_context = NA_Context_create(
             hg_core_class->na_sm_class);
-        HG_CHECK_ERROR_NORET(context->core_context.na_sm_context == NULL, error,
-            "Could not create NA SM context");
+        if (!context->core_context.na_sm_context) {
+            HG_LOG_ERROR("Could not create NA SM context");
+            ret = HG_NA_ERROR;
+            goto done;
+        }
     }
 #endif
 
     /* Create poll set */
     context->poll_set = hg_poll_create();
-    HG_CHECK_ERROR_NORET(context->poll_set == NULL, error,
-        "Could not create poll set");
+    if (!context->poll_set) {
+        HG_LOG_ERROR("Could not create poll set");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
 
 #ifdef HG_HAS_SELF_FORWARD
     /* Create event for completion queue notification */
     fd = hg_event_create();
-    HG_CHECK_ERROR_NORET(fd < 0, error, "Could not create event");
+    if (fd < 0) {
+        HG_LOG_ERROR("Could not create event");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
     context->completion_queue_notify = fd;
 
     /* Add event to context poll set */
@@ -3602,17 +3808,22 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
 #ifdef HG_HAS_SM_ROUTING
     /* Auto SM requires hg_core_progress_poll */
     if (context->core_context.na_sm_context) {
-        HG_CHECK_ERROR_NORET(context->progress != hg_core_progress_poll, error,
-            "Auto SM mode not supported with selected plugin");
-
+        if (context->progress != hg_core_progress_poll) {
+            HG_LOG_ERROR("Auto SM mode not supported with selected plugin");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
         if (HG_CORE_CONTEXT_CLASS(context)->progress_mode == NA_NO_BLOCK)
             /* Force to use progress poll */
             na_poll_fd = 0;
         else {
             na_poll_fd = NA_Poll_get_fd(hg_core_class->na_sm_class,
                 context->core_context.na_sm_context);
-            HG_CHECK_ERROR_NORET(na_poll_fd < 0, error,
-                "Could not get NA SM poll fd");
+            if (na_poll_fd < 0) {
+                HG_LOG_ERROR("Could not get NA SM poll fd");
+                ret = HG_NA_ERROR;
+                goto done;
+            }
         }
         hg_poll_add(context->poll_set, na_poll_fd, HG_POLLIN,
             hg_core_progress_na_sm_cb, context);
@@ -3625,11 +3836,12 @@ HG_Core_context_create_id(hg_core_class_t *hg_core_class, hg_uint8_t id)
     /* Increment context count of parent class */
     hg_atomic_incr32(&HG_CORE_CONTEXT_CLASS(context)->n_contexts);
 
+done:
+    if (ret != HG_SUCCESS && context) {
+        HG_Core_context_destroy((hg_core_context_t *) context);
+        context = NULL;
+    }
     return (hg_core_context_t *) context;
-
-error:
-    HG_Core_context_destroy((hg_core_context_t *) context);
-    return NULL;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -3638,32 +3850,41 @@ HG_Core_context_destroy(hg_core_context_t *context)
 {
     struct hg_core_private_context *private_context =
         (struct hg_core_private_context *) context;
+    na_return_t na_ret;
+    hg_return_t ret = HG_SUCCESS;
     unsigned int actual_count;
     int na_poll_fd;
     hg_util_int32_t n_handles;
-    hg_bool_t empty;
-    na_return_t na_ret;
-    hg_return_t ret = HG_SUCCESS;
-    int rc;
 
-    if (!context)
-        goto done;
+    if (!context) goto done;
 
     /* Prevent repost of handles */
     private_context->finalizing = HG_TRUE;
 
     /* Check pending list and cancel posted handles */
-    ret = hg_core_pending_list_cancel(private_context);
-    HG_CHECK_HG_ERROR(done, ret, "Cannot cancel list of pending entries");
+    if (!HG_LIST_IS_EMPTY(&private_context->pending_list)) {
+        ret = hg_core_pending_list_cancel(private_context);
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Cannot cancel list of pending entries");
+            goto done;
+        }
+    }
+#ifdef HG_HAS_SM_ROUTING
+    /* Check pending list and cancel posted handles */
+    if (!HG_LIST_IS_EMPTY(&private_context->sm_pending_list)) {
+        ret = hg_core_sm_pending_list_cancel(private_context);
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Cannot cancel list of SM pending entries");
+            goto done;
+        }
+    }
+#endif
 
     /* Trigger everything we can from NA, if something completed it will
      * be moved to the HG context completion queue */
     do {
         na_ret = NA_Trigger(context->na_context, 0, 1, NULL, &actual_count);
     } while ((na_ret == NA_SUCCESS) && actual_count);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
-        (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
-        NA_Error_to_string(na_ret));
 
 #ifdef HG_HAS_SM_ROUTING
     if (context->na_sm_context) {
@@ -3671,15 +3892,15 @@ HG_Core_context_destroy(hg_core_context_t *context)
             na_ret = NA_Trigger(context->na_sm_context, 0, 1, NULL,
                 &actual_count);
         } while ((na_ret == NA_SUCCESS) && actual_count);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
-            (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
-            NA_Error_to_string(na_ret));
     }
 #endif
 
     /* Check that operations have completed */
-    ret = hg_core_context_lists_wait(private_context);
-    HG_CHECK_HG_ERROR(done, ret, "Could not wait on HG core handle list");
+    ret = hg_core_created_list_wait(private_context);
+    if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
+        HG_LOG_ERROR("Could not wait on HG core handle list");
+        goto done;
+    }
 
     /* Number of handles for that context should be 0 */
     n_handles = hg_atomic_get32(&private_context->n_handles);
@@ -3693,32 +3914,42 @@ HG_Core_context_destroy(hg_core_context_t *context)
                 hg_core_handle);
         }
         hg_thread_spin_unlock(&private_context->created_list_lock);
-        ret = HG_BUSY;
+        ret = HG_PROTOCOL_ERROR;
         goto done;
     }
 
     /* Check that completion queue is empty now */
-    HG_CHECK_ERROR(!hg_atomic_queue_is_empty(private_context->completion_queue),
-        done, ret, HG_BUSY, "Completion queue should be empty");
+    if (!hg_atomic_queue_is_empty(private_context->completion_queue)) {
+        HG_LOG_ERROR("Completion queue should be empty");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
     hg_atomic_queue_free(private_context->completion_queue);
 
     /* Check that completion queue is empty now */
     hg_thread_mutex_lock(&private_context->completion_queue_mutex);
-    empty = HG_QUEUE_IS_EMPTY(&private_context->backfill_queue);
+    if (!HG_QUEUE_IS_EMPTY(&private_context->backfill_queue)) {
+        HG_LOG_ERROR("Completion queue should be empty");
+        ret = HG_PROTOCOL_ERROR;
+        hg_thread_mutex_unlock(&private_context->completion_queue_mutex);
+        goto done;
+    }
     hg_thread_mutex_unlock(&private_context->completion_queue_mutex);
-    HG_CHECK_ERROR(!empty, done, ret, HG_BUSY,
-        "Completion queue should be empty");
 
 #ifdef HG_HAS_SELF_FORWARD
     if (private_context->completion_queue_notify > 0) {
-        rc = hg_poll_remove(private_context->poll_set,
-            private_context->completion_queue_notify);
-        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
-            "Could not remove self processing event from poll set");
-
-        rc = hg_event_destroy(private_context->completion_queue_notify);
-        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
-            "Could not destroy self processing event");
+        if (hg_poll_remove(private_context->poll_set,
+            private_context->completion_queue_notify) != HG_UTIL_SUCCESS) {
+            HG_LOG_ERROR("Could not remove self processing event from poll set");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
+        if (hg_event_destroy(private_context->completion_queue_notify)
+            != HG_UTIL_SUCCESS) {
+            HG_LOG_ERROR("Could not destroy self processing event");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
     }
 #endif
 
@@ -3729,10 +3960,12 @@ HG_Core_context_destroy(hg_core_context_t *context)
         /* If NA plugin exposes fd, remove it from poll set */
         na_poll_fd = NA_Poll_get_fd(context->core_class->na_class,
             context->na_context);
-    if (na_poll_fd >= 0) {
-        rc = hg_poll_remove(private_context->poll_set, na_poll_fd);
-        HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
-            "Could not remove NA poll descriptor from poll set");
+    if ((na_poll_fd >= 0)
+        && hg_poll_remove(private_context->poll_set, na_poll_fd)
+        != HG_UTIL_SUCCESS) {
+        HG_LOG_ERROR("Could not remove NA poll descriptor from poll set");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
     }
 
 #ifdef HG_HAS_SM_ROUTING
@@ -3744,34 +3977,38 @@ HG_Core_context_destroy(hg_core_context_t *context)
             /* If NA plugin exposes fd, remove it from poll set */
             na_poll_fd = NA_Poll_get_fd(context->core_class->na_sm_class,
                 context->na_sm_context);
-        if (na_poll_fd >= 0) {
-            rc = hg_poll_remove(private_context->poll_set, na_poll_fd);
-            HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_NOENTRY,
-                "Could not remove NA poll descriptor from poll set");
+        if ((na_poll_fd >= 0)
+            && hg_poll_remove(private_context->poll_set, na_poll_fd)
+            != HG_UTIL_SUCCESS) {
+            HG_LOG_ERROR("Could not remove NA poll descriptor from poll set");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
         }
     }
 #endif
 
     /* Destroy poll set */
-    rc = hg_poll_destroy(private_context->poll_set);
-    HG_CHECK_ERROR(rc != HG_UTIL_SUCCESS, done, ret, HG_FAULT,
-        "Could not destroy poll set");
+    if (hg_poll_destroy(private_context->poll_set) != HG_UTIL_SUCCESS) {
+        HG_LOG_ERROR("Could not destroy poll set");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Destroy NA context */
-    if (context->na_context) {
-        na_ret = NA_Context_destroy(context->core_class->na_class,
-            context->na_context);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not destroy NA context (%s)", NA_Error_to_string(na_ret));
+    if (context->na_context && NA_Context_destroy(context->core_class->na_class,
+            context->na_context) != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not destroy NA context");
+        ret = HG_NA_ERROR;
+        goto done;
     }
 
 #ifdef HG_HAS_SM_ROUTING
     /* Destroy NA SM context */
-    if (context->na_sm_context) {
-        na_ret = NA_Context_destroy(context->core_class->na_sm_class,
-            context->na_sm_context);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-            "Could not destroy NA SM context");
+    if (context->na_sm_context && NA_Context_destroy(
+        context->core_class->na_sm_class, context->na_sm_context) != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not destroy NA SM context");
+        ret = HG_NA_ERROR;
+        goto done;
     }
 #endif
 
@@ -3783,6 +4020,9 @@ HG_Core_context_destroy(hg_core_context_t *context)
     hg_thread_mutex_destroy(&private_context->completion_queue_mutex);
     hg_thread_cond_destroy(&private_context->completion_queue_cond);
     hg_thread_spin_destroy(&private_context->pending_list_lock);
+#ifdef HG_HAS_SM_ROUTING
+    hg_thread_spin_destroy(&private_context->sm_pending_list_lock);
+#endif
     hg_thread_spin_destroy(&private_context->created_list_lock);
 
     /* Decrement context count of parent class */
@@ -3803,8 +4043,11 @@ HG_Core_context_set_handle_create_callback(hg_core_context_t *context,
         (struct hg_core_private_context *) context;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core context");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     private_context->handle_create = callback;
     private_context->handle_create_arg = arg;
@@ -3821,18 +4064,26 @@ HG_Core_context_post(hg_core_context_t *context, unsigned int request_count,
     hg_bool_t use_sm = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core context");
-    HG_CHECK_ERROR(request_count == 0, done, ret, HG_INVALID_ARG,
-        "Request count must be greater than 0");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!request_count) {
+        HG_LOG_ERROR("Request count must be greater than 0");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
 #ifdef HG_HAS_SM_ROUTING
     do {
 #endif
         ret = hg_core_context_post((struct hg_core_private_context *) context,
             request_count, repost, use_sm);
-        HG_CHECK_HG_ERROR(done, ret, "Could not post requests on context");
-
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not post requests on context");
+            goto done;
+        }
 #ifdef HG_HAS_SM_ROUTING
         if (context->na_sm_context)
             use_sm = !use_sm;
@@ -3855,8 +4106,11 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
     hg_return_t ret = HG_SUCCESS;
     int hash_ret;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, error, ret, HG_INVALID_ARG,
-        "NULL HG core class");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Check if registered and set RPC CB */
     hg_thread_spin_lock(&private_class->func_map_lock);
@@ -3869,15 +4123,21 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
     if (!hg_core_rpc_info) {
         /* Allocate the key */
         func_key = (hg_id_t *) malloc(sizeof(hg_id_t));
-        HG_CHECK_ERROR(func_key == NULL, error, ret, HG_NOMEM,
-            "Could not allocate ID key");
+        if (!func_key) {
+            HG_LOG_ERROR("Could not allocate ID");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
         *func_key = id;
 
         /* Fill info and store it into the function map */
         hg_core_rpc_info = (struct hg_core_rpc_info *) malloc(
             sizeof(struct hg_core_rpc_info));
-        HG_CHECK_ERROR(hg_core_rpc_info == NULL, error, ret, HG_NOMEM,
-            "Could not allocate HG info");
+        if (!hg_core_rpc_info) {
+            HG_LOG_ERROR("Could not allocate HG info");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
 
         hg_core_rpc_info->rpc_cb = rpc_cb;
         hg_core_rpc_info->data = NULL;
@@ -3887,16 +4147,18 @@ HG_Core_register(hg_core_class_t *hg_core_class, hg_id_t id,
         hash_ret = hg_hash_table_insert(private_class->func_map,
             (hg_hash_table_key_t) func_key, hg_core_rpc_info);
         hg_thread_spin_unlock(&private_class->func_map_lock);
-        HG_CHECK_ERROR(hash_ret == 0, error, ret, HG_INVALID_ARG,
-            "Could not insert RPC ID into function map (already registered?)");
+        if (!hash_ret) {
+            HG_LOG_ERROR("Could not insert RPC ID into function map (already registered?)");
+            ret = HG_INVALID_PARAM;
+            goto done;
+        }
     }
 
-    return ret;
-
-error:
-    free(func_key);
-    free(hg_core_rpc_info);
-
+done:
+    if (ret != HG_SUCCESS) {
+        free(func_key);
+        free(hg_core_rpc_info);
+    }
     return ret;
 }
 
@@ -3909,15 +4171,21 @@ HG_Core_deregister(hg_core_class_t *hg_core_class, hg_id_t id)
     hg_return_t ret = HG_SUCCESS;
     int hash_ret;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core class");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     hash_ret = hg_hash_table_remove(private_class->func_map,
         (hg_hash_table_key_t) &id);
     hg_thread_spin_unlock(&private_class->func_map_lock);
-    HG_CHECK_ERROR(hash_ret == 0, done, ret, HG_NOENTRY,
-        "Could not deregister RPC ID from function map");
+    if (!hash_ret) {
+        HG_LOG_ERROR("Could not deregister RPC ID from function map");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
 done:
     return ret;
@@ -3931,10 +4199,16 @@ HG_Core_registered(hg_core_class_t *hg_core_class, hg_id_t id, hg_bool_t *flag)
         (struct hg_core_private_class *) hg_core_class;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core class");
-    HG_CHECK_ERROR(flag == NULL, done, ret, HG_INVALID_ARG,
-        "NULL flag");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!flag) {
+        HG_LOG_ERROR("NULL flag");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     *flag = (hg_bool_t) (hg_hash_table_lookup(private_class->func_map,
@@ -3955,18 +4229,24 @@ HG_Core_register_data(hg_core_class_t *hg_core_class, hg_id_t id, void *data,
     struct hg_core_rpc_info *hg_core_rpc_info = NULL;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core class");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
         private_class->func_map, (hg_hash_table_key_t) &id);
     hg_thread_spin_unlock(&private_class->func_map_lock);
-    HG_CHECK_ERROR(hg_core_rpc_info == NULL, done, ret, HG_NOENTRY,
-        "Could not find RPC ID in function map");
+    if (!hg_core_rpc_info) {
+        HG_LOG_ERROR("Could not find RPC ID in function map");
+        ret = HG_NO_MATCH;
+        goto done;
+    }
 
-    HG_CHECK_WARNING(hg_core_rpc_info->data,
-        "Overriding data previously registered");
+    if (hg_core_rpc_info->data)
+        HG_LOG_WARNING("Overriding data previously registered");
     hg_core_rpc_info->data = data;
     hg_core_rpc_info->free_callback = free_callback;
 
@@ -3983,14 +4263,19 @@ HG_Core_registered_data(hg_core_class_t *hg_core_class, hg_id_t id)
     struct hg_core_rpc_info *hg_core_rpc_info = NULL;
     void *data = NULL;
 
-    HG_CHECK_ERROR_NORET(hg_core_class == NULL, done, "NULL HG core class");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        goto done;
+    }
 
     hg_thread_spin_lock(&private_class->func_map_lock);
     hg_core_rpc_info = (struct hg_core_rpc_info *) hg_hash_table_lookup(
         private_class->func_map, (hg_hash_table_key_t) &id);
     hg_thread_spin_unlock(&private_class->func_map_lock);
-    HG_CHECK_ERROR_NORET(hg_core_rpc_info == NULL, done,
-        "Could not find RPC ID in function map");
+    if (!hg_core_rpc_info) {
+        HG_LOG_ERROR("Could not find RPC ID in function map");
+        goto done;
+    }
 
     data = hg_core_rpc_info->data;
 
@@ -4005,16 +4290,28 @@ HG_Core_addr_lookup(hg_core_context_t *context, hg_core_cb_t callback,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core context");
-    HG_CHECK_ERROR(callback == NULL, done, ret, HG_INVALID_ARG,
-        "NULL callback");
-    HG_CHECK_ERROR(name == NULL, done, ret, HG_INVALID_ARG,
-        "NULL lookup");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!callback) {
+        HG_LOG_ERROR("NULL callback");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!name) {
+        HG_LOG_ERROR("NULL lookup name");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = hg_core_addr_lookup((struct hg_core_private_context *) context,
         callback, arg, name, op_id);
-    HG_CHECK_HG_ERROR(done, ret, "Could not lookup address");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not lookup address");
+        goto done;
+    }
 
 done:
     return ret;
@@ -4026,16 +4323,25 @@ HG_Core_addr_create(hg_core_class_t *hg_core_class, hg_core_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core class");
-    HG_CHECK_ERROR(addr == NULL, done, ret, HG_INVALID_ARG,
-        "NULL pointer to address");
+    if (hg_core_class == NULL) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!addr) {
+        HG_LOG_ERROR("NULL pointer to address");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     *addr = (hg_core_addr_t) hg_core_addr_create(
         (struct hg_core_private_class *) hg_core_class,
         hg_core_class->na_class);
-    HG_CHECK_ERROR(*addr == HG_CORE_ADDR_NULL, done, ret, HG_NOMEM,
-        "Could not create address");
+    if (*addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("Could not create address");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
 
 done:
     return ret;
@@ -4047,12 +4353,18 @@ HG_Core_addr_free(hg_core_class_t *hg_core_class, hg_core_addr_t addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core class");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = hg_core_addr_free((struct hg_core_private_class *) hg_core_class,
         (struct hg_core_private_addr *) addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not free address");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not free address");
+        goto done;
+    }
 
 done:
     return ret;
@@ -4067,13 +4379,19 @@ HG_Core_addr_set_remove(hg_core_class_t *hg_core_class, hg_core_addr_t addr)
     hg_return_t ret = HG_SUCCESS;
     na_return_t na_ret;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core class");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     na_ret = NA_Addr_set_remove(hg_core_addr->core_addr.na_class,
         hg_core_addr->core_addr.na_addr);
-    HG_CHECK_ERROR(na_ret != NA_SUCCESS, done, ret, (hg_return_t) na_ret,
-        "Could not set address to be removed (%s)", NA_Error_to_string(na_ret));
+    if (na_ret != NA_SUCCESS) {
+        HG_LOG_ERROR("Could not set address to be removed");
+        ret = HG_NA_ERROR;
+        goto done;
+    }
 
 done:
     return ret;
@@ -4085,14 +4403,23 @@ HG_Core_addr_self(hg_core_class_t *hg_core_class, hg_core_addr_t *addr)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core class");
-    HG_CHECK_ERROR(addr == NULL, done, ret, HG_INVALID_ARG,
-        "NULL pointer to address");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!addr) {
+        HG_LOG_ERROR("NULL pointer to address");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = hg_core_addr_self((struct hg_core_private_class *) hg_core_class,
         (struct hg_core_private_addr **) addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not get self address");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not get self address");
+        goto done;
+    }
 
 done:
     return ret;
@@ -4105,17 +4432,29 @@ HG_Core_addr_dup(hg_core_class_t *hg_core_class, hg_core_addr_t addr,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core class");
-    HG_CHECK_ERROR(addr == HG_CORE_ADDR_NULL, done, ret, HG_INVALID_ARG,
-        "NULL addr");
-    HG_CHECK_ERROR(new_addr == NULL, done, ret, HG_INVALID_ARG,
-        "NULL pointer to dup addr");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("NULL addr");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!new_addr) {
+        HG_LOG_ERROR("NULL pointer to destination address");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = hg_core_addr_dup((struct hg_core_private_class *) hg_core_class,
         (struct hg_core_private_addr *) addr,
         (struct hg_core_private_addr **) new_addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not duplicate address");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not duplicate address");
+        goto done;
+    }
 
 done:
     return ret;
@@ -4128,14 +4467,18 @@ HG_Core_addr_to_string(hg_core_class_t *hg_core_class, char *buf,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_class == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core class");
-    HG_CHECK_ERROR(buf_size == NULL, done, ret, HG_INVALID_ARG,
-        "NULL pointer to buffer size");
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = hg_core_addr_to_string((struct hg_core_private_class *) hg_core_class,
         buf, buf_size, (struct hg_core_private_addr *) addr);
-    HG_CHECK_HG_ERROR(done, ret, "Could not convert address to string");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not convert address to string");
+        goto done;
+    }
 
 done:
     return ret;
@@ -4154,10 +4497,16 @@ HG_Core_create(hg_core_context_t *context, hg_core_addr_t addr, hg_id_t id,
     hg_bool_t use_sm = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, error, ret, HG_INVALID_ARG,
-        "NULL HG core context");
-    HG_CHECK_ERROR(handle == NULL, error, ret, HG_INVALID_ARG,
-        "NULL pointer to HG core handle");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
 #ifdef HG_HAS_SM_ROUTING
     if (private_addr
@@ -4167,30 +4516,37 @@ HG_Core_create(hg_core_context_t *context, hg_core_addr_t addr, hg_id_t id,
 
     /* Create new handle */
     hg_core_handle = hg_core_create(private_context, use_sm);
-    HG_CHECK_ERROR(hg_core_handle == NULL, error, ret, HG_NOMEM,
-        "Could not create HG core handle");
+    if (!hg_core_handle) {
+        HG_LOG_ERROR("Could not create HG core handle");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
 
     /* Set addr / RPC ID */
     ret = hg_core_set_rpc(hg_core_handle, private_addr, id);
-    if (ret == HG_NOENTRY)
-        goto error;
-    HG_CHECK_HG_ERROR(error, ret, "Could not set rpc to handle");
+    if (ret != HG_SUCCESS) {
+        if (ret != HG_NO_MATCH) /* silence error if invalid ID is used */
+            HG_LOG_ERROR("Could not set rpc to handle");
+        goto done;
+    }
 
     /* Execute class callback on handle, this allows upper layers to
      * allocate private data on handle creation */
     if (private_context->handle_create) {
         ret = private_context->handle_create((hg_core_handle_t) hg_core_handle,
             private_context->handle_create_arg);
-        HG_CHECK_HG_ERROR(error, ret, "Error in HG handle create callback");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Error in HG core handle create callback");
+            goto done;
+        }
     }
 
     *handle = (hg_core_handle_t) hg_core_handle;
 
-    return ret;
-
-error:
-    hg_core_destroy(hg_core_handle);
-
+done:
+    if (ret != HG_SUCCESS) {
+        hg_core_destroy(hg_core_handle);
+    }
     return ret;
 }
 
@@ -4202,15 +4558,21 @@ HG_Core_destroy(hg_core_handle_t handle)
         (struct hg_core_private_handle *) handle;
     hg_return_t ret = HG_SUCCESS;
 
-    if (hg_core_handle == NULL)
+    if (!hg_core_handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        ret = HG_INVALID_PARAM;
         goto done;
+    }
 
     /* Repost handle if we were listening, otherwise destroy it */
     if (hg_core_handle->repost
         && !HG_CORE_HANDLE_CONTEXT(hg_core_handle)->finalizing) {
         /* Repost handle */
         ret = hg_core_reset_post(hg_core_handle);
-        HG_CHECK_HG_ERROR(done, ret, "Cannot repost handle");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Cannot repost handle");
+            goto done;
+        }
     } else
         hg_core_destroy(hg_core_handle);
 
@@ -4228,26 +4590,36 @@ HG_Core_reset(hg_core_handle_t handle, hg_core_addr_t addr, hg_id_t id)
         (struct hg_core_private_addr *) addr;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core handle");
-
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG core handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
     /* Not safe to reset
      * TODO could add the ability to defer the reset operation */
-    HG_CHECK_ERROR(hg_atomic_get32(&hg_core_handle->in_use), done, ret,
-        HG_BUSY, "Cannot reset HG core handle, still in use, "
-            "refcount: %d", hg_atomic_get32(&hg_core_handle->ref_count));
+    if (hg_atomic_get32(&hg_core_handle->in_use)) {
+        HG_LOG_ERROR("Cannot reset HG core handle, handle is still in use, "
+            "refcount: %d",
+            hg_atomic_get32(&hg_core_handle->ref_count));
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
 #ifdef HG_HAS_SM_ROUTING
     if (hg_core_addr
         && (hg_core_addr->core_addr.na_class != hg_core_handle->na_class)) {
         struct hg_core_private_context *private_context =
             (struct hg_core_private_context *) hg_core_handle->core_handle.info.context;
-        hg_bool_t use_sm = (private_context->core_context.core_class->na_sm_class
-            == hg_core_addr->core_addr.na_class);
+        hg_bool_t use_sm =
+            (private_context->core_context.core_class->na_sm_class
+                == hg_core_addr->core_addr.na_class);
         /* In that case, we must free and re-allocate NA resources */
         hg_core_free_na(hg_core_handle);
         ret = hg_core_alloc_na(hg_core_handle, use_sm);
-        HG_CHECK_HG_ERROR(done, ret, "Could not re-allocate NA resources");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not re-allocate handle NA resources");
+            goto done;
+        }
     }
 #endif
 
@@ -4256,9 +4628,9 @@ HG_Core_reset(hg_core_handle_t handle, hg_core_addr_t addr, hg_id_t id)
 
     /* Set addr / RPC ID */
     ret = hg_core_set_rpc(hg_core_handle, hg_core_addr, id);
-    if (ret == HG_NOENTRY)
+    if (ret != HG_SUCCESS) {
         goto done;
-    HG_CHECK_HG_ERROR(done, ret, "Could not set rpc to handle");
+    }
 
 done:
     return ret;
@@ -4270,14 +4642,15 @@ HG_Core_ref_incr(hg_core_handle_t handle)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) handle;
-    hg_return_t ret = HG_SUCCESS;
-
-    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core handle");
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
     hg_atomic_incr32(&hg_core_handle->ref_count);
 
-done:
-    return ret;
+    return HG_SUCCESS;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4286,14 +4659,13 @@ HG_Core_ref_get(hg_core_handle_t handle)
 {
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) handle;
-    hg_int32_t ret;
-
-    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, -1,
-        "NULL HG core handle");
-    ret = (hg_int32_t) hg_atomic_get32(&hg_core_handle->ref_count);
-
-done:
-    return ret;
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return -1;
+    }
+#endif
+    return (hg_int32_t) hg_atomic_get32(&hg_core_handle->ref_count);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4304,40 +4676,39 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     struct hg_core_private_handle *hg_core_handle =
         (struct hg_core_private_handle *) handle;
     hg_size_t header_size;
-    hg_bool_t in_use;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core handle");
-    HG_CHECK_ERROR(hg_core_handle->core_handle.info.addr == HG_CORE_ADDR_NULL,
-        done, ret, HG_INVALID_ARG, "NULL target addr");
-    HG_CHECK_ERROR(hg_core_handle->core_handle.info.id == 0, done, ret,
-        HG_INVALID_ARG, "NULL RPC ID");
-
+    if (!hg_core_handle) {
+        HG_LOG_ERROR("NULL handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (hg_core_handle->core_handle.info.addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("NULL target addr");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+    if (!hg_core_handle->core_handle.info.id) {
+        HG_LOG_ERROR("NULL RPC ID");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 #ifndef HG_HAS_SELF_FORWARD
-    HG_CHECK_ERROR(hg_core_handle->is_self, done, ret, HG_INVALID_PARAM,
-        "Forward to self not enabled, please enable HG_USE_SELF_FORWARD");
+    if (hg_core_handle->is_self) {
+        HG_LOG_ERROR("Not enabled, please enable HG_USE_SELF_FORWARD");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 #endif
-    in_use = (hg_atomic_cas32(&hg_core_handle->in_use, HG_FALSE, HG_TRUE)
-        != HG_UTIL_TRUE);
-    /* Not safe to reset
-     * TODO could add the ability to defer the reset operation */
-    HG_CHECK_ERROR(in_use, done, ret, HG_BUSY,
-        "Not safe to use HG core handle, handle is still in use, refcount: %d",
-        hg_atomic_get32(&hg_core_handle->ref_count));
-
-    /* Make sure any cancelation has been processed on this handle before
-     * re-using it */
-    while (hg_atomic_get32(&hg_core_handle->canceling)) {
-        int cb_ret[HG_CORE_MAX_TRIGGER_COUNT] = {0};
-        unsigned int trigger_count = 0;
-        na_return_t na_ret;
-
-        na_ret = NA_Trigger(hg_core_handle->na_context, 0,
-            HG_CORE_MAX_TRIGGER_COUNT, cb_ret, &trigger_count);
-        HG_CHECK_ERROR(na_ret != NA_SUCCESS && na_ret != NA_TIMEOUT, done, ret,
-            (hg_return_t) na_ret, "Could not trigger NA callback (%s)",
-            NA_Error_to_string(na_ret));
+    if (hg_atomic_cas32(&hg_core_handle->in_use, HG_FALSE, HG_TRUE)
+        != HG_UTIL_TRUE) {
+        /* Not safe to reset
+         * TODO could add the ability to defer the reset operation */
+        HG_LOG_ERROR("Not safe to use HG core handle, handle is still in use, "
+            "refcount: %d", hg_atomic_get32(
+                &hg_core_handle->ref_count));
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
     }
 
 #ifdef HG_HAS_COLLECT_STATS
@@ -4349,20 +4720,19 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     hg_core_handle->na_op_count = 1; /* Default (no response) */
     hg_atomic_set32(&hg_core_handle->na_op_completed_count, 0);
 
-    /* Increase ref count here so that a call to HG_Destroy does not free the
-     * handle but only schedules its completion
-     */
-    hg_atomic_incr32(&hg_core_handle->ref_count);
-
     /* Set header size */
     header_size = hg_core_header_request_get_size() +
         hg_core_handle->core_handle.na_in_header_offset;
 
     /* Set the actual size of the msg that needs to be transmitted */
     hg_core_handle->in_buf_used = header_size + payload_size;
-    HG_CHECK_ERROR(hg_core_handle->in_buf_used
-        > hg_core_handle->core_handle.in_buf_size, error, ret, HG_MSGSIZE,
-        "Exceeding input buffer size");
+    if (hg_core_handle->in_buf_used > hg_core_handle->core_handle.in_buf_size) {
+        HG_LOG_ERROR("Exceeding input buffer size");
+        ret = HG_SIZE_ERROR;
+        /* Handle is no longer in use */
+        hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
+        goto done;
+    }
 
     /* Parse flags */
     if (flags & HG_CORE_NO_RESPONSE)
@@ -4388,26 +4758,32 @@ HG_Core_forward(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     /* Encode request header */
     ret = hg_core_proc_header_request(&hg_core_handle->core_handle,
         &hg_core_handle->in_header, HG_ENCODE);
-    HG_CHECK_HG_ERROR(error, ret, "Could not encode header");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not encode header");
+        /* Handle is no longer in use */
+        hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
+        goto done;
+    }
+
+    /* Increase ref count here so that a call to HG_Destroy does not free the
+     * handle but only schedules its completion
+     */
+    hg_atomic_incr32(&hg_core_handle->ref_count);
 
     /* If addr is self, forward locally, otherwise send the encoded buffer
      * through NA and pre-post response */
     ret = hg_core_handle->forward(hg_core_handle);
-    if (ret == HG_AGAIN)
-        goto error;
-
-    HG_CHECK_HG_ERROR(error, ret, "Could not forward buffer");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not forward buffer");
+        /* Handle is no longer in use */
+        hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
+        /* Rollback ref_count taken above */
+        hg_atomic_decr32(&hg_core_handle->ref_count);
+        goto done;
+    }
 
 done:
-    return ret;
-
-error:
-    /* Handle is no longer in use */
-    hg_atomic_set32(&hg_core_handle->in_use, HG_FALSE);
-    /* Rollback ref_count taken above */
-    hg_atomic_decr32(&hg_core_handle->ref_count);
-
-    return ret;
+     return ret;
 }
 
 /*---------------------------------------------------------------------------*/
@@ -4420,12 +4796,25 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     hg_size_t header_size;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_core_handle == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core handle");
-
+    if (!hg_core_handle) {
+        HG_LOG_ERROR("NULL handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+#ifndef HG_HAS_SELF_FORWARD
+    if (NA_Addr_is_self(hg_core_handle->core_handle.info.addr->na_class,
+        hg_core_handle->core_handle.info.addr->na_addr)) {
+        HG_LOG_ERROR("Not enabled, please enable HG_USE_SELF_FORWARD");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+#endif
     /* Cannot respond if no_response flag set */
-    HG_CHECK_ERROR(hg_core_handle->no_response, done, ret, HG_OPNOTSUPPORTED,
-        "Sending response was disabled on that RPC");
+    if (hg_core_handle->no_response) {
+        HG_LOG_ERROR("Sending response was disabled on that RPC");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     /* Set header size */
     header_size = hg_core_header_response_get_size() +
@@ -4433,9 +4822,12 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
 
     /* Set the actual size of the msg that needs to be transmitted */
     hg_core_handle->out_buf_used = header_size + payload_size;
-    HG_CHECK_ERROR(hg_core_handle->out_buf_used
-        > hg_core_handle->core_handle.out_buf_size, done, ret, HG_MSGSIZE,
-        "Exceeding output buffer size");
+    if (hg_core_handle->out_buf_used
+        > hg_core_handle->core_handle.out_buf_size) {
+        HG_LOG_ERROR("Exceeding output buffer size");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
 
     /* Set callback, keep request and response callbacks separate so that
      * they do not get overwritten when forwarding to ourself */
@@ -4450,12 +4842,18 @@ HG_Core_respond(hg_core_handle_t handle, hg_core_cb_t callback, void *arg,
     /* Encode response header */
     ret = hg_core_proc_header_response(&hg_core_handle->core_handle,
         &hg_core_handle->out_header, HG_ENCODE);
-    HG_CHECK_HG_ERROR(done, ret, "Could not encode header");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not encode header");
+        goto done;
+    }
 
     /* If addr is self, forward locally, otherwise send the encoded buffer
      * through NA and pre-post response */
     ret = hg_core_handle->respond(hg_core_handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not respond");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not respond");
+        goto done;
+    }
 
 done:
     return ret;
@@ -4469,13 +4867,18 @@ HG_Core_progress(hg_core_context_t *context, unsigned int timeout)
         (struct hg_core_private_context *) context;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core context");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Make progress on the HG layer */
     ret = private_context->progress(private_context, timeout);
-    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
-        "Could not make progress");
+    if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
+        HG_LOG_ERROR("Could not make progress");
+        goto done;
+    }
 
 done:
     return ret;
@@ -4488,13 +4891,18 @@ HG_Core_trigger(hg_core_context_t *context, unsigned int timeout,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(context == NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core context");
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = hg_core_trigger((struct hg_core_private_context *) context, timeout,
         max_count, actual_count);
-    HG_CHECK_ERROR_NORET(ret != HG_SUCCESS && ret != HG_TIMEOUT, done,
-        "Could not trigger callbacks");
+    if (ret != HG_SUCCESS && ret != HG_TIMEOUT) {
+        HG_LOG_ERROR("Could not trigger callbacks");
+        goto done;
+    }
 
 done:
     return ret;
@@ -4506,11 +4914,17 @@ HG_Core_cancel(hg_core_handle_t handle)
 {
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(handle == HG_CORE_HANDLE_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG core handle");
+    if (!handle) {
+        HG_LOG_ERROR("NULL handle");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     ret = hg_core_cancel((struct hg_core_private_handle *) handle);
-    HG_CHECK_HG_ERROR(done, ret, "Could not cancel handle");
+    if (ret != HG_SUCCESS && ret != HG_CANCEL_ERROR) {
+        HG_LOG_ERROR("Could not cancel handle");
+        goto done;
+    }
 
 done:
     return ret;
diff --git a/src/mercury_core.h b/src/mercury_core.h
index 46ca770..27eaa27 100644
--- a/src/mercury_core.h
+++ b/src/mercury_core.h
@@ -13,6 +13,7 @@
 
 #include "mercury_core_types.h"
 #include "mercury_core_header.h"
+#include "mercury_error.h"
 
 #include "na.h"
 
@@ -31,8 +32,8 @@ struct hg_core_info {
     hg_core_class_t *core_class;    /* HG core class */
     hg_core_context_t *context;     /* HG core context */
     hg_core_addr_t addr;            /* HG address at target/origin */
-    hg_id_t id;                     /* RPC ID */
     hg_uint8_t context_id;          /* Context ID at target/origin */
+    hg_id_t id;                     /* RPC ID */
 };
 
 /* Callback info structs */
@@ -49,14 +50,14 @@ struct hg_core_cb_info_respond {
 };
 
 struct hg_core_cb_info {
+    void *arg;                  /* User data */
+    hg_return_t ret;            /* Return value */
+    hg_cb_type_t type;          /* Callback type */
     union {                     /* Union of callback info structures */
         struct hg_core_cb_info_lookup lookup;
         struct hg_core_cb_info_forward forward;
         struct hg_core_cb_info_respond respond;
     } info;
-    void *arg;                  /* User data */
-    hg_cb_type_t type;          /* Callback type */
-    hg_return_t ret;            /* Return value */
 };
 
 /* RPC / HG callbacks */
@@ -96,7 +97,7 @@ extern "C" {
  *
  * \return Pointer to HG core class or NULL in case of failure
  */
-HG_PUBLIC hg_core_class_t *
+HG_EXPORT hg_core_class_t *
 HG_Core_init(
         const char *na_info_string,
         hg_bool_t na_listen
@@ -115,7 +116,7 @@ HG_Core_init(
  *
  * \return Pointer to HG core class or NULL in case of failure
  */
-HG_PUBLIC hg_core_class_t *
+HG_EXPORT hg_core_class_t *
 HG_Core_init_opt(
         const char *na_info_string,
         hg_bool_t na_listen,
@@ -129,7 +130,7 @@ HG_Core_init_opt(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_finalize(
         hg_core_class_t *hg_core_class
         );
@@ -140,7 +141,7 @@ HG_Core_finalize(
  * to HG_Finalize(), this routine gives a chance to programs that terminate
  * abnormally to easily clean up those resources.
  */
-HG_PUBLIC void
+HG_EXPORT void
 HG_Core_cleanup(
         void
         );
@@ -160,7 +161,7 @@ HG_Core_cleanup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_set_more_data_callback(
         struct hg_core_class *hg_core_class,
         hg_return_t (*more_data_acquire_callback)(hg_core_handle_t, hg_op_t,
@@ -292,7 +293,7 @@ HG_Core_class_get_data(
  *
  * \return Pointer to HG core context or NULL in case of failure
  */
-HG_PUBLIC hg_core_context_t *
+HG_EXPORT hg_core_context_t *
 HG_Core_context_create(
         hg_core_class_t *hg_core_class
         );
@@ -308,7 +309,7 @@ HG_Core_context_create(
  *
  * \return Pointer to HG core context or NULL in case of failure
  */
-HG_PUBLIC hg_core_context_t *
+HG_EXPORT hg_core_context_t *
 HG_Core_context_create_id(
         hg_core_class_t *hg_core_class,
         hg_uint8_t id
@@ -321,7 +322,7 @@ HG_Core_context_create_id(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_context_destroy(
         hg_core_context_t *context
         );
@@ -417,7 +418,7 @@ HG_Core_context_get_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_context_set_handle_create_callback(
         hg_core_context_t *context,
         hg_return_t (*callback)(hg_core_handle_t, void *),
@@ -437,7 +438,7 @@ HG_Core_context_set_handle_create_callback(
  *
  * \return the associated class
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_context_post(
         hg_core_context_t *context,
         unsigned int request_count,
@@ -454,7 +455,7 @@ HG_Core_context_post(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_register(
         hg_core_class_t *hg_core_class,
         hg_id_t id,
@@ -471,7 +472,7 @@ HG_Core_register(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_deregister(
         hg_core_class_t *hg_core_class,
         hg_id_t id
@@ -486,7 +487,7 @@ HG_Core_deregister(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_registered(
         hg_core_class_t *hg_core_class,
         hg_id_t id,
@@ -505,7 +506,7 @@ HG_Core_registered(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_register_data(
         hg_core_class_t *hg_core_class,
         hg_id_t id,
@@ -522,7 +523,7 @@ HG_Core_register_data(
  *
  * \return Pointer to data or NULL
  */
-HG_PUBLIC void *
+HG_EXPORT void *
 HG_Core_registered_data(
         hg_core_class_t *hg_core_class,
         hg_id_t id
@@ -541,7 +542,7 @@ HG_Core_registered_data(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_addr_lookup(
         hg_core_context_t *context,
         hg_core_cb_t callback,
@@ -558,7 +559,7 @@ HG_Core_addr_lookup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_addr_create(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t *addr
@@ -572,7 +573,7 @@ HG_Core_addr_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_addr_free(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t addr
@@ -589,7 +590,7 @@ HG_Core_addr_free(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_addr_set_remove(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t addr
@@ -641,7 +642,7 @@ HG_Core_addr_get_na_class(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_addr_self(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t *addr
@@ -658,7 +659,7 @@ HG_Core_addr_self(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_addr_dup(
         hg_core_class_t *hg_core_class,
         hg_core_addr_t addr,
@@ -679,7 +680,7 @@ HG_Core_addr_dup(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_addr_to_string(
         hg_core_class_t *hg_core_class,
         char *buf,
@@ -700,7 +701,7 @@ HG_Core_addr_to_string(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_create(
         hg_core_context_t *context,
         hg_core_addr_t addr,
@@ -716,7 +717,7 @@ HG_Core_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_destroy(
         hg_core_handle_t handle
         );
@@ -733,7 +734,7 @@ HG_Core_destroy(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_reset(
         hg_core_handle_t handle,
         hg_core_addr_t addr,
@@ -747,7 +748,7 @@ HG_Core_reset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_ref_incr(
         hg_core_handle_t handle
         );
@@ -759,7 +760,7 @@ HG_Core_ref_incr(
  *
  * \return Non-negative value or negative if the handle is not valid
  */
-HG_PUBLIC hg_int32_t
+HG_EXPORT hg_int32_t
 HG_Core_ref_get(
         hg_core_handle_t handle
         );
@@ -887,7 +888,7 @@ HG_Core_get_output(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_forward(
         hg_core_handle_t handle,
         hg_core_cb_t callback,
@@ -909,7 +910,7 @@ HG_Core_forward(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_respond(
         hg_core_handle_t handle,
         hg_core_cb_t callback,
@@ -930,7 +931,7 @@ HG_Core_respond(
  *
  * \return HG_SUCCESS if any completion has occurred / HG error code otherwise
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_progress(
         hg_core_context_t *context,
         unsigned int timeout
@@ -948,7 +949,7 @@ HG_Core_progress(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_trigger(
         hg_core_context_t *context,
         unsigned int timeout,
@@ -963,7 +964,7 @@ HG_Core_trigger(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Core_cancel(
         hg_core_handle_t handle
         );
@@ -989,9 +990,9 @@ struct hg_core_context {
 #ifdef HG_HAS_SM_ROUTING
     na_context_t *na_sm_context;        /* NA SM context */
 #endif
-    void *data;                         /* User data */
-    void (*data_free_callback)(void *); /* User data free callback */
     hg_uint8_t id;                      /* Context ID */
+    void *data;                         /* User data */
+    void (*data_free_callback)(void *); /* User data free callback */
 };
 
 /* HG core addr */
@@ -1014,20 +1015,26 @@ struct hg_core_rpc_info {
 struct hg_core_handle {
     struct hg_core_info info;           /* HG info */
     struct hg_core_rpc_info *rpc_info;  /* Associated RPC registration info */
-    void *data;                         /* User data */
-    void (*data_free_callback)(void *); /* User data free callback */
     void *in_buf;                       /* Input buffer */
     void *out_buf;                      /* Output buffer */
     na_size_t in_buf_size;              /* Input buffer size */
     na_size_t out_buf_size;             /* Output buffer size */
     na_size_t na_in_header_offset;      /* Input NA header offset */
     na_size_t na_out_header_offset;     /* Output NA header offset */
+    void *data;                         /* User data */
+    void (*data_free_callback)(void *); /* User data free callback */
 };
 
 /*---------------------------------------------------------------------------*/
 static HG_INLINE const char *
 HG_Core_class_get_name(const hg_core_class_t *hg_core_class)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return NULL;
+    }
+#endif
     return NA_Get_class_name(hg_core_class->na_class);
 }
 
@@ -1035,6 +1042,12 @@ HG_Core_class_get_name(const hg_core_class_t *hg_core_class)
 static HG_INLINE const char *
 HG_Core_class_get_protocol(const hg_core_class_t *hg_core_class)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return NULL;
+    }
+#endif
     return NA_Get_class_protocol(hg_core_class->na_class);
 }
 
@@ -1042,6 +1055,12 @@ HG_Core_class_get_protocol(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_bool_t
 HG_Core_class_is_listening(const hg_core_class_t *hg_core_class)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return HG_FALSE;
+    }
+#endif
     return NA_Is_listening(hg_core_class->na_class);
 }
 
@@ -1049,6 +1068,12 @@ HG_Core_class_is_listening(const hg_core_class_t *hg_core_class)
 static HG_INLINE na_class_t *
 HG_Core_class_get_na(const hg_core_class_t *hg_core_class)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return NULL;
+    }
+#endif
     return hg_core_class->na_class;
 }
 
@@ -1057,6 +1082,12 @@ HG_Core_class_get_na(const hg_core_class_t *hg_core_class)
 static HG_INLINE na_class_t *
 HG_Core_class_get_na_sm(const hg_core_class_t *hg_core_class)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return NULL;
+    }
+#endif
     return hg_core_class->na_sm_class;
 }
 #endif
@@ -1065,8 +1096,15 @@ HG_Core_class_get_na_sm(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_size_t
 HG_Core_class_get_input_eager_size(const hg_core_class_t *hg_core_class)
 {
-    hg_size_t unexp = NA_Msg_get_max_unexpected_size(hg_core_class->na_class),
-        header = hg_core_header_request_get_size() +
+    hg_size_t unexp, header;
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (hg_core_class == NULL) {
+        HG_LOG_ERROR("NULL HG core class");
+        return 0;
+    }
+#endif
+    unexp  = NA_Msg_get_max_unexpected_size(hg_core_class->na_class);
+    header = hg_core_header_request_get_size() +
         NA_Msg_get_unexpected_header_size(hg_core_class->na_class);
 
     return (unexp > header) ? unexp - header : 0;
@@ -1076,8 +1114,15 @@ HG_Core_class_get_input_eager_size(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_size_t
 HG_Core_class_get_output_eager_size(const hg_core_class_t *hg_core_class)
 {
-    hg_size_t exp = NA_Msg_get_max_expected_size(hg_core_class->na_class),
-        header = hg_core_header_response_get_size() +
+    hg_size_t exp, header;
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (hg_core_class == NULL) {
+        HG_LOG_ERROR("NULL HG core class");
+        return 0;
+    }
+#endif
+    exp    = NA_Msg_get_max_expected_size(hg_core_class->na_class);
+    header = hg_core_header_response_get_size() +
         NA_Msg_get_expected_header_size(hg_core_class->na_class);
 
     return (exp > header) ? exp - header : 0;
@@ -1088,6 +1133,12 @@ static HG_INLINE hg_return_t
 HG_Core_class_set_data(hg_core_class_t *hg_core_class, void *data,
     void (*free_callback)(void *))
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return HG_INVALID_PARAM;
+    }
+#endif
     hg_core_class->data = data;
     hg_core_class->data_free_callback = free_callback;
 
@@ -1098,6 +1149,12 @@ HG_Core_class_set_data(hg_core_class_t *hg_core_class, void *data,
 static HG_INLINE void *
 HG_Core_class_get_data(const hg_core_class_t *hg_core_class)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!hg_core_class) {
+        HG_LOG_ERROR("NULL HG core class");
+        return NULL;
+    }
+#endif
     return hg_core_class->data;
 }
 
@@ -1105,6 +1162,12 @@ HG_Core_class_get_data(const hg_core_class_t *hg_core_class)
 static HG_INLINE hg_core_class_t *
 HG_Core_context_get_class(const hg_core_context_t *context)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return NULL;
+    }
+#endif
     return context->core_class;
 }
 
@@ -1112,6 +1175,12 @@ HG_Core_context_get_class(const hg_core_context_t *context)
 static HG_INLINE na_context_t *
 HG_Core_context_get_na(const hg_core_context_t *context)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return NULL;
+    }
+#endif
     return context->na_context;
 }
 
@@ -1120,6 +1189,12 @@ HG_Core_context_get_na(const hg_core_context_t *context)
 static HG_INLINE na_context_t *
 HG_Core_context_get_na_sm(const hg_core_context_t *context)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return NULL;
+    }
+#endif
     return context->na_sm_context;
 }
 #endif
@@ -1128,6 +1203,12 @@ HG_Core_context_get_na_sm(const hg_core_context_t *context)
 static HG_INLINE hg_uint8_t
 HG_Core_context_get_id(const hg_core_context_t *context)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return HG_INVALID_PARAM;
+    }
+#endif
     return context->id;
 }
 
@@ -1136,6 +1217,12 @@ static HG_INLINE hg_return_t
 HG_Core_context_set_data(hg_core_context_t *context, void *data,
     void (*free_callback)(void *))
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return HG_INVALID_PARAM;
+    }
+#endif
     context->data = data;
     context->data_free_callback = free_callback;
 
@@ -1146,6 +1233,12 @@ HG_Core_context_set_data(hg_core_context_t *context, void *data,
 static HG_INLINE void *
 HG_Core_context_get_data(const hg_core_context_t *context)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!context) {
+        HG_LOG_ERROR("NULL HG core context");
+        return NULL;
+    }
+#endif
     return context->data;
 }
 
@@ -1153,6 +1246,12 @@ HG_Core_context_get_data(const hg_core_context_t *context)
 static HG_INLINE hg_return_t
 HG_Core_addr_set_na(hg_core_addr_t core_addr, na_addr_t na_addr)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (core_addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("NULL HG core address");
+        return HG_INVALID_PARAM;
+    }
+#endif
     core_addr->na_addr = na_addr;
 
     return HG_SUCCESS;
@@ -1162,6 +1261,12 @@ HG_Core_addr_set_na(hg_core_addr_t core_addr, na_addr_t na_addr)
 static HG_INLINE na_addr_t
 HG_Core_addr_get_na(hg_core_addr_t addr)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("NULL addr");
+        return NA_ADDR_NULL;
+    }
+#endif
     return addr->na_addr;
 }
 
@@ -1169,6 +1274,12 @@ HG_Core_addr_get_na(hg_core_addr_t addr)
 static HG_INLINE na_class_t *
 HG_Core_addr_get_na_class(hg_core_addr_t addr)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (addr == HG_CORE_ADDR_NULL) {
+        HG_LOG_ERROR("NULL addr");
+        return NULL;
+    }
+#endif
     return addr->na_class;
 }
 
@@ -1177,6 +1288,12 @@ static HG_INLINE hg_return_t
 HG_Core_set_data(hg_core_handle_t handle, void *data,
     void (*free_callback)(void *))
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
     handle->data = data;
     handle->data_free_callback = free_callback;
 
@@ -1187,6 +1304,12 @@ HG_Core_set_data(hg_core_handle_t handle, void *data,
 static HG_INLINE void *
 HG_Core_get_data(hg_core_handle_t handle)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return NULL;
+    }
+#endif
     return handle->data;
 }
 
@@ -1194,6 +1317,12 @@ HG_Core_get_data(hg_core_handle_t handle)
 static HG_INLINE const struct hg_core_info *
 HG_Core_get_info(hg_core_handle_t handle)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return NULL;
+    }
+#endif
     return &handle->info;
 }
 
@@ -1201,6 +1330,12 @@ HG_Core_get_info(hg_core_handle_t handle)
 static HG_INLINE const void *
 HG_Core_get_rpc_data(hg_core_handle_t handle)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL pointer to HG core handle");
+        return NULL;
+    }
+#endif
     return (handle->rpc_info) ? handle->rpc_info->data : NULL;
 }
 
@@ -1208,6 +1343,12 @@ HG_Core_get_rpc_data(hg_core_handle_t handle)
 static HG_INLINE hg_return_t
 HG_Core_set_target_id(hg_core_handle_t handle, hg_uint8_t id)
 {
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL HG core handle");
+        return HG_INVALID_PARAM;
+    }
+#endif
     handle->info.context_id = id;
 
     return HG_SUCCESS;
@@ -1218,7 +1359,21 @@ static HG_INLINE hg_return_t
 HG_Core_get_input(hg_core_handle_t handle, void **in_buf,
     hg_size_t *in_buf_size)
 {
-    hg_size_t header_offset = hg_core_header_request_get_size() +
+    hg_size_t header_offset;
+
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL handle");
+        return HG_INVALID_PARAM;
+    }
+
+    if (!in_buf || !in_buf_size) {
+        HG_LOG_ERROR("NULL pointer");
+        return HG_INVALID_PARAM;
+    }
+#endif
+
+    header_offset = hg_core_header_request_get_size() +
         handle->na_in_header_offset;
 
     /* Space must be left for request header */
@@ -1233,7 +1388,21 @@ static HG_INLINE hg_return_t
 HG_Core_get_output(hg_core_handle_t handle, void **out_buf,
     hg_size_t *out_buf_size)
 {
-    hg_size_t header_offset = hg_core_header_response_get_size() +
+    hg_size_t header_offset;
+
+#ifdef HG_HAS_VERBOSE_ERROR
+    if (!handle) {
+        HG_LOG_ERROR("NULL handle");
+        return HG_INVALID_PARAM;
+    }
+
+    if (!out_buf || !out_buf_size) {
+        HG_LOG_ERROR("NULL pointer");
+        return HG_INVALID_PARAM;
+    }
+#endif
+
+    header_offset = hg_core_header_response_get_size() +
         handle->na_out_header_offset;
 
     /* Space must be left for response header */
diff --git a/src/mercury_core_header.c b/src/mercury_core_header.c
index 04e1c8f..8794f69 100644
--- a/src/mercury_core_header.c
+++ b/src/mercury_core_header.c
@@ -160,8 +160,11 @@ hg_core_header_request_proc(hg_proc_op_t op, void *buf, size_t buf_size,
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(buf_size < sizeof(struct hg_core_header_request), done,
-        ret, HG_INVALID_ARG, "Invalid buffer size");
+    if (buf_size < sizeof(struct hg_core_header_request)) {
+        HG_LOG_ERROR("Invalid buffer size");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
 #ifdef HG_HAS_CHECKSUMS
     /* Reset header checksum first */
@@ -192,9 +195,12 @@ hg_core_header_request_proc(hg_proc_op_t op, void *buf, size_t buf_size,
     hg_proc_buf_memcpy(buf_ptr, &n_hash_header, sizeof(n_hash_header), op);
     if (op == HG_DECODE) {
         hg_uint16_t h_hash_header = ntohs(n_hash_header);
-        HG_CHECK_ERROR(header->hash.header != h_hash_header, done, ret,
-            HG_CHECKSUM_ERROR,
-            "checksum 0x%04X does not match (expected 0x%04X!)");
+        if (header->hash.header != h_hash_header) {
+            HG_LOG_ERROR("checksum 0x%04X does not match (expected 0x%04X!)",
+                header->hash.header, h_hash_header);
+            ret = HG_CHECKSUM_ERROR;
+            goto done;
+        }
     }
 #endif
 
@@ -214,8 +220,11 @@ hg_core_header_response_proc(hg_proc_op_t op, void *buf, size_t buf_size,
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(buf_size < sizeof(struct hg_core_header_response), done, ret,
-        HG_OVERFLOW, "Invalid buffer size");
+    if (buf_size < sizeof(struct hg_core_header_response)) {
+        HG_LOG_ERROR("Invalid buffer size");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
 
 #ifdef HG_HAS_CHECKSUMS
     /* Reset header checksum first */
@@ -240,9 +249,12 @@ hg_core_header_response_proc(hg_proc_op_t op, void *buf, size_t buf_size,
     hg_proc_buf_memcpy(buf_ptr, &n_hash_header, sizeof(n_hash_header), op);
     if (op == HG_DECODE) {
         hg_uint16_t h_hash_header = ntohs(n_hash_header);
-        HG_CHECK_ERROR(header->hash.header != h_hash_header, done, ret,
-            HG_CHECKSUM_ERROR,
-            "checksum 0x%04X does not match (expected 0x%04X!)");
+        if (header->hash.header != h_hash_header) {
+            HG_LOG_ERROR("checksum 0x%04X does not match (expected 0x%04X!)",
+                header->hash.header, h_hash_header);
+            ret = HG_CHECKSUM_ERROR;
+            goto done;
+        }
     }
 #endif
 
@@ -258,12 +270,18 @@ hg_core_header_request_verify(const struct hg_core_header *hg_core_header)
     hg_return_t ret = HG_SUCCESS;
 
     /* Must match HG */
-    HG_CHECK_ERROR(
-        (((header->hg >> 1) & 'H') != 'H') || (((header->hg) & 'G') != 'G'),
-        done, ret, HG_PROTOCOL_ERROR, "Invalid HG byte");
+    if ((((header->hg >> 1)  & 'H') != 'H') ||
+        (((header->hg)       & 'G') != 'G')) {
+        HG_LOG_ERROR("Invalid HG byte");
+        ret = HG_NO_MATCH;
+        goto done;
+    }
 
-    HG_CHECK_ERROR(header->protocol != HG_CORE_PROTOCOL_VERSION, done, ret,
-        HG_PROTONOSUPPORT, "Invalid protocol version");
+    if (header->protocol != HG_CORE_PROTOCOL_VERSION) {
+        HG_LOG_ERROR("Invalid protocol version");
+        ret = HG_NO_MATCH;
+        goto done;
+    }
 
 done:
     return ret;
@@ -276,8 +294,9 @@ hg_core_header_response_verify(const struct hg_core_header *hg_core_header)
     const struct hg_core_header_response *header = &hg_core_header->msg.response;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_WARNING(header->ret_code, "Response return code: %s",
-        HG_Error_to_string((hg_return_t) header->ret_code));
+    if (header->ret_code)
+        HG_LOG_WARNING("Response return code: %s",
+            HG_Error_to_string((hg_return_t) header->ret_code));
 
     return ret;
 }
diff --git a/src/mercury_core_header.h b/src/mercury_core_header.h
index a742da4..a72e24f 100644
--- a/src/mercury_core_header.h
+++ b/src/mercury_core_header.h
@@ -132,7 +132,7 @@ hg_core_header_response_get_size(void)
  * \param hg_core_header [IN/OUT]   pointer to request header structure
  *
  */
-HG_PRIVATE void
+HG_EXPORT void
 hg_core_header_request_init(
         struct hg_core_header *hg_core_header
         );
@@ -143,7 +143,7 @@ hg_core_header_request_init(
  * \param hg_core_header [IN/OUT]   pointer to response header structure
  *
  */
-HG_PRIVATE void
+HG_EXPORT void
 hg_core_header_response_init(
         struct hg_core_header *hg_core_header
         );
@@ -154,7 +154,7 @@ hg_core_header_response_init(
  * \param hg_core_header [IN/OUT]   pointer to request header structure
  *
  */
-HG_PRIVATE void
+HG_EXPORT void
 hg_core_header_request_finalize(
         struct hg_core_header *hg_core_header
         );
@@ -165,7 +165,7 @@ hg_core_header_request_finalize(
  * \param hg_core_header [IN/OUT]   pointer to response header structure
  *
  */
-HG_PRIVATE void
+HG_EXPORT void
 hg_core_header_response_finalize(
         struct hg_core_header *hg_core_header
         );
@@ -176,7 +176,7 @@ hg_core_header_response_finalize(
  * \param hg_core_header [IN/OUT]   pointer to request header structure
  *
  */
-HG_PRIVATE void
+HG_EXPORT void
 hg_core_header_request_reset(
         struct hg_core_header *hg_core_header
         );
@@ -187,7 +187,7 @@ hg_core_header_request_reset(
  * \param hg_core_header [IN/OUT]   pointer to response header structure
  *
  */
-HG_PRIVATE void
+HG_EXPORT void
 hg_core_header_response_reset(
         struct hg_core_header *hg_core_header
         );
@@ -202,7 +202,7 @@ hg_core_header_response_reset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PRIVATE hg_return_t
+HG_EXPORT hg_return_t
 hg_core_header_request_proc(
         hg_proc_op_t op,
         void *buf,
@@ -220,7 +220,7 @@ hg_core_header_request_proc(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PRIVATE hg_return_t
+HG_EXPORT hg_return_t
 hg_core_header_response_proc(
         hg_proc_op_t op,
         void *buf,
@@ -235,7 +235,7 @@ hg_core_header_response_proc(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PRIVATE hg_return_t
+HG_EXPORT hg_return_t
 hg_core_header_request_verify(
         const struct hg_core_header *hg_core_header
         );
@@ -247,7 +247,7 @@ hg_core_header_request_verify(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PRIVATE hg_return_t
+HG_EXPORT hg_return_t
 hg_core_header_response_verify(
         const struct hg_core_header *hg_core_header
         );
diff --git a/src/mercury_core_types.h b/src/mercury_core_types.h
index 244e0fe..4bec24a 100644
--- a/src/mercury_core_types.h
+++ b/src/mercury_core_types.h
@@ -30,42 +30,21 @@ struct hg_init_info {
 };
 
 /* Error return codes:
- * Functions return 0 for success or corresponding return code */
-#define HG_RETURN_VALUES                                                    \
-    X(HG_SUCCESS)           /*!< operation succeeded */                     \
-    X(HG_PERMISSION)        /*!< operation not permitted */                 \
-    X(HG_NOENTRY)           /*!< no such file or directory */               \
-    X(HG_INTERRUPT)         /*!< operation interrupted */                   \
-    X(HG_AGAIN)             /*!< operation must be retried */               \
-    X(HG_NOMEM)             /*!< out of memory */                           \
-    X(HG_ACCESS)            /*!< permission denied */                       \
-    X(HG_FAULT)             /*!< bad address */                             \
-    X(HG_BUSY)              /*!< device or resource busy */                 \
-    X(HG_NODEV)             /*!< no such device */                          \
-    X(HG_INVALID_ARG)       /*!< invalid argument */                        \
-    X(HG_PROTOCOL_ERROR)    /*!< protocol error */                          \
-    X(HG_OVERFLOW)          /*!< value too large */                         \
-    X(HG_MSGSIZE)           /*!< message size too long */                   \
-    X(HG_PROTONOSUPPORT)    /*!< protocol not supported */                  \
-    X(HG_OPNOTSUPPORTED)    /*!< operation not supported on endpoint */     \
-    X(HG_ADDRINUSE)         /*!< address already in use */                  \
-    X(HG_ADDRNOTAVAIL)      /*!< cannot assign requested address */         \
-    X(HG_TIMEOUT)           /*!< operation reached timeout */               \
-    X(HG_CANCELED)          /*!< operation canceled */                      \
-    X(HG_CHECKSUM_ERROR)    /*!< checksum error */                          \
-    X(HG_NA_ERROR)          /*!< generic NA error */                        \
-    X(HG_OTHER_ERROR)       /*!< generic HG error */                        \
-    X(HG_RETURN_MAX)
-
-#define X(a) a,
-typedef enum hg_return { HG_RETURN_VALUES } hg_return_t;
-#undef X
-
-/* Compat return codes */
-#define HG_INVALID_PARAM    HG_INVALID_ARG
-#define HG_SIZE_ERROR       HG_MSGSIZE
-#define HG_NOMEM_ERROR      HG_NOMEM
-#define HG_NO_MATCH         HG_NOENTRY
+ * Functions return 0 for success or HG_XXX_ERROR for failure */
+typedef enum hg_return {
+    HG_SUCCESS = 0,     /*!< operation succeeded */
+    HG_NA_ERROR,        /*!< error in NA layer */
+    HG_TIMEOUT,         /*!< reached timeout */
+    HG_INVALID_PARAM,   /*!< invalid parameter */
+    HG_SIZE_ERROR,      /*!< size error */
+    HG_NOMEM_ERROR,     /*!< no memory error */
+    HG_PROTOCOL_ERROR,  /*!< protocol does not match */
+    HG_NO_MATCH,        /*!< no function match */
+    HG_CHECKSUM_ERROR,  /*!< checksum error */
+    HG_CANCELED,        /*!< operation was canceled */
+    HG_CANCEL_ERROR,    /*!< operation could not be canceled */
+    HG_OTHER_ERROR      /*!< error from mercury_util or external to mercury */
+} hg_return_t;
 
 /* Callback operation type */
 typedef enum hg_cb_type {
diff --git a/src/mercury_error.h b/src/mercury_error.h
index 75262c2..5b49a1b 100644
--- a/src/mercury_error.h
+++ b/src/mercury_error.h
@@ -19,85 +19,18 @@
 
 /* Default error macro */
 #ifdef HG_HAS_VERBOSE_ERROR
-# include <mercury_log.h>
-# define HG_LOG_MASK hg_log_mask
-/* Log mask will be initialized in init routine */
-extern HG_PRIVATE unsigned int HG_LOG_MASK;
-# define HG_LOG_MODULE_NAME    "HG"
-# define HG_LOG_ERROR(...) do {                                 \
-    if (HG_LOG_MASK & HG_LOG_TYPE_ERROR)                        \
-        HG_LOG_WRITE_ERROR(HG_LOG_MODULE_NAME, __VA_ARGS__);    \
-} while (0)
-# define HG_LOG_DEBUG(...) do {                                 \
-    if (HG_LOG_MASK & HG_LOG_TYPE_DEBUG)                        \
-        HG_LOG_WRITE_DEBUG(HG_LOG_MODULE_NAME, __VA_ARGS__);    \
-} while (0)
-# define HG_LOG_WARNING(...) do {                               \
-    if (HG_LOG_MASK & HG_LOG_TYPE_WARNING)                      \
-        HG_LOG_WRITE_WARNING(HG_LOG_MODULE_NAME, __VA_ARGS__);  \
-} while (0)
+  #include <mercury_log.h>
+  #define HG_LOG_MODULE_NAME "HG"
+  #define HG_LOG_ERROR(...)                                 \
+      HG_LOG_WRITE_ERROR(HG_LOG_MODULE_NAME, __VA_ARGS__)
+  #define HG_LOG_DEBUG(...)                                 \
+      HG_LOG_WRITE_DEBUG(HG_LOG_MODULE_NAME, __VA_ARGS__)
+  #define HG_LOG_WARNING(...)                               \
+      HG_LOG_WRITE_WARNING(HG_LOG_MODULE_NAME, __VA_ARGS__)
 #else
-# define HG_LOG_ERROR(...)      (void)0
-# define HG_LOG_DEBUG(...)      (void)0
-# define HG_LOG_WARNING(...)    (void)0
+  #define HG_LOG_ERROR(...) (void)0
+  #define HG_LOG_DEBUG(...) (void)0
+  #define HG_LOG_WARNING(...) (void)0
 #endif
 
-/* Branch predictor hints */
-#ifndef _WIN32
-# define likely(x)       __builtin_expect(!!(x), 1)
-# define unlikely(x)     __builtin_expect(!!(x), 0)
-#else
-# define likely(x)       (x)
-# define unlikely(x)     (x)
-#endif
-
-/* Error macros */
-#define HG_GOTO_DONE(label, ret, ret_val) do {                  \
-    ret = ret_val;                                              \
-    goto label;                                                 \
-} while (0)
-
-#define HG_GOTO_ERROR(label, ret, err_val, ...) do {            \
-    HG_LOG_ERROR(__VA_ARGS__);                                  \
-    ret = err_val;                                              \
-    goto label;                                                 \
-} while (0)
-
-/* Check for hg_ret value and goto label */
-#define HG_CHECK_HG_ERROR(label, hg_ret, ...) do {              \
-    if (unlikely(hg_ret != HG_SUCCESS)) {                       \
-        HG_LOG_ERROR(__VA_ARGS__);                              \
-        goto label;                                             \
-    }                                                           \
-} while (0)
-
-/* Check for cond, set ret to err_val and goto label */
-#define HG_CHECK_ERROR(cond, label, ret, err_val, ...) do {     \
-    if (unlikely(cond)) {                                       \
-        HG_LOG_ERROR(__VA_ARGS__);                              \
-        ret = err_val;                                          \
-        goto label;                                             \
-    }                                                           \
-} while (0)
-
-#define HG_CHECK_ERROR_NORET(cond, label, ...) do {             \
-    if (unlikely(cond)) {                                       \
-        HG_LOG_ERROR(__VA_ARGS__);                              \
-        goto label;                                             \
-    }                                                           \
-} while (0)
-
-#define HG_CHECK_ERROR_DONE(cond, ...) do {                     \
-    if (unlikely(cond)) {                                       \
-        HG_LOG_ERROR(__VA_ARGS__);                              \
-    }                                                           \
-} while (0)
-
-/* Check for cond and print warning */
-#define HG_CHECK_WARNING(cond, ...) do {                        \
-    if (unlikely(cond)) {                                       \
-        HG_LOG_WARNING(__VA_ARGS__);                            \
-    }                                                           \
-} while (0)
-
 #endif /* MERCURY_ERROR_H */
diff --git a/src/mercury_header.c b/src/mercury_header.c
index a281eaf..296092b 100644
--- a/src/mercury_header.c
+++ b/src/mercury_header.c
@@ -92,21 +92,29 @@ hg_header_proc(hg_proc_op_t op, void *buf, size_t buf_size,
 
     switch (hg_header->op) {
         case HG_INPUT:
-            HG_CHECK_ERROR(buf_size < sizeof(struct hg_header_input), done, ret,
-                HG_INVALID_ARG, "Invalid buffer size");
+            if (buf_size < sizeof(struct hg_header_input)) {
+                HG_LOG_ERROR("Invalid buffer size");
+                ret = HG_INVALID_PARAM;
+                goto done;
+            }
 #ifdef HG_HAS_CHECKSUMS
             header_hash = &hg_header->msg.input.hash;
 #endif
             break;
         case HG_OUTPUT:
-            HG_CHECK_ERROR(buf_size < sizeof(struct hg_header_output), done,
-                ret, HG_INVALID_ARG, "Invalid buffer size");
+            if (buf_size < sizeof(struct hg_header_output)) {
+                HG_LOG_ERROR("Invalid buffer size");
+                ret = HG_SIZE_ERROR;
+                goto done;
+            }
 #ifdef HG_HAS_CHECKSUMS
             header_hash = &hg_header->msg.output.hash;
 #endif
             break;
         default:
-            HG_GOTO_ERROR(done, ret, HG_INVALID_ARG, "Invalid header op");
+            HG_LOG_ERROR("Invalid header op");
+            ret = HG_INVALID_PARAM;
+            goto done;
     }
 
 #ifdef HG_HAS_CHECKSUMS
diff --git a/src/mercury_header.h b/src/mercury_header.h
index 48d7de6..74c458f 100644
--- a/src/mercury_header.h
+++ b/src/mercury_header.h
@@ -102,7 +102,7 @@ hg_header_get_size(hg_op_t op)
  * \param hg_header [IN/OUT]    pointer to header structure
  * \param op [IN]               HG operation type: HG_INPUT / HG_OUTPUT
  */
-HG_PRIVATE void
+HG_EXPORT void
 hg_header_init(
         struct hg_header *hg_header,
         hg_op_t op
@@ -113,7 +113,7 @@ hg_header_init(
  *
  * \param hg_header [IN/OUT]    pointer to header structure
  */
-HG_PRIVATE void
+HG_EXPORT void
 hg_header_finalize(
         struct hg_header *hg_header
         );
@@ -124,7 +124,7 @@ hg_header_finalize(
  * \param hg_header [IN/OUT]    pointer to header structure
  * \param op [IN]               HG operation type: HG_INPUT / HG_OUTPUT
  */
-HG_PRIVATE void
+HG_EXPORT void
 hg_header_reset(
         struct hg_header *hg_header,
         hg_op_t op
@@ -140,7 +140,7 @@ hg_header_reset(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PRIVATE hg_return_t
+HG_EXPORT hg_return_t
 hg_header_proc(
         hg_proc_op_t op,
         void *buf,
diff --git a/src/mercury_hl.c b/src/mercury_hl.c
index fdd6296..4cbd025 100644
--- a/src/mercury_hl.c
+++ b/src/mercury_hl.c
@@ -74,11 +74,6 @@ hg_request_class_t *HG_REQUEST_CLASS_DEFAULT = NULL;
 /* For convenience, register HG_Hl_finalize() */
 static hg_bool_t hg_atexit_g = HG_FALSE;
 
-/* Default error log mask */
-#ifdef HG_HAS_VERBOSE_ERROR
-unsigned int HG_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
-#endif
-
 /*---------------------------------------------------------------------------*/
 static int
 hg_hl_request_progress(unsigned int timeout, void *arg)
@@ -158,9 +153,11 @@ HG_Hl_init(const char *na_info_string, hg_bool_t na_listen)
 
     /* First register finalize function if not set */
     if (!hg_atexit_g) {
-        int rc = atexit(hg_hl_finalize);
-        HG_CHECK_ERROR(rc != 0, done, ret, HG_INVALID_ARG,
-            "Cannot set exit function");
+        if (atexit(hg_hl_finalize) != 0) {
+            HG_LOG_ERROR("Cannot set exit function");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
         hg_atexit_g = HG_TRUE;
     }
 
@@ -168,29 +165,40 @@ HG_Hl_init(const char *na_info_string, hg_bool_t na_listen)
     if (!na_info_string) {
         na_info_string = getenv(HG_PORT_NAME);
     }
-    HG_CHECK_ERROR(na_info_string == NULL, done, ret, HG_INVALID_ARG,
-        HG_PORT_NAME " environment variable must be set");
+    if (!na_info_string) {
+        HG_LOG_ERROR(HG_PORT_NAME " environment variable must be set");
+        goto done;
+    }
 
     /* Initialize HG */
     if (!HG_CLASS_DEFAULT) {
         HG_CLASS_DEFAULT = HG_Init(na_info_string, na_listen);
-        HG_CHECK_ERROR(HG_CLASS_DEFAULT == NULL, done, ret, HG_FAULT,
-            "Could not initialize HG class");
+        if (!HG_CLASS_DEFAULT) {
+            HG_LOG_ERROR("Could not initialize HG class");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
     }
 
     /* Create HG context */
     if (!HG_CONTEXT_DEFAULT) {
         HG_CONTEXT_DEFAULT = HG_Context_create(HG_CLASS_DEFAULT);
-        HG_CHECK_ERROR(HG_CONTEXT_DEFAULT == NULL, done, ret, HG_FAULT,
-            "Could not create HG context");
+        if (!HG_CONTEXT_DEFAULT) {
+            HG_LOG_ERROR("Could not create HG context");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
     }
 
     /* Initialize request class */
     if (!HG_REQUEST_CLASS_DEFAULT) {
         HG_REQUEST_CLASS_DEFAULT = hg_request_init(hg_hl_request_progress,
                 hg_hl_request_trigger, HG_CONTEXT_DEFAULT);
-        HG_CHECK_ERROR(HG_REQUEST_CLASS_DEFAULT == NULL, done, ret,
-            HG_FAULT, "Could not create HG request class");
+        if (!HG_REQUEST_CLASS_DEFAULT) {
+            HG_LOG_ERROR("Could not create HG request class");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
     }
 
 done:
@@ -206,32 +214,43 @@ HG_Hl_init_opt(const char *na_info_string, hg_bool_t na_listen,
 
     /* First register finalize function if not set */
     if (!hg_atexit_g) {
-        int rc = atexit(hg_hl_finalize);
-        HG_CHECK_ERROR(rc != 0, done, ret, HG_INVALID_ARG,
-            "Cannot set exit function");
+        if (atexit(hg_hl_finalize) != 0) {
+            HG_LOG_ERROR("Cannot set exit function");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
         hg_atexit_g = HG_TRUE;
     }
 
     /* Initialize HG */
     if (!HG_CLASS_DEFAULT) {
         HG_CLASS_DEFAULT = HG_Init_opt(na_info_string, na_listen, hg_init_info);
-        HG_CHECK_ERROR(HG_CLASS_DEFAULT == NULL, done, ret, HG_FAULT,
-            "Could not initialize HG class");
+        if (!HG_CLASS_DEFAULT) {
+            HG_LOG_ERROR("Could not initialize HG class");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
     }
 
     /* Create HG context */
     if (!HG_CONTEXT_DEFAULT) {
         HG_CONTEXT_DEFAULT = HG_Context_create(HG_CLASS_DEFAULT);
-        HG_CHECK_ERROR(HG_CONTEXT_DEFAULT == NULL, done, ret, HG_FAULT,
-            "Could not create HG context");
+        if (!HG_CONTEXT_DEFAULT) {
+            HG_LOG_ERROR("Could not create HG context");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
     }
 
     /* Initialize request class */
     if (!HG_REQUEST_CLASS_DEFAULT) {
         HG_REQUEST_CLASS_DEFAULT = hg_request_init(hg_hl_request_progress,
                 hg_hl_request_trigger, HG_CONTEXT_DEFAULT);
-        HG_CHECK_ERROR(HG_REQUEST_CLASS_DEFAULT == NULL, done, ret, HG_FAULT,
-            "Could not create HG request class");
+        if (!HG_REQUEST_CLASS_DEFAULT) {
+            HG_LOG_ERROR("Could not create HG request class");
+            ret = HG_PROTOCOL_ERROR;
+            goto done;
+        }
     }
 
 done:
@@ -253,14 +272,20 @@ HG_Hl_finalize(void)
     /* Destroy context */
     if (HG_CONTEXT_DEFAULT) {
         ret = HG_Context_destroy(HG_CONTEXT_DEFAULT);
-        HG_CHECK_HG_ERROR(done, ret, "Could not destroy HG context");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not destroy HG context");
+            goto done;
+        }
         HG_CONTEXT_DEFAULT = NULL;
     }
 
     /* Finalize interface */
     if (HG_CLASS_DEFAULT) {
         ret = HG_Finalize(HG_CLASS_DEFAULT);
-        HG_CHECK_HG_ERROR(done, ret, "Could not finalize HG class");
+        if (ret != HG_SUCCESS) {
+            HG_LOG_ERROR("Could not finalize HG class");
+            goto done;
+        }
         HG_CLASS_DEFAULT = NULL;
     }
 
@@ -278,8 +303,11 @@ HG_Hl_addr_lookup_wait(hg_context_t *context, hg_request_class_t *request_class,
     unsigned int flag = 0;
     struct hg_lookup_request_arg request_args;
 
-    HG_CHECK_ERROR(request_class == NULL, done, ret, HG_INVALID_ARG,
-        "Uninitialized request class");
+    if (!request_class) {
+        HG_LOG_ERROR("Uninitialized request class");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     request = hg_request_create(request_class);
     request_args.addr_ptr = addr;
@@ -288,12 +316,18 @@ HG_Hl_addr_lookup_wait(hg_context_t *context, hg_request_class_t *request_class,
     /* Forward call to remote addr and get a new request */
     ret = HG_Addr_lookup(context, hg_hl_addr_lookup_cb, &request_args, name,
             HG_OP_ID_IGNORE);
-    HG_CHECK_HG_ERROR(done, ret, "Could not lookup address");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not lookup address");
+        goto done;
+    }
 
     /* Wait for request to be marked completed */
     hg_request_wait(request, timeout, &flag);
-    HG_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
-        "Operation did not complete");
+    if (!flag) {
+        HG_LOG_ERROR("Operation did not complete");
+        ret = HG_TIMEOUT;
+        goto done;
+    }
 
     /* Free request */
     hg_request_destroy(request);
@@ -312,19 +346,28 @@ HG_Hl_forward_wait(hg_request_class_t *request_class, hg_handle_t handle,
     hg_return_t ret = HG_SUCCESS;
     unsigned int flag = 0;
 
-    HG_CHECK_ERROR(request_class == NULL, done, ret, HG_INVALID_ARG,
-        "Uninitialized request class");
+    if (!request_class) {
+        HG_LOG_ERROR("Uninitialized request class");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     request = hg_request_create(request_class);
 
     /* Forward call to remote addr and get a new request */
     ret = HG_Forward(handle, hg_hl_forward_cb, request, in_struct);
-    HG_CHECK_HG_ERROR(done, ret, "Could not forward call");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not forward call");
+        goto done;
+    }
 
     /* Wait for request to be marked completed */
     hg_request_wait(request, timeout, &flag);
-    HG_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
-        "Operation did not complete");
+    if (!flag) {
+        HG_LOG_ERROR("Operation did not complete");
+        ret = HG_TIMEOUT;
+        goto done;
+    }
 
     /* Free request */
     hg_request_destroy(request);
@@ -345,8 +388,11 @@ HG_Hl_bulk_transfer_wait(hg_context_t *context,
     hg_return_t ret = HG_SUCCESS;
     unsigned int flag = 0;
 
-    HG_CHECK_ERROR(request_class == NULL, done, ret, HG_INVALID_ARG,
-        "Uninitialized request class");
+    if (!request_class) {
+        HG_LOG_ERROR("Uninitialized request class");
+        ret = HG_PROTOCOL_ERROR;
+        goto done;
+    }
 
     request = hg_request_create(request_class);
 
@@ -354,12 +400,18 @@ HG_Hl_bulk_transfer_wait(hg_context_t *context,
     ret = HG_Bulk_transfer(context, hg_hl_bulk_transfer_cb, request, op,
             origin_addr, origin_handle, origin_offset, local_handle,
             local_offset, size, HG_OP_ID_IGNORE);
-    HG_CHECK_HG_ERROR(done, ret, "Could not transfer data");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not transfer data");
+        goto done;
+    }
 
     /* Wait for request to be marked completed */
     hg_request_wait(request, timeout, &flag);
-    HG_CHECK_ERROR(flag == 0, done, ret, HG_TIMEOUT,
-        "Operation did not complete");
+    if (!flag) {
+        HG_LOG_ERROR("Operation did not complete");
+        ret = HG_TIMEOUT;
+        goto done;
+    }
 
     /* Free request */
     hg_request_destroy(request);
diff --git a/src/mercury_hl.h b/src/mercury_hl.h
index 1709e48..27938f3 100644
--- a/src/mercury_hl.h
+++ b/src/mercury_hl.h
@@ -37,9 +37,9 @@ extern "C" {
 /********************/
 
 /* HG default */
-extern HG_PUBLIC hg_class_t *HG_CLASS_DEFAULT;
-extern HG_PUBLIC hg_context_t *HG_CONTEXT_DEFAULT;
-extern HG_PUBLIC hg_request_class_t *HG_REQUEST_CLASS_DEFAULT;
+extern HG_EXPORT hg_class_t *HG_CLASS_DEFAULT;
+extern HG_EXPORT hg_context_t *HG_CONTEXT_DEFAULT;
+extern HG_EXPORT hg_request_class_t *HG_REQUEST_CLASS_DEFAULT;
 
 /*********************/
 /* Public Prototypes */
@@ -60,7 +60,7 @@ extern HG_PUBLIC hg_request_class_t *HG_REQUEST_CLASS_DEFAULT;
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Hl_init(
         const char *na_info_string,
         hg_bool_t na_listen
@@ -81,7 +81,7 @@ HG_Hl_init(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Hl_init_opt(
         const char *na_info_string,
         hg_bool_t na_listen,
@@ -93,7 +93,7 @@ HG_Hl_init_opt(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Hl_finalize(
         void
         );
@@ -104,7 +104,7 @@ HG_Hl_finalize(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Hl_addr_lookup_wait(
         hg_context_t *context,
         hg_request_class_t *request_class,
@@ -120,7 +120,7 @@ HG_Hl_addr_lookup_wait(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Hl_forward_wait(
         hg_request_class_t *request_class,
         hg_handle_t handle,
@@ -144,7 +144,7 @@ HG_Hl_forward_wait(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 HG_Hl_bulk_transfer_wait(
         hg_context_t *context,
         hg_request_class_t *request_class,
diff --git a/src/mercury_hl_macros.h b/src/mercury_hl_macros.h
index d527609..49d983b 100644
--- a/src/mercury_hl_macros.h
+++ b/src/mercury_hl_macros.h
@@ -119,6 +119,7 @@
 #define HG_GET_OUTPUT(with_ret, ret_fail) \
         hg_ret = HG_Get_output(handle, &out_struct); \
         if (hg_ret != HG_SUCCESS) { \
+            HG_LOG_ERROR("Could not get output"); \
             BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
             goto done; \
         }
@@ -127,6 +128,7 @@
 #define HG_FREE_OUTPUT(with_ret, ret_fail) \
         hg_ret = HG_Free_output(handle, &out_struct); \
         if (hg_ret != HG_SUCCESS) { \
+            HG_LOG_ERROR("Could not free output"); \
             BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
             goto done; \
         }
@@ -155,6 +157,7 @@
                 BOOST_PP_IF(bulk_read, HG_BULK_READ_ONLY, HG_BULK_READWRITE), \
                 &bulk_handle); \
         if (hg_ret != HG_SUCCESS) { \
+            HG_LOG_ERROR("Could not create HG bulk handle\n"); \
             BOOST_PP_IF(with_ret, ret = fail_ret;, BOOST_PP_EMPTY()) \
             goto done; \
         }
@@ -163,6 +166,7 @@
 #define HG_BULK_FREE(bulk_handle, with_ret, fail_ret) \
         hg_ret = HG_Bulk_free(bulk_handle); \
         if (hg_ret != HG_SUCCESS) { \
+            HG_LOG_ERROR("Could not free HG bulk handle"); \
             BOOST_PP_IF(with_ret, ret = fail_ret;, BOOST_PP_EMPTY()) \
             goto done; \
         } \
@@ -190,6 +194,7 @@
 #define HG_BULK_LOCAL_FREE(local_bulk_handle) \
         hg_ret = HG_Bulk_free(local_bulk_handle); \
         if (hg_ret != HG_SUCCESS) { \
+            HG_LOG_ERROR("Could not free block call"); \
             goto done; \
         } \
         free(HG_GEN_GET_NAME(BOOST_PP_SEQ_HEAD(HG_BULK_BUF)));
@@ -207,6 +212,7 @@
                 0, \
                 HG_GEN_GET_NAME(BOOST_PP_SEQ_HEAD(HG_BULK_COUNT))); \
         if (hg_ret != HG_SUCCESS) { \
+            HG_LOG_ERROR("Could not transfer bulk data"); \
             goto done; \
         }
 
@@ -274,6 +280,7 @@
             hg_ret = HG_Create(HG_CLASS_DEFAULT, HG_CONTEXT_DEFAULT, \
                     NA_ADDR_DEFAULT, id, &handle); \
             if (hg_ret != HG_SUCCESS) { \
+                HG_LOG_ERROR("Could not create HG handle"); \
                 BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
                 goto done; \
             } \
@@ -295,6 +302,7 @@
             hg_ret = HG_Hl_forward_wait(handle, \
                     BOOST_PP_IF(with_input, &in_struct, NULL)); \
             if (hg_ret != HG_SUCCESS) { \
+                HG_LOG_ERROR("Could not forward call"); \
                 BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
                 goto done; \
             } \
@@ -323,6 +331,7 @@
             /* Destroy handle */ \
             hg_ret = HG_Destroy(handle); \
             if (hg_ret != HG_SUCCESS) { \
+                HG_LOG_ERROR("Could not destroy HG handle"); \
                 BOOST_PP_IF(with_ret, ret = ret_fail;, BOOST_PP_EMPTY()) \
                 goto done; \
             } \
@@ -366,6 +375,7 @@
                 BOOST_PP_IF(with_input, \
                         hg_ret = HG_Get_input(handle, &in_struct); \
                         if (hg_ret != HG_SUCCESS) { \
+                            HG_LOG_ERROR("Could not get input"); \
                             goto done; \
                         } \
                         \
@@ -422,6 +432,7 @@
                                 &out_struct, \
                                 NULL) ); \
                 if (hg_ret != HG_SUCCESS) { \
+                    HG_LOG_ERROR("Could not respond"); \
                     goto done; \
                 } \
                 \
@@ -429,6 +440,7 @@
                 BOOST_PP_IF(with_input, \
                         hg_ret = HG_Free_input(handle, &in_struct); \
                         if (hg_ret != HG_SUCCESS) { \
+                            HG_LOG_ERROR("Could not free input"); \
                             goto done; \
                         } \
                         , BOOST_PP_EMPTY()) \
@@ -436,6 +448,7 @@
                 /* Destroy handle */ \
                 hg_ret = HG_Destroy(handle); \
                 if (hg_ret != HG_SUCCESS) { \
+                    HG_LOG_ERROR("Could not destroy HG handle"); \
                     goto done; \
                 } \
                 \
diff --git a/src/mercury_macros.h b/src/mercury_macros.h
index 98f48d9..8f4e330 100644
--- a/src/mercury_macros.h
+++ b/src/mercury_macros.h
@@ -53,6 +53,7 @@ typedef struct \
     ret = BOOST_PP_CAT(hg_proc_, HG_GEN_GET_TYPE(field) \
             (proc, &struct_name->HG_GEN_GET_NAME(field))); \
     if (ret != HG_SUCCESS) { \
+      HG_LOG_ERROR("Proc error"); \
       return ret; \
     }
 
diff --git a/src/mercury_private.h b/src/mercury_private.h
index ef610d9..781d906 100644
--- a/src/mercury_private.h
+++ b/src/mercury_private.h
@@ -28,13 +28,13 @@ typedef enum {
 
 /* Completion queue entry */
 struct hg_completion_entry {
+    hg_op_type_t op_type;
     union {
         struct hg_core_op_id *hg_core_op_id;
         hg_core_handle_t hg_core_handle;
         struct hg_bulk_op_id *hg_bulk_op_id;
     } op_id;
     HG_QUEUE_ENTRY(hg_completion_entry) entry;
-    hg_op_type_t op_type;
 };
 
 #endif /* MERCURY_PRIVATE_H */
diff --git a/src/mercury_proc.c b/src/mercury_proc.c
index 95853ad..94fd0ca 100644
--- a/src/mercury_proc.c
+++ b/src/mercury_proc.c
@@ -10,11 +10,11 @@
 
 #include "mercury_proc.h"
 #include "mercury_proc_buf.h"
-#include "mercury_error.h"
 #include "mercury_mem.h"
 
 #ifdef HG_HAS_CHECKSUMS
 # include <mchecksum.h>
+# include <mchecksum_error.h>
 #endif
 
 /****************/
@@ -26,27 +26,27 @@
 /************************************/
 
 struct hg_proc_buf {
-    void *buf;              /* Pointer to allocated buffer */
-    void *buf_ptr;          /* Pointer to current position */
-    hg_size_t size;         /* Total buffer size */
-    hg_size_t size_left;    /* Available size for user */
+    void *    buf;       /* Pointer to allocated buffer */
+    void *    buf_ptr;   /* Pointer to current position */
+    hg_size_t size;      /* Total buffer size */
+    hg_size_t size_left; /* Available size for user */
     hg_bool_t is_mine;
 #ifdef HG_HAS_XDR
-    XDR xdr;
+    XDR      xdr;
 #endif
 };
 
 struct hg_proc {
+    hg_class_t *hg_class;               /* HG class */
+    hg_proc_op_t op;
     struct hg_proc_buf proc_buf;
     struct hg_proc_buf extra_buf;
-    hg_class_t *hg_class;           /* HG class */
     struct hg_proc_buf *current_buf;
 #ifdef HG_HAS_CHECKSUMS
     mchecksum_object_t checksum;    /* Checksum */
     void *checksum_hash;            /* Base checksum buf */
     size_t checksum_size;           /* Checksum size */
 #endif
-    hg_proc_op_t op;
 };
 
 /********************/
@@ -77,13 +77,18 @@ hg_proc_create(hg_class_t *hg_class, hg_proc_hash_t hash, hg_proc_t *proc)
     const char *hash_method;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(hg_class == NULL, error, ret, HG_INVALID_ARG,
-        "NULL HG class");
+    if (!hg_class) {
+        HG_LOG_ERROR("NULL HG class");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_proc = (struct hg_proc *) malloc(sizeof(struct hg_proc));
-    HG_CHECK_ERROR(hg_proc == NULL, error, ret, HG_NOMEM,
-        "Could not allocate proc");
-
+    if (!hg_proc) {
+        HG_LOG_ERROR("Could not allocate proc");
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
     memset(hg_proc, 0, sizeof(struct hg_proc));
     hg_proc->hg_class = hg_class;
 
@@ -103,34 +108,34 @@ hg_proc_create(hg_class_t *hg_class, hg_proc_hash_t hash, hg_proc_t *proc)
             break;
     }
 
-#ifdef HG_HAS_CHECKSUMS
     if (hash_method) {
-        int rc = mchecksum_init(hash_method, &hg_proc->checksum);
-        HG_CHECK_ERROR(rc < 0, error, ret, HG_CHECKSUM_ERROR,
-            "Could not initialize checksum");
+#ifdef HG_HAS_CHECKSUMS
+        int checksum_ret;
+
+        checksum_ret = mchecksum_init(hash_method, &hg_proc->checksum);
+        if (checksum_ret != MCHECKSUM_SUCCESS) {
+            HG_LOG_ERROR("Could not initialize checksum");
+            ret = HG_CHECKSUM_ERROR;
+            goto done;
+        }
 
         hg_proc->checksum_size = mchecksum_get_size(hg_proc->checksum);
         hg_proc->checksum_hash = (char *) malloc(hg_proc->checksum_size);
-        HG_CHECK_ERROR(hg_proc->checksum_hash == NULL, error, ret,
-            HG_NOMEM, "Could not allocate space for checksum hash");
-    }
+        if (!hg_proc->checksum_hash) {
+            HG_LOG_ERROR("Could not allocate space for checksum hash");
+            ret = HG_NOMEM_ERROR;
+            goto done;
+        }
 #endif
+    }
 
     /* Default to proc_buf */
     hg_proc->current_buf = &hg_proc->proc_buf;
 
     *proc = (struct hg_proc *) hg_proc;
 
-    return ret;
-
-error:
-    if (hg_proc) {
-#ifdef HG_HAS_CHECKSUMS
-        if (hash_method && hg_proc->checksum != MCHECKSUM_OBJECT_NULL) {
-            free(hg_proc->checksum_hash);
-            mchecksum_destroy(hg_proc->checksum);
-        }
-#endif
+done:
+    if (ret != HG_SUCCESS) {
         free(hg_proc);
     }
     return ret;
@@ -141,23 +146,24 @@ hg_return_t
 hg_proc_create_set(hg_class_t *hg_class, void *buf, hg_size_t buf_size,
     hg_proc_op_t op, hg_proc_hash_t hash, hg_proc_t *proc)
 {
-    hg_proc_t hg_proc = HG_PROC_NULL;
+    hg_proc_t hg_proc;
     hg_return_t ret = HG_SUCCESS;
 
     ret = hg_proc_create(hg_class, hash, &hg_proc);
-    HG_CHECK_HG_ERROR(error, ret, "Could not create proc");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not create proc");
+        goto done;
+    }
 
     ret = hg_proc_reset(hg_proc, buf, buf_size, op);
-    HG_CHECK_HG_ERROR(error, ret, "Could not reset proc");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not reset proc");
+        goto done;
+    }
 
     *proc = hg_proc;
 
-    return ret;
-
-error:
-    if (hg_proc != HG_PROC_NULL)
-        hg_proc_free(hg_proc);
-
+done:
     return ret;
 }
 
@@ -168,15 +174,19 @@ hg_proc_free(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    if (!hg_proc)
-        goto done;
+    if (!hg_proc) goto done;
 
 #ifdef HG_HAS_CHECKSUMS
     if (hg_proc->checksum != MCHECKSUM_OBJECT_NULL) {
-        int rc = mchecksum_destroy(hg_proc->checksum);
-        HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
-            "Could not destroy checksum");
+        int checksum_ret;
+
+        checksum_ret = mchecksum_destroy(hg_proc->checksum);
+        if (checksum_ret != MCHECKSUM_SUCCESS) {
+            HG_LOG_ERROR("Could not destroy checksum");
+            ret = HG_CHECKSUM_ERROR;
+        }
     }
+
     free(hg_proc->checksum_hash);
 #endif
 
@@ -198,11 +208,13 @@ hg_proc_reset(hg_proc_t proc, void *buf, hg_size_t buf_size, hg_proc_op_t op)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
-        "NULL HG proc");
-    HG_CHECK_ERROR(!buf && op != HG_FREE, done, ret, HG_INVALID_ARG,
-        "NULL buffer");
+    if (!hg_proc) goto done;
 
+    if (!buf && op != HG_FREE) {
+        HG_LOG_ERROR("NULL buffer");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
     hg_proc->op = op;
 #ifdef HG_HAS_XDR
     switch (op) {
@@ -216,8 +228,9 @@ hg_proc_reset(hg_proc_t proc, void *buf, hg_size_t buf_size, hg_proc_op_t op)
             xdrmem_create(&hg_proc->proc_buf.xdr, (char *) buf, buf_size, XDR_FREE);
             break;
         default:
-            HG_GOTO_ERROR(done, ret, HG_INVALID_PARAM,
-                "Unknown proc operation");
+            HG_LOG_ERROR("Unknown proc operation");
+            ret = HG_INVALID_PARAM;
+            goto done;
     }
 #endif
 
@@ -241,9 +254,13 @@ hg_proc_reset(hg_proc_t proc, void *buf, hg_size_t buf_size, hg_proc_op_t op)
 #ifdef HG_HAS_CHECKSUMS
     /* Reset checksum */
     if (hg_proc->checksum != MCHECKSUM_OBJECT_NULL) {
-        int rc = mchecksum_reset(hg_proc->checksum);
-        HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
-            "Could not reset checksum");
+        int checksum_ret;
+
+        checksum_ret = mchecksum_reset(hg_proc->checksum);
+        if (checksum_ret != MCHECKSUM_SUCCESS) {
+            HG_LOG_ERROR("Could not reset checksum");
+            ret = HG_CHECKSUM_ERROR;
+        }
         memset(hg_proc->checksum_hash, 0, hg_proc->checksum_size);
     }
 #endif
@@ -259,7 +276,10 @@ hg_proc_get_class(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_class_t *hg_class = NULL;
 
-    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        goto done;
+    }
 
     hg_class = hg_proc->hg_class;
 
@@ -274,7 +294,10 @@ hg_proc_get_op(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_proc_op_t proc_op = HG_ENCODE;
 
-    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        goto done;
+    }
 
     proc_op = hg_proc->op;
 
@@ -289,7 +312,10 @@ hg_proc_get_size(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_size_t size = 0;
 
-    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        goto done;
+    }
 
     size = hg_proc->proc_buf.size + hg_proc->extra_buf.size;
 
@@ -304,7 +330,10 @@ hg_proc_get_size_used(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_size_t size = 0;
 
-    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        goto done;
+    }
 
     size = hg_proc->current_buf->size - hg_proc->current_buf->size_left;
 
@@ -322,30 +351,31 @@ hg_proc_set_size(hg_proc_t proc, hg_size_t req_buf_size)
     hg_size_t page_size = (hg_size_t) hg_mem_get_page_size();
     void *new_buf = NULL;
     ptrdiff_t current_pos;
-    hg_bool_t allocated = HG_FALSE;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(proc == HG_PROC_NULL, error, ret, HG_INVALID_ARG,
-        "Proc is not initialized");
-
     /* Save current position */
     current_pos = (char *) hg_proc->current_buf->buf_ptr -
         (char *) hg_proc->current_buf->buf;
 
     /* Get one more page size buf */
     new_buf_size = ((hg_size_t)(req_buf_size / page_size) + 1) * page_size;
-    HG_CHECK_ERROR(new_buf_size <= hg_proc_get_size(proc), error, ret,
-        HG_INVALID_ARG, "Buffer is already of the size requested");
+    if (new_buf_size <= hg_proc_get_size(proc)) {
+        HG_LOG_ERROR("Buffer is already of the size requested");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
 
     /* If was not using extra buffer init extra buffer */
-    if (!hg_proc->extra_buf.buf) {
+    if (!hg_proc->extra_buf.buf)
         /* Allocate buffer */
         new_buf = hg_mem_aligned_alloc(page_size, new_buf_size);
-        allocated = HG_TRUE;
-    } else
+    else
         new_buf = realloc(hg_proc->extra_buf.buf, new_buf_size);
-    HG_CHECK_ERROR(new_buf == NULL, error, ret, HG_NOMEM,
-        "Could not allocate buffer of size %zu", new_buf_size);
+    if (!new_buf) {
+        HG_LOG_ERROR("Could not allocate buffer of size %zu", new_buf_size);
+        ret = HG_NOMEM_ERROR;
+        goto done;
+    }
 
     if (!hg_proc->extra_buf.buf) {
         /* Copy proc_buf (should be small) */
@@ -361,11 +391,7 @@ hg_proc_set_size(hg_proc_t proc, hg_size_t req_buf_size)
     hg_proc->extra_buf.size_left = hg_proc->extra_buf.size - (hg_size_t) current_pos;
     hg_proc->extra_buf.is_mine = HG_TRUE;
 
-    return ret;
-
-error:
-    if (new_buf && allocated)
-        hg_mem_aligned_free(new_buf);
+done:
     return ret;
 }
 
@@ -376,7 +402,10 @@ hg_proc_get_size_left(hg_proc_t proc)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_size_t size = 0;
 
-    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        goto done;
+    }
 
     size = hg_proc->current_buf->size_left;
 
@@ -394,7 +423,10 @@ hg_proc_save_ptr(hg_proc_t proc, hg_size_t data_size)
     unsigned int cur_pos;
 #endif
 
-    HG_CHECK_ERROR_NORET(proc == HG_PROC_NULL, done, "Proc is not initialized");
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        goto done;
+    }
 
     /* If not enough space allocate extra space if encoding or
      * just get extra buffer if decoding */
@@ -438,7 +470,10 @@ hg_proc_restore_ptr(hg_proc_t proc, void *data, hg_size_t data_size)
 
 #ifdef HG_HAS_CHECKSUMS
     ret = hg_proc_checksum_update(proc, data, data_size);
-    HG_CHECK_HG_ERROR(done, ret, "Could not update checksum");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not update checksum");
+        goto done;
+    }
 #else
     /* Silent warning */
     (void)proc;
@@ -476,10 +511,10 @@ hg_proc_set_extra_buf_is_mine(hg_proc_t proc, hg_bool_t theirs)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
-        "Proc is not initialized");
-    HG_CHECK_ERROR(hg_proc->extra_buf.buf == NULL, done, ret, HG_INVALID_ARG,
-        "Extra buf is not set");
+    if (!hg_proc->extra_buf.buf) {
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     hg_proc->extra_buf.is_mine = (hg_bool_t) (!theirs);
 
@@ -493,18 +528,24 @@ hg_proc_flush(hg_proc_t proc)
 {
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
 #ifdef HG_HAS_CHECKSUMS
-    int rc;
+    int checksum_ret;
 #endif
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
-        "Proc is not initialized");
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
 #ifdef HG_HAS_CHECKSUMS
-    rc = mchecksum_get(hg_proc->checksum, hg_proc->checksum_hash,
+    checksum_ret = mchecksum_get(hg_proc->checksum, hg_proc->checksum_hash,
         hg_proc->checksum_size, MCHECKSUM_FINALIZE);
-    HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
-        "Could not get checksum");
+    if (checksum_ret != MCHECKSUM_SUCCESS) {
+        HG_LOG_ERROR("Could not get checksum");
+        ret = HG_CHECKSUM_ERROR;
+        goto done;
+    }
 #endif
 
 done:
@@ -518,26 +559,32 @@ hg_proc_memcpy(hg_proc_t proc, void *data, hg_size_t data_size)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
-        "Proc is not initialized");
-
-    if (hg_proc->op == HG_FREE)
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        ret = HG_INVALID_PARAM;
         goto done;
+    }
+
+    if (hg_proc->op == HG_FREE) goto done;
 
     /* If not enough space allocate extra space if encoding or
      * just get extra buffer if decoding */
     if (hg_proc->current_buf->size_left < data_size)
         hg_proc_set_size(proc, hg_proc->proc_buf.size +
-            hg_proc->extra_buf.size + data_size);
+                hg_proc->extra_buf.size + data_size);
 
     /* Process data */
-    hg_proc->current_buf->buf_ptr = hg_proc_buf_memcpy(
-        hg_proc->current_buf->buf_ptr, data, data_size, hg_proc->op);
+    hg_proc->current_buf->buf_ptr =
+            hg_proc_buf_memcpy(hg_proc->current_buf->buf_ptr, data, data_size,
+                    hg_proc->op);
     hg_proc->current_buf->size_left -= data_size;
 
 #ifdef HG_HAS_CHECKSUMS
     ret = hg_proc_checksum_update(proc, data, data_size);
-    HG_CHECK_HG_ERROR(done, ret, "Could not update checksum");
+    if (ret != HG_SUCCESS) {
+        HG_LOG_ERROR("Could not update checksum");
+        goto done;
+    }
 #endif
 
 done:
@@ -550,16 +597,22 @@ static HG_INLINE hg_return_t
 hg_proc_checksum_update(hg_proc_t proc, void *data, hg_size_t data_size)
 {
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
+    int checksum_ret;
     hg_return_t ret = HG_SUCCESS;
-    int rc;
 
-    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
-        "Proc is not initialized");
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     /* Update checksum */
-    rc = mchecksum_update(hg_proc->checksum, data, data_size);
-    HG_CHECK_ERROR(rc < 0, done, ret, HG_CHECKSUM_ERROR,
-        "Could not update checksum");
+    checksum_ret = mchecksum_update(hg_proc->checksum, data, data_size);
+    if (checksum_ret != MCHECKSUM_SUCCESS) {
+        HG_LOG_ERROR("Could not update checksum");
+        ret = HG_CHECKSUM_ERROR;
+        goto done;
+    }
 
 done:
     return ret;
@@ -572,12 +625,23 @@ hg_proc_checksum_get(hg_proc_t proc, void *hash, hg_size_t hash_size)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
-        "Proc is not initialized");
-    HG_CHECK_ERROR(hash == NULL, done, ret, HG_INVALID_ARG,
-       "NULL hash pointer");
-    HG_CHECK_ERROR(hash_size < hg_proc->checksum_size, done, ret,
-        HG_INVALID_ARG, "Hash size passed is too small");
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (!hash) {
+        HG_LOG_ERROR("NULL hash pointer");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (hash_size < hg_proc->checksum_size) {
+        HG_LOG_ERROR("Hash size passed is too small");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
 
     memcpy(hash, hg_proc->checksum_hash, hg_proc->checksum_size);
 
@@ -592,10 +656,17 @@ hg_proc_checksum_verify(hg_proc_t proc, const void *hash, hg_size_t hash_size)
     struct hg_proc *hg_proc = (struct hg_proc *) proc;
     hg_return_t ret = HG_SUCCESS;
 
-    HG_CHECK_ERROR(proc == HG_PROC_NULL, done, ret, HG_INVALID_ARG,
-        "Proc is not initialized");
-    HG_CHECK_ERROR(hash_size < hg_proc->checksum_size, done, ret,
-        HG_INVALID_ARG, "Hash size passed is too small");
+    if (!hg_proc) {
+        HG_LOG_ERROR("Proc is not initialized");
+        ret = HG_INVALID_PARAM;
+        goto done;
+    }
+
+    if (hash_size < hg_proc->checksum_size) {
+        HG_LOG_ERROR("Hash size is not valid");
+        ret = HG_SIZE_ERROR;
+        goto done;
+    }
 
     /* Verify checksums */
     if (memcmp(hash, hg_proc->checksum_hash, hg_proc->checksum_size) != 0) {
diff --git a/src/mercury_proc.h b/src/mercury_proc.h
index 7b04069..5553f7d 100644
--- a/src/mercury_proc.h
+++ b/src/mercury_proc.h
@@ -12,6 +12,7 @@
 #define MERCURY_PROC_H
 
 #include "mercury_types.h"
+#include "mercury_error.h"
 
 #include <stdlib.h>
 #include <string.h>
@@ -71,7 +72,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_create(
         hg_class_t *hg_class,
         hg_proc_hash_t hash,
@@ -93,7 +94,7 @@ hg_proc_create(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_create_set(
         hg_class_t *hg_class,
         void *buf,
@@ -110,7 +111,7 @@ hg_proc_create_set(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_free(
         hg_proc_t proc
         );
@@ -126,7 +127,7 @@ hg_proc_free(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_reset(
         hg_proc_t proc,
         void *buf,
@@ -141,7 +142,7 @@ hg_proc_reset(
  *
  * \return HG class
  */
-HG_PUBLIC hg_class_t *
+HG_EXPORT hg_class_t *
 hg_proc_get_class(
         hg_proc_t proc
         );
@@ -153,7 +154,7 @@ hg_proc_get_class(
  *
  * \return Operation type
  */
-HG_PUBLIC hg_proc_op_t
+HG_EXPORT hg_proc_op_t
 hg_proc_get_op(
         hg_proc_t proc
         );
@@ -165,7 +166,7 @@ hg_proc_get_op(
  *
  * \return Non-negative size value
  */
-HG_PUBLIC hg_size_t
+HG_EXPORT hg_size_t
 hg_proc_get_size(
         hg_proc_t proc
         );
@@ -177,7 +178,7 @@ hg_proc_get_size(
  *
  * \return Non-negative size value
  */
-HG_PUBLIC hg_size_t
+HG_EXPORT hg_size_t
 hg_proc_get_size_used(
         hg_proc_t proc
         );
@@ -192,7 +193,7 @@ hg_proc_get_size_used(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_set_size(
         hg_proc_t proc,
         hg_size_t buf_size
@@ -205,7 +206,7 @@ hg_proc_set_size(
  *
  * \return Non-negative size value
  */
-HG_PUBLIC hg_size_t
+HG_EXPORT hg_size_t
 hg_proc_get_size_left(
         hg_proc_t proc
         );
@@ -218,7 +219,7 @@ hg_proc_get_size_left(
  *
  * \return Buffer pointer
  */
-HG_PUBLIC void *
+HG_EXPORT void *
 hg_proc_save_ptr(
         hg_proc_t proc,
         hg_size_t data_size
@@ -232,7 +233,7 @@ hg_proc_save_ptr(
  *
  * \return XDR stream pointer
  */
-HG_PUBLIC XDR *
+HG_EXPORT XDR *
 hg_proc_get_xdr_ptr(
         hg_proc_t proc
         );
@@ -247,7 +248,7 @@ hg_proc_get_xdr_ptr(
  *
  * \return Buffer pointer
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_restore_ptr(
         hg_proc_t proc,
         void *data,
@@ -261,7 +262,7 @@ hg_proc_restore_ptr(
  *
  * \return Pointer to buffer or NULL if no extra buffer has been used
  */
-HG_PUBLIC void *
+HG_EXPORT void *
 hg_proc_get_extra_buf(
         hg_proc_t proc
         );
@@ -273,7 +274,7 @@ hg_proc_get_extra_buf(
  *
  * \return Size of buffer or 0 if no extra buffer has been used
  */
-HG_PUBLIC hg_size_t
+HG_EXPORT hg_size_t
 hg_proc_get_extra_size(
         hg_proc_t proc
         );
@@ -286,7 +287,7 @@ hg_proc_get_extra_size(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_set_extra_buf_is_mine(
         hg_proc_t proc,
         hg_bool_t mine
@@ -300,7 +301,7 @@ hg_proc_set_extra_buf_is_mine(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_flush(
         hg_proc_t proc
         );
@@ -315,7 +316,7 @@ hg_proc_flush(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_memcpy(
         hg_proc_t proc,
         void *data,
@@ -334,7 +335,7 @@ hg_proc_memcpy(
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_checksum_get(
         hg_proc_t proc,
         void *hash,
@@ -352,7 +353,7 @@ hg_proc_checksum_get(
  *
  * \return HG_SUCCESS if matches or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_proc_checksum_verify(
         hg_proc_t proc,
         const void *hash,
diff --git a/src/mercury_proc_bulk.h b/src/mercury_proc_bulk.h
index 488c7c9..fccbe9c 100644
--- a/src/mercury_proc_bulk.h
+++ b/src/mercury_proc_bulk.h
@@ -56,18 +56,21 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
             }
             /* Encode size */
             ret = hg_proc_uint64_t(proc, &buf_size);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Proc error");
                 return ret;
+            }
             if (!buf_size)
                 break;
             if (cached_ptr)
                 hg_proc_raw(proc, cached_ptr, buf_size);
             else {
                 buf = hg_proc_save_ptr(proc, buf_size);
-                ret = HG_Bulk_serialize(buf, buf_size, request_eager,
-                    *bulk_ptr);
-                if (ret != HG_SUCCESS)
+                ret = HG_Bulk_serialize(buf, buf_size, request_eager, *bulk_ptr);
+                if (ret != HG_SUCCESS) {
+                    HG_LOG_ERROR("Could not serialize bulk handle");
                     return ret;
+                }
                 hg_proc_restore_ptr(proc, buf, buf_size);
             }
             break;
@@ -77,8 +80,10 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
 
             /* Decode size */
             ret = hg_proc_uint64_t(proc, &buf_size);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Proc error");
                 return ret;
+            }
             if (!buf_size) {
                 /* If buf_size is 0, define handle to HG_BULK_NULL */
                 *bulk_ptr = HG_BULK_NULL;
@@ -87,12 +92,16 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
 
             buf = hg_proc_save_ptr(proc, buf_size);
             ret = HG_Bulk_deserialize(hg_class, bulk_ptr, buf, buf_size);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not deserialize bulk handle");
                 return ret;
+            }
             /* Cache serialize ptr to buf */
             ret = HG_Bulk_set_serialize_cached_ptr(*bulk_ptr, buf, buf_size);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not set serialize cached ptr");
                 return ret;
+            }
             hg_proc_restore_ptr(proc, buf, buf_size);
             break;
         }
@@ -104,13 +113,16 @@ hg_proc_hg_bulk_t(hg_proc_t proc, void *data)
             }
             /* Set serialize ptr to NULL */
             ret = HG_Bulk_set_serialize_cached_ptr(*bulk_ptr, NULL, 0);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not set serialize cached ptr");
                 return ret;
-
+            }
             /* Decrement refcount on bulk handle */
             ret = HG_Bulk_free(*bulk_ptr);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not free bulk handle");
                 return ret;
+            }
             *bulk_ptr = HG_BULK_NULL;
             break;
         default:
diff --git a/src/mercury_types.h b/src/mercury_types.h
index 6e7443c..d853875 100644
--- a/src/mercury_types.h
+++ b/src/mercury_types.h
@@ -30,8 +30,8 @@ struct hg_info {
     hg_class_t *hg_class;       /* HG class */
     hg_context_t *context;      /* HG context */
     hg_addr_t addr;             /* HG address at target/origin */
-    hg_id_t id;                 /* RPC ID */
     hg_uint8_t context_id;      /* Context ID at target/origin */
+    hg_id_t id;                 /* RPC ID */
 };
 
 /**
@@ -62,15 +62,15 @@ struct hg_cb_info_bulk {
 };
 
 struct hg_cb_info {
+    void *arg;                  /* User data */
+    hg_return_t ret;            /* Return value */
+    hg_cb_type_t type;          /* Callback type */
     union {                     /* Union of callback info structures */
         struct hg_cb_info_lookup lookup;
         struct hg_cb_info_forward forward;
         struct hg_cb_info_respond respond;
         struct hg_cb_info_bulk bulk;
     } info;
-    void *arg;                  /* User data */
-    hg_cb_type_t type;          /* Callback type */
-    hg_return_t ret;            /* Return value */
 };
 
 /* RPC / HG callbacks */
diff --git a/src/na/na.c b/src/na/na.c
index 9cb8ecd..869cdb0 100644
--- a/src/na/na.c
+++ b/src/na/na.c
@@ -19,6 +19,9 @@
 /****************/
 /* Local Macros */
 /****************/
+/* Convert value to string */
+#define NA_ERROR_STRING_MACRO(def, value, string) \
+  if (value == def) string = #def
 
 #define NA_CLASS_DELIMITER "+" /* e.g. "class+protocol" */
 
@@ -43,22 +46,18 @@ struct na_private_class {
 /* Private context / do not expose private members to plugins */
 struct na_private_context {
     struct na_context context;                  /* Must remain as first field */
-    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
+    na_class_t *na_class;                       /* Pointer to NA class */
 #ifdef NA_HAS_MULTI_PROGRESS
+    hg_thread_mutex_t progress_mutex;           /* Progress mutex */
     hg_thread_cond_t  progress_cond;            /* Progress cond */
+    hg_atomic_int32_t progressing;              /* Progressing count */
 #endif
+    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
     hg_thread_mutex_t completion_queue_mutex;   /* Completion queue mutex */
-#ifdef NA_HAS_MULTI_PROGRESS
-    hg_thread_mutex_t progress_mutex;           /* Progress mutex */
-#endif
+    hg_thread_cond_t  completion_queue_cond;    /* Completion queue cond */
     HG_QUEUE_HEAD(na_cb_completion_data) backfill_queue; /* Backfill completion queue */
-    struct hg_atomic_queue *completion_queue;   /* Default completion queue */
-    na_class_t *na_class;                       /* Pointer to NA class */
     hg_atomic_int32_t backfill_queue_count;     /* Number of entries in backfill queue */
     hg_atomic_int32_t trigger_waiting;          /* Polling/waiting in trigger */
-#ifdef NA_HAS_MULTI_PROGRESS
-    hg_atomic_int32_t progressing;              /* Progressing count */
-#endif
 };
 
 /********************/
@@ -78,40 +77,35 @@ na_info_free(
     struct na_info *na_info
     );
 
+#ifdef NA_DEBUG
+/* Print NA info */
+static void
+na_info_print(struct na_info *na_info);
+#endif
+
 /*******************/
 /* Local Variables */
 /*******************/
 
-/* NA plugin class table */
-static const struct na_class_ops *const na_class_table[] = {
+static const struct na_class_ops *na_class_table[] = {
 #ifdef NA_HAS_SM
-    &NA_PLUGIN_OPS(sm), /* Keep NA SM first for protocol selection */
-#endif
-#ifdef NA_HAS_OFI
-    &NA_PLUGIN_OPS(ofi),
+    &na_sm_class_ops_g, /* Keep NA SM first for protocol selection */
 #endif
 #ifdef NA_HAS_BMI
-    &NA_PLUGIN_OPS(bmi),
+    &na_bmi_class_ops_g,
 #endif
 #ifdef NA_HAS_MPI
-    &NA_PLUGIN_OPS(mpi),
+    &na_mpi_class_ops_g,
 #endif
 #ifdef NA_HAS_CCI
-    &NA_PLUGIN_OPS(cci),
+    &na_cci_class_ops_g,
+#endif
+#ifdef NA_HAS_OFI
+    &na_ofi_class_ops_g,
 #endif
     NULL
 };
 
-/* Return code string table */
-#define X(a) #a,
-static const char *const na_return_name[] = { NA_RETURN_VALUES };
-#undef X
-
-/* Default error log mask */
-#ifdef NA_HAS_VERBOSE_ERROR
-unsigned int NA_LOG_MASK = HG_LOG_TYPE_ERROR | HG_LOG_TYPE_WARNING;
-#endif
-
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_info_parse(const char *info_string, struct na_info **na_info_ptr)
@@ -121,7 +115,7 @@ na_info_parse(const char *info_string, struct na_info **na_info_ptr)
     na_return_t ret = NA_SUCCESS;
 
     na_info = (struct na_info *) malloc(sizeof(struct na_info));
-    NA_CHECK_ERROR(na_info == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_info == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate NA info struct");
 
     /* Initialize NA info */
@@ -131,7 +125,7 @@ na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 
     /* Copy info string and work from that */
     input_string = strdup(info_string);
-    NA_CHECK_ERROR(input_string == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(input_string == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not duplicate host string");
 
     /**
@@ -150,18 +144,18 @@ na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 
         /* Get NA class name */
         na_info->class_name = strdup(token);
-        NA_CHECK_ERROR(na_info->class_name == NULL, error, ret, NA_NOMEM,
+        NA_CHECK_ERROR(na_info->class_name == NULL, error, ret, NA_NOMEM_ERROR,
             "Could not duplicate NA info class name");
 
         /* Get protocol name */
         na_info->protocol_name = strdup(_locator);
         NA_CHECK_ERROR(na_info->protocol_name == NULL, error, ret,
-            NA_NOMEM, "Could not duplicate NA info protocol name");
+            NA_NOMEM_ERROR, "Could not duplicate NA info protocol name");
     } else {
         /* Get protocol name */
         na_info->protocol_name = strdup(token);
         NA_CHECK_ERROR(na_info->protocol_name == NULL, error, ret,
-            NA_NOMEM, "Could not duplicate NA info protocol name");
+            NA_NOMEM_ERROR, "Could not duplicate NA info protocol name");
     }
 
     /* Is the host string empty? */
@@ -170,14 +164,14 @@ na_info_parse(const char *info_string, struct na_info **na_info_ptr)
 
     /* Format sanity check ("://") */
     NA_CHECK_ERROR(strncmp(locator, "//", 2) != 0, error, ret,
-        NA_PROTONOSUPPORT, "Bad address string format");
+        NA_PROTOCOL_ERROR, "Bad address string format");
 
     /* :// followed by empty hostname is allowed, explicitly check here */
     if (locator[2] == '\0')
         goto done;
 
     na_info->host_name = strdup(locator + 2);
-    NA_CHECK_ERROR(na_info->host_name == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_info->host_name == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not duplicate NA info host name");
 
 done:
@@ -205,6 +199,19 @@ na_info_free(struct na_info *na_info)
     free(na_info);
 }
 
+/*---------------------------------------------------------------------------*/
+#ifdef NA_DEBUG
+static void
+na_info_print(struct na_info *na_info)
+{
+    if (!na_info) return;
+
+    printf("Class: %s\n", na_info->class_name);
+    printf("Protocol: %s\n", na_info->protocol_name);
+    printf("Hostname: %s\n", na_info->host_name);
+}
+#endif
+
 /*---------------------------------------------------------------------------*/
 na_class_t *
 NA_Initialize(const char *info_string, na_bool_t listen)
@@ -223,24 +230,14 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
     const unsigned int plugin_count =
         sizeof(na_class_table) / sizeof(na_class_table[0]) - 1;
     na_bool_t plugin_found = NA_FALSE;
-#ifdef NA_HAS_VERBOSE_ERROR
-    const char *log_level = NULL;
-#endif
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(info_string == NULL, error, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(info_string == NULL, error, ret, NA_INVALID_PARAM,
         "NULL info string");
 
-#ifdef NA_HAS_VERBOSE_ERROR
-    /* Set log level */
-    log_level = getenv("HG_NA_LOG_LEVEL");
-    if (log_level && (strcmp(log_level, "debug") == 0))
-        NA_LOG_MASK |= HG_LOG_TYPE_DEBUG;
-#endif
-
     na_private_class = (struct na_private_class *) malloc(
         sizeof(struct na_private_class));
-    NA_CHECK_ERROR(na_private_class == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_private_class == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate class");
     memset(na_private_class, 0, sizeof(struct na_private_class));
 
@@ -251,18 +248,18 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
     if (na_init_info)
         na_private_class->na_class.progress_mode = na_init_info->progress_mode;
 
-    /* Print debug info */
-    NA_LOG_DEBUG("Class: %s, Protocol: %s, Hostname: %s" , na_info->class_name,
-        na_info->protocol_name, na_info->host_name);
+#ifdef NA_DEBUG
+    na_info_print(na_info);
+#endif
 
     for (plugin_index = 0; plugin_index < plugin_count; plugin_index++) {
         na_bool_t verified = NA_FALSE;
 
         NA_CHECK_ERROR(na_class_table[plugin_index]->class_name == NULL, error,
-            ret, NA_PROTONOSUPPORT, "class name is not defined");
+            ret, NA_PROTOCOL_ERROR, "class name is not defined");
 
         NA_CHECK_ERROR(na_class_table[plugin_index]->check_protocol == NULL,
-            error, ret, NA_OPNOTSUPPORTED,
+            error, ret, NA_PROTOCOL_ERROR,
             "check_protocol plugin callback is not defined");
 
         /* Skip check protocol if class name does not match */
@@ -277,7 +274,7 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
             na_info->protocol_name);
         if (!verified) {
             NA_CHECK_ERROR(na_info->class_name, error, ret,
-                NA_PROTONOSUPPORT,
+                NA_PROTOCOL_ERROR,
                 "Specified class name does not support requested protocol");
             continue;
         }
@@ -289,7 +286,7 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
             na_info->class_name = strdup(
                 na_class_table[plugin_index]->class_name);
             NA_CHECK_ERROR(na_info->class_name == NULL, error, ret,
-                NA_NOMEM, "Unable to dup class name string");
+                NA_NOMEM_ERROR, "Unable to dup class name string");
         }
 
         /* All checks have passed */
@@ -297,15 +294,15 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
         break;
     }
 
-    NA_CHECK_ERROR(!plugin_found, error, ret, NA_PROTONOSUPPORT,
+    NA_CHECK_ERROR(!plugin_found, error, ret, NA_PROTOCOL_ERROR,
         "No suitable plugin found that matches %s", info_string);
 
     na_private_class->na_class.ops = na_class_table[plugin_index];
     NA_CHECK_ERROR(na_private_class->na_class.ops == NULL, error, ret,
-        NA_INVALID_ARG, "NULL NA class ops");
+        NA_PROTOCOL_ERROR, "NULL NA class ops");
 
     NA_CHECK_ERROR(na_private_class->na_class.ops->initialize == NULL, error,
-        ret, NA_OPNOTSUPPORTED, "initialize plugin callback is not defined");
+        ret, NA_PROTOCOL_ERROR, "initialize plugin callback is not defined");
 
     ret = na_private_class->na_class.ops->initialize(
         &na_private_class->na_class, na_info, listen);
@@ -313,7 +310,7 @@ NA_Initialize_opt(const char *info_string, na_bool_t listen,
 
     na_private_class->na_class.protocol_name = strdup(na_info->protocol_name);
     NA_CHECK_ERROR(na_private_class->na_class.protocol_name == NULL, error, ret,
-        NA_NOMEM, "Could not duplicate protocol name");
+        NA_NOMEM_ERROR, "Could not duplicate protocol name");
 
     na_private_class->na_class.listen = listen;
 
@@ -341,10 +338,10 @@ NA_Finalize(na_class_t *na_class)
     if (!na_private_class)
         goto done;
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->finalize == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "finalize plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "finalize plugin callback is not defined");
 
     ret = na_class->ops->finalize(&na_private_class->na_class);
 
@@ -385,16 +382,16 @@ NA_Context_create_id(na_class_t *na_class, na_uint8_t id)
     na_return_t ret = NA_SUCCESS;
     struct na_private_context *na_private_context = NULL;
 
-    NA_CHECK_ERROR(na_class == NULL, error, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, error, ret, NA_INVALID_PARAM,
         "NULL NA class");
 
     na_private_context = (struct na_private_context *) malloc(
         sizeof(struct na_private_context));
-    NA_CHECK_ERROR(na_private_context == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_private_context == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate context");
     na_private_context->na_class = na_class;
 
-    NA_CHECK_ERROR(na_class->ops == NULL, error, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, error, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (na_class->ops->context_create) {
         ret = na_class->ops->context_create(na_class,
@@ -406,7 +403,7 @@ NA_Context_create_id(na_class_t *na_class, na_uint8_t id)
     na_private_context->completion_queue =
         hg_atomic_queue_alloc(NA_ATOMIC_QUEUE_SIZE);
     NA_CHECK_ERROR(na_private_context->completion_queue == NULL, error, ret,
-        NA_NOMEM, "Could not allocate queue");
+        NA_NOMEM_ERROR, "Could not allocate queue");
     HG_QUEUE_INIT(&na_private_context->backfill_queue);
     hg_atomic_init32(&na_private_context->backfill_queue_count, 0);
 
@@ -438,14 +435,14 @@ NA_Context_destroy(na_class_t *na_class, na_context_t *context)
     na_bool_t empty;
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
     if (!context)
         goto done;
 
     /* Check that completion queue is empty now */
     empty = hg_atomic_queue_is_empty(na_private_context->completion_queue);
-    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_BUSY,
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
         "Completion queue should be empty");
     hg_atomic_queue_free(na_private_context->completion_queue);
 
@@ -453,7 +450,7 @@ NA_Context_destroy(na_class_t *na_class, na_context_t *context)
     hg_thread_mutex_lock(&na_private_context->completion_queue_mutex);
     empty = HG_QUEUE_IS_EMPTY(&na_private_context->backfill_queue);
     hg_thread_mutex_unlock(&na_private_context->completion_queue_mutex);
-    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_BUSY,
+    NA_CHECK_ERROR(empty == NA_FALSE, done, ret, NA_PROTOCOL_ERROR,
         "Completion queue should be empty");
 
     /* Destroy completion queue mutex/cond */
@@ -461,7 +458,7 @@ NA_Context_destroy(na_class_t *na_class, na_context_t *context)
     hg_thread_cond_destroy(&na_private_context->completion_queue_cond);
 
     /* Destroy NA plugin context */
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (na_class->ops->context_destroy) {
         ret = na_class->ops->context_destroy(na_class,
@@ -489,8 +486,10 @@ NA_Op_create(na_class_t *na_class)
 
     NA_CHECK_ERROR_NORET(na_class == NULL, done, "NULL NA class");
     NA_CHECK_ERROR_NORET(na_class->ops == NULL, done, "NULL NA class ops");
-    NA_CHECK_ERROR_NORET(na_class->ops->op_create == NULL, done,
-        "op_create plugin callback is not defined");
+
+    if (!na_class->ops->op_create)
+        /* Not provided */
+        goto done;
 
     ret = na_class->ops->op_create(na_class);
 
@@ -504,17 +503,19 @@ NA_Op_destroy(na_class_t *na_class, na_op_id_t op_id)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
 
     if (op_id == NA_OP_ID_NULL)
         /* Nothing to do */
         goto done;
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
-    NA_CHECK_ERROR(na_class->ops->op_destroy == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "op_destroy plugin callback is not defined");
+
+    if (!na_class->ops->op_destroy)
+        /* Not provided */
+        goto done;
 
     ret = na_class->ops->op_destroy(na_class, op_id);
 
@@ -531,21 +532,21 @@ NA_Addr_lookup(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     char *short_name = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_PARAM,
         "NULL context");
-    NA_CHECK_ERROR(name == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(name == NULL, done, ret, NA_INVALID_PARAM,
         "Lookup name is NULL");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->addr_lookup == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "addr_lookup plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "addr_lookup plugin callback is not defined");
 
     /* Copy name and work from that */
     name_string = strdup(name);
-    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM,
+    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM_ERROR,
         "Could not duplicate string");
 
     /* If NA class name was specified, we can remove the name here:
@@ -571,14 +572,14 @@ NA_Addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr)
     char *short_name = NULL;
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(name == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(name == NULL, done, ret, NA_INVALID_PARAM,
         "Lookup name is NULL");
-    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_PARAM,
         "NULL pointer to na_addr_t");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (!na_class->ops->addr_lookup2)
         /* Until we switch to new lookup, exit if no callback */
@@ -588,7 +589,7 @@ NA_Addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr)
 
     /* Copy name and work from that */
     name_string = strdup(name);
-    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM,
+    NA_CHECK_ERROR(name_string == NULL, done, ret, NA_NOMEM_ERROR,
         "Could not duplicate string");
 
     /* If NA class name was specified, we can remove the name here:
@@ -611,15 +612,15 @@ NA_Addr_self(na_class_t *na_class, na_addr_t *addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_PARAM,
         "NULL pointer to na_addr_t");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->addr_self == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "addr_self plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "addr_self plugin callback is not defined");
 
     ret = na_class->ops->addr_self(na_class, addr);
 
@@ -633,17 +634,17 @@ NA_Addr_dup(na_class_t *na_class, na_addr_t addr, na_addr_t *new_addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_PARAM,
         "NULL addr");
-    NA_CHECK_ERROR(new_addr == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(new_addr == NULL, done, ret, NA_INVALID_PARAM,
         "NULL pointer to NA addr");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->addr_dup == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "addr_dup plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "addr_dup plugin callback is not defined");
 
     ret = na_class->ops->addr_dup(na_class, addr, new_addr);
 
@@ -657,16 +658,16 @@ NA_Addr_free(na_class_t *na_class, na_addr_t addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
     if (addr == NA_ADDR_NULL)
         /* Nothing to do */
         goto done;
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->addr_free == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "addr_free plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "addr_free plugin callback is not defined");
 
     ret = na_class->ops->addr_free(na_class, addr);
 
@@ -680,13 +681,13 @@ NA_Addr_set_remove(na_class_t *na_class, na_addr_t addr)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
     if (addr == NA_ADDR_NULL)
         /* Nothing to do */
         goto done;
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (na_class->ops->addr_set_remove)
         ret = na_class->ops->addr_set_remove(na_class, addr);
@@ -704,18 +705,18 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
     na_size_t buf_size_used = 0, plugin_buf_size = 0;
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
     /* buf can be NULL */
-    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
         "NULL buffer size");
-    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_PARAM,
         "NULL addr");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->addr_to_string == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "addr_to_string plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "addr_to_string plugin callback is not defined");
 
     /* Automatically prepend string by plugin name with class delimiter,
      * except for MPI plugin (special case, because of generated string) */
@@ -726,7 +727,7 @@ NA_Addr_to_string(na_class_t *na_class, char *buf, na_size_t *buf_size,
         buf_size_used = strlen(na_class->ops->class_name)
             + strlen(NA_CLASS_DELIMITER);
         if (buf_ptr) {
-            NA_CHECK_ERROR(buf_size_used >= *buf_size, done, ret, NA_OVERFLOW,
+            NA_CHECK_ERROR(buf_size_used >= *buf_size, done, ret, NA_SIZE_ERROR,
                 "Buffer size too small to copy addr");
             strcpy(buf_ptr, na_class->ops->class_name);
             strcat(buf_ptr, NA_CLASS_DELIMITER);
@@ -752,19 +753,19 @@ NA_Addr_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
         "NULL buffer");
-    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
         "NULL buffer size");
-    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(addr == NA_ADDR_NULL, done, ret, NA_INVALID_PARAM,
         "NULL addr");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->addr_serialize == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "addr_serialize plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "addr_serialize plugin callback is not defined");
 
     ret = na_class->ops->addr_serialize(na_class, buf, buf_size, addr);
 
@@ -779,19 +780,19 @@ NA_Addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(addr == NULL, done, ret, NA_INVALID_PARAM,
         "NULL pointer to addr");
-    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
         "NULL buffer");
-    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
         "NULL buffer size");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->addr_deserialize == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "addr_deserialize plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "addr_deserialize plugin callback is not defined");
 
     ret = na_class->ops->addr_deserialize(na_class, addr, buf, buf_size);
 
@@ -833,17 +834,17 @@ NA_Msg_buf_free(na_class_t *na_class, void *buf, void *plugin_data)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
         "NULL buffer");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (na_class->ops->msg_buf_free)
         ret = na_class->ops->msg_buf_free(na_class, buf, plugin_data);
     else {
-        NA_CHECK_ERROR(plugin_data != (void *)1, done, ret, NA_FAULT,
+        NA_CHECK_ERROR(plugin_data != (void *)1, done, ret, NA_PROTOCOL_ERROR,
             "Invalid plugin data value");
         hg_mem_aligned_free(buf);
     }
@@ -858,14 +859,14 @@ NA_Msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
         "NULL buffer");
-    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
         "NULL buffer size");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (na_class->ops->msg_init_unexpected)
         ret = na_class->ops->msg_init_unexpected(na_class, buf, buf_size);
@@ -880,14 +881,14 @@ NA_Msg_init_expected(na_class_t *na_class, void *buf, na_size_t buf_size)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
         "NULL buffer");
-    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
         "NULL buffer size");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (na_class->ops->msg_init_expected)
         ret = na_class->ops->msg_init_expected(na_class, buf, buf_size);
@@ -903,17 +904,17 @@ NA_Mem_handle_create(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
         "NULL buffer");
-    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
         "NULL buffer size");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->mem_handle_create == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "mem_handle_create plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "mem_handle_create plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_create(na_class, buf, buf_size, flags,
         mem_handle);
@@ -930,17 +931,17 @@ NA_Mem_handle_create_segments(na_class_t *na_class, struct na_segment *segments,
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(segments == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(segments == NULL, done, ret, NA_INVALID_PARAM,
         "NULL pointer to segments");
-    NA_CHECK_ERROR(segment_count == 0, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(segment_count == 0, done, ret, NA_INVALID_PARAM,
         "NULL segment count");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->mem_handle_create_segments == NULL, done, ret,
-        NA_OPNOTSUPPORTED,
+        NA_PROTOCOL_ERROR,
         "mem_handle_create_segments plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_create_segments(na_class, segments,
@@ -956,15 +957,15 @@ NA_Mem_handle_free(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
     NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
-        NA_INVALID_ARG, "NULL memory handle");
+        NA_INVALID_PARAM, "NULL memory handle");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->mem_handle_free == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "mem_handle_free plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "mem_handle_free plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_free(na_class, mem_handle);
 
@@ -978,12 +979,12 @@ NA_Mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
     NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
-        NA_INVALID_ARG, "NULL memory handle");
+        NA_INVALID_PARAM, "NULL memory handle");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (na_class->ops->mem_register)
         /* Optional */
@@ -999,12 +1000,12 @@ NA_Mem_deregister(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
     NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
-        NA_INVALID_ARG, "NULL memory handle");
+        NA_INVALID_PARAM, "NULL memory handle");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (na_class->ops->mem_deregister)
         /* Optional */
@@ -1020,12 +1021,12 @@ NA_Mem_publish(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
     NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
-        NA_INVALID_ARG, "NULL memory handle");
+        NA_INVALID_PARAM, "NULL memory handle");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (na_class->ops->mem_publish)
         /* Optional */
@@ -1041,12 +1042,12 @@ NA_Mem_unpublish(na_class_t *na_class, na_mem_handle_t mem_handle)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
     NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
-        NA_INVALID_ARG, "NULL memory handle");
+        NA_INVALID_PARAM, "NULL memory handle");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     if (na_class->ops->mem_unpublish)
         /* Optional */
@@ -1063,19 +1064,19 @@ NA_Mem_handle_serialize(na_class_t *na_class, void *buf, na_size_t buf_size,
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
         "NULL buffer");
-    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
         "NULL buffer size");
     NA_CHECK_ERROR(mem_handle == NA_MEM_HANDLE_NULL, done, ret,
-        NA_INVALID_ARG, "NULL memory handle");
+        NA_INVALID_PARAM, "NULL memory handle");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->mem_handle_serialize == NULL, done, ret,
-        NA_OPNOTSUPPORTED,
+        NA_PROTOCOL_ERROR,
         "mem_handle_serialize plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_serialize(na_class, buf, buf_size,
@@ -1092,19 +1093,19 @@ NA_Mem_handle_deserialize(na_class_t *na_class, na_mem_handle_t *mem_handle,
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
     NA_CHECK_ERROR(mem_handle == NULL, done, ret,
-        NA_INVALID_ARG, "NULL pointer to memory handle");
-    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_ARG,
+        NA_INVALID_PARAM, "NULL pointer to memory handle");
+    NA_CHECK_ERROR(buf == NULL, done, ret, NA_INVALID_PARAM,
         "NULL buffer");
-    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(buf_size == 0, done, ret, NA_INVALID_PARAM,
         "NULL buffer size");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->mem_handle_deserialize == NULL, done, ret,
-        NA_OPNOTSUPPORTED,
+        NA_PROTOCOL_ERROR,
         "mem_handle_deserialize plugin callback is not defined");
 
     ret = na_class->ops->mem_handle_deserialize(na_class, mem_handle, buf,
@@ -1159,15 +1160,15 @@ NA_Progress(na_class_t *na_class, na_context_t *context, unsigned int timeout)
 #endif
     na_return_t ret = NA_TIMEOUT;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(na_private_context == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_private_context == NULL, done, ret, NA_INVALID_PARAM,
         "NULL context");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
     NA_CHECK_ERROR(na_class->ops->progress == NULL, done, ret,
-        NA_OPNOTSUPPORTED, "progress plugin callback is not defined");
+        NA_PROTOCOL_ERROR, "progress plugin callback is not defined");
 
     /* Do not block if NA_NO_BLOCK option is passed */
     if (na_private_class->na_class.progress_mode == NA_NO_BLOCK)
@@ -1266,7 +1267,7 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
     na_return_t ret = NA_SUCCESS;
     unsigned int count = 0;
 
-    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_PARAM,
         "NULL context");
 
     /* Do not block if NA_NO_BLOCK option is passed */
@@ -1295,7 +1296,7 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
                 hg_thread_mutex_unlock(
                     &na_private_context->completion_queue_mutex);
                 if (!completion_data)
-                    continue; /* Give another chance to grab it */
+                    continue; /* Give another change to grab it */
             } else {
                 hg_time_t t1, t2;
 
@@ -1336,12 +1337,12 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
 
                 hg_time_get_current(&t2);
                 remaining -= hg_time_to_double(hg_time_subtract(t2, t1));
-                continue; /* Give another chance to grab it */
+                continue; /* Give another change to grab it */
             }
         }
 
-        /* Completion data should be valid */
-        NA_CHECK_ERROR(completion_data == NULL, done, ret, NA_INVALID_ARG,
+        /* Completion queue should not be empty now */
+        NA_CHECK_ERROR(completion_data == NULL, done, ret, NA_PROTOCOL_ERROR,
             "NULL completion data");
 
         /* Execute callback */
@@ -1365,10 +1366,9 @@ NA_Trigger(na_context_t *context, unsigned int timeout, unsigned int max_count,
         count++;
     }
 
-    if (actual_count)
+done:
+    if ((ret == NA_SUCCESS || ret == NA_TIMEOUT) && actual_count)
         *actual_count = count;
-
-done:
     return ret;
 }
 
@@ -1378,16 +1378,16 @@ NA_Cancel(na_class_t *na_class, na_context_t *context, na_op_id_t op_id)
 {
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class == NULL, done, ret, NA_INVALID_PARAM,
         "NULL NA class");
-    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(context == NULL, done, ret, NA_INVALID_PARAM,
         "NULL context");
-    NA_CHECK_ERROR(op_id == NA_OP_ID_NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(op_id == NA_OP_ID_NULL, done, ret, NA_INVALID_PARAM,
         "NULL operation ID");
 
-    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_INVALID_ARG,
+    NA_CHECK_ERROR(na_class->ops == NULL, done, ret, NA_PROTOCOL_ERROR,
         "NULL NA class ops");
-    NA_CHECK_ERROR(na_class->ops->cancel == NULL, done, ret, NA_OPNOTSUPPORTED,
+    NA_CHECK_ERROR(na_class->ops->cancel == NULL, done, ret, NA_PROTOCOL_ERROR,
         "cancel plugin callback is not defined");
 
     ret = na_class->ops->cancel(na_class, context, op_id);
@@ -1400,7 +1400,20 @@ done:
 const char *
 NA_Error_to_string(na_return_t errnum)
 {
-    return na_return_name[errnum];
+    const char *na_error_string = "UNDEFINED/UNRECOGNIZED NA ERROR";
+
+    NA_ERROR_STRING_MACRO(NA_SUCCESS, errnum, na_error_string);
+    NA_ERROR_STRING_MACRO(NA_CANCELED, errnum, na_error_string);
+    NA_ERROR_STRING_MACRO(NA_TIMEOUT, errnum, na_error_string);
+    NA_ERROR_STRING_MACRO(NA_INVALID_PARAM, errnum, na_error_string);
+    NA_ERROR_STRING_MACRO(NA_SIZE_ERROR, errnum, na_error_string);
+    NA_ERROR_STRING_MACRO(NA_ALIGNMENT_ERROR, errnum, na_error_string);
+    NA_ERROR_STRING_MACRO(NA_PERMISSION_ERROR, errnum, na_error_string);
+    NA_ERROR_STRING_MACRO(NA_NOMEM_ERROR, errnum, na_error_string);
+    NA_ERROR_STRING_MACRO(NA_PROTOCOL_ERROR, errnum, na_error_string);
+    NA_ERROR_STRING_MACRO(NA_ADDRINUSE_ERROR, errnum, na_error_string);
+
+    return na_error_string;
 }
 
 /*---------------------------------------------------------------------------*/
diff --git a/src/na/na.h b/src/na/na.h
index b3a3d7d..eba537b 100644
--- a/src/na/na.h
+++ b/src/na/na.h
@@ -44,7 +44,7 @@ extern "C" {
  *
  * \return Pointer to NA class or NULL in case of failure
  */
-NA_PUBLIC na_class_t *
+NA_EXPORT na_class_t *
 NA_Initialize(
         const char *info_string,
         na_bool_t   listen
@@ -62,7 +62,7 @@ NA_Initialize(
  *
  * \return Pointer to NA class or NULL in case of failure
  */
-NA_PUBLIC na_class_t *
+NA_EXPORT na_class_t *
 NA_Initialize_opt(
         const char                *info_string,
         na_bool_t                  listen,
@@ -76,7 +76,7 @@ NA_Initialize_opt(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Finalize(
         na_class_t *na_class
         );
@@ -88,7 +88,7 @@ NA_Finalize(
  * abnormally to easily clean up those resources. This includes instances
  * from all plugins.
  */
-NA_PUBLIC void
+NA_EXPORT void
 NA_Cleanup(
         void
         );
@@ -136,7 +136,7 @@ NA_Is_listening(
  *
  * \return Pointer to NA context or NULL in case of failure
  */
-NA_PUBLIC na_context_t *
+NA_EXPORT na_context_t *
 NA_Context_create(
         na_class_t *na_class
         ) NA_WARN_UNUSED_RESULT;
@@ -149,7 +149,7 @@ NA_Context_create(
  *
  * \return Pointer to NA context or NULL in case of failure
  */
-NA_PUBLIC na_context_t *
+NA_EXPORT na_context_t *
 NA_Context_create_id(
         na_class_t *na_class,
         na_uint8_t id
@@ -163,7 +163,7 @@ NA_Context_create_id(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Context_destroy(
         na_class_t   *na_class,
         na_context_t *context
@@ -181,7 +181,7 @@ NA_Context_destroy(
  *
  * \return valid operation ID or NA_OP_ID_NULL
  */
-NA_PUBLIC na_op_id_t
+NA_EXPORT na_op_id_t
 NA_Op_create(
         na_class_t *na_class
         );
@@ -195,7 +195,7 @@ NA_Op_create(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Op_destroy(
         na_class_t *na_class,
         na_op_id_t op_id
@@ -220,7 +220,7 @@ NA_Op_destroy(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Addr_lookup(
         na_class_t   *na_class,
         na_context_t *context,
@@ -242,7 +242,7 @@ NA_Addr_lookup(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Addr_lookup2(
         na_class_t *na_class,
         const char *name,
@@ -257,7 +257,7 @@ NA_Addr_lookup2(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Addr_free(
         na_class_t *na_class,
         na_addr_t   addr
@@ -274,7 +274,7 @@ NA_Addr_free(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Addr_set_remove(
         na_class_t *na_class,
         na_addr_t   addr
@@ -288,7 +288,7 @@ NA_Addr_set_remove(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Addr_self(
         na_class_t *na_class,
         na_addr_t  *addr
@@ -305,7 +305,7 @@ NA_Addr_self(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Addr_dup(
         na_class_t *na_class,
         na_addr_t   addr,
@@ -340,7 +340,7 @@ NA_Addr_is_self(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Addr_to_string(
         na_class_t *na_class,
         char       *buf,
@@ -372,7 +372,7 @@ NA_Addr_get_serialize_size(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Addr_serialize(
         na_class_t  *na_class,
         void        *buf,
@@ -391,7 +391,7 @@ NA_Addr_serialize(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Addr_deserialize(
         na_class_t      *na_class,
         na_addr_t       *addr,
@@ -476,7 +476,7 @@ NA_Msg_get_max_tag(
  *
  * \return Pointer to allocated memory or NULL in case of failure
  */
-NA_PUBLIC void *
+NA_EXPORT void *
 NA_Msg_buf_alloc(
         na_class_t *na_class,
         na_size_t buf_size,
@@ -494,7 +494,7 @@ NA_Msg_buf_alloc(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Msg_buf_free(
         na_class_t *na_class,
         void *buf,
@@ -513,7 +513,7 @@ NA_Msg_buf_free(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Msg_init_unexpected(
         na_class_t *na_class,
         void *buf,
@@ -615,7 +615,7 @@ NA_Msg_recv_unexpected(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Msg_init_expected(
         na_class_t *na_class,
         void *buf,
@@ -726,7 +726,7 @@ NA_Msg_recv_expected(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Mem_handle_create(
         na_class_t      *na_class,
         void            *buf,
@@ -754,7 +754,7 @@ NA_Mem_handle_create(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Mem_handle_create_segments(
         na_class_t        *na_class,
         struct na_segment *segments,
@@ -771,7 +771,7 @@ NA_Mem_handle_create_segments(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Mem_handle_free(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -787,7 +787,7 @@ NA_Mem_handle_free(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Mem_register(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -801,7 +801,7 @@ NA_Mem_register(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Mem_deregister(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -817,7 +817,7 @@ NA_Mem_deregister(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Mem_publish(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -831,7 +831,7 @@ NA_Mem_publish(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Mem_unpublish(
         na_class_t      *na_class,
         na_mem_handle_t  mem_handle
@@ -867,7 +867,7 @@ NA_Mem_handle_get_serialize_size(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Mem_handle_serialize(
         na_class_t      *na_class,
         void            *buf,
@@ -885,7 +885,7 @@ NA_Mem_handle_serialize(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Mem_handle_deserialize(
         na_class_t      *na_class,
         na_mem_handle_t *mem_handle,
@@ -1002,7 +1002,7 @@ NA_Poll_get_fd(
  *
  * \return NA_TRUE if it is safe to block or NA_FALSE otherwise
  */
-NA_PUBLIC na_bool_t
+NA_EXPORT na_bool_t
 NA_Poll_try_wait(
         na_class_t      *na_class,
         na_context_t    *context
@@ -1021,7 +1021,7 @@ NA_Poll_try_wait(
  *
  * \return NA_SUCCESS if any completion has occurred / NA error code otherwise
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Progress(
         na_class_t   *na_class,
         na_context_t *context,
@@ -1041,7 +1041,7 @@ NA_Progress(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Trigger(
         na_context_t *context,
         unsigned int  timeout,
@@ -1059,7 +1059,7 @@ NA_Trigger(
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_Cancel(
         na_class_t   *na_class,
         na_context_t *context,
@@ -1073,7 +1073,7 @@ NA_Cancel(
  *
  * \return String
  */
-NA_PUBLIC const char *
+NA_EXPORT const char *
 NA_Error_to_string(
         na_return_t errnum
         ) NA_WARN_UNUSED_RESULT;
@@ -1094,10 +1094,10 @@ struct na_info {
 /* NA class definition */
 struct na_class {
     const struct na_class_ops *ops;             /* Class operations */
-    void *plugin_class;                         /* Plugin private class */
     char *protocol_name;                        /* Name of protocol */
-    na_progress_mode_t progress_mode;           /* NA progress mode */
     na_bool_t listen;                           /* Listen for connections */
+    na_progress_mode_t progress_mode;           /* NA progress mode */
+    void *plugin_class;                         /* Plugin private class */
 };
 
 /* NA context definition */
diff --git a/src/na/na_bmi.c b/src/na/na_bmi.c
index 6eedcbe..40eab78 100644
--- a/src/na/na_bmi.c
+++ b/src/na/na_bmi.c
@@ -23,13 +23,6 @@
 /* Local Macros */
 /****************/
 
-/* Error compat */
-#define NA_INVALID_PARAM    NA_INVALID_ARG
-#define NA_SIZE_ERROR       NA_MSGSIZE
-#define NA_NOMEM_ERROR      NA_NOMEM
-#define NA_PERMISSION_ERROR NA_PERMISSION
-#define NA_ADDRINUSE_ERROR  NA_ADDRINUSE
-
 /* Max addr name */
 #define NA_BMI_MAX_ADDR_NAME 256
 
@@ -509,7 +502,7 @@ na_bmi_cancel(
 /* Local Variables */
 /*******************/
 
-const struct na_class_ops NA_PLUGIN_OPS(bmi) = {
+NA_PLUGIN_OPS(bmi) = {
         "bmi",                                /* name */
         na_bmi_check_protocol,                /* check_protocol */
         na_bmi_initialize,                    /* initialize */
diff --git a/src/na/na_cci.c b/src/na/na_cci.c
index 6ce6c9e..a105133 100644
--- a/src/na/na_cci.c
+++ b/src/na/na_cci.c
@@ -28,14 +28,6 @@
 /****************/
 /* Local Macros */
 /****************/
-
-/* Error compat */
-#define NA_INVALID_PARAM    NA_INVALID_ARG
-#define NA_SIZE_ERROR       NA_MSGSIZE
-#define NA_NOMEM_ERROR      NA_NOMEM
-#define NA_PERMISSION_ERROR NA_PERMISSION
-#define NA_ADDRINUSE_ERROR  NA_ADDRINUSE
-
 /* Max tag */
 #define NA_CCI_MAX_TAG ((1 << 30) -1)
 
@@ -368,7 +360,7 @@ na_cci_cancel(na_class_t * na_class, na_context_t * context, na_op_id_t op_id);
 /* Local Variables */
 /*******************/
 
-const struct na_class_ops NA_PLUGIN_OPS(cci) = {
+NA_PLUGIN_OPS(cci) = {
     "cci",                                  /* name */
     na_cci_check_protocol,                  /* check_protocol */
     na_cci_initialize,                      /* initialize */
diff --git a/src/na/na_config.h.in b/src/na/na_config.h.in
index d153909..effe390 100644
--- a/src/na/na_config.h.in
+++ b/src/na/na_config.h.in
@@ -13,97 +13,21 @@
 #ifndef NA_CONFIG_H
 #define NA_CONFIG_H
 
-/*************************************/
-/* Public Type and Struct Definition */
-/*************************************/
-
-/* Type definitions */
-#ifdef _WIN32
-  typedef signed   __int64 na_int64_t;
-  typedef signed   __int32 na_int32_t;
-  typedef signed   __int16 na_int16_t;
-  typedef signed   __int8  na_int8_t;
-  typedef unsigned __int64 na_uint64_t;
-  typedef unsigned __int32 na_uint32_t;
-  typedef unsigned __int16 na_uint16_t;
-  typedef unsigned __int8  na_uint8_t;
-#else
-# include <stdint.h>
-# include <stddef.h>
-  typedef int64_t  na_int64_t;
-  typedef int32_t  na_int32_t;
-  typedef int16_t  na_int16_t;
-  typedef int8_t   na_int8_t;
-  typedef uint64_t na_uint64_t;
-  typedef uint32_t na_uint32_t;
-  typedef uint16_t na_uint16_t;
-  typedef uint8_t  na_uint8_t;
-#endif
-typedef na_uint8_t   na_bool_t;
-typedef na_uint64_t  na_ptr_t;
-
-/* True / false */
-#define NA_TRUE     1
-#define NA_FALSE    0
-
-/*****************/
-/* Public Macros */
-/*****************/
-
-/* Visibility of symbols */
+/* Import/export declarations */
 #if defined(_WIN32)
-# define NA_ABI_IMPORT __declspec(dllimport)
-# define NA_ABI_EXPORT __declspec(dllexport)
-# define NA_ABI_HIDDEN
+    #define NA_ABI_IMPORT __declspec(dllimport)
+    #define NA_ABI_EXPORT __declspec(dllexport)
+    #define NA_ABI_HIDDEN
 #elif defined(__GNUC__) && (__GNUC__ >= 4)
-# define NA_ABI_IMPORT __attribute__((visibility("default")))
-# define NA_ABI_EXPORT __attribute__((visibility("default")))
-# define NA_ABI_HIDDEN __attribute__((visibility("hidden")))
+    #define NA_ABI_IMPORT __attribute__((visibility("default")))
+    #define NA_ABI_EXPORT __attribute__((visibility("default")))
+    #define NA_ABI_HIDDEN __attribute__((visibility("hidden")))
 #else
-# define NA_ABI_IMPORT
-# define NA_ABI_EXPORT
-# define NA_ABI_HIDDEN
+    #define NA_ABI_IMPORT
+    #define NA_ABI_EXPORT
+    #define NA_ABI_HIDDEN
 #endif
 
-/* Inline macro */
-#ifdef _WIN32
-# define NA_INLINE __inline
-#else
-# define NA_INLINE __inline__
-#endif
-
-/* Unused return values */
-#if defined(__GNUC__)
-# define NA_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
-#else
-# define NA_WARN_UNUSED_RESULT
-#endif
-
-/* Fallthrough macro */
-#if defined(__GNUC__) && (__GNUC__ >= 7)
-# define NA_FALLTHROUGH() __attribute__((fallthrough))
-#else
-# define NA_FALLTHROUGH()
-#endif
-
-/* Shared libraries */
-#cmakedefine NA_BUILD_SHARED_LIBS
-#ifdef NA_BUILD_SHARED_LIBS
-# ifdef na_EXPORTS
-#  define NA_PUBLIC NA_ABI_EXPORT
-# else
-#  define NA_PUBLIC NA_ABI_IMPORT
-# endif
-# define NA_PRIVATE NA_ABI_HIDDEN
-#else
-# define NA_PUBLIC
-# define NA_PRIVATE
-#endif
-
-/* Build Options */
-#cmakedefine NA_HAS_MULTI_PROGRESS
-#cmakedefine NA_HAS_VERBOSE_ERROR
-
 /* BMI */
 #cmakedefine NA_HAS_BMI
 
@@ -125,4 +49,66 @@ typedef na_uint64_t  na_ptr_t;
 #cmakedefine NA_SM_SHM_PREFIX "@NA_SM_SHM_PREFIX@"
 #cmakedefine NA_SM_TMP_DIRECTORY "@NA_SM_TMP_DIRECTORY@"
 
+/* Build Options */
+#cmakedefine NA_HAS_MULTI_PROGRESS
+#cmakedefine NA_HAS_VERBOSE_ERROR
+
+/* Define if build shared libraries */
+#cmakedefine NA_BUILD_SHARED_LIBS
+
+/* Define export declaration */
+#ifdef NA_BUILD_SHARED_LIBS
+    #ifdef na_EXPORTS
+      #define NA_EXPORT NA_ABI_EXPORT
+    #else
+      #define NA_EXPORT NA_ABI_IMPORT
+    #endif
+#else
+    #define NA_EXPORT
+#endif
+
+/* Standard types */
+#ifdef _WIN32
+    typedef signed   __int64 na_int64_t;
+    typedef signed   __int32 na_int32_t;
+    typedef signed   __int16 na_int16_t;
+    typedef signed   __int8  na_int8_t;
+    typedef unsigned __int64 na_uint64_t;
+    typedef unsigned __int32 na_uint32_t;
+    typedef unsigned __int16 na_uint16_t;
+    typedef unsigned __int8  na_uint8_t;
+#else
+    #include <stdint.h>
+    #include <stddef.h>
+    typedef int64_t  na_int64_t;
+    typedef int32_t  na_int32_t;
+    typedef int16_t  na_int16_t;
+    typedef int8_t   na_int8_t;
+    typedef uint64_t na_uint64_t;
+    typedef uint32_t na_uint32_t;
+    typedef uint16_t na_uint16_t;
+    typedef uint8_t  na_uint8_t;
+#endif
+typedef na_uint8_t   na_bool_t;
+typedef na_uint64_t  na_ptr_t;
+
+/* Inline declarations */
+#ifdef _WIN32
+   #define NA_INLINE __inline
+#else
+   #define NA_INLINE __inline__
+#endif
+
+/* Unused return values */
+#if defined(__GNUC__)
+    #define NA_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
+#else
+    #define NA_WARN_UNUSED_RESULT
+#endif
+
+/* Return codes */
+#define NA_TRUE     1
+#define NA_FALSE    0
+
 #endif /* NA_CONFIG_H */
+
diff --git a/src/na/na_error.h b/src/na/na_error.h
index f661211..2f0ed26 100644
--- a/src/na/na_error.h
+++ b/src/na/na_error.h
@@ -16,22 +16,13 @@
 /* Default error macro */
 #ifdef NA_HAS_VERBOSE_ERROR
 # include <mercury_log.h>
-# define NA_LOG_MASK na_log_mask
-/* Log mask will be initialized in init routine */
-extern NA_PRIVATE unsigned int NA_LOG_MASK;
 # define NA_LOG_MODULE_NAME "NA"
-# define NA_LOG_ERROR(...) do {                                 \
-    if (NA_LOG_MASK & HG_LOG_TYPE_ERROR)                        \
-        HG_LOG_WRITE_ERROR(NA_LOG_MODULE_NAME, __VA_ARGS__);    \
-} while (0)
-# define NA_LOG_DEBUG(...) do {                                 \
-    if (NA_LOG_MASK & HG_LOG_TYPE_DEBUG)                        \
-        HG_LOG_WRITE_DEBUG(NA_LOG_MODULE_NAME, __VA_ARGS__);    \
-} while (0)
-# define NA_LOG_WARNING(...) do {                               \
-    if (NA_LOG_MASK & HG_LOG_TYPE_WARNING)                      \
-        HG_LOG_WRITE_WARNING(NA_LOG_MODULE_NAME, __VA_ARGS__);  \
-} while (0)
+# define NA_LOG_ERROR(...)                                      \
+    HG_LOG_WRITE_ERROR(NA_LOG_MODULE_NAME, __VA_ARGS__)
+# define NA_LOG_DEBUG(...)                                      \
+    HG_LOG_WRITE_DEBUG(NA_LOG_MODULE_NAME, __VA_ARGS__)
+# define NA_LOG_WARNING(...)                                    \
+    HG_LOG_WRITE_WARNING(NA_LOG_MODULE_NAME, __VA_ARGS__)
 #else
 # define NA_LOG_ERROR(...)      (void)0
 # define NA_LOG_DEBUG(...)      (void)0
@@ -48,14 +39,9 @@ extern NA_PRIVATE unsigned int NA_LOG_MASK;
 #endif
 
 /* Error macros */
-#define NA_GOTO_DONE(label, ret, ret_val) do {                  \
-    ret = ret_val;                                              \
-    goto label;                                                 \
-} while (0)
-
-#define NA_GOTO_ERROR(label, ret, err_val, ...) do {            \
+#define NA_GOTO_ERROR(label, ret, error, ...) do {              \
     NA_LOG_ERROR(__VA_ARGS__);                                  \
-    ret = err_val;                                              \
+    ret = error;                                                \
     goto label;                                                 \
 } while (0)
 
@@ -83,17 +69,4 @@ extern NA_PRIVATE unsigned int NA_LOG_MASK;
     }                                                           \
 } while (0)
 
-#define NA_CHECK_ERROR_DONE(cond, ...) do {                     \
-    if (unlikely(cond)) {                                       \
-        NA_LOG_ERROR(__VA_ARGS__);                              \
-    }                                                           \
-} while (0)
-
-/* Check for cond and print warning */
-#define NA_CHECK_WARNING(cond, ...) do {                        \
-    if (unlikely(cond)) {                                       \
-        NA_LOG_WARNING(__VA_ARGS__);                            \
-    }                                                           \
-} while (0)
-
 #endif /* NA_ERROR_H */
diff --git a/src/na/na_mpi.c b/src/na/na_mpi.c
index 03137cd..637a97e 100644
--- a/src/na/na_mpi.c
+++ b/src/na/na_mpi.c
@@ -25,12 +25,6 @@
 /* Local Macros */
 /****************/
 
-/* Error compat */
-#define NA_INVALID_PARAM    NA_INVALID_ARG
-#define NA_SIZE_ERROR       NA_MSGSIZE
-#define NA_NOMEM_ERROR      NA_NOMEM
-#define NA_PERMISSION_ERROR NA_PERMISSION
-
 /* MPI initialization flags */
 #define MPI_INIT_SERVER 0x01 /* set up to listen for unexpected messages */
 #define MPI_INIT_STATIC 0x10 /* set up static inter-communicator */
@@ -147,8 +141,7 @@ struct na_mpi_op_id {
     na_cb_type_t type;
     na_cb_t callback; /* Callback */
     void *arg;
-    hg_atomic_int32_t ref_count;    /* Ref count */
-    hg_atomic_int32_t completed;    /* Operation completed */
+    na_bool_t completed; /* Operation completed */
     na_bool_t canceled;  /* Operation canceled */
     union {
       struct na_mpi_info_lookup lookup;
@@ -269,19 +262,6 @@ na_mpi_finalize(
         na_class_t *na_class
         );
 
-/* op_create */
-static na_op_id_t
-na_mpi_op_create(
-        na_class_t      *na_class
-        );
-
-/* op_destroy */
-static na_return_t
-na_mpi_op_destroy(
-        na_class_t      *na_class,
-        na_op_id_t       op_id
-        );
-
 /* addr_lookup */
 static na_return_t
 na_mpi_addr_lookup(
@@ -551,7 +531,7 @@ na_mpi_cancel(
 /* Local Variables */
 /*******************/
 
-const struct na_class_ops NA_PLUGIN_OPS(mpi) = {
+NA_PLUGIN_OPS(mpi) = {
         "mpi",                                /* name */
         na_mpi_check_protocol,                /* check_protocol */
         na_mpi_initialize,                    /* initialize */
@@ -559,8 +539,8 @@ const struct na_class_ops NA_PLUGIN_OPS(mpi) = {
         NULL,                                 /* cleanup */
         NULL,                                 /* context_create */
         NULL,                                 /* context_destroy */
-        na_mpi_op_create,                     /* op_create */
-        na_mpi_op_destroy,                    /* op_destroy */
+        NULL,                                 /* op_create */
+        NULL,                                 /* op_destroy */
         na_mpi_addr_lookup,                   /* addr_lookup */
         NULL,                                 /* addr_lookup2 */
         na_mpi_addr_free,                     /* addr_free */
@@ -1236,43 +1216,6 @@ na_mpi_finalize(na_class_t *na_class)
     return ret;
 }
 
-/*---------------------------------------------------------------------------*/
-static na_op_id_t
-na_mpi_op_create(na_class_t NA_UNUSED *na_class)
-{
-    struct na_mpi_op_id *na_mpi_op_id = NULL;
-
-    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
-    if (!na_mpi_op_id) {
-        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
-        goto done;
-    }
-    memset(na_mpi_op_id, 0, sizeof(struct na_mpi_op_id));
-    hg_atomic_init32(&na_mpi_op_id->ref_count, 1);
-    /* Completed by default */
-    hg_atomic_init32(&na_mpi_op_id->completed, 1);
-
-done:
-    return (na_op_id_t) na_mpi_op_id;
-}
-
-/*---------------------------------------------------------------------------*/
-static na_return_t
-na_mpi_op_destroy(na_class_t NA_UNUSED *na_class, na_op_id_t op_id)
-{
-    struct na_mpi_op_id *na_mpi_op_id = (struct na_mpi_op_id *) op_id;
-    na_return_t ret = NA_SUCCESS;
-
-    if (hg_atomic_decr32(&na_mpi_op_id->ref_count)) {
-        /* Cannot free yet */
-        goto done;
-    }
-    free(na_mpi_op_id);
-
-done:
-    return ret;
-}
-
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
@@ -1283,13 +1226,18 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     int mpi_ret;
 
-    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
-    hg_atomic_incr32(&na_mpi_op_id->ref_count);
+    /* Allocate op_id */
+    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    if (!na_mpi_op_id) {
+        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_LOOKUP;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    hg_atomic_set32(&na_mpi_op_id->completed, 0);
+    na_mpi_op_id->completed = NA_FALSE;
     na_mpi_op_id->canceled = NA_FALSE;
 
     /* Allocate addr */
@@ -1310,6 +1258,9 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
     /* get port_name and remote server rank */
     na_mpi_get_port_info(name, na_mpi_addr->port_name, &na_mpi_addr->rank);
 
+    /* Assign op_id */
+    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
+
     /* Try to connect, must prevent concurrent threads to
      * create new communicators */
     hg_thread_mutex_lock(&NA_MPI_CLASS(na_class)->accept_mutex);
@@ -1378,7 +1329,7 @@ na_mpi_addr_lookup(na_class_t *na_class, na_context_t *context,
 done:
     if (ret != NA_SUCCESS) {
         free(na_mpi_addr);
-        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
+        free(na_mpi_op_id);
     }
 
     return ret;
@@ -1537,16 +1488,24 @@ na_mpi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
     int mpi_ret;
 
-    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
-    hg_atomic_incr32(&na_mpi_op_id->ref_count);
+    /* Allocate op_id */
+    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    if (!na_mpi_op_id) {
+        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_SEND_UNEXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    hg_atomic_set32(&na_mpi_op_id->completed, 0);
+    na_mpi_op_id->completed = NA_FALSE;
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.send_unexpected.data_request = MPI_REQUEST_NULL;
 
+    /* Assign op_id */
+    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
+
     mpi_ret = MPI_Isend(buf, mpi_buf_size, MPI_BYTE, mpi_addr->rank,
             mpi_tag, mpi_addr->comm,
             &na_mpi_op_id->info.send_unexpected.data_request);
@@ -1564,7 +1523,7 @@ na_mpi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
+        free(na_mpi_op_id);
     }
     return ret;
 }
@@ -1579,18 +1538,25 @@ na_mpi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
     na_return_t ret = NA_SUCCESS;
 
     /* Allocate na_op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
-    hg_atomic_incr32(&na_mpi_op_id->ref_count);
+    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    if (!na_mpi_op_id) {
+        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_RECV_UNEXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    hg_atomic_set32(&na_mpi_op_id->completed, 0);
+    na_mpi_op_id->completed = NA_FALSE;
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.recv_unexpected.buf = buf;
     na_mpi_op_id->info.recv_unexpected.buf_size = (int) buf_size;
     na_mpi_op_id->info.recv_unexpected.remote_addr = NULL;
 
+    /* Assign op_id */
+    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
+
     /* Add op_id to queue of pending unexpected recv ops and make some progress
      * in case messages are already arrived */
     ret = na_mpi_msg_unexpected_op_push(na_class, na_mpi_op_id);
@@ -1613,7 +1579,7 @@ na_mpi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
+        free(na_mpi_op_id);
     }
     return ret;
 }
@@ -1633,16 +1599,23 @@ na_mpi_msg_send_expected(na_class_t *na_class, na_context_t *context,
     int mpi_ret;
 
     /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
-    hg_atomic_incr32(&na_mpi_op_id->ref_count);
+    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    if (!na_mpi_op_id) {
+        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_SEND_EXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    hg_atomic_set32(&na_mpi_op_id->completed, 0);
+    na_mpi_op_id->completed = NA_FALSE;
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.send_expected.data_request = MPI_REQUEST_NULL;
 
+    /* Assign op_id */
+    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
+
     mpi_ret = MPI_Isend(buf, mpi_buf_size, MPI_BYTE, mpi_addr->rank,
             mpi_tag, mpi_addr->comm,
             &na_mpi_op_id->info.send_expected.data_request);
@@ -1660,7 +1633,7 @@ na_mpi_msg_send_expected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
+        free(na_mpi_op_id);
     }
     return ret;
 }
@@ -1680,18 +1653,25 @@ na_mpi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     int mpi_ret;
 
     /* Allocate op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
-    hg_atomic_incr32(&na_mpi_op_id->ref_count);
+    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    if (!na_mpi_op_id) {
+        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_RECV_EXPECTED;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    hg_atomic_set32(&na_mpi_op_id->completed, 0);
+    na_mpi_op_id->completed = NA_FALSE;
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.recv_expected.buf_size = mpi_buf_size;
     na_mpi_op_id->info.recv_expected.actual_size = 0;
     na_mpi_op_id->info.recv_expected.data_request = MPI_REQUEST_NULL;
 
+    /* Assign op_id */
+    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
+
     mpi_ret = MPI_Irecv(buf, mpi_buf_size, MPI_BYTE, mpi_addr->rank,
             mpi_tag, mpi_addr->comm,
             &na_mpi_op_id->info.recv_expected.data_request);
@@ -1709,7 +1689,7 @@ na_mpi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
-        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
+        free(na_mpi_op_id);
     }
     return ret;
 }
@@ -1868,13 +1848,18 @@ na_mpi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
             goto done;
     }
 
-    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
-    hg_atomic_incr32(&na_mpi_op_id->ref_count);
+    /* Allocate op_id */
+    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    if (!na_mpi_op_id) {
+        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_PUT;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    hg_atomic_set32(&na_mpi_op_id->completed, 0);
+    na_mpi_op_id->completed = NA_FALSE;
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.put.rma_request = MPI_REQUEST_NULL;
     na_mpi_op_id->info.put.data_request = MPI_REQUEST_NULL;
@@ -1896,6 +1881,9 @@ na_mpi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_mpi_rma_info->tag = na_mpi_gen_rma_tag(na_class);
     na_mpi_op_id->info.put.rma_info = na_mpi_rma_info;
 
+    /* Assign op_id */
+    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
+
     /* Post the MPI send request */
     mpi_ret = MPI_Isend(na_mpi_rma_info, sizeof(struct na_mpi_rma_info),
             MPI_BYTE, na_mpi_addr->rank, NA_MPI_RMA_REQUEST_TAG,
@@ -1924,8 +1912,8 @@ na_mpi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
 done:
     if (ret != NA_SUCCESS) {
+        free(na_mpi_op_id);
         free(na_mpi_rma_info);
-        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -1966,13 +1954,18 @@ na_mpi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
             goto done;
     }
 
-    na_mpi_op_id = (struct na_mpi_op_id *) *op_id;
-    hg_atomic_incr32(&na_mpi_op_id->ref_count);
+    /* Allocate op_id */
+    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
+    if (!na_mpi_op_id) {
+        NA_LOG_ERROR("Could not allocate NA MPI operation ID");
+        ret = NA_NOMEM_ERROR;
+        goto done;
+    }
     na_mpi_op_id->context = context;
     na_mpi_op_id->type = NA_CB_GET;
     na_mpi_op_id->callback = callback;
     na_mpi_op_id->arg = arg;
-    hg_atomic_set32(&na_mpi_op_id->completed, 0);
+    na_mpi_op_id->completed = NA_FALSE;
     na_mpi_op_id->canceled = NA_FALSE;
     na_mpi_op_id->info.get.rma_request = MPI_REQUEST_NULL;
     na_mpi_op_id->info.get.data_request = MPI_REQUEST_NULL;
@@ -1994,6 +1987,9 @@ na_mpi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
     na_mpi_rma_info->tag = na_mpi_gen_rma_tag(na_class);
     na_mpi_op_id->info.get.rma_info = na_mpi_rma_info;
 
+    /* Assign op_id */
+    if (op_id && op_id != NA_OP_ID_IGNORE) *op_id = (na_op_id_t) na_mpi_op_id;
+
     /* Post the MPI send request */
     mpi_ret = MPI_Isend(na_mpi_rma_info, sizeof(struct na_mpi_rma_info),
             MPI_BYTE, na_mpi_addr->rank, NA_MPI_RMA_REQUEST_TAG,
@@ -2022,8 +2018,8 @@ na_mpi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
 
 done:
     if (ret != NA_SUCCESS) {
+        free(na_mpi_op_id);
         free(na_mpi_rma_info);
-        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -2222,7 +2218,7 @@ na_mpi_progress_unexpected_rma(na_class_t *na_class, na_context_t *context,
     }
 
     /* Allocate na_op_id */
-    na_mpi_op_id = (struct na_mpi_op_id *) na_mpi_op_create(na_class);
+    na_mpi_op_id = (struct na_mpi_op_id *) malloc(sizeof(struct na_mpi_op_id));
     if (!na_mpi_op_id) {
         NA_LOG_ERROR("Could not allocate NA MPI operation ID");
         ret = NA_NOMEM_ERROR;
@@ -2232,7 +2228,7 @@ na_mpi_progress_unexpected_rma(na_class_t *na_class, na_context_t *context,
     na_mpi_op_id->context = context;
     na_mpi_op_id->callback = NULL;
     na_mpi_op_id->arg = NULL;
-    hg_atomic_set32(&na_mpi_op_id->completed, 0);
+    na_mpi_op_id->completed = NA_FALSE;
     na_mpi_op_id->canceled = NA_FALSE;
 
     switch (na_mpi_rma_info->op) {
@@ -2289,8 +2285,8 @@ na_mpi_progress_unexpected_rma(na_class_t *na_class, na_context_t *context,
 
 done:
     if (ret != NA_SUCCESS) {
+        free(na_mpi_op_id);
         free(na_mpi_rma_info);
-        na_mpi_op_destroy(na_class, (na_op_id_t) na_mpi_op_id);
     }
     return ret;
 }
@@ -2315,7 +2311,7 @@ na_mpi_progress_expected(na_class_t *na_class, na_context_t NA_UNUSED *context,
         MPI_Status *status = MPI_STATUS_IGNORE;
 
         /* If the op_id is marked as completed, something is wrong */
-        if (hg_atomic_get32(&na_mpi_op_id->completed)) {
+        if (na_mpi_op_id->completed) {
             NA_LOG_ERROR("Op ID should not have completed yet");
             ret = NA_PROTOCOL_ERROR;
             goto done;
@@ -2395,7 +2391,7 @@ na_mpi_progress_expected(na_class_t *na_class, na_context_t NA_UNUSED *context,
         /* If internal operation call release directly otherwise add callback
          * to completion queue */
         if (internal) {
-            hg_atomic_set32(&na_mpi_op_id->completed, 1);
+            na_mpi_op_id->completed = NA_TRUE;
             /* Remove entry from list */
             HG_LIST_REMOVE(na_mpi_op_id, entry);
 
@@ -2434,7 +2430,7 @@ na_mpi_complete(struct na_mpi_op_id *na_mpi_op_id)
     int mpi_ret;
 
     /* Mark op id as completed */
-    hg_atomic_set32(&na_mpi_op_id->completed, 1);
+    na_mpi_op_id->completed = NA_TRUE;
 
     /* Init callback info */
     callback_info = &na_mpi_op_id->completion_data.callback_info;
@@ -2557,10 +2553,10 @@ na_mpi_release(void *arg)
 {
     struct na_mpi_op_id *na_mpi_op_id = (struct na_mpi_op_id *) arg;
 
-    if (na_mpi_op_id && !hg_atomic_get32(&na_mpi_op_id->completed)) {
-        NA_LOG_WARNING("Releasing resources from an uncompleted operation");
+    if (na_mpi_op_id && !na_mpi_op_id->completed) {
+        NA_LOG_ERROR("Releasing resources from an uncompleted operation");
     }
-    na_mpi_op_destroy(NULL, (na_op_id_t) na_mpi_op_id);
+    free(na_mpi_op_id);
 }
 
 /*---------------------------------------------------------------------------*/
@@ -2572,8 +2568,8 @@ na_mpi_cancel(na_class_t *na_class, na_context_t NA_UNUSED *context,
     na_return_t ret = NA_SUCCESS;
     int mpi_ret;
 
-    if (hg_atomic_get32(&na_mpi_op_id->completed))
-        goto done;
+    /* TODO make this atomic */
+    if (na_mpi_op_id->completed) goto done;
 
     switch (na_mpi_op_id->type) {
         case NA_CB_LOOKUP:
diff --git a/src/na/na_mpi.h b/src/na/na_mpi.h
index cc9ae46..7014760 100644
--- a/src/na/na_mpi.h
+++ b/src/na/na_mpi.h
@@ -28,7 +28,7 @@ extern "C" {
  *
  * \return NA_SUCCESS or corresponding NA error code
  */
-NA_PUBLIC na_return_t
+NA_EXPORT na_return_t
 NA_MPI_Set_init_intra_comm(MPI_Comm intra_comm);
 
 /**
@@ -39,7 +39,7 @@ NA_MPI_Set_init_intra_comm(MPI_Comm intra_comm);
  *
  * \return Pointer to string
  */
-NA_PUBLIC const char *
+NA_EXPORT const char *
 NA_MPI_Get_port_name(
         na_class_t *na_class
         );
diff --git a/src/na/na_ofi.c b/src/na/na_ofi.c
index 5c13067..7e1618e 100644
--- a/src/na/na_ofi.c
+++ b/src/na/na_ofi.c
@@ -171,10 +171,10 @@
 enum na_ofi_prov_type { NA_OFI_PROV_TYPES };
 #undef X
 #define X(a, b, c, d, e, f, g) b,
-static const char * const na_ofi_prov_name[] = { NA_OFI_PROV_TYPES };
+static char * const na_ofi_prov_name[] = { NA_OFI_PROV_TYPES };
 #undef X
 #define X(a, b, c, d, e, f, g) c,
-static const char *const na_ofi_prov_alt_name[] = { NA_OFI_PROV_TYPES };
+static char * const na_ofi_prov_alt_name[] = { NA_OFI_PROV_TYPES };
 #undef X
 #define X(a, b, c, d, e, f, g) d,
 static na_uint32_t const na_ofi_prov_addr_format[] = { NA_OFI_PROV_TYPES };
@@ -222,10 +222,6 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 /* Receive context bits for SEP */
 #define NA_OFI_SEP_RX_CTX_BITS          (8)
 
-/* Op ID status bits */
-#define NA_OFI_OP_COMPLETED             (1 << 0)
-#define NA_OFI_OP_CANCELED              (1 << 1)
-
 /* Private data access */
 #define NA_OFI_CLASS(na_class)      \
     ((struct na_ofi_class *)((na_class)->plugin_class))
@@ -326,14 +322,15 @@ struct na_ofi_op_id {
     na_context_t *context;                  /* NA context associated    */
     struct na_ofi_addr *addr;               /* Address associated       */
     HG_QUEUE_ENTRY(na_ofi_op_id) entry;     /* Entry in queue           */
-    hg_atomic_int32_t status;               /* Operation status         */
+    hg_atomic_int32_t completed;            /* Operation completed      */
+    hg_atomic_int32_t canceled;             /* Operation canceled       */
     hg_atomic_int32_t refcount;             /* Refcount                 */
 };
 
 /* Op queue */
 struct na_ofi_queue {
-    HG_QUEUE_HEAD(na_ofi_op_id) queue;
     hg_thread_spin_t lock;
+    HG_QUEUE_HEAD(na_ofi_op_id) queue;
 };
 
 /* Context */
@@ -349,6 +346,8 @@ struct na_ofi_context {
 /* Endpoint */
 struct na_ofi_endpoint {
     struct na_ofi_addr *src_addr;           /* Endpoint address         */
+    char *src_node;                         /* Fabric address           */
+    char *src_service;                      /* Service name             */
     struct fi_info *fi_prov;                /* Provider info            */
     struct fid_ep *fi_ep;                   /* Endpoint handle          */
     struct fid_wait *fi_wait;               /* Wait set handle          */
@@ -561,8 +560,9 @@ na_ofi_domain_close(struct na_ofi_domain *na_ofi_domain);
  */
 static na_return_t
 na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
-    const char *node, void *src_addr, na_size_t src_addrlen, na_bool_t no_wait,
-    na_uint8_t max_contexts, struct na_ofi_endpoint **na_ofi_endpoint_p);
+    const char *node, const char *service, void *src_addr,
+    na_size_t src_addrlen, na_bool_t no_wait, na_uint8_t max_contexts,
+    struct na_ofi_endpoint **na_ofi_endpoint_p);
 
 /**
  * Open basic endpoint.
@@ -670,6 +670,12 @@ na_ofi_op_id_addref(struct na_ofi_op_id *na_ofi_op_id);
 static NA_INLINE void
 na_ofi_op_id_decref(struct na_ofi_op_id *na_ofi_op_id);
 
+/**
+ * OP ID is valid.
+ */
+static NA_INLINE na_bool_t
+na_ofi_op_id_valid(struct na_ofi_op_id *na_ofi_op_id);
+
 /**
  * Push OP ID to unexpected queue.
  */
@@ -684,11 +690,17 @@ static NA_INLINE void
 na_ofi_msg_unexpected_op_remove(na_context_t *context,
     struct na_ofi_op_id *na_ofi_op_id);
 
+/**
+ * Pop and return first OP ID from unexpected queue.
+ */
+static NA_INLINE struct na_ofi_op_id *
+na_ofi_msg_unexpected_op_pop(na_context_t *context);
+
 /**
  * Read from CQ.
  */
 static na_return_t
-na_ofi_cq_read(na_context_t *context, size_t max_count,
+na_ofi_cq_read(na_class_t *na_class, na_context_t *context, size_t max_count,
     struct fi_cq_tagged_entry cq_events[], fi_addr_t src_addrs[],
     void **src_err_addr, size_t *src_err_addrlen, size_t *actual_count);
 
@@ -940,7 +952,7 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context, na_op_id_t op_id);
 /* Local Variables */
 /*******************/
 
-const struct na_class_ops NA_PLUGIN_OPS(ofi) = {
+NA_PLUGIN_OPS(ofi) = {
     "ofi",                                  /* name */
     na_ofi_check_protocol,                  /* check_protocol */
     na_ofi_initialize,                      /* initialize */
@@ -1074,12 +1086,12 @@ na_ofi_str_to_addr(const char *str, na_uint32_t addr_format, void **addr,
         case FI_SOCKADDR_IN:
             return na_ofi_str_to_sin(str, addr, len);
         case FI_ADDR_PSMX2:
-            return na_ofi_str_to_psm2(str, addr, len);
+            return na_ofi_str_to_sin(str, addr, len);
         case FI_ADDR_GNI:
             return na_ofi_str_to_gni(str, addr, len);
         default:
             NA_LOG_ERROR("Unsupported address format");
-            return NA_PROTONOSUPPORT;
+            return NA_PROTOCOL_ERROR;
     }
 }
 
@@ -1093,7 +1105,7 @@ na_ofi_str_to_sin(const char *str, void **addr, na_size_t *len)
 
     *len = sizeof(*sin_addr);
     sin_addr = calloc(1, *len);
-    NA_CHECK_ERROR(sin_addr == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(sin_addr == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate sin address");
 
     sin_addr->sin.sin_family = AF_INET;
@@ -1105,10 +1117,10 @@ na_ofi_str_to_sin(const char *str, void **addr, na_size_t *len)
 
         ip[sizeof(ip) - 1] = '\0';
         rc = inet_pton(AF_INET, ip, &sin_addr->sin.sin_addr);
-        NA_CHECK_ERROR(rc != 1, error, ret, NA_PROTONOSUPPORT,
+        NA_CHECK_ERROR(rc != 1, error, ret, NA_PROTOCOL_ERROR,
             "Unable to convert IPv4 address: %s\n", ip);
     } else
-        NA_GOTO_ERROR(error, ret, NA_PROTONOSUPPORT,
+        NA_GOTO_ERROR(error, ret, NA_PROTOCOL_ERROR,
             "Malformed FI_ADDR_STR: %s\n", str);
 
     sin_addr->sin.sin_port = htons(sin_addr->sin.sin_port);
@@ -1131,12 +1143,12 @@ na_ofi_str_to_psm2(const char *str, void **addr, na_size_t *len)
 
     *len = sizeof(*psm2_addr);
     psm2_addr = calloc(1, *len);
-    NA_CHECK_ERROR(psm2_addr == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(psm2_addr == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate psm2 address");
 
     rc = sscanf(str, "%*[^:]://%" SCNx64 ":%" SCNx64,
         (uint64_t *) &psm2_addr->addr0, (uint64_t *) &psm2_addr->addr1);
-    NA_CHECK_ERROR(rc != 2, error, ret, NA_PROTONOSUPPORT,
+    NA_CHECK_ERROR(rc != 2, error, ret, NA_PROTOCOL_ERROR,
         "Could not convert addr string to PSM2 addr format");
 
     *addr = psm2_addr;
@@ -1160,16 +1172,16 @@ na_ofi_str_to_gni(const char *str, void **addr, na_size_t *len)
 
     *len = sizeof(*gni_addr);
     gni_addr = calloc(1, *len);
-    NA_CHECK_ERROR(gni_addr == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(gni_addr == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate gni address");
 
     rc = sscanf(str, "%*[^:]://%04u:0x%08" PRIx32 ":0x%08" PRIx32 ":%02u:0x%06"
         PRIx32 ":0x%08" PRIx32 ":%02u", &version, &device_addr, &cdm_id,
         &name_type, &cm_nic_cdm_id, &cookie, &rx_ctx_cnt);
-    NA_CHECK_ERROR(rc != 7, error, ret, NA_PROTONOSUPPORT,
+    NA_CHECK_ERROR(rc != 7, error, ret, NA_PROTOCOL_ERROR,
             "Could not convert addr string to GNI addr format");
     NA_CHECK_ERROR(version != NA_OFI_GNI_AV_STR_ADDR_VERSION, error, ret,
-        NA_PROTONOSUPPORT, "Unsupported GNI string addr format");
+        NA_PROTOCOL_ERROR, "Unsupported GNI string addr format");
 
     gni_addr->device_addr = device_addr;
     gni_addr->cdm_id = cdm_id;
@@ -1177,10 +1189,12 @@ na_ofi_str_to_gni(const char *str, void **addr, na_size_t *len)
     gni_addr->cm_nic_cdm_id = cm_nic_cdm_id & 0xffffff;
     gni_addr->cookie = cookie;
     gni_addr->rx_ctx_cnt = rx_ctx_cnt & 0xff;
+    /*
     NA_LOG_DEBUG("GNI addr is: device_addr=%x, cdm_id=%x, name_type=%x, "
         "cm_nic_cdm_id=%x, cookie=%x, rx_ctx_cnt=%u",
         gni_addr->device_addr, gni_addr->cdm_id, gni_addr->name_type,
         gni_addr->cm_nic_cdm_id, gni_addr->cookie, gni_addr->rx_ctx_cnt);
+     */
 
     *addr = gni_addr;
 
@@ -1200,8 +1214,8 @@ na_ofi_addr_to_key(na_uint32_t addr_format, const void *addr, na_size_t len)
             assert(len == sizeof(struct na_ofi_sin_addr));
             return na_ofi_sin_to_key((const struct na_ofi_sin_addr *) addr);
         case FI_ADDR_PSMX2:
-            assert(len == sizeof(struct na_ofi_psm2_addr));
-            return na_ofi_psm2_to_key((const struct na_ofi_psm2_addr *) addr);
+            assert(len == sizeof(struct na_ofi_sin_addr));
+            return na_ofi_sin_to_key((const struct na_ofi_sin_addr *) addr);
         case FI_ADDR_GNI:
             assert(len == sizeof(struct na_ofi_gni_addr));
             return na_ofi_gni_to_key((const struct na_ofi_gni_addr *) addr);
@@ -1255,6 +1269,73 @@ na_ofi_addr_ht_key_equal(hg_hash_table_key_t vlocation1,
     return *((na_uint64_t *) vlocation1) == *((na_uint64_t *) vlocation2);
 }
 
+static na_return_t
+na_ofi_av_insert(struct na_ofi_domain *domain, const void *addr,
+    na_size_t addrlen, fi_addr_t *fi_addr)
+{
+    char *node_str, service_str[16];
+    struct fi_info *tmp_info = NULL;
+    int rc = 0;
+    int ret = 0;
+
+    if (na_ofi_prov_addr_format[domain->prov_type] == FI_ADDR_PSMX2) {
+        struct na_ofi_sin_addr *sin_addr = addr;
+        node_str = inet_ntoa(sin_addr->sin.sin_addr);
+        sprintf (service_str, "%d", ntohs(sin_addr->sin.sin_port));
+
+        /* Resolve node / service (always pass a numeric host) */
+        rc = fi_getinfo(NA_OFI_VERSION, node_str,
+            service_str /* service */,
+            0 /* flags */,
+            domain->fi_prov /* hints */, &tmp_info);
+        if (rc != 0) {
+            NA_LOG_ERROR("fi_getinfo (%s:%s) failed, rc: %d(%s).",
+                         node_str, service_str, rc, fi_strerror(-rc));
+            ret = NA_PROTOCOL_ERROR;
+            goto out;
+        }
+        addr = tmp_info->dest_addr;
+    }
+
+    na_ofi_domain_lock(domain);
+    rc = fi_av_insert(domain->fi_av, tmp_info->dest_addr, 1, fi_addr,
+            0 /* flags */, NULL /* context */);
+    na_ofi_domain_unlock(domain);
+
+    if (rc < 0) {
+        NA_LOG_ERROR("fi_av_insert/svc failed(node %s, service %s), rc: %d(%s).",
+                     node_str, service_str, rc, fi_strerror(-rc));
+        ret = NA_PROTOCOL_ERROR;
+        goto out;
+    }
+
+    /* The below just to verify the AV address resolution */
+    /*
+    void *peer_addr;
+    char peer_addr_str[NA_OFI_MAX_URI_LEN] = {'\0'};
+
+    peer_addr = malloc(addrlen);
+    if (peer_addr == NULL) {
+        NA_LOG_ERROR("Could not allocate peer_addr.");
+        ret = NA_NOMEM_ERROR;
+        goto out;
+    }
+    rc = fi_av_lookup(domain->fi_av, *fi_addr, peer_addr, &addrlen);
+    if (rc != 0) {
+        NA_LOG_ERROR("fi_av_lookup failed, rc: %d(%s).", rc, fi_strerror(-rc));
+        ret = NA_PROTOCOL_ERROR;
+        goto out;
+    }
+    addrlen = NA_OFI_MAX_URI_LEN;
+    fi_av_straddr(domain->fi_av, peer_addr, peer_addr_str, &addrlen);
+    NA_LOG_DEBUG("node %s, service %s, peer address %s.",
+                 node_str, service_str, peer_addr_str);
+    free(peer_addr);
+    */
+out:
+    return ret;
+}
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
@@ -1268,7 +1349,7 @@ na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
 
     /* Generate key */
     *addr_key = na_ofi_addr_to_key(addr_format, addr, addrlen);
-    NA_CHECK_ERROR(*addr_key == 0, out, ret, NA_PROTONOSUPPORT,
+    NA_CHECK_ERROR(*addr_key == 0, out, ret, NA_PROTOCOL_ERROR,
         "Could not generate key from addr");
 
     /* Lookup key */
@@ -1282,10 +1363,8 @@ na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
     }
 
     /* Insert addr into AV if key not found */
-    na_ofi_domain_lock(domain);
-    rc = fi_av_insert(domain->fi_av, addr, 1, fi_addr, 0 /* flags */, NULL);
-    na_ofi_domain_unlock(domain);
-    NA_CHECK_ERROR(rc < 1, out, ret, NA_PROTOCOL_ERROR,
+    rc = na_ofi_av_insert(domain, addr, addrlen, fi_addr);
+    NA_CHECK_ERROR(rc != NA_SUCCESS, out, ret, NA_PROTOCOL_ERROR,
         "fi_av_insert() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
     hg_thread_rwlock_wrlock(&domain->rwlock);
@@ -1302,12 +1381,12 @@ na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
 
     /* Allocate new key */
     ht_key = malloc(sizeof(na_uint64_t));
-    NA_CHECK_ERROR(ht_key == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(ht_key == NULL, error, ret, NA_NOMEM_ERROR,
         "Cannot allocate memory for ht_key");
 
     /* Allocate new value */
     ht_value = malloc(sizeof(*fi_addr));
-    NA_CHECK_ERROR(ht_value == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(ht_value == NULL, error, ret, NA_NOMEM_ERROR,
         "cannot allocate memory for ht_key");
 
     *((na_uint64_t *) ht_key) = *addr_key;
@@ -1315,7 +1394,7 @@ na_ofi_addr_ht_lookup(struct na_ofi_domain *domain, na_uint32_t addr_format,
 
     /* Insert new value */
     rc = hg_hash_table_insert(domain->addr_ht, ht_key, ht_value);
-    NA_CHECK_ERROR(rc == 0, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(rc == 0, error, ret, NA_NOMEM_ERROR,
         "hg_hash_table_insert() failed");
 
 unlock:
@@ -1341,7 +1420,7 @@ na_ofi_addr_ht_remove(struct na_ofi_domain *domain, fi_addr_t *fi_addr,
 
     hg_thread_rwlock_wrlock(&domain->rwlock);
     rc = hg_hash_table_remove(domain->addr_ht, (hg_hash_table_key_t) addr_key);
-    NA_CHECK_ERROR(rc != 1, unlock, ret, NA_NOENTRY,
+    NA_CHECK_ERROR(rc != 1, unlock, ret, NA_PROTOCOL_ERROR,
         "hg_hash_table_remove() failed");
 
     rc = fi_av_remove(domain->fi_av, fi_addr, 1, 0 /* flags */);
@@ -1366,7 +1445,7 @@ na_ofi_av_lookup(struct na_ofi_domain *na_ofi_domain, fi_addr_t fi_addr,
 
 retry:
     addr = malloc(addrlen);
-    NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate %zu bytes for address", addrlen);
 
     /* Lookup address from AV */
@@ -1404,13 +1483,13 @@ na_ofi_getinfo(enum na_ofi_prov_type prov_type, struct fi_info **providers)
       * Hints to query && filter providers.
       */
     hints = fi_allocinfo();
-    NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM_ERROR,
         "fi_allocinfo() failed");
 
     /* Protocol name is provider name, filter out providers within libfabric */
     hints->fabric_attr->prov_name = strdup(na_ofi_prov_name[prov_type]);
     NA_CHECK_ERROR(hints->fabric_attr->prov_name == NULL, cleanup, ret,
-        NA_NOMEM, "Could not duplicate name");
+        NA_NOMEM_ERROR, "Could not duplicate name");
 
     /* mode: operational mode, NA_OFI passes in context for communication calls. */
     /* FI_ASYNC_IOV mode indicates  that  the  application  must  provide  the
@@ -1499,7 +1578,7 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
 
     /* Allocate new sin addr to store result */
     na_ofi_sin_addr = calloc(1, sizeof(*na_ofi_sin_addr));
-    NA_CHECK_ERROR(na_ofi_sin_addr == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_sin_addr == NULL, out, ret, NA_NOMEM_ERROR,
         "Could not allocate sin address");
     na_ofi_sin_addr->sin.sin_family = AF_INET;
     na_ofi_sin_addr->sin.sin_port = htons(port & 0xffff);
@@ -1519,7 +1598,7 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
             const char *ptr = inet_ntop(rp->ai_addr->sa_family,
                 &((struct sockaddr_in *) rp->ai_addr)->sin_addr, ip_res,
                 INET_ADDRSTRLEN);
-            NA_CHECK_ERROR(ptr == NULL, out, ret, NA_ADDRNOTAVAIL,
+            NA_CHECK_ERROR(ptr == NULL, out, ret, NA_PROTOCOL_ERROR,
                 "IP could not be resolved");
             break;
         }
@@ -1527,7 +1606,7 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
 
     /* Check and compare interfaces */
     s = getifaddrs(&ifaddrs);
-    NA_CHECK_ERROR(s == -1, out, ret, NA_ADDRNOTAVAIL,
+    NA_CHECK_ERROR(s == -1, out, ret, NA_PROTOCOL_ERROR,
         "getifaddrs() failed");
 
     for (ifaddr = ifaddrs; ifaddr != NULL; ifaddr = ifaddr->ifa_next) {
@@ -1544,7 +1623,7 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
         ptr = inet_ntop(ifaddr->ifa_addr->sa_family,
             &((struct sockaddr_in *) ifaddr->ifa_addr)->sin_addr, ip,
             INET_ADDRSTRLEN);
-        NA_CHECK_ERROR(ptr == NULL, out, ret, NA_ADDRNOTAVAIL,
+        NA_CHECK_ERROR(ptr == NULL, out, ret, NA_PROTOCOL_ERROR,
             "IP could not be resolved for: %s", ifaddr->ifa_name);
 
         /* Compare hostnames / device names */
@@ -1560,7 +1639,7 @@ na_ofi_check_interface(const char *hostname, unsigned int port,
         *na_ofi_sin_addr_ptr = na_ofi_sin_addr;
         if (ifa_name) {
             *ifa_name = strdup(ifaddr->ifa_name);
-            NA_CHECK_ERROR(*ifa_name == NULL, out, ret, NA_NOMEM,
+            NA_CHECK_ERROR(*ifa_name == NULL, out, ret, NA_NOMEM_ERROR,
                 "Could not dup ifa_name");
         }
     }
@@ -1650,7 +1729,8 @@ na_ofi_domain_open(struct na_ofi_class *priv, enum na_ofi_prov_type prov_type,
     }
     hg_thread_mutex_unlock(&na_ofi_domain_list_mutex_g);
     if (domain_found) {
-        NA_LOG_DEBUG("Found existing domain (%s)", na_ofi_domain->prov_name);
+//        NA_LOG_DEBUG("Found existing domain (%s)",
+//            na_ofi_domain->prov_name);
         *na_ofi_domain_p = na_ofi_domain;
         return ret;
     }
@@ -1663,45 +1743,45 @@ na_ofi_domain_open(struct na_ofi_class *priv, enum na_ofi_prov_type prov_type,
     prov = providers;
     while (prov != NULL) {
         if (na_ofi_verify_provider(prov_type, domain_name, prov)) {
-            NA_LOG_DEBUG("mode 0x%llx, fabric_attr -> prov_name: %s, name: %s; "
-                "domain_attr -> name: %s, threading: %d.", prov->mode,
-                prov->fabric_attr->prov_name, prov->fabric_attr->name,
-                prov->domain_attr->name, prov->domain_attr->threading);
+//            NA_LOG_DEBUG("mode 0x%llx, fabric_attr -> prov_name: %s, name: %s; "
+//                "domain_attr -> name: %s, threading: %d.", prov->mode,
+//                prov->fabric_attr->prov_name, prov->fabric_attr->name,
+//                prov->domain_attr->name, prov->domain_attr->threading);
             prov_found = NA_TRUE;
             break;
         }
         prov = prov->next;
     }
-    NA_CHECK_ERROR(!prov_found, error, ret, NA_NOENTRY,
+    NA_CHECK_ERROR(!prov_found, error, ret, NA_PROTOCOL_ERROR,
         "No provider found for \"%s\" provider on domain \"%s\"",
         na_ofi_prov_name[prov_type], domain_name);
 
     na_ofi_domain = (struct na_ofi_domain *) malloc(
         sizeof(struct na_ofi_domain));
-    NA_CHECK_ERROR(na_ofi_domain == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_domain == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate na_ofi_domain");
     memset(na_ofi_domain, 0, sizeof(struct na_ofi_domain));
     hg_atomic_init32(&na_ofi_domain->refcount, 1);
 
     /* Init mutex */
     rc = hg_thread_mutex_init(&na_ofi_domain->mutex);
-    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_NOMEM_ERROR,
         "hg_thread_mutex_init() failed");
 
     /* Init rw lock */
     rc = hg_thread_rwlock_init(&na_ofi_domain->rwlock);
-    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(rc != HG_UTIL_SUCCESS, error, ret, NA_NOMEM_ERROR,
         "hg_thread_rwlock_init() failed");
 
     /* Keep fi_info */
     na_ofi_domain->fi_prov = fi_dupinfo(prov);
     NA_CHECK_ERROR(na_ofi_domain->fi_prov == NULL, error, ret,
-        NA_NOMEM, "Could not duplicate fi_info");
+        NA_NOMEM_ERROR, "Could not duplicate fi_info");
 
     /* Dup provider name */
     na_ofi_domain->prov_name = strdup(prov->fabric_attr->prov_name);
     NA_CHECK_ERROR(na_ofi_domain->prov_name == NULL, error, ret,
-        NA_NOMEM, "Could not duplicate name");
+        NA_NOMEM_ERROR, "Could not duplicate name");
 
     na_ofi_domain->prov_type = prov_type;
 
@@ -1750,12 +1830,12 @@ na_ofi_domain_open(struct na_ofi_class *priv, enum na_ofi_prov_type prov_type,
             MIN(na_ofi_domain->fi_prov->domain_attr->tx_ctx_cnt,
                 na_ofi_domain->fi_prov->domain_attr->rx_ctx_cnt);
         NA_CHECK_ERROR(priv->max_contexts > min_ctx_cnt, error, ret,
-            NA_INVALID_ARG, "Maximum number of requested contexts (%d) "
+            NA_INVALID_PARAM, "Maximum number of requested contexts (%d) "
             "exceeds provider limitation (%d)", priv->max_contexts,
             min_ctx_cnt);
-        NA_LOG_DEBUG("fi_domain created, tx_ctx_cnt %d, rx_ctx_cnt %d",
-            na_ofi_domain->fi_prov->domain_attr->tx_ctx_cnt,
-            na_ofi_domain->fi_prov->domain_attr->rx_ctx_cnt);
+//        NA_LOG_DEBUG("fi_domain created, tx_ctx_cnt %d, rx_ctx_cnt %d.",
+//            na_ofi_domain->fi_prov->domain_attr->tx_ctx_cnt,
+//            na_ofi_domain->fi_prov->domain_attr->rx_ctx_cnt);
     }
 
 #ifdef NA_OFI_HAS_EXT_GNI_H
@@ -1821,7 +1901,7 @@ na_ofi_domain_open(struct na_ofi_class *priv, enum na_ofi_prov_type prov_type,
     na_ofi_domain->addr_ht = hg_hash_table_new(na_ofi_addr_ht_key_hash,
         na_ofi_addr_ht_key_equal);
         NA_CHECK_ERROR(na_ofi_domain->addr_ht == NULL, error, ret,
-            NA_NOMEM, "hg_hash_table_new() failed");
+            NA_NOMEM_ERROR, "hg_hash_table_new() failed");
     hg_hash_table_register_free_functions(na_ofi_domain->addr_ht, free, free);
 
     /* Insert to global domain list */
@@ -1922,8 +2002,9 @@ out:
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
-    const char *node, void *src_addr, na_size_t src_addrlen, na_bool_t no_wait,
-    na_uint8_t max_contexts, struct na_ofi_endpoint **na_ofi_endpoint_p)
+    const char *node, const char *service, void *src_addr,
+    na_size_t src_addrlen, na_bool_t no_wait, na_uint8_t max_contexts,
+    struct na_ofi_endpoint **na_ofi_endpoint_p)
 {
     struct na_ofi_endpoint *na_ofi_endpoint;
     struct fi_info *hints = NULL;
@@ -1934,13 +2015,29 @@ na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
 
     na_ofi_endpoint = (struct na_ofi_endpoint *) malloc(
         sizeof(struct na_ofi_endpoint));
-    NA_CHECK_ERROR(na_ofi_endpoint == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_endpoint == NULL, out, ret, NA_NOMEM_ERROR,
         "Could not allocate na_ofi_endpoint");
     memset(na_ofi_endpoint, 0, sizeof(struct na_ofi_endpoint));
 
+    /* Dup node string */
+    if (node && strcmp("\0", node)
+        && !(na_ofi_endpoint->src_node = strdup(node))) {
+        NA_LOG_ERROR("Could not duplicate node name");
+        ret = NA_NOMEM_ERROR;
+        goto out;
+    }
+
+    /* Dup service string */
+    if (service && strcmp("\0", service)
+            && !(na_ofi_endpoint->src_service = strdup(service))) {
+        NA_LOG_ERROR("Could not duplicate service name");
+        ret = NA_NOMEM_ERROR;
+        goto out;
+    }
+
     /* Dup fi_info */
     hints = fi_dupinfo(na_ofi_domain->fi_prov);
-    NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(hints == NULL, out, ret, NA_NOMEM_ERROR,
         "Could not duplicate fi_info");
 
     if (src_addr) {
@@ -1955,7 +2052,7 @@ na_ofi_endpoint_open(const struct na_ofi_domain *na_ofi_domain,
     hints->ep_attr->tx_ctx_cnt = max_contexts;
     hints->ep_attr->rx_ctx_cnt = max_contexts;
 
-    rc = fi_getinfo(NA_OFI_VERSION, node, NULL, flags, hints,
+    rc = fi_getinfo(NA_OFI_VERSION, node, service, flags, hints,
         &na_ofi_endpoint->fi_prov);
     NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTOCOL_ERROR,
         "fi_getinfo(%s) failed, rc: %d(%s)", node, rc, fi_strerror(-rc));
@@ -2005,7 +2102,7 @@ na_ofi_basic_ep_open(const struct na_ofi_domain *na_ofi_domain,
     /* Initialize queue / mutex */
     na_ofi_endpoint->unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
     NA_CHECK_ERROR(na_ofi_endpoint->unexpected_op_queue == NULL, out,
-        ret, NA_NOMEM, "Could not allocate unexpected_op_queue");
+        ret, NA_NOMEM_ERROR, "Could not allocate unexpected_op_queue");
     HG_QUEUE_INIT(&na_ofi_endpoint->unexpected_op_queue->queue);
     hg_thread_spin_init(&na_ofi_endpoint->unexpected_op_queue->lock);
 
@@ -2101,7 +2198,7 @@ na_ofi_endpoint_close(struct na_ofi_endpoint *na_ofi_endpoint)
         /* Check that unexpected op queue is empty */
         na_bool_t empty = HG_QUEUE_IS_EMPTY(
             &na_ofi_endpoint->unexpected_op_queue->queue);
-        NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_BUSY,
+        NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_PROTOCOL_ERROR,
             "Unexpected op queue should be empty");
         hg_thread_spin_destroy(&na_ofi_endpoint->unexpected_op_queue->lock);
         free(na_ofi_endpoint->unexpected_op_queue);
@@ -2160,12 +2257,12 @@ na_ofi_get_ep_addr(na_class_t *na_class, struct na_ofi_addr **na_ofi_addr_ptr)
     int rc;
 
     na_ofi_addr = na_ofi_addr_alloc(priv->domain);
-    NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate NA OFI addr");
 
 retry:
     addr = malloc(addrlen);
-    NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(addr == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate addr");
 
     rc = fi_getname(&na_ofi_endpoint->fi_ep->fid, addr, &addrlen);
@@ -2174,9 +2271,14 @@ retry:
         free(addr);
         goto retry;
     }
-    NA_CHECK_ERROR(rc != 0, error, ret, NA_PROTOCOL_ERROR,
-        "fi_getname() failed, rc: %d(%s), addrlen: %zu", rc, fi_strerror(-rc),
-        addrlen);
+
+    /**
+     * addr now contains the ip:service string internal to psm2. overwrite it
+     * the external ip:port string
+     */
+    struct sockaddr_in *my_sin_addr = addr;
+    my_sin_addr->sin_addr.s_addr = inet_addr(priv->endpoint->src_node);
+    my_sin_addr->sin_port = htons(atoi(priv->endpoint->src_service));
 
     na_ofi_addr->addr = addr;
     na_ofi_addr->addrlen = addrlen;
@@ -2202,6 +2304,7 @@ error:
 static na_return_t
 na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
 {
+    struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
     struct na_ofi_domain *na_ofi_domain = NA_OFI_CLASS(na_class)->domain;
     char addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
         fi_addr_str[NA_OFI_MAX_URI_LEN] = {'\0'},
@@ -2210,31 +2313,43 @@ na_ofi_get_uri(na_class_t *na_class, const void *addr, char **uri_ptr)
     na_return_t ret = NA_SUCCESS;
     int rc;
 
-    /* Convert FI address to a printable string */
-    fi_av_straddr(na_ofi_domain->fi_av, addr, fi_addr_str, &fi_addr_strlen);
-    NA_CHECK_ERROR(fi_addr_strlen > NA_OFI_MAX_URI_LEN, out, ret,
-        NA_PROTOCOL_ERROR, "fi_av_straddr() address truncated, addrlen: %zu",
-        fi_addr_strlen);
-
-    /* Remove unnecessary "://" prefix from string if present */
-    if (strstr(fi_addr_str, "://")) {
-        strtok_r(fi_addr_str, ":", &fi_addr_str_ptr);
-        rc = strncmp(fi_addr_str_ptr, "//", 2);
-        NA_CHECK_ERROR(rc != 0, out, ret, NA_PROTONOSUPPORT,
-            "Bad address string format");
-        fi_addr_str_ptr += 2;
-    } else
+    if (na_ofi_domain->prov_type == NA_OFI_PROV_PSM2) {
+        /* do not use fi_av_straddr(), as it returns the psm2 native URI */
+        snprintf(fi_addr_str, fi_addr_strlen, "%s:%s",
+            priv->endpoint->src_node, priv->endpoint->src_service);
         fi_addr_str_ptr = fi_addr_str;
+    } else {
+        /* Convert FI address to a printable string */
+        fi_av_straddr(na_ofi_domain->fi_av, addr, fi_addr_str, &fi_addr_strlen);
+        if (fi_addr_strlen > NA_OFI_MAX_URI_LEN) {
+            NA_LOG_ERROR("fi_av_straddr() address truncated, addrlen: %zu",
+                fi_addr_strlen);
+            ret = NA_PROTOCOL_ERROR;
+            goto out;
+        }
+
+        /* Remove unnecessary "://" prefix from string if present */
+        if (strstr(fi_addr_str, "://")) {
+            strtok_r(fi_addr_str, ":", &fi_addr_str_ptr);
+            if (strncmp(fi_addr_str_ptr, "//", 2) != 0) {
+                NA_LOG_ERROR("Bad address string format");
+                ret = NA_PROTOCOL_ERROR;
+                goto out;
+            }
+            fi_addr_str_ptr += 2;
+        } else
+            fi_addr_str_ptr = fi_addr_str;
+    }
 
     /* Generate URI */
     rc = snprintf(addr_str, NA_OFI_MAX_URI_LEN, "%s://%s",
         na_ofi_domain->fi_prov->fabric_attr->prov_name, fi_addr_str_ptr);
     NA_CHECK_ERROR(rc < 0 || rc > NA_OFI_MAX_URI_LEN, out, ret,
-        NA_OVERFLOW, "snprintf() failed or name truncated, rc: %d", rc);
+        NA_PROTOCOL_ERROR, "snprintf() failed or name truncated, rc: %d", rc);
 
     /* Dup URI */
     uri = strdup(addr_str);
-    NA_CHECK_ERROR(uri == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(uri == NULL, out, ret, NA_NOMEM_ERROR,
         "Could not strdup address string");
 
     *uri_ptr = uri;
@@ -2285,8 +2400,8 @@ na_ofi_addr_decref(struct na_ofi_addr *na_ofi_addr)
     /* Do not call fi_av_remove() here to prevent multiple insert/remove calls
      * into AV */
     if (na_ofi_addr->remove) {
-        NA_LOG_DEBUG("fi_addr=%" SCNx64 " ht_key=%" SCNx64,
-            na_ofi_addr->fi_addr, na_ofi_addr->ht_key);
+//        NA_LOG_DEBUG("fi_addr=%" SCNx64 " ht_key=%" SCNx64,
+//            na_ofi_addr->fi_addr, na_ofi_addr->ht_key);
         na_ofi_addr_ht_remove(na_ofi_addr->domain, &na_ofi_addr->fi_addr,
             &na_ofi_addr->ht_key);
     }
@@ -2496,6 +2611,16 @@ na_ofi_op_id_decref(struct na_ofi_op_id *na_ofi_op_id)
     return;
 }
 
+/*---------------------------------------------------------------------------*/
+static NA_INLINE na_bool_t
+na_ofi_op_id_valid(struct na_ofi_op_id *na_ofi_op_id)
+{
+    if (na_ofi_op_id == NULL)
+        return NA_FALSE;
+
+    return NA_TRUE;
+}
+
 /*---------------------------------------------------------------------------*/
 static NA_INLINE void
 na_ofi_msg_unexpected_op_push(na_context_t *context,
@@ -2521,9 +2646,24 @@ na_ofi_msg_unexpected_op_remove(na_context_t *context,
     hg_thread_spin_unlock(&ctx->unexpected_op_queue->lock);
 }
 
+/*---------------------------------------------------------------------------*/
+static NA_INLINE struct na_ofi_op_id *
+na_ofi_msg_unexpected_op_pop(na_context_t *context)
+{
+    struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
+    struct na_ofi_op_id *na_ofi_op_id;
+
+    hg_thread_spin_lock(&ctx->unexpected_op_queue->lock);
+    na_ofi_op_id = HG_QUEUE_FIRST(&ctx->unexpected_op_queue->queue);
+    HG_QUEUE_POP_HEAD(&ctx->unexpected_op_queue->queue, entry);
+    hg_thread_spin_unlock(&ctx->unexpected_op_queue->lock);
+
+    return na_ofi_op_id;
+}
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_cq_read(na_context_t *context, size_t max_count,
+na_ofi_cq_read(na_class_t *na_class, na_context_t *context, size_t max_count,
     struct fi_cq_tagged_entry cq_events[], fi_addr_t src_addrs[],
     void **src_err_addr, size_t *src_err_addrlen, size_t *actual_count)
 {
@@ -2558,43 +2698,50 @@ na_ofi_cq_read(na_context_t *context, size_t max_count,
         "fi_cq_readerr() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
 
     switch (cq_err.err) {
-        case FI_ECANCELED: {
-            struct na_ofi_op_id *na_ofi_op_id = container_of(
-                cq_err.op_context, struct na_ofi_op_id, fi_ctx);
+        case FI_ECANCELED:
+//            NA_LOG_DEBUG("got a FI_ECANCELED event, cq_event.flags 0x%x.",
+//                         cq_err.flags);
+            goto out;
 
-            NA_CHECK_ERROR(na_ofi_op_id == NULL, out, ret, NA_INVALID_ARG,
-                "Invalid operation ID");
-            NA_CHECK_ERROR(
-                hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED,
-                out, ret, NA_FAULT, "Operation ID was completed");
-            NA_LOG_DEBUG("FI_ECANCELED event on operation ID %p", na_ofi_op_id);
-            NA_CHECK_ERROR(
-                !(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_CANCELED),
-                out, ret, NA_FAULT, "Operation ID was not canceled");
+        case FI_EADDRNOTAVAIL: {
+            struct na_ofi_class *priv = NA_OFI_CLASS(na_class);
+            struct fid_av *av_hdl = priv->domain->fi_av;
+            void *err_addr = NULL;
+            size_t err_addrlen;
 
-            if (na_ofi_op_id->completion_data.callback_info.type
-                == NA_CB_RECV_UNEXPECTED) {
-                /* Remove OP ID from OP queue if canceled */
-                na_ofi_msg_unexpected_op_remove(context, na_ofi_op_id);
+            /* Copy addr information */
+            err_addr = malloc(cq_err.err_data_size);
+            NA_CHECK_ERROR(err_addr == NULL, out, ret, NA_NOMEM_ERROR,
+                "Could not allocate err_addr");
+            err_addrlen = cq_err.err_data_size;
+            memcpy(err_addr, cq_err.err_data, err_addrlen);
+
+            na_ofi_domain_lock(priv->domain);
+            /* Insert new source addr into AV if address was not found */
+            rc = fi_av_insert(av_hdl, err_addr, 1, &src_addrs[0],
+                0 /* flags */, NULL /* context */);
+            na_ofi_domain_unlock(priv->domain);
+            if (unlikely(rc < 1)) {
+                free(err_addr);
+                NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
+                    "fi_av_insert() failed, rc: %d(%s)",
+                    rc, fi_strerror((int) -rc));
             }
-
-            /* Complete operation in canceled state */
-            ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
-            NA_CHECK_NA_ERROR(out, ret, "Unable to complete operation");
-         }
-            break;
-
-        case FI_EADDRNOTAVAIL:
             /* Only one error event processed in that case */
             memcpy(&cq_events[0], &cq_err, sizeof(cq_events[0]));
             *src_err_addr = cq_err.err_data;
             *src_err_addrlen = cq_err.err_data_size;
             *actual_count = 1;
             break;
-
+        }
+        case FI_EIO:
+            NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
+                "fi_cq_readerr() got err: %d(%s), prov_errno: %d(%s)",
+                cq_err.err, fi_strerror(cq_err.err), cq_err.prov_errno,
+                fi_strerror(-cq_err.prov_errno));
+            break;
         default:
-            /* Ignore errors from OFI that we cannot handle */
-            NA_LOG_WARNING(
+            NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
                 "fi_cq_readerr() got err: %d(%s), prov_errno: %d(%s)",
                 cq_err.err, fi_strerror(cq_err.err), cq_err.prov_errno,
                 fi_strerror(-cq_err.prov_errno));
@@ -2615,11 +2762,16 @@ na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
         cq_event->op_context, struct na_ofi_op_id, fi_ctx);
     na_return_t ret = NA_SUCCESS;
 
-    NA_CHECK_ERROR(na_ofi_op_id == NULL, out, ret, NA_INVALID_ARG,
-        "Invalid operation ID");
-    /* Cannot have an already completed operation ID, sanity check */
-    NA_CHECK_ERROR(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED,
-        out, ret, NA_FAULT, "Operation ID was completed");
+    NA_CHECK_ERROR(!na_ofi_op_id_valid(na_ofi_op_id), out, ret,
+        NA_PROTOCOL_ERROR, "Bad na_ofi_op_id, ignoring event");
+    if (hg_atomic_get32(&na_ofi_op_id->canceled)) {
+        ret = NA_CANCELED;
+        goto complete;
+    }
+    // TODO check that
+    if (hg_atomic_get32(&na_ofi_op_id->completed))
+        NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
+            "Ignoring CQ event as the op is completed");
 
     if (cq_event->flags & FI_SEND) {
         ret = na_ofi_cq_process_send_event(na_ofi_op_id);
@@ -2641,9 +2793,10 @@ na_ofi_cq_process_event(na_class_t *na_class, na_context_t *context,
         ret = na_ofi_cq_process_rma_event(na_ofi_op_id);
         NA_CHECK_NA_ERROR(out, ret, "Could not process rma event");
     } else
-        NA_GOTO_ERROR(out, ret, NA_PROTONOSUPPORT,
+        NA_GOTO_ERROR(out, ret, NA_PROTOCOL_ERROR,
             "Unsupported CQ event flags: 0x%x.", cq_event->flags);
 
+complete:
     /* Complete operation */
     ret = na_ofi_complete(na_ofi_op_id, ret);
     NA_CHECK_NA_ERROR(out, ret, "Unable to complete operation");
@@ -2680,14 +2833,14 @@ na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
     na_return_t ret = NA_SUCCESS;
 
     NA_CHECK_ERROR(cb_type != NA_CB_RECV_UNEXPECTED, out, ret,
-        NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_RECV_UNEXPECTED",
+        NA_PROTOCOL_ERROR, "Invalid cb_type %d, expected NA_CB_RECV_UNEXPECTED",
         cb_type);
-    NA_CHECK_ERROR(tag > NA_OFI_MAX_TAG, out, ret, NA_OVERFLOW,
+    NA_CHECK_ERROR(tag > NA_OFI_MAX_TAG, out, ret, NA_PROTOCOL_ERROR,
         "Invalid tag value");
 
     /* Allocate new address */
     na_ofi_addr = na_ofi_addr_alloc(domain);
-    NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM_ERROR,
         "na_ofi_addr_alloc() failed");
     /* Unexpected addresses do not need to set addr/addrlen info, fi_av_lookup()
      * can be used when needed. */
@@ -2709,7 +2862,7 @@ na_ofi_cq_process_recv_unexpected_event(na_class_t *na_class,
             &na_ofi_addr->ht_key);
         NA_CHECK_NA_ERROR(error, ret, "na_ofi_addr_ht_lookup() failed");
     } else
-        NA_GOTO_ERROR(error, ret, NA_PROTONOSUPPORT,
+        NA_GOTO_ERROR(error, ret, NA_PROTOCOL_ERROR,
             "Insufficient address information");
 
     na_ofi_addr_addref(na_ofi_addr); /* decref in addr_free() */
@@ -2735,10 +2888,10 @@ na_ofi_cq_process_recv_expected_event(struct na_ofi_op_id *na_ofi_op_id,
     na_return_t ret = NA_SUCCESS;
 
     NA_CHECK_ERROR(cb_type != NA_CB_RECV_EXPECTED, out, ret,
-        NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_RECV_EXPECTED",
+        NA_PROTOCOL_ERROR, "Invalid cb_type %d, expected NA_CB_RECV_EXPECTED",
         cb_type);
     NA_CHECK_ERROR(na_ofi_op_id->info.recv_expected.tag
-        != (tag & ~NA_OFI_EXPECTED_TAG_FLAG), out, ret, NA_INVALID_ARG,
+        != (tag & ~NA_OFI_EXPECTED_TAG_FLAG), out, ret, NA_PROTOCOL_ERROR,
         "Invalid tag 0x%x, expected 0x%x",
         na_ofi_op_id->info.recv_expected.tag,
         tag & ~NA_OFI_EXPECTED_TAG_FLAG);
@@ -2757,7 +2910,7 @@ na_ofi_cq_process_rma_event(struct na_ofi_op_id *na_ofi_op_id)
     na_return_t ret = NA_SUCCESS;
 
     NA_CHECK_ERROR(cb_type != NA_CB_PUT && cb_type != NA_CB_GET, out, ret,
-        NA_INVALID_ARG, "Invalid cb_type %d, expected NA_CB_PUT/GET",
+        NA_PROTOCOL_ERROR, "Invalid cb_type %d, expected NA_CB_PUT/GET",
         cb_type);
 
 out:
@@ -2770,61 +2923,46 @@ na_ofi_complete(struct na_ofi_op_id *na_ofi_op_id, na_return_t op_ret)
 {
     struct na_ofi_addr *na_ofi_addr = na_ofi_op_id->addr;
     struct na_cb_info *callback_info = NULL;
-#if defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
-    hg_util_int32_t status;
-#endif
     na_return_t ret = NA_SUCCESS;
 
-#if !defined(HG_UTIL_HAS_OPA_PRIMITIVES_H)
-    /* Mark op id as completed before checking for cancelation */
-    hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
-#else
-    do {
-        status = hg_atomic_get32(&na_ofi_op_id->status);
-    } while (!hg_atomic_cas32(&na_ofi_op_id->status, status,
-        (status | NA_OFI_OP_COMPLETED)));
-#endif
-
-    /* If it was canceled while being processed, set callback ret accordingly */
-    if (hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_CANCELED) {
-        NA_LOG_DEBUG("Operation ID %p was canceled", na_ofi_op_id);
-        op_ret = (op_ret == NA_SUCCESS) ? NA_CANCELED : op_ret;
-    }
+    /* Mark op id as completed */
+    if (!hg_atomic_cas32(&na_ofi_op_id->completed, 0, 1))
+        return ret;
 
     /* Init callback info */
     callback_info = &na_ofi_op_id->completion_data.callback_info;
     callback_info->ret = op_ret;
 
     switch (callback_info->type) {
-        case NA_CB_LOOKUP:
-            callback_info->info.lookup.addr =
-                na_ofi_op_id->info.lookup.addr;
-            break;
-        case NA_CB_RECV_UNEXPECTED:
-            /* Fill callback info */
-            callback_info->info.recv_unexpected.actual_buf_size =
-                na_ofi_op_id->info.recv_unexpected.msg_size;
-            callback_info->info.recv_unexpected.source =
-                na_ofi_op_id->addr;
-            callback_info->info.recv_unexpected.tag =
-                na_ofi_op_id->info.recv_unexpected.tag;
-            break;
-        case NA_CB_RECV_EXPECTED:
-            /* Check buf_size and msg_size */
-            NA_CHECK_ERROR(
-                na_ofi_op_id->info.recv_expected.msg_size >
+    case NA_CB_LOOKUP:
+        callback_info->info.lookup.addr =
+            na_ofi_op_id->info.lookup.addr;
+        break;
+    case NA_CB_RECV_UNEXPECTED:
+        /* Fill callback info */
+        callback_info->info.recv_unexpected.actual_buf_size =
+            na_ofi_op_id->info.recv_unexpected.msg_size;
+        callback_info->info.recv_unexpected.source =
+            na_ofi_op_id->addr;
+        callback_info->info.recv_unexpected.tag =
+            na_ofi_op_id->info.recv_unexpected.tag;
+        break;
+    case NA_CB_RECV_EXPECTED:
+        /* Check buf_size and msg_size */
+        NA_CHECK_ERROR(
+            na_ofi_op_id->info.recv_expected.msg_size >
             na_ofi_op_id->info.recv_expected.buf_size, out, ret,
-            NA_MSGSIZE, "Expected recv msg size too large for buffer");
-            break;
-        case NA_CB_SEND_UNEXPECTED:
-        case NA_CB_SEND_EXPECTED:
-        case NA_CB_PUT:
-        case NA_CB_GET:
-            break;
-        default:
-            NA_GOTO_ERROR(out, ret, NA_INVALID_ARG,
-                "Operation type %d not supported", callback_info->type);
-            break;
+            NA_SIZE_ERROR, "Expected recv msg size too large for buffer");
+        break;
+    case NA_CB_SEND_UNEXPECTED:
+    case NA_CB_SEND_EXPECTED:
+    case NA_CB_PUT:
+    case NA_CB_GET:
+        break;
+    default:
+        NA_GOTO_ERROR(out, ret, NA_INVALID_PARAM,
+            "Operation type %d not supported", callback_info->type);
+        break;
     }
 
     /* Add OP to NA completion queue */
@@ -2845,9 +2983,8 @@ na_ofi_release(void *arg)
 {
     struct na_ofi_op_id *na_ofi_op_id = (struct na_ofi_op_id *) arg;
 
-    NA_CHECK_WARNING(na_ofi_op_id &&
-        (!(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED)),
-        "Releasing resources from an uncompleted operation");
+    if (na_ofi_op_id && !hg_atomic_get32(&na_ofi_op_id->completed))
+        NA_LOG_WARNING("Releasing resources from an uncompleted operation");
 
     na_ofi_op_id_decref(na_ofi_op_id);
 }
@@ -2865,7 +3002,7 @@ na_ofi_check_protocol(const char *protocol_name)
     enum na_ofi_prov_type type;
 
     type = na_ofi_prov_name_to_type(protocol_name);
-    NA_CHECK_ERROR(type == NA_OFI_PROV_NULL, out, ret, NA_PROTONOSUPPORT,
+    NA_CHECK_ERROR(type == NA_OFI_PROV_NULL, out, ret, NA_PROTOCOL_ERROR,
         "Protocol %s not supported", protocol_name);
 
     /* Get info from provider */
@@ -2874,11 +3011,11 @@ na_ofi_check_protocol(const char *protocol_name)
 
     prov = providers;
     while (prov != NULL) {
-        NA_LOG_DEBUG("fabric_attr - prov_name %s, name - %s, "
-            "domain_attr - name %s, mode: 0x%llx, domain_attr->mode 0x%llx, "
-            "caps: 0x%llx", prov->fabric_attr->prov_name,
-            prov->fabric_attr->name, prov->domain_attr->name, prov->mode,
-            prov->domain_attr->mode, prov->caps);
+//        NA_LOG_DEBUG("fabric_attr - prov_name %s, name - %s, "
+//            "domain_attr - name %s, mode: 0x%llx, domain_attr->mode 0x%llx, caps: 0x%llx.",
+//            prov->fabric_attr->prov_name, prov->fabric_attr->name,
+//            prov->domain_attr->name, prov->mode, prov->domain_attr->mode,
+//            prov->caps);
         if (!strcmp(na_ofi_prov_name[type], prov->fabric_attr->prov_name)) {
             accept = NA_TRUE;
             break;
@@ -2904,6 +3041,7 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     char *host_name = NULL;
     unsigned int port = 0;
     const char *node_ptr = NULL;
+    char *service_str = NULL;
     char node[NA_OFI_MAX_URI_LEN] = {'\0'};
     char *domain_name_ptr = NULL;
     char domain_name[NA_OFI_MAX_URI_LEN] = {'\0'};
@@ -2913,13 +3051,13 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     na_return_t ret = NA_SUCCESS;
     enum na_ofi_prov_type prov_type;
 
-    NA_LOG_DEBUG("Entering na_ofi_initialize() class_name %s, protocol_name %s,"
-        " host_name %s", na_info->class_name, na_info->protocol_name,
-        na_info->host_name);
+//    NA_LOG_DEBUG("Entering na_ofi_initialize class_name %s, protocol_name %s, "
+//                 "host_name %s\n", na_info->class_name, na_info->protocol_name,
+//                 na_info->host_name);
 
     prov_type = na_ofi_prov_name_to_type(na_info->protocol_name);
     NA_CHECK_ERROR(prov_type == NA_OFI_PROV_NULL, out, ret,
-        NA_INVALID_ARG, "Protocol %s not supported", na_info->protocol_name);
+        NA_INVALID_PARAM, "Protocol %s not supported", na_info->protocol_name);
 
 #if defined(NA_OFI_HAS_EXT_GNI_H) && defined(NA_OFI_GNI_HAS_UDREG)
     /* In case of GNI using udreg, we check to see whether MPICH_GNI_NDREG_ENTRIES
@@ -2927,7 +3065,7 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
      * to work if Cray MPI is also used. Print error msg suggesting workaround.
      */
     NA_CHECK_ERROR(prov_type == NA_OFI_PROV_GNI
-        && !getenv("MPICH_GNI_NDREG_ENTRIES"), out, ret, NA_INVALID_ARG,
+        && !getenv("MPICH_GNI_NDREG_ENTRIES"), out, ret, NA_INVALID_PARAM,
         "ofi+gni provider requested, but the MPICH_GNI_NDREG_ENTRIES "
         "environment variable is not set.\n" "Please run this executable with "
         "\"export MPICH_GNI_NDREG_ENTRIES=1024\" to ensure compatibility."
@@ -2937,14 +3075,13 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     /* Use default interface name if no hostname was passed */
     if (na_info->host_name) {
         host_name = strdup(na_info->host_name);
-        NA_CHECK_ERROR(host_name == NULL, out, ret, NA_NOMEM,
+        NA_CHECK_ERROR(host_name == NULL, out, ret, NA_NOMEM_ERROR,
             "strdup() of host_name failed");
 
         /* Extract hostname */
         if (strstr(host_name, ":")) {
-            char *port_str = NULL;
-            strtok_r(host_name, ":", &port_str);
-            port = (unsigned int) strtoul(port_str, NULL, 10);
+            strtok_r(host_name, ":", &service_str);
+            port = (unsigned int) strtoul(service_str, NULL, 10);
         }
 
         /* Extract domain (if specified) */
@@ -2982,7 +3119,8 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
                 strncpy(domain_name, resolve_name, NA_OFI_MAX_URI_LEN - 1);
                 domain_name_ptr = domain_name;
             }
-        } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI) {
+        } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_GNI ||
+                   na_ofi_prov_addr_format[prov_type] == FI_ADDR_PSMX2) {
             struct na_ofi_sin_addr *na_ofi_sin_addr = NULL;
             const char *ptr;
 
@@ -2990,13 +3128,13 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
             ret = na_ofi_check_interface(resolve_name, 0, NULL,
                 &na_ofi_sin_addr);
             NA_CHECK_ERROR(ret != NA_SUCCESS || !na_ofi_sin_addr, out, ret,
-                NA_ADDRNOTAVAIL, "Could not check interfaces");
+                NA_PROTOCOL_ERROR, "Could not check interfaces");
 
             /* Node must match IP resolution */
             ptr = inet_ntop(na_ofi_sin_addr->sin.sin_family,
                 &na_ofi_sin_addr->sin.sin_addr, node, sizeof(node));
             free(na_ofi_sin_addr);
-            NA_CHECK_ERROR(ptr == NULL, out, ret, NA_ADDRNOTAVAIL,
+            NA_CHECK_ERROR(ptr == NULL, out, ret, NA_PROTOCOL_ERROR,
                 "Could not convert IP to string");
             node_ptr = node;
         } else if (na_ofi_prov_addr_format[prov_type] == FI_ADDR_PSMX2) {
@@ -3018,7 +3156,7 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     /* Create private data */
     na_class->plugin_class = (struct na_ofi_class *) malloc(
         sizeof(struct na_ofi_class));
-    NA_CHECK_ERROR(na_class->plugin_class == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_class->plugin_class == NULL, out, ret, NA_NOMEM_ERROR,
         "Could not allocate NA private data class");
     memset(na_class->plugin_class, 0, sizeof(struct na_ofi_class));
     priv = NA_OFI_CLASS(na_class);
@@ -3041,10 +3179,12 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
         na_ofi_prov_name[prov_type], domain_name_ptr);
 
     /* Create endpoint */
-    ret = na_ofi_endpoint_open(priv->domain, node_ptr, src_addr, src_addrlen,
-        priv->no_wait, priv->max_contexts, &priv->endpoint);
-    NA_CHECK_NA_ERROR(out, ret, "Could not create endpoint for %s",
-        resolve_name);
+    ret = na_ofi_endpoint_open(priv->domain, node_ptr, service_str, src_addr,
+        src_addrlen, priv->no_wait, priv->max_contexts, &priv->endpoint);
+    if (ret != NA_SUCCESS) {
+        NA_LOG_ERROR("Could not create endpoint for %s", resolve_name);
+        goto out;
+    }
 
     /* Get address from endpoint */
     ret = na_ofi_get_ep_addr(na_class, &priv->endpoint->src_addr);
@@ -3119,7 +3259,7 @@ na_ofi_context_create(na_class_t *na_class, void **context, na_uint8_t id)
     int rc = 0;
 
     ctx = (struct na_ofi_context *)calloc(1, sizeof(struct na_ofi_context));
-    NA_CHECK_ERROR(ctx == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(ctx == NULL, out, ret, NA_NOMEM_ERROR,
         "Could not allocate na_ofi_context");
     ctx->idx = id;
 
@@ -3135,14 +3275,14 @@ na_ofi_context_create(na_class_t *na_class, void **context, na_uint8_t id)
     } else {
         ctx->unexpected_op_queue = malloc(sizeof(struct na_ofi_queue));
         NA_CHECK_ERROR(ctx->unexpected_op_queue == NULL, error, ret,
-            NA_NOMEM, "Could not allocate unexpected_op_queue/_lock");
+            NA_NOMEM_ERROR, "Could not allocate unexpected_op_queue/_lock");
 
         /* Initialize queue / mutex */
         HG_QUEUE_INIT(&ctx->unexpected_op_queue->queue);
         hg_thread_spin_init(&ctx->unexpected_op_queue->lock);
 
         NA_CHECK_ERROR(priv->contexts >= priv->max_contexts ||
-            id >= priv->max_contexts, error, ret, NA_OPNOTSUPPORTED,
+            id >= priv->max_contexts, error, ret, NA_PROTOCOL_ERROR,
             "contexts %d, context id %d, max_contexts %d",
             priv->contexts, id, priv->max_contexts);
 
@@ -3224,7 +3364,7 @@ na_ofi_context_destroy(na_class_t *na_class, void *context)
     /* Check that unexpected op queue is empty */
     if (na_ofi_with_sep(na_class)) {
         na_bool_t empty = HG_QUEUE_IS_EMPTY(&ctx->unexpected_op_queue->queue);
-        NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_BUSY,
+        NA_CHECK_ERROR(empty == NA_FALSE, out, ret, NA_PROTOCOL_ERROR,
             "Unexpected op queue should be empty");
     }
 
@@ -3284,7 +3424,7 @@ na_ofi_op_create(na_class_t NA_UNUSED *na_class)
         "Could not allocate NA OFI operation ID");
     hg_atomic_init32(&na_ofi_op_id->refcount, 1);
     /* Completed by default */
-    hg_atomic_init32(&na_ofi_op_id->status, NA_OFI_OP_COMPLETED);
+    hg_atomic_init32(&na_ofi_op_id->completed, NA_TRUE);
 
     /* Set op ID release callbacks */
     na_ofi_op_id->completion_data.plugin_callback = na_ofi_release;
@@ -3317,7 +3457,7 @@ na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
     /* Check op_id */
     NA_CHECK_ERROR(
         op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
-        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
     na_ofi_op_id_addref(na_ofi_op_id);
@@ -3325,7 +3465,8 @@ na_ofi_addr_lookup(na_class_t *na_class, na_context_t *context,
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_LOOKUP;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
 
     /* Lookup addr */
     ret = na_ofi_addr_lookup2(na_class, name, (na_addr_t *) &na_ofi_addr);
@@ -3362,14 +3503,14 @@ na_ofi_addr_lookup2(na_class_t *na_class, const char *name, na_addr_t *addr)
 
     /* Check provider from name */
     NA_CHECK_ERROR(na_ofi_addr_prov(name) != domain->prov_type, out, ret,
-        NA_INVALID_ARG, "Unrecognized provider type found from: %s", name);
+        NA_INVALID_PARAM, "Unrecognized provider type found from: %s", name);
 
     /* Allocate addr */
     na_ofi_addr = na_ofi_addr_alloc(domain);
-    NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_addr == NULL, error, ret, NA_NOMEM_ERROR,
         "na_ofi_addr_alloc() failed");
     na_ofi_addr->uri = strdup(name);
-    NA_CHECK_ERROR(na_ofi_addr->uri == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_addr->uri == NULL, error, ret, NA_NOMEM_ERROR,
         "strdup() of URI failed");
 
     /* Convert name to address */
@@ -3460,7 +3601,7 @@ na_ofi_addr_to_string(na_class_t NA_UNUSED *na_class, char *buf,
     /* If there is no URI for address, attempt to reconstruct one */
     if (!na_ofi_addr->uri) {
         NA_CHECK_ERROR(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out, ret,
-            NA_ADDRNOTAVAIL, "Addr is not initialized");
+            NA_PROTOCOL_ERROR, "Addr is not initialized");
 
         /* If we don't have the addr either, look it up from AV */
         if (!na_ofi_addr->addr) {
@@ -3475,7 +3616,7 @@ na_ofi_addr_to_string(na_class_t NA_UNUSED *na_class, char *buf,
 
     str_len = strlen(na_ofi_addr->uri);
     if (buf) {
-        NA_CHECK_ERROR(str_len >= *buf_size, out, ret, NA_OVERFLOW,
+        NA_CHECK_ERROR(str_len >= *buf_size, out, ret, NA_SIZE_ERROR,
             "Buffer size too small to copy addr");
         strcpy(buf, na_ofi_addr->uri);
     }
@@ -3523,7 +3664,7 @@ na_ofi_addr_serialize(na_class_t NA_UNUSED *na_class, void *buf,
 
     if (!na_ofi_addr->addr) {
         NA_CHECK_ERROR(na_ofi_addr->fi_addr == FI_ADDR_UNSPEC, out, ret,
-            NA_ADDRNOTAVAIL, "Addr is not initialized");
+            NA_PROTOCOL_ERROR, "Addr is not initialized");
 
         /* If we don't have the addr, look it up from AV */
         ret = na_ofi_av_lookup(na_ofi_addr->domain, na_ofi_addr->fi_addr,
@@ -3532,7 +3673,7 @@ na_ofi_addr_serialize(na_class_t NA_UNUSED *na_class, void *buf,
     }
 
     len = na_ofi_addr->addrlen + sizeof(na_ofi_addr->addrlen);
-    NA_CHECK_ERROR(buf_size < len, out, ret, NA_OVERFLOW,
+    NA_CHECK_ERROR(buf_size < len, out, ret, NA_SIZE_ERROR,
         "Buffer size too small for serializing address");
 
     /* TODO could skip the addrlen but include it for sanity check */
@@ -3555,12 +3696,12 @@ na_ofi_addr_deserialize(na_class_t *na_class, na_addr_t *addr, const void *buf,
 
     /* Allocate addr */
     na_ofi_addr = na_ofi_addr_alloc(domain);
-    NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_addr == NULL, out, ret, NA_NOMEM_ERROR,
         "na_ofi_addr_alloc() failed");
     memcpy(&na_ofi_addr->addrlen, buf, sizeof(na_ofi_addr->addrlen));
 
     na_ofi_addr->addr = malloc(na_ofi_addr->addrlen);
-    NA_CHECK_ERROR(na_ofi_addr->addr == NULL, error, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_addr->addr == NULL, error, ret, NA_NOMEM_ERROR,
         "Could not allocate %zu bytes for address", na_ofi_addr->addrlen);
     memcpy(na_ofi_addr->addr,
         (const na_uint8_t *) buf + sizeof(na_ofi_addr->addrlen),
@@ -3698,10 +3839,10 @@ na_ofi_msg_init_unexpected(na_class_t *na_class, void *buf, na_size_t buf_size)
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
-    na_context_t *context, na_cb_t callback, void *arg, const void *buf,
-    na_size_t buf_size, void *plugin_data, na_addr_t dest_addr,
-    na_uint8_t dest_id, na_tag_t tag, na_op_id_t *op_id)
+na_ofi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
+    void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
+    na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     struct fid_ep *ep_hdl = ctx->fi_tx;
@@ -3715,7 +3856,7 @@ na_ofi_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
     /* Check op_id */
     NA_CHECK_ERROR(
         op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
-        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
     na_ofi_op_id_addref(na_ofi_op_id);
@@ -3725,17 +3866,15 @@ na_ofi_msg_send_unexpected(na_class_t NA_UNUSED *na_class,
     na_ofi_op_id->completion_data.callback_info.arg = arg;
     na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
     na_ofi_op_id->addr = na_ofi_addr;
-    hg_atomic_set32(&na_ofi_op_id->status, 0);
-
-    /* Specify target receive context */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
 
     /* Post the FI unexpected send request */
+    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
     do {
         rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr, tag,
             &na_ofi_op_id->fi_ctx);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        /* for EAGAIN, progress and do it again */
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
@@ -3756,9 +3895,9 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_recv_unexpected(na_class_t NA_UNUSED *na_class,
-    na_context_t *context, na_cb_t callback, void *arg, void *buf,
-    na_size_t buf_size, void *plugin_data, na_op_id_t *op_id)
+na_ofi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
+    na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
+    void *plugin_data, na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     struct fid_ep *ep_hdl = ctx->fi_rx;
@@ -3770,7 +3909,7 @@ na_ofi_msg_recv_unexpected(na_class_t NA_UNUSED *na_class,
     /* Check op_id */
     NA_CHECK_ERROR(
         op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
-        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
     na_ofi_op_id_addref(na_ofi_op_id);
@@ -3779,7 +3918,8 @@ na_ofi_msg_recv_unexpected(na_class_t NA_UNUSED *na_class,
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
     na_ofi_op_id->addr = NULL; /* Make sure the addr is reset */
-    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
     na_ofi_op_id->info.recv_unexpected.buf = buf;
     na_ofi_op_id->info.recv_unexpected.buf_size = buf_size;
 
@@ -3789,8 +3929,7 @@ na_ofi_msg_recv_unexpected(na_class_t NA_UNUSED *na_class,
     do {
         rc = fi_trecv(ep_hdl, buf, buf_size, mr_hdl, FI_ADDR_UNSPEC,
             1 /* tag */, NA_OFI_UNEXPECTED_TAG_IGNORE, &na_ofi_op_id->fi_ctx);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        /* for EAGAIN, progress and do it again */
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
@@ -3811,7 +3950,7 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
+na_ofi_msg_send_expected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, const void *buf, na_size_t buf_size,
     void *plugin_data, na_addr_t dest_addr, na_uint8_t dest_id, na_tag_t tag,
     na_op_id_t *op_id)
@@ -3828,7 +3967,7 @@ na_ofi_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
     /* Check op_id */
     NA_CHECK_ERROR(
         op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
-        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
     na_ofi_op_id_addref(na_ofi_op_id);
@@ -3838,17 +3977,15 @@ na_ofi_msg_send_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
     na_ofi_op_id->completion_data.callback_info.arg = arg;
     na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
     na_ofi_op_id->addr = na_ofi_addr;
-    hg_atomic_set32(&na_ofi_op_id->status, 0);
-
-    /* Specify target receive context */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
 
     /* Post the FI expected send request */
+    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, dest_id, NA_OFI_SEP_RX_CTX_BITS);
     do {
         rc = fi_tsend(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
             NA_OFI_EXPECTED_TAG_FLAG | tag, &na_ofi_op_id->fi_ctx);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        /* for EAGAIN, progress and do it again */
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
@@ -3869,7 +4006,7 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_msg_recv_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
+na_ofi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
     na_cb_t callback, void *arg, void *buf, na_size_t buf_size,
     void *plugin_data, na_addr_t source_addr, na_uint8_t source_id,
     na_tag_t tag, na_op_id_t *op_id)
@@ -3886,7 +4023,7 @@ na_ofi_msg_recv_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
     /* Check op_id */
     NA_CHECK_ERROR(
         op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
-        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
     na_ofi_op_id_addref(na_ofi_op_id);
@@ -3894,22 +4031,21 @@ na_ofi_msg_recv_expected(na_class_t NA_UNUSED *na_class, na_context_t *context,
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_RECV_EXPECTED;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
     na_ofi_addr_addref(na_ofi_addr); /* decref in na_ofi_complete() */
     na_ofi_op_id->addr = na_ofi_addr;
     na_ofi_op_id->info.recv_expected.buf = buf;
     na_ofi_op_id->info.recv_expected.buf_size = buf_size;
     na_ofi_op_id->info.recv_expected.tag = tag;
 
-    /* Specify target receive context */
-    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, source_id, NA_OFI_SEP_RX_CTX_BITS);
-
     /* Post the FI expected recv request */
+    fi_addr = fi_rx_addr(na_ofi_addr->fi_addr, source_id, NA_OFI_SEP_RX_CTX_BITS);
     do {
         rc = fi_trecv(ep_hdl, buf, buf_size, mr_hdl, fi_addr,
-            NA_OFI_EXPECTED_TAG_FLAG | tag, 0 /* ignore */, &na_ofi_op_id->fi_ctx);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
+            NA_OFI_EXPECTED_TAG_FLAG | tag, 0 /* ignore */,
+            &na_ofi_op_id->fi_ctx);
+        /* for EAGAIN, progress and do it again */
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
@@ -3939,7 +4075,7 @@ na_ofi_mem_handle_create(na_class_t NA_UNUSED *na_class, void *buf,
     /* Allocate memory handle */
     na_ofi_mem_handle = (struct na_ofi_mem_handle *) calloc(1,
         sizeof(struct na_ofi_mem_handle));
-    NA_CHECK_ERROR(na_ofi_mem_handle == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_mem_handle == NULL, out, ret, NA_NOMEM_ERROR,
         "Could not allocate NA OFI memory handle");
 
     na_ofi_mem_handle->desc.base = (na_ptr_t)buf;
@@ -3994,7 +4130,7 @@ na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t mem_handle)
             access = FI_READ | FI_WRITE | FI_REMOTE_READ | FI_REMOTE_WRITE;
             break;
         default:
-            NA_GOTO_ERROR(out, ret, NA_INVALID_ARG,
+            NA_GOTO_ERROR(out, ret, NA_INVALID_PARAM,
                 "Invalid memory access flag");
             break;
     }
@@ -4056,7 +4192,7 @@ na_ofi_mem_handle_serialize(na_class_t NA_UNUSED *na_class, void *buf,
     na_return_t ret = NA_SUCCESS;
 
     NA_CHECK_ERROR(buf_size < sizeof(struct na_ofi_mem_desc), out, ret,
-        NA_OVERFLOW, "Buffer size too small for serializing handle");
+        NA_SIZE_ERROR, "Buffer size too small for serializing handle");
 
     /* Copy struct */
     memcpy(buf, &na_ofi_mem_handle->desc, sizeof(na_ofi_mem_handle->desc));
@@ -4074,11 +4210,11 @@ na_ofi_mem_handle_deserialize(na_class_t NA_UNUSED *na_class,
     na_return_t ret = NA_SUCCESS;
 
     NA_CHECK_ERROR(buf_size < sizeof(struct na_ofi_mem_desc), out, ret,
-        NA_OVERFLOW, "Buffer size too small for deserializing handle");
+        NA_SIZE_ERROR, "Buffer size too small for deserializing handle");
 
     na_ofi_mem_handle = (struct na_ofi_mem_handle *)
             malloc(sizeof(struct na_ofi_mem_handle));
-    NA_CHECK_ERROR(na_ofi_mem_handle == NULL, out, ret, NA_NOMEM,
+    NA_CHECK_ERROR(na_ofi_mem_handle == NULL, out, ret, NA_NOMEM_ERROR,
         "Could not allocate NA OFI memory handle");
 
     /* Copy struct */
@@ -4093,11 +4229,11 @@ out:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_put(na_class_t NA_UNUSED *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, na_mem_handle_t local_mem_handle,
-    na_offset_t local_offset, na_mem_handle_t remote_mem_handle,
-    na_offset_t remote_offset, na_size_t length, na_addr_t remote_addr,
-    na_uint8_t remote_id, na_op_id_t *op_id)
+na_ofi_put(na_class_t *na_class, na_context_t *context, na_cb_t callback,
+    void *arg, na_mem_handle_t local_mem_handle, na_offset_t local_offset,
+    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset,
+    na_size_t length, na_addr_t remote_addr, na_uint8_t remote_id,
+    na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     struct fid_ep *ep_hdl = ctx->fi_tx;
@@ -4133,7 +4269,7 @@ na_ofi_put(na_class_t NA_UNUSED *na_class, na_context_t *context,
     /* Check op_id */
     NA_CHECK_ERROR(
         op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
-        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
     na_ofi_op_id_addref(na_ofi_op_id);
@@ -4141,20 +4277,20 @@ na_ofi_put(na_class_t NA_UNUSED *na_class, na_context_t *context,
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_PUT;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
     na_ofi_addr_addref(na_ofi_addr); /* for na_ofi_complete() */
     na_ofi_op_id->addr = na_ofi_addr;
 
     /* Assign context */
     msg_rma.context = &na_ofi_op_id->fi_ctx;
 
-    /* Post the OFI RMA write.
-     * For writes, FI_DELIVERY_COMPLETE guarantees that the operation
-     * has been processed by the destination */
+    /* Post the OFI RMA write */
     do {
+        /* For writes, FI_DELIVERY_COMPLETE guarantees that the operation
+         * has been processed by the destination */
         rc = fi_writemsg(ep_hdl, &msg_rma, FI_COMPLETION | FI_DELIVERY_COMPLETE);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        /* for EAGAIN, progress and do it again */
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
@@ -4175,11 +4311,11 @@ error:
 
 /*---------------------------------------------------------------------------*/
 static na_return_t
-na_ofi_get(na_class_t NA_UNUSED *na_class, na_context_t *context,
-    na_cb_t callback, void *arg, na_mem_handle_t local_mem_handle,
-    na_offset_t local_offset, na_mem_handle_t remote_mem_handle,
-    na_offset_t remote_offset, na_size_t length, na_addr_t remote_addr,
-    na_uint8_t remote_id, na_op_id_t *op_id)
+na_ofi_get(na_class_t *na_class, na_context_t *context, na_cb_t callback,
+    void *arg, na_mem_handle_t local_mem_handle, na_offset_t local_offset,
+    na_mem_handle_t remote_mem_handle, na_offset_t remote_offset,
+    na_size_t length, na_addr_t remote_addr, na_uint8_t remote_id,
+    na_op_id_t *op_id)
 {
     struct na_ofi_context *ctx = NA_OFI_CONTEXT(context);
     struct fid_ep *ep_hdl = ctx->fi_tx;
@@ -4215,7 +4351,7 @@ na_ofi_get(na_class_t NA_UNUSED *na_class, na_context_t *context,
     /* Check op_id */
     NA_CHECK_ERROR(
         op_id == NULL || op_id == NA_OP_ID_IGNORE || *op_id == NA_OP_ID_NULL,
-        out, ret, NA_INVALID_ARG, "Invalid operation ID");
+        out, ret, NA_INVALID_PARAM, "Invalid operation ID");
 
     na_ofi_op_id = (struct na_ofi_op_id *) *op_id;
     na_ofi_op_id_addref(na_ofi_op_id);
@@ -4223,7 +4359,8 @@ na_ofi_get(na_class_t NA_UNUSED *na_class, na_context_t *context,
     na_ofi_op_id->completion_data.callback_info.type = NA_CB_GET;
     na_ofi_op_id->completion_data.callback = callback;
     na_ofi_op_id->completion_data.callback_info.arg = arg;
-    hg_atomic_set32(&na_ofi_op_id->status, 0);
+    hg_atomic_set32(&na_ofi_op_id->completed, NA_FALSE);
+    hg_atomic_set32(&na_ofi_op_id->canceled, NA_FALSE);
     na_ofi_addr_addref(na_ofi_addr); /* for na_ofi_complete() */
     na_ofi_op_id->addr = na_ofi_addr;
 
@@ -4233,8 +4370,7 @@ na_ofi_get(na_class_t NA_UNUSED *na_class, na_context_t *context,
     /* Post the OFI RMA read */
     do {
         rc = fi_readmsg(ep_hdl, &msg_rma, FI_COMPLETION);
-//        if (rc == -FI_EAGAIN)
-//            NA_GOTO_DONE(error, ret, NA_AGAIN);
+        /* for EAGAIN, progress and do it again */
         if (rc == -FI_EAGAIN)
             na_ofi_progress(na_class, context, 0);
         else
@@ -4346,8 +4482,8 @@ na_ofi_progress(na_class_t *na_class, na_context_t *context,
         }
 
         /* Read from CQ */
-        ret = na_ofi_cq_read(context, NA_OFI_CQ_EVENT_NUM, cq_events, src_addrs,
-            &src_err_addr_ptr, &src_err_addrlen, &actual_count);
+        ret = na_ofi_cq_read(na_class, context, NA_OFI_CQ_EVENT_NUM, cq_events,
+            src_addrs, &src_err_addr_ptr, &src_err_addrlen, &actual_count);
         NA_CHECK_NA_ERROR(out, ret,
             "Could not read events from context CQ");
 
@@ -4383,54 +4519,90 @@ na_ofi_cancel(na_class_t *na_class, na_context_t *context,
     na_op_id_t op_id)
 {
     struct na_ofi_op_id *na_ofi_op_id = (struct na_ofi_op_id *) op_id;
-    struct fid_ep *fi_ep = NULL;
-    na_return_t ret = NA_SUCCESS;
     ssize_t rc;
+    na_return_t ret = NA_SUCCESS;
 
-    /* Exit if op has already completed */
-    if (!hg_atomic_cas32(&na_ofi_op_id->status, 0, NA_OFI_OP_CANCELED))
+    NA_CHECK_ERROR(na_ofi_op_id_valid(na_ofi_op_id) == NA_FALSE, out, ret,
+        NA_PROTOCOL_ERROR, "Invalid operation ID");
+
+    if (hg_atomic_get32(&na_ofi_op_id->completed))
+        goto out;
+
+    if (!hg_atomic_cas32(&na_ofi_op_id->canceled, NA_FALSE, NA_TRUE)) {
+        NA_LOG_WARNING("ignore canceling for a canceled op.");
         goto out;
+    }
 
-    NA_LOG_DEBUG("Canceling operation ID %p", na_ofi_op_id);
+    hg_atomic_incr32(&na_ofi_op_id->canceled);
 
     switch (na_ofi_op_id->completion_data.callback_info.type) {
-        case NA_CB_RECV_UNEXPECTED:
-        case NA_CB_RECV_EXPECTED:
-            fi_ep = NA_OFI_CONTEXT(context)->fi_rx;
-            break;
-        case NA_CB_SEND_UNEXPECTED:
-        case NA_CB_SEND_EXPECTED:
-        case NA_CB_PUT:
-        case NA_CB_GET:
-            fi_ep = NA_OFI_CONTEXT(context)->fi_tx;
-            break;
-        case NA_CB_LOOKUP:
-        default:
-            NA_GOTO_ERROR(out, ret, NA_INVALID_ARG,
-                "Operation type %d not supported",
-                na_ofi_op_id->completion_data.callback_info.type);
-            break;
+    case NA_CB_LOOKUP:
+        break;
+    case NA_CB_RECV_UNEXPECTED: {
+        struct na_ofi_op_id *tmp = NULL, *first = NULL;
+
+        rc = fi_cancel(&NA_OFI_CONTEXT(context)->fi_rx->fid,
+            &na_ofi_op_id->fi_ctx);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_CANCEL_ERROR,
+            "fi_cancel() unexpected recv failed, rc: %d(%s)",
+            rc, fi_strerror((int) -rc));
+
+        tmp = first = na_ofi_msg_unexpected_op_pop(context);
+        do {
+            NA_CHECK_ERROR(tmp == NULL, out, ret, NA_PROTOCOL_ERROR,
+                "Head of unexpected op queue is NULL");
+            if (tmp == na_ofi_op_id)
+                break;
+
+            na_ofi_msg_unexpected_op_push(context, tmp);
+            tmp = na_ofi_msg_unexpected_op_pop(context);
+            NA_CHECK_ERROR(tmp == first, out, ret, NA_PROTOCOL_ERROR,
+                "Could not find operation ID");
+        } while (tmp != na_ofi_op_id);
+
+        ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
     }
+        break;
+    case NA_CB_RECV_EXPECTED:
+        rc = fi_cancel(&NA_OFI_CONTEXT(context)->fi_rx->fid,
+            &na_ofi_op_id->fi_ctx);
+        NA_CHECK_ERROR(rc != 0, out, ret, NA_CANCEL_ERROR,
+            "fi_cancel() expected recv failed, rc: %d(%s)",
+            rc, fi_strerror((int) -rc));
 
-    /* fi_cancel() is an asynchronous operation, either the operation
-     * will be canceled and an FI_ECANCELED event will be generated
-     * or it will show up in the regular completion queue.
-     */
-    rc = fi_cancel(&fi_ep->fid, &na_ofi_op_id->fi_ctx);
-    NA_LOG_DEBUG("fi_cancel() rc: %d(%s)", (int) rc,
-        fi_strerror((int) -rc));
-//    NA_CHECK_ERROR(rc == -FI_ENOENT, out, ret, NA_OPNOTSUPPORTED,
-//        "fi_cancel() failed, rc: %d(%s)", rc, fi_strerror((int) -rc));
+        ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
+        break;
+    case NA_CB_SEND_UNEXPECTED:
+    case NA_CB_SEND_EXPECTED:
+    case NA_CB_PUT:
+    case NA_CB_GET:
+        /* May or may not be canceled in that case */
+        rc = fi_cancel(&NA_OFI_CONTEXT(context)->fi_tx->fid,
+            &na_ofi_op_id->fi_ctx);
+        if (rc != 0) {
+            NA_LOG_WARNING("fi_cancel() failed, rc: %d(%s)",
+                         rc, fi_strerror((int) -rc));
+        }
+        /* fi_cancel() is not guaranteed to return proper return code for now */
+//        if (rc == 0) {
+            /* Complete only if successfully canceled */
+        ret = na_ofi_complete(na_ofi_op_id, NA_CANCELED);
+//        } else
+//            ret = NA_CANCEL_ERROR;
+        break;
+    default:
+        break;
+    }
 
     /* Work around segfault on fi_cq_signal() in some providers */
     if (!(na_ofi_prov_flags[NA_OFI_CLASS(na_class)->domain->prov_type]
         & NA_OFI_SKIP_SIGNAL)) {
         /* Signal CQ to wake up and no longer wait on FD */
-        int rc_signal = fi_cq_signal(NA_OFI_CONTEXT(context)->fi_cq);
-        NA_CHECK_ERROR(rc_signal != 0 && rc_signal != -ENOSYS, out, ret,
+        rc = fi_cq_signal(NA_OFI_CONTEXT(context)->fi_cq);
+        NA_CHECK_ERROR(rc != 0 && rc != -ENOSYS, out, ret,
             NA_PROTOCOL_ERROR, "fi_cq_signal (op type %d) failed, rc: %d(%s)",
-            na_ofi_op_id->completion_data.callback_info.type, rc_signal,
-            fi_strerror((int) -rc_signal));
+            na_ofi_op_id->completion_data.callback_info.type, rc,
+            fi_strerror((int) -rc));
     }
 
 out:
diff --git a/src/na/na_plugin.h b/src/na/na_plugin.h
index 05a6076..848191c 100644
--- a/src/na/na_plugin.h
+++ b/src/na/na_plugin.h
@@ -28,8 +28,8 @@ typedef void (*na_plugin_cb_t)(void *arg);
 
 /* Completion data stored in completion queue */
 struct na_cb_completion_data {
-    struct na_cb_info callback_info;    /* Callback info struct */
     na_cb_t callback;                   /* Pointer to function */
+    struct na_cb_info callback_info;    /* Callback info struct */
     na_plugin_cb_t plugin_callback;     /* Callback which will be called after
                                          * the user callback returns. */
     void *plugin_callback_args;         /* Argument to plugin_callback */
@@ -74,7 +74,8 @@ struct na_cb_completion_data {
 /**
  * Plugin ops definition
  */
-#define NA_PLUGIN_OPS(plugin_name) na_ ##plugin_name ##_class_ops_g
+#define NA_PLUGIN_OPS(plugin_name) \
+    const struct na_class_ops na_ ##plugin_name ##_class_ops_g
 
 /*********************/
 /* Public Prototypes */
@@ -94,7 +95,7 @@ extern "C" {
  *
  * \return NA_SUCCESS or corresponding NA error code (failure is not an option)
  */
-NA_PRIVATE na_return_t
+NA_EXPORT na_return_t
 na_cb_completion_add(
         na_context_t                 *context,
         struct na_cb_completion_data *na_cb_completion_data
@@ -103,21 +104,20 @@ na_cb_completion_add(
 /*********************/
 /* Public Variables */
 /*********************/
-
 #ifdef NA_HAS_SM
-extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(sm);
+NA_EXPORT NA_PLUGIN_OPS(sm);
 #endif
 #ifdef NA_HAS_BMI
-extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(bmi);
+NA_EXPORT NA_PLUGIN_OPS(bmi);
 #endif
 #ifdef NA_HAS_MPI
-extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(mpi);
+NA_EXPORT NA_PLUGIN_OPS(mpi);
 #endif
 #ifdef NA_HAS_CCI
-extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(cci);
+NA_EXPORT NA_PLUGIN_OPS(cci);
 #endif
 #ifdef NA_HAS_OFI
-extern NA_PRIVATE const struct na_class_ops NA_PLUGIN_OPS(ofi);
+NA_EXPORT NA_PLUGIN_OPS(ofi);
 #endif
 
 #ifdef __cplusplus
diff --git a/src/na/na_sm.c b/src/na/na_sm.c
index 38463ea..63494eb 100644
--- a/src/na/na_sm.c
+++ b/src/na/na_sm.c
@@ -47,12 +47,6 @@
 /* Local Macros */
 /****************/
 
-/* Error compat */
-#define NA_INVALID_PARAM    NA_INVALID_ARG
-#define NA_SIZE_ERROR       NA_MSGSIZE
-#define NA_NOMEM_ERROR      NA_NOMEM
-#define NA_PERMISSION_ERROR NA_PERMISSION
-
 /* Plugin constants */
 #define NA_SM_MAX_FILENAME      64
 #define NA_SM_NUM_BUFS          64
@@ -895,7 +889,7 @@ na_sm_cancel(
 /* Local Variables */
 /*******************/
 
-const struct na_class_ops NA_PLUGIN_OPS(sm) = {
+NA_PLUGIN_OPS(sm) = {
     "na",                                   /* name */
     na_sm_check_protocol,                   /* check_protocol */
     na_sm_initialize,                       /* initialize */
diff --git a/src/na/na_types.h b/src/na/na_types.h
index 1f32ee2..fd18929 100644
--- a/src/na/na_types.h
+++ b/src/na/na_types.h
@@ -37,9 +37,9 @@ typedef enum na_progress_mode {
 
 /* Init info */
 struct na_init_info {
-    const char *auth_key;               /* Authorization key */
     na_progress_mode_t progress_mode;   /* Progress mode */
     na_uint8_t max_contexts;            /* Max contexts */
+    const char *auth_key;               /* Authorization key */
 };
 
 /* Segment */
@@ -48,34 +48,21 @@ struct na_segment {
     na_size_t size;     /* Size of the segment in bytes */
 };
 
-/* Return codes:
- * Functions return 0 for success or corresponding return code */
-#define NA_RETURN_VALUES                                                    \
-    X(NA_SUCCESS)           /*!< operation succeeded */                     \
-    X(NA_PERMISSION)        /*!< operation not permitted */                 \
-    X(NA_NOENTRY)           /*!< no such file or directory */               \
-    X(NA_INTERRUPT)         /*!< operation interrupted */                   \
-    X(NA_AGAIN)             /*!< operation must be retried */               \
-    X(NA_NOMEM)             /*!< out of memory */                           \
-    X(NA_ACCESS)            /*!< permission denied */                       \
-    X(NA_FAULT)             /*!< bad address */                             \
-    X(NA_BUSY)              /*!< device or resource busy */                 \
-    X(NA_NODEV)             /*!< no such device */                          \
-    X(NA_INVALID_ARG)       /*!< invalid argument */                        \
-    X(NA_PROTOCOL_ERROR)    /*!< protocol error */                          \
-    X(NA_OVERFLOW)          /*!< value too large */                         \
-    X(NA_MSGSIZE)           /*!< message size too long */                   \
-    X(NA_PROTONOSUPPORT)    /*!< protocol not supported */                  \
-    X(NA_OPNOTSUPPORTED)    /*!< operation not supported on endpoint */     \
-    X(NA_ADDRINUSE)         /*!< address already in use */                  \
-    X(NA_ADDRNOTAVAIL)      /*!< cannot assign requested address */         \
-    X(NA_TIMEOUT)           /*!< operation reached timeout */               \
-    X(NA_CANCELED)          /*!< operation canceled */                      \
-    X(NA_RETURN_MAX)
-
-#define X(a) a,
-typedef enum na_return { NA_RETURN_VALUES } na_return_t;
-#undef X
+/* Error return codes:
+ * Functions return 0 for success or NA_XXX_ERROR for failure */
+typedef enum na_return {
+    NA_SUCCESS,             /*!< operation succeeded */
+    NA_TIMEOUT,             /*!< reached timeout */
+    NA_INVALID_PARAM,       /*!< invalid parameter */
+    NA_SIZE_ERROR,          /*!< message size error */
+    NA_ALIGNMENT_ERROR,     /*!< alignment error */
+    NA_PERMISSION_ERROR,    /*!< read/write permission error */
+    NA_NOMEM_ERROR,         /*!< no memory error */
+    NA_PROTOCOL_ERROR,      /*!< unknown error reported from the protocol layer */
+    NA_CANCELED,            /*!< operation was canceled */
+    NA_CANCEL_ERROR,        /*!< operation could not be canceled */
+    NA_ADDRINUSE_ERROR      /*!< address already in use */
+} na_return_t;
 
 /* Callback operation type */
 typedef enum na_cb_type {
@@ -101,13 +88,13 @@ struct na_cb_info_recv_unexpected {
 
 /* Callback info struct */
 struct na_cb_info {
+    void *arg;          /* User data */
+    na_return_t ret;    /* Return value */
+    na_cb_type_t type;  /* Callback type */
     union {             /* Union of callback info structures */
         struct na_cb_info_lookup lookup;
         struct na_cb_info_recv_unexpected recv_unexpected;
     } info;
-    void *arg;          /* User data */
-    na_cb_type_t type;  /* Callback type */
-    na_return_t ret;    /* Return value */
 };
 
 /* Callback type */
diff --git a/src/proc_extra/mercury_proc_string.h b/src/proc_extra/mercury_proc_string.h
index e1bc9ab..918dce6 100644
--- a/src/proc_extra/mercury_proc_string.h
+++ b/src/proc_extra/mercury_proc_string.h
@@ -16,8 +16,8 @@
 
 #include <string.h>
 
-typedef const char *hg_const_string_t;
-typedef char *hg_string_t;
+typedef const char * hg_const_string_t;
+typedef char * hg_string_t;
 
 #ifdef __cplusplus
 extern "C" {
@@ -45,29 +45,35 @@ static HG_INLINE hg_return_t
 hg_proc_hg_const_string_t(hg_proc_t proc, void *data)
 {
     hg_string_object_t string;
-    hg_const_string_t *strdata = (hg_const_string_t *) data;
+    hg_const_string_t *strdata = (hg_const_string_t*)data;
     hg_return_t ret = HG_SUCCESS;
 
     switch (hg_proc_get_op(proc)) {
         case HG_ENCODE:
             hg_string_object_init_const_char(&string, *strdata, 0);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Proc error");
                 goto done;
+            }
             hg_string_object_free(&string);
             break;
         case HG_DECODE:
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Proc error");
                 goto done;
+            }
             *strdata = hg_string_object_swap(&string, 0);
             hg_string_object_free(&string);
             break;
         case HG_FREE:
             hg_string_object_init_const_char(&string, *strdata, 1);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Proc error");
                 goto done;
+            }
             break;
         default:
             break;
@@ -89,29 +95,35 @@ static HG_INLINE hg_return_t
 hg_proc_hg_string_t(hg_proc_t proc, void *data)
 {
     hg_string_object_t string;
-    hg_string_t *strdata = (hg_string_t *) data;
+    hg_string_t *strdata = (hg_string_t*)data;
     hg_return_t ret = HG_SUCCESS;
 
     switch (hg_proc_get_op(proc)) {
         case HG_ENCODE:
             hg_string_object_init_char(&string, *strdata, 0);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Proc error");
                 goto done;
+            }
             hg_string_object_free(&string);
             break;
         case HG_DECODE:
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Proc error");
                 goto done;
+            }
             *strdata = hg_string_object_swap(&string, 0);
             hg_string_object_free(&string);
             break;
         case HG_FREE:
             hg_string_object_init_char(&string, *strdata, 1);
             ret = hg_proc_hg_string_object_t(proc, &string);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Proc error");
                 goto done;
+            }
             break;
         default:
             break;
@@ -134,61 +146,67 @@ hg_proc_hg_string_object_t(hg_proc_t proc, void *string)
 {
     hg_uint64_t string_len = 0;
     hg_return_t ret = HG_SUCCESS;
-    hg_string_object_t *strobj = (hg_string_object_t *) string;
+    hg_string_object_t *strobj = (hg_string_object_t*)string;
 
     switch (hg_proc_get_op(proc)) {
         case HG_ENCODE:
             string_len = (strobj->data) ? strlen(strobj->data) + 1 : 0;
             ret = hg_proc_uint64_t(proc, &string_len);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Proc error");
                 goto done;
+            }
             if (string_len) {
                 ret = hg_proc_raw(proc, strobj->data, string_len);
-                if (ret != HG_SUCCESS)
+                if (ret != HG_SUCCESS) {
+                    HG_LOG_ERROR("Proc error");
                     goto done;
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_const);
-                if (ret != HG_SUCCESS)
+                }
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_const);
+                if (ret != HG_SUCCESS) {
+                    HG_LOG_ERROR("Proc error");
                     goto done;
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_owned);
-                if (ret != HG_SUCCESS)
+                }
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_owned);
+                if (ret != HG_SUCCESS) {
+                    HG_LOG_ERROR("Proc error");
                     goto done;
+                }
             }
             break;
         case HG_DECODE:
             ret = hg_proc_uint64_t(proc, &string_len);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Proc error");
                 goto done;
+            }
             if (string_len) {
-                strobj->data = (char *) malloc(string_len);
-                if (strobj->data == NULL) {
-                    ret = HG_NOMEM;
-                    goto done;
-                }
+                strobj->data = (char*) malloc(string_len);
                 ret = hg_proc_raw(proc, strobj->data, string_len);
                 if (ret != HG_SUCCESS) {
-                    free(strobj->data);
-                    strobj->data = NULL;
+                    HG_LOG_ERROR("Proc error");
                     goto done;
                 }
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_const);
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_const);
                 if (ret != HG_SUCCESS) {
-                    free(strobj->data);
-                    strobj->data = NULL;
+                    HG_LOG_ERROR("Proc error");
                     goto done;
                 }
-                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t *) &strobj->is_owned);
+                ret = hg_proc_hg_uint8_t(proc, (hg_uint8_t*) &strobj->is_owned);
                 if (ret != HG_SUCCESS) {
-                    free(strobj->data);
-                    strobj->data = NULL;
+                    HG_LOG_ERROR("Proc error");
                     goto done;
                 }
-            } else
+            } else {
                 strobj->data = NULL;
+            }
             break;
         case HG_FREE:
             ret = hg_string_object_free(strobj);
-            if (ret != HG_SUCCESS)
+            if (ret != HG_SUCCESS) {
+                HG_LOG_ERROR("Could not free string object");
                 goto done;
+            }
             break;
         default:
             break;
diff --git a/src/proc_extra/mercury_string_object.c b/src/proc_extra/mercury_string_object.c
index b7c7832..76863c2 100644
--- a/src/proc_extra/mercury_string_object.c
+++ b/src/proc_extra/mercury_string_object.c
@@ -9,7 +9,6 @@
  */
 
 #include "mercury_string_object.h"
-#include "mercury_error.h"
 
 #include <string.h>
 #include <stdlib.h>
@@ -56,7 +55,7 @@ hg_string_object_init_const_char(hg_string_object_t *string, const char *s,
 {
     hg_return_t ret = HG_SUCCESS;
 
-    string->data = (char *) s;
+    string->data = (char*) s;
     string->is_owned = is_owned;
     string->is_const = 1;
 
@@ -88,12 +87,9 @@ hg_string_object_dup(hg_string_object_t string, hg_string_object_t *new_string)
     hg_return_t ret = HG_SUCCESS;
 
     new_string->data = strdup(string.data);
-    HG_CHECK_ERROR(new_string->data == NULL, done, ret, HG_NOMEM,
-        "Could not dup string data");
     new_string->is_owned = 1;
     new_string->is_const = 0;
 
-done:
     return ret;
 }
 
diff --git a/src/proc_extra/mercury_string_object.h b/src/proc_extra/mercury_string_object.h
index 7d29e26..ab5ae01 100644
--- a/src/proc_extra/mercury_string_object.h
+++ b/src/proc_extra/mercury_string_object.h
@@ -30,7 +30,7 @@ extern "C" {
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_string_object_init(hg_string_object_t *string);
 
 /**
@@ -42,9 +42,8 @@ hg_string_object_init(hg_string_object_t *string);
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
-hg_string_object_init_char(hg_string_object_t *string, char *s,
-    hg_bool_t is_owned);
+HG_EXPORT hg_return_t
+hg_string_object_init_char(hg_string_object_t *string, char *s, hg_bool_t is_owned);
 
 /**
  * Initialize a string object from the const string pointed to by s.
@@ -55,9 +54,8 @@ hg_string_object_init_char(hg_string_object_t *string, char *s,
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
-hg_string_object_init_const_char(hg_string_object_t *string, const char *s,
-    hg_bool_t is_owned);
+HG_EXPORT hg_return_t
+hg_string_object_init_const_char(hg_string_object_t *string, const char *s, hg_bool_t is_owned);
 
 /**
  * Free a string object.
@@ -66,7 +64,7 @@ hg_string_object_init_const_char(hg_string_object_t *string, const char *s,
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_string_object_free(hg_string_object_t *string);
 
 /**
@@ -77,7 +75,7 @@ hg_string_object_free(hg_string_object_t *string);
  *
  * \return HG_SUCCESS or corresponding HG error code
  */
-HG_PUBLIC hg_return_t
+HG_EXPORT hg_return_t
 hg_string_object_dup(hg_string_object_t string, hg_string_object_t *new_string);
 
 /**
@@ -87,7 +85,7 @@ hg_string_object_dup(hg_string_object_t string, hg_string_object_t *new_string);
  *
  * \return Pointer to string contained by string before the swap
  */
-HG_PUBLIC char *
+HG_EXPORT char *
 hg_string_object_swap(hg_string_object_t *string, char *s);
 
 #ifdef __cplusplus
diff --git a/src/util/mercury_log.c b/src/util/mercury_log.c
index e17e973..7e18319 100644
--- a/src/util/mercury_log.c
+++ b/src/util/mercury_log.c
@@ -57,7 +57,7 @@ hg_log_set_stream_error(FILE *stream)
 
 /*---------------------------------------------------------------------------*/
 void
-hg_log_write(unsigned int log_type, const char *module, const char *file,
+hg_log_write(hg_log_type_t log_type, const char *module, const char *file,
     unsigned int line, const char *func, const char *format, ...)
 {
     char buf[HG_UTIL_LOG_MAX_BUF];
diff --git a/src/util/mercury_log.h b/src/util/mercury_log.h
index d6eb11e..bec44c3 100644
--- a/src/util/mercury_log.h
+++ b/src/util/mercury_log.h
@@ -15,10 +15,11 @@
 
 #include <stdio.h>
 
-#define HG_LOG_TYPE_NONE    0
-#define HG_LOG_TYPE_DEBUG   0x01
-#define HG_LOG_TYPE_WARNING 0x02
-#define HG_LOG_TYPE_ERROR   0x04
+typedef enum {
+    HG_LOG_TYPE_DEBUG,
+    HG_LOG_TYPE_WARNING,
+    HG_LOG_TYPE_ERROR
+} hg_log_type_t;
 
 /* For compatibility */
 #if defined(__STDC_VERSION__) &&  (__STDC_VERSION__ < 199901L)
@@ -91,7 +92,7 @@ hg_log_set_stream_error(FILE *stream);
  * \param format [IN]           string format
  */
 HG_UTIL_EXPORT void
-hg_log_write(unsigned int log_type, const char *module, const char *file,
+hg_log_write(hg_log_type_t log_type, const char *module, const char *file,
     unsigned int line, const char *func, const char *format, ...);
 
 #ifdef __cplusplus
